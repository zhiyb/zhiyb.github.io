

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>python3-cookbook 3.0.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
        <link rel="copyright" title="版权所有" href="index.html#document-copyright"/>
    <link rel="top" title="None" href="index.html#document-index"/> 

  
  <script src="_static/js/modernizr.min.js"></script>


<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://python3-cookbook.readthedocs.io/zh_CN/latest/" />

<link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />

<script type="text/javascript" src="_static/readthedocs-data.js"></script>

<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = 'index'
</script>

<script type="text/javascript" src="_static/readthedocs-dynamic-include.js"></script>

<!-- end RTD <extrahead> --></head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html#document-index" class="icon icon-home"> python3-cookbook
          

          
          </a>

          
            
            
            
              <div class="version">
                stable
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-copyright">Copyright</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-preface">前言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">项目主页</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">译者的话</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">作者的话</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">这本书适合谁</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">这本书不适合谁</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">在线示例代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">使用示例代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">联系我们</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">致谢</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p01_data_structures_algorithms">第一章：数据结构和算法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p01_unpack_sequence_into_separate_variables">1.1 解压序列赋值给多个变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p02_unpack_elements_from_iterables">1.2 解压可迭代对象赋值给多个变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p03_keep_last_n_items">1.3 保留最后 N 个元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p04_find_largest_or_smallest_n_items">1.4 查找最大或最小的 N 个元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p05_implement_a_priority_queue">1.5 实现一个优先级队列</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p06_map_keys_to_multiple_values_in_dict">1.6 字典中的键映射多个值</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p07_keep_dict_in_order">1.7 字典排序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p08_calculating_with_dict">1.8 字典的运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p09_find_commonalities_in_dicts">1.9 查找两字典的相同点</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p10_remove_duplicates_from_seq_order">1.10 删除序列相同元素并保持顺序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p11_naming_slice">1.11 命名切片</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p12_determine_most_freqently_items_in_seq">1.12 序列中出现次数最多的元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p13_sort_list_of_dicts_by_key">1.13 通过某个关键字排序一个字典列表</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p14_sort_objects_without_compare_support">1.14 排序不支持原生比较的对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p15_group_records_based_on_field">1.15 通过某个字段将记录分组</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p16_filter_sequence_elements">1.16 过滤序列元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p17_extract_subset_of_dict">1.17 从字典中提取子集</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p18_map_names_to_sequence_elements">1.18 映射名称到序列元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p19_transform_and_reduce_data_same_time">1.19 转换并同时计算数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c01/p20_combine_multiple_map_to_single_map">1.20 合并多个字典或映射</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p02_strings_and_text">第二章：字符串和文本</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p01_split_string_on_multiple_delimiters">2.1 使用多个界定符分割字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p02_match_text_at_start_end">2.2 字符串开头或结尾匹配</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p03_match_strings_with_shell_wildcard">2.3 用Shell通配符匹配字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p04_match_and_search_text">2.4 字符串匹配和搜索</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p05_search_and_replace_text">2.5 字符串搜索和替换</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p06_search_replace_case_insensitive">2.6 字符串忽略大小写的搜索替换</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p07_specify_regexp_for_shortest_match">2.7 最短匹配模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p08_regexp_for_multiline_partterns">2.8 多行匹配模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p09_normalize_unicode_text_to_regexp">2.9 将Unicode文本标准化</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p10_work_with_unicode_in_regexp">2.10 在正则式中使用Unicode</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p11_strip_unwanted_characters">2.11 删除字符串中不需要的字符</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p12_sanitizing_clean_up_text">2.12 审查清理文本字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p13_aligning_text_strings">2.13 字符串对齐</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p14_combine_and_concatenate_strings">2.14 合并拼接字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p15_interpolating_variables_in_strings">2.15 字符串中插入变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p16_reformat_text_to_fixed_number_columns">2.16 以指定列宽格式化字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p17_handle_html_xml_in_text">2.17 在字符串中处理html和xml</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p18_tokenizing_text">2.18 字符串令牌解析</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p19_writing_recursive_descent_parser">2.19 实现一个简单的递归下降分析器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c02/p20_perform_text_operations_on_byte_string">2.20 字节字符串上的字符串操作</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p03_numbers_dates_times">第三章：数字日期和时间</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p01_round_number">3.1 数字的四舍五入</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p02_accurate_decimal_calculations">3.2 执行精确的浮点数运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p03_format_numbers_for_output">3.3 数字的格式化输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p04_binary_octal_hexadecimal_int">3.4 二八十六进制整数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p05_pack_unpack_large_int_from_bytes">3.5 字节到大整数的打包与解包</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p06_complex_math">3.6 复数的数学运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p07_infinity_and_nan">3.7 无穷大与NaN</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p08_calculating_with_fractions">3.8 分数运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p09_calculating_with_large_num_arrays">3.9 大型数组运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p10_matrix_and_linear_algebra_calculation">3.10 矩阵与线性代数运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p11_pick_things_at_random">3.11 随机选择</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p12_convert_days_to_seconds_and_others">3.12 基本的日期与时间转换</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p13_determine_last_friday_date">3.13 计算最后一个周五的日期</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p14_date_range_for_current_month">3.14 计算当前月份的日期范围</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p15_convert_strings_into_datetimes">3.15 字符串转换为日期</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c03/p16_manipulate_dates_involving_timezone">3.16 结合时区的日期操作</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p04_iterators_and_generators">第四章：迭代器与生成器</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p01_manually_consuming_iterator">4.1 手动遍历迭代器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p02_delegating_iteration">4.2 代理迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p03_create_new_iteration_with_generators">4.3 使用生成器创建新的迭代模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p04_implement_iterator_protocol">4.4 实现迭代器协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p05_iterating_in_reverse">4.5 反向迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p06_define_generator_func_with_extra_state">4.6 带有外部状态的生成器函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p07_taking_slice_of_iterator">4.7 迭代器切片</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p08_skip_first_part_of_iterable">4.8 跳过可迭代对象的开始部分</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p09_iterate_over_combination_or_permutation">4.9 排列组合的迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p10_iterate_over_index_value_pairs_of_sequence">4.10 序列上索引值迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p11_iterate_over_multiple_sequences_simultaneously">4.11 同时迭代多个序列</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p12_iterate_on_items_in_separate_containers">4.12 不同集合上元素的迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p13_create_data_processing_pipelines">4.13 创建数据处理管道</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p14_flattening_nested_sequence">4.14 展开嵌套的序列</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p15_iterate_in_sorted_order_over_merged_sorted_iterables">4.15 顺序迭代合并后的排序迭代对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c04/p16_replace_infinite_while_loops_with_iterator">4.16 迭代器代替while无限循环</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p05_files_and_io">第五章：文件与IO</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p01_read_write_text_data">5.1 读写文本数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p02_printing_to_file">5.2 打印输出至文件中</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p03_print_with_different_separator_or_line_ending">5.3 使用其他分隔符或行终止符打印</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p04_read_write_binary_data">5.4 读写字节数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p05_write_to_file_not_exist">5.5 文件不存在才能写入</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p06_io_operations_on_string">5.6 字符串的I/O操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p07_read_write_compressed_datafiles">5.7 读写压缩文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p08_iterate_over_fixed_sized_records">5.8 固定大小记录的文件迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p09_read_binary_data_into_mutable_buffer">5.9 读取二进制数据到可变缓冲区中</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p10_memory_mapping_binary_files">5.10 内存映射的二进制文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p11_manipulating_pathnames">5.11 文件路径名的操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p12_test_for_the_existence_of_file">5.12 测试文件是否存在</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p13_get_directory_listing">5.13 获取文件夹中的文件列表</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p14_bypassing_filename_encoding">5.14 忽略文件名编码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p15_printing_bad_filenames">5.15 打印不合法的文件名</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p16_add_change_encoding_of_already_open_file">5.16 增加或改变已打开文件的编码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p17_write_bytes_to_text_file">5.17 将字节写入文本文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p18_wrap_existing_file_descriptor_as_file_object">5.18 将文件描述符包装成文件对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p19_make_temporary_files_and_directories">5.19 创建临时文件和文件夹</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p20_communicating_with_serial_ports">5.20 与串行端口的数据通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c05/p21_serializing_python_objects">5.21 序列化Python对象</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p06_data_encoding_and_process">第六章：数据编码和处理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p01_read_write_csv_data">6.1 读写CSV数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p02_read-write_json_data">6.2 读写JSON数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p03_parse_simple_xml_data">6.3 解析简单的XML数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p04_parse_huge_xml_files_incrementally">6.4 增量式解析大型XML文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p05_turning_dictionary_into_xml">6.5 将字典转换为XML</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p06_parse_modify_rewrite_xml">6.6 解析和修改XML</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p07_parse_xml_documents_with_namespaces">6.7 利用命名空间解析XML文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p08_interact_with_relational_database">6.8 与关系型数据库的交互</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p09_decode_encode_hexadecimal_digits">6.9 编码和解码十六进制数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p10_decode_encode_base64">6.10 编码解码Base64数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p11_read_write_binary_arrays_of_structures">6.11 读写二进制数组数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p12_read_nested_and_variable_sized_binary_structures">6.12 读取嵌套和可变长二进制数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c06/p13_summarizing_and_perform_statistics">6.13 数据的累加与统计操作</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p07_functions">第七章：函数</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p01_functions_that_accept_any_number_arguments">7.1 可接受任意数量参数的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p02_functions_that_only_accept_keyword_arguments">7.2 只接受关键字参数的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p03_attach_informatinal_matadata_to_function_arguments">7.3 给函数参数增加元信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p04_return_multiple_values_from_function">7.4 返回多个值的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p05_define_functions_with_default_arguments">7.5 定义有默认参数的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p06_define_anonymous_or_inline_functions">7.6 定义匿名或内联函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p07_capturing_variables_in_anonymous_functions">7.7 匿名函数捕获变量值</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p08_make_callable_with_fewer_arguments">7.8 减少可调用对象的参数个数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p09_replace_single_method_classes_with_functions">7.9 将单方法的类转换为函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p10_carry_extra_state_with_callback_functions">7.10 带额外状态信息的回调函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p11_inline_callback_functions">7.11 内联回调函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c07/p12_access_variables_defined_inside_closure">7.12 访问闭包中定义的变量</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p08_classes_and_objects">第八章：类与对象</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p01_change_string_representation_of_instances">8.1 改变对象的字符串显示</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p02_customizing_string_formatting">8.2 自定义字符串的格式化</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p03_make_objects_support_context_management_protocol">8.3 让对象支持上下文管理协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p04_save_memory_when_create_large_number_instances">8.4 创建大量对象时节省内存方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p05_encapsulating_names_in_class">8.5 在类中封装属性名</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p06_create_managed_attributes">8.6 创建可管理的属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p07_calling_method_on_parent_class">8.7 调用父类方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p08_extending_property_in_subclass">8.8 子类中扩展property</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p09_create_new_kind_of_class_or_instance_attribute">8.9 创建新的类或实例属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p10_using_lazily_computed_properties">8.10 使用延迟计算属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p11_simplify_initialization_of_data_structure">8.11 简化数据结构的初始化</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p12_define_interface_or_abstract_base_class">8.12 定义接口或者抽象基类</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p13_implementing_data_model_or_type_system">8.13 实现数据模型的类型约束</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p14_implementing_custom_containers">8.14 实现自定义容器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p15_delegating_attribute_access">8.15 属性的代理访问</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p16_define_more_than_one_constructor_in_class">8.16 在类中定义多个构造器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p17_create_instance_without_invoking_init_method">8.17 创建不调用init方法的实例</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p18_extending_classes_with_mixins">8.18 利用Mixins扩展类功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p19_implements_stateful_objects_or_state_machines">8.19 实现状态对象或者状态机</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p20_call_method_on_object_by_string_name">8.20 通过字符串调用对象方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p21_implementing_visitor_pattern">8.21 实现访问者模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p22_implementing_visitor_pattern_without_recursion">8.22 不用递归实现访问者模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p23_managing_memory_in_cyclic_data_structures">8.23 循环引用数据结构的内存管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p24_making_classes_support_comparison_operations">8.24 让类支持比较操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c08/p25_creating_cached_instances">8.25 创建缓存实例</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p09_meta_programming">第九章：元编程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p01_put_wrapper_around_function">9.1 在函数上添加包装器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p02_preserve_function_metadata_when_write_decorators">9.2 创建装饰器时保留函数元信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p03_unwrapping_decorator">9.3 解除一个装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p04_define_decorator_that_takes_arguments">9.4 定义一个带参数的装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p05_define_decorator_with_user_adjustable_attributes">9.5 可自定义属性的装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p06_define_decorator_that_takes_optional_argument">9.6 带可选参数的装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p07_enforcing_type_check_on_function_using_decorator">9.7 利用装饰器强制函数上的类型检查</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p08_define_decorators_as_part_of_class">9.8 将装饰器定义为类的一部分</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p09_define_decorators_as_classes">9.9 将装饰器定义为类</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p10_apply_decorators_to_class_and_static_methods">9.10 为类和静态方法提供装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p11_write_decorators_that_add_arguments_to_functions">9.11 装饰器为被包装函数增加参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p12_using_decorators_to_patch_class_definitions">9.12 使用装饰器扩充类的功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p13_using_mataclass_to_control_instance_creation">9.13 使用元类控制实例的创建</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p14_capture_class_attribute_definition_order">9.14 捕获类的属性定义顺序</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p15_define_metaclass_that_takes_optional_arguments">9.15 定义有可选参数的元类</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p16_enforce_argument_signature_on_args_kwargs">9.16 *args和**kwargs的强制参数签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p17_enforce_coding_conventions_in_classes">9.17 在类上强制使用编程规约</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p18_define_classes_programmatically">9.18 以编程方式定义类</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p19_initializing_class_members_at_definition_time">9.19 在定义的时候初始化类的成员</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p20_implement_multiple_dispatch_with_function_annotations">9.20 利用函数注解实现方法重载</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p21_avoid_repetitive_property_methods">9.21 避免重复的属性方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p22_define_context_managers_the_easy_way">9.22 定义上下文管理器的简单方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p23_executing_code_with_local_side_effects">9.23 在局部变量域中执行代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p24_parse_and_analyzing_python_source">9.24 解析与分析Python源码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c09/p25_disassembling_python_byte_code">9.25 拆解Python字节码</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p10_modules_and_packages">第十章：模块与包</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p01_make_hierarchical_package_of_modules">10.1 构建一个模块的层级包</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p02_control_the_import_of_everything">10.2 控制模块被全部导入的内容</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p03_import_submodules_by_relative_names">10.3 使用相对路径名导入包中子模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p04_split_module_into_multiple_files">10.4 将模块分割成多个文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p05_separate_directories_import_by_namespace">10.5 利用命名空间导入目录分散的代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p06_reloading_modules">10.6 重新加载模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p07_make_directory_or_zip_runnable_as_main_script">10.7 运行目录或压缩文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p08_read_datafile_within_package">10.8 读取位于包中的数据文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p09_add_directories_to_sys_path">10.9 将文件夹加入到sys.path</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p10_import_modules_using_name_given_in_string">10.10 通过字符串名导入模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p11_load_modules_from_remote_machine_by_hooks">10.11 通过钩子远程加载模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p12_patching_modules_on_import">10.12 导入模块的同时修改模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p13_installing_packages_just_for_yourself">10.13 安装私有的包</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p14_creating_new_python_environment">10.14 创建新的Python环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c10/p15_distributing_packages">10.15 分发包</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p11_network_and_web_program">第十一章：网络与Web编程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p01_interact_with_http_services_as_client">11.1 作为客户端与HTTP服务交互</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p02_creating_tcp_server">11.2 创建TCP服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p03_creating_udp_server">11.3 创建UDP服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p04_generate_range_of_ip_addresses_from_cidr_address">11.4 通过CIDR地址生成对应的IP地址集</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p05_creating_simple_rest_based_interface">11.5 创建一个简单的REST接口</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p06_implement_simple_remote_procedure_call_with_xml_rpc">11.6 通过XML-RPC实现简单的远程调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p07_communicate_simply_between_interpreters">11.7 在不同的Python解释器之间交互</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p08_implementing_remote_procedure_calls">11.8 实现远程方法调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p09_authenticating_clients_simply">11.9 简单的客户端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p10_add_ssl_to_network_services">11.10 在网络服务中加入SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p11_pass_socket_file_descriptor_between_processes">11.11 进程间传递Socket文件描述符</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p12_understanding_event_driven_io">11.12 理解事件驱动的IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c11/p13_sending_receiving_large_arrays">11.13 发送与接收大型数组</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p12_concurrency">第十二章：并发编程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p01_start_stop_thread">12.1 启动与停止线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p02_determining_if_thread_has_started">12.2 判断线程是否已经启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p03_communicating_between_threads">12.3 线程间通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p04_locking_critical_sections">12.4 给关键部分加锁</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p05_locking_with_deadlock_avoidance">12.5 防止死锁的加锁机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p06_storing_thread_specific_state">12.6 保存线程的状态信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p07_creating_thread_pool">12.7 创建一个线程池</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p08_perform_simple_parallel_programming">12.8 简单的并行编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p09_dealing_with_gil_stop_worring_about_it">12.9 Python的全局锁问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p10_defining_an_actor_task">12.10 定义一个Actor任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p11_implement_publish_subscribe_messaging">12.11 实现消息发布/订阅模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p12_using_generators_as_alternative_to_threads">12.12 使用生成器代替线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p13_polling_multiple_thread_queues">12.13 多个线程队列轮询</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c12/p14_launching_daemon_process_on_unix">12.14 在Unix系统上面启动守护进程</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p13_utility_script_and_system_manage">第十三章：脚本编程与系统管理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p01_accept_input_via_redirect_pips_or_input_files">13.1 通过重定向/管道/文件接受输入</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p02_terminate_program_with_an_error_message">13.2 终止程序并给出错误信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p03_parsing_command_line_options">13.3 解析命令行选项</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p04_prompt_for_password_at_runtime">13.4 运行时弹出密码输入提示</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p05_getting_terminal_size">13.5 获取终端的大小</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p06_executing_external_command_and_get_its_output">13.6 执行外部命令并获取它的输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p07_copy_move_files_and_directories">13.7 复制或者移动文件和目录</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p08_creating_and_unpacking_archives">13.8 创建和解压归档文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p09_find_files_by_name">13.9 通过文件名查找文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p10_read_configuration_files">13.10 读取配置文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p11_add_logging_to_simple_scripts">13.11 给简单脚本增加日志功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p12_add_logging_to_libraries">13.12 给函数库增加日志功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p13_making_stopwatch_timer">13.13 实现一个计时器</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p14_putting_limits_on_memory_and_cpu_usage">13.14 限制内存和CPU的使用量</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c13/p15_luanch_a_web_browser">13.15 启动一个WEB浏览器</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p14_test_debug_and_exceptions">第十四章：测试、调试和异常</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p01_testing_output_sent_to_stdout">14.1 测试stdout输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p02_patching_objects_in_unit_tests">14.2 在单元测试中给对象打补丁</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p03_testing_for_exceptional_conditions_in_unit_tests">14.3 在单元测试中测试异常情况</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p04_logging_test_output_to_file">14.4 将测试输出用日志记录到文件中</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p05_skip_or_anticipate_test_failures">14.5 忽略或期望测试失败</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p06_handle_multiple_exceptions">14.6 处理多个异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p07_catching_all_exceptions">14.7 捕获所有异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p08_creating_custom_exceptions">14.8 创建自定义异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p09_raise_exception_in_response_to_another_exception">14.9 捕获异常后抛出另外的异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p10_reraising_the_last_exception">14.10 重新抛出被捕获的异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p11_issuing_warning_messages">14.11 输出警告信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p12_debugging_basic_program_crashes">14.12 调试基本的程序崩溃错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p13_profiling_and_timing_your_program">14.13 给你的程序做性能测试</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c14/p14_make_your_program_run_faster">14.14 加速程序运行</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p15_c_extensions">第十五章：C语言扩展</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p01_access_ccode_using_ctypes">15.1 使用ctypes访问C代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p02_write_simple_c_extension_module">15.2 简单的C扩展模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p03_write_extension_function_operate_on_arrays">15.3 编写扩展函数操作数组</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p04_manage_opaque_pointers_in_c_extension_modules">15.4 在C扩展模块中操作隐形指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p05_define_and_export_c_api_from_extension_modules">15.5 从扩展模块中定义和导出C的API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p06_calling_python_from_c">15.6 从C语言中调用Python代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p07_release_the_gil_in_c_extensions">15.7 从C扩展中释放全局锁</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p08_mix_threads_from_c_and_python">15.8 C和Python中的线程混用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p09_wrap_c_code_with_swig">15.9 用WSIG包装C代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p10_wrap_existing_c_code_with_cython">15.10 用Cython包装C代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p11_use_cython_to_write_high_performance_array_operation">15.11 用Cython写高性能的数组操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p12_turning_function_pointer_into_callable">15.12 将函数指针转换为可调用对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p13_pass_null_terminated_string_to_c_libraries">15.13 传递NULL结尾的字符串给C函数库</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p14_pass_unicode_strings_to_c_libraries">15.14 传递Unicode字符串给C函数库</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p15_converting_c_string_to_python">15.15 C字符串转换为Python字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p16_work_with_c_strings_of_dubious_encoding">15.16 不确定编码格式的C字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p17_pass_filenames_to_c_extensions">15.17 传递文件名给C扩展</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p18_pass_open_files_to_c_extensions">15.18 传递已打开的文件给C扩展</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p19_read_file_like_objects_from_c">15.19 从C语言中读取类文件对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p20_consuming_an_iterable_from_c">15.20 处理C语言中的可迭代对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-c15/p21_diagnosing_segmentation_faults">15.21 诊断分段错误</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapters/p16_appendix">附录A</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">在线资源</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#python">Python学习书籍</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">高级书籍</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-aboutme">关于译者</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-roadmap">Roadmap</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html#document-index">python3-cookbook</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html#document-index">Docs</a> &raquo;</li>
        
      <li>python3-cookbook 3.0.0 文档</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/yidao620c/python3-cookbook/blob/727e4b1a0b9cdcd5d6aed40b1720f8de80c9a93c/source/index.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="python-cookbook-3rd-edition-documentation">
<h1>Python Cookbook 3rd Edition Documentation<a class="headerlink" href="#python-cookbook-3rd-edition-documentation" title="永久链接至标题">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-copyright"></span><div class="section" id="copyright">
<h2>Copyright<a class="headerlink" href="#copyright" title="永久链接至标题">¶</a></h2>
<div class="line-block">
<div class="line">书名：    《Python Cookbook》3rd Edition</div>
<div class="line">作者：     David Beazley, Brian K. Jones</div>
<div class="line">译者：     熊能</div>
<div class="line">版本：     第3版</div>
<div class="line">出版社：   O’Reilly Media, Inc.</div>
<div class="line">出版日期：  2013年5月08日</div>
<div class="line">Copyright © 2013 David Beazley and Brian Jones. All rights reserved.</div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="line-block">
<div class="line">更多发布信息请参考 <a class="reference external" href="http://oreilly.com/catalog/errata.csp?isbn=9781449340377">http://oreilly.com/catalog/errata.csp?isbn=9781449340377</a></div>
</div>
</div>
<span id="document-preface"></span><div class="section" id="id1">
<h2>前言<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<div class="section" id="id2">
<h3>项目主页<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p>
</div>
<div class="section" id="id3">
<h3>译者的话<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>人生苦短，我用 Python！</p>
<p>译者一直坚持使用 Python 3，因为它代表了 Python 的未来。虽然向后兼容是它的硬伤，但是这个局面迟早会改变的，
而且 Python 3 的未来需要每个人的帮助和支持。
目前市面上的教程书籍，网上的手册大部分基本都是 2.x 系列的，专门基于 3.x 系列的书籍少的可怜。</p>
<p>最近看到一本《Python Cookbook》3rd Edition，完全基于 Python 3，写的也很不错。
为了 Python 3 的普及，我也不自量力，想做点什么事情。于是乎，就有了翻译这本书的冲动了！
这不是一项轻松的工作，却是一件值得做的工作：不仅方便了别人，而且对自己翻译能力也是一种锻炼和提升。</p>
<p>译者会坚持对自己每一句的翻译负责，力求高质量。但受能力限制，也难免有疏漏或者表意不当的地方。
如果译文中有什么错漏的地方请大家见谅，也欢迎大家随时指正： <a class="reference external" href="mailto:yidao620&#37;&#52;&#48;gmail&#46;com">yidao620<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</div>
<div class="section" id="id4">
<h3>作者的话<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>自从 2008 年以来，Python 3 横空出世并慢慢进化。Python 3 的流行一直被认为需要很长一段时间。
事实上，到我写这本书的 2013 年，绝大部分的 Python 程序员仍然在生产环境中使用的是版本 2 系列，
最主要是因为 Python 3 不向后兼容。毫无疑问，对于工作在遗留代码上的每个程序员来讲，向后兼容是不得不考虑的问题。
但是放眼未来，你就会发现 Python 3 给你带来不一样的惊喜。</p>
<p>正如 Python 3 代表未来一样，新的《Python Cookbook》版本相比较之前的版本有了一个全新的改变。
首先，也是最重要的，这意味着本书是一本非常前沿的参考书。书中所有代码都是在 Python 3.3 版本下面编写和测试的，
并没有考虑之前老版本的兼容性，也没有标注旧版本下的解决方案。这样子可能会有争议，
但是我们最终的目的是写一本完全基于现代工具和语言的书籍。
我们希望本书能够指导人们使用 Python 3 编写新的代码或者升级之前的遗留代码。</p>
<p>毫无疑问，编写一本这样的书给编辑工作带来一定的挑战。如果在网上搜索 Python 秘籍的话，会在诸如 ActiveState’s Python recipes 或者 Stack Overflow 的网站上搜到数以千计的有用的秘籍，但是其中绝大部分都已经是过时的了。
这些秘籍除了是基于 Python 2 编写之外，可能还有很多解决方案在不同的版本之间是不一样的 （比如 2.3 和 2.4 版本）。
另外，它们还会经常使用一些过时的技术，这些可能已经内置到 Python 3.3 里面去了。寻找完全基于 Python 3 的秘籍真的难上加难啊。</p>
<p>这本书的所有主题都是基于已经存在的代码和技术，而不是专门去寻找 Python 3 特有的秘籍。
在原有代码基础上，我们完全使用最新的 Python 技术去改造。
所以，任何想使用最新技术编写代码的程序员，都可以将本书当做一本很好的参考书籍。</p>
<p>在选择要包含哪些秘籍方面，很明显不可能编写一本书囊括 Python 领域所有的东西。
因此，我们优先选择了 Python 语言核心部分，以及那些有着广泛应用领域的问题。
另外，其中有很多秘籍用来展示 Python 3 的新特性，
这对于很多人来说是比较陌生的，哪怕是使用 Python 老版本的经验丰富的程序员。
这些示例程序也会偏向于展示一些有着广泛应用的编程技术 （即编程模式），
而不是仅仅定位在一些具体的问题上。尽管也提及到了一些第三方包，但是本书主要定位在 Python 语言核心和标准库。</p>
</div>
<div class="section" id="id5">
<h3>这本书适合谁<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>这本书的目标读者是那些想深入理解 Python 语言机制和现代编程风格的有经验的 Python 程序员。
本书大部分内容集中于在标准库，框架和应用程序中广泛使用的高级技术。
本书所有示例均假设读者具有一定的编程背景并且可以读懂相关主题
（比如基本的计算机科学知识，数据结构知识，算法复杂度，系统编程，并行，C 语言编程等）。
另外，每个示例都只是一个入门指导，如果读者想深入研究，需要自己去查阅更多资料。
我们假定读者可以很熟练的使用搜索引擎以及知道怎样查询在线的 Python 文档。</p>
<p>有一些更加高级的秘籍，如果耐心阅读，将有助于理解 Python 底层的工作原理。
从中你将学到一些新的技巧和技术，并应用到你自己的代码中去。</p>
</div>
<div class="section" id="id6">
<h3>这本书不适合谁<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>这本书不适合 Python 的初学者。事实上，本书假定读者具有 Python 教程或入门书籍中所教授的基础知识。
本书也不是那种快速参考手册 （例如快速查询某个模块下的某个函数）。
本书旨在聚焦几个最重要的主题，演示几种可能的解决方案，
提供一个跳板引导读者进入一些更高级的内容（这些可以在网上或者参考手册中找到）。</p>
</div>
<div class="section" id="id7">
<h3>在线示例代码<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>本书几乎所有源代码均可以在 <a class="reference external" href="http://github.com/dabeaz/python-cookbook">http://github.com/dabeaz/python-cookbook</a> 上面找到。
作者欢迎各位读者修正 bug，改进代码和评论。</p>
</div>
<div class="section" id="id8">
<h3>使用示例代码<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>本书就是帮助你完成你的工作的。
一般来讲，只要是本书上面的示例代码，你都可以随时拿过去在你的源代码和文档中使用。
除非你使用了大量的代码，否则不需要向我们申请许可。
例如，使用几个代码片段去完成一个程序不需要许可，贩卖或者分发示例代码的光盘则需要许可。
引用本书和示例代码去网上回答一个问题不需要许可，但是合并大量的代码到你的正式产品文档中去则需要许可。</p>
<p>我们不会要求你添加代码的出处，但是如果你这么做了，我们会很感激的。
引用通常包含标题，作者，出版社，ISBN。
例如：<em>Python Cookbook</em>, 3rd edition, by David Beazley and Brian K. Jones (O’Reilly).
Copyright 2013 David Beazley and Brian Jones, 978-1-449-34037-7.</p>
<p>如果你觉得你对示例代码的使用超出了合理使用或者上述列出的许可范围，
请随时联系我们，我们的邮箱是 <a class="reference external" href="mailto:permissions&#37;&#52;&#48;oreilly&#46;com">permissions<span>&#64;</span>oreilly<span>&#46;</span>com</a>。</p>
</div>
<div class="section" id="id9">
<h3>联系我们<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>请将关于本书的评论和问题发送给出版社：</p>
<div class="line-block">
<div class="line">O’Reilly Media, Inc.</div>
<div class="line">1005 Gravenstein Highway North</div>
<div class="line">Sebastopol, CA 95472</div>
<div class="line">800-998-9938 (in the United States or Canada)</div>
<div class="line">707-829-0515 (international or local)</div>
<div class="line">707-829-0104 (fax)</div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>我们为本书建立了一个网页， 其中包含勘误表，示例和一些其他信息。
可以通过链接 <a class="reference external" href="http://oreil.ly/python_cookbook_3e">http://oreil.ly/python_cookbook_3e</a> 访问。</p>
<p>关于本书的建议和技术性问题，请发送邮件至： <a class="reference external" href="mailto:bookquestions&#37;&#52;&#48;oreilly&#46;com">bookquestions<span>&#64;</span>oreilly<span>&#46;</span>com</a></p>
<p>关于我们的书籍，讨论会，新闻的更多信息， 请访问我们的网站： <a class="reference external" href="http://www.oreilly.com">http://www.oreilly.com</a></p>
<p>在 Facebook 上找到我们：<a class="reference external" href="http://facebook.com/oreilly">http://facebook.com/oreilly</a></p>
<p>在 Twitter 上关注我们：<a class="reference external" href="http://twitter.com/oreillymedia">http://twitter.com/oreillymedia</a></p>
<p>在 YouTube 上观看我们：<a class="reference external" href="http://www.youtube.com/oreillymedia">http://www.youtube.com/oreillymedia</a></p>
</div>
<div class="section" id="id10">
<h3>致谢<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>我们衷心感谢本书的技术校审人员 Jake Vanderplas，Robert Kern 和 Andrea Crotti 非常有用的评论和建议，
还有 Python 社区的帮助和鼓励。我们同样感谢上一个版本的编辑 Alex Martelli，Anna Ravenscroft 和 David Ascher。
尽管这个版本是新创作的，但是前一个版本为本书提供了一个挑选主题和秘籍的初始框架。
最后也是最重要的，我们要感谢所有早期预览版本的读者，感谢你们为本书的改进提出的建议和意见。</p>
</div>
</div>
<span id="document-chapters/p01_data_structures_algorithms"></span><div class="section" id="id1">
<h2>第一章：数据结构和算法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>Python 提供了大量的内置数据结构，包括列表，集合以及字典。大多数情况下使用这些数据结构是很简单的。
但是，我们也会经常碰到到诸如查询，排序和过滤等等这些普遍存在的问题。
因此，这一章的目的就是讨论这些比较常见的问题和算法。
另外，我们也会给出在集合模块 <code class="docutils literal"><span class="pre">collections</span></code> 当中操作这些数据结构的方法。</p>
<div class="toctree-wrapper compound">
<span id="document-c01/p01_unpack_sequence_into_separate_variables"></span><div class="section" id="id1">
<h3>1.1 解压序列赋值给多个变量<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。
唯一的前提就是变量的数量必须跟序列元素的数量是一样的。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">5</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">date</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">&#39;ACME&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">date</span>
<span class="go">(2012, 12, 21)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">mon</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">&#39;ACME&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">year</span>
<span class="go">2012</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mon</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">day</span>
<span class="go">21</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果变量个数和序列元素的个数不匹配，会产生一个异常。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; p = (4, 5)
&gt;&gt;&gt; x, y, z = p
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: need more than 2 values to unpack
&gt;&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>实际上，这种解压赋值可以用在任何可迭代对象上面，而不仅仅是列表或者元组。
包括字符串，文件对象，迭代器和生成器。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&#39;H&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&#39;e&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">&#39;o&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有时候，你可能只想解压一部分，丢弃其他的值。对于这种情况 Python 并没有提供特殊的语法。
但是你可以使用任意变量名去占位，到时候丢掉这些变量就行了。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shares</span>
<span class="go">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">price</span>
<span class="go">91.1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你必须保证你选用的那些占位变量名在其他地方没被使用到。</p>
</div>
</div>
<span id="document-c01/p02_unpack_elements_from_iterables"></span><div class="section" id="id1">
<h3>1.2 解压可迭代对象赋值给多个变量<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 <code class="docutils literal"><span class="pre">ValueError</span></code> 。
那么怎样才能从这个可迭代对象中解压出 N 个元素出来？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python 的星号表达式可以用来解决这个问题。比如，你在学习一门课程，在学期末的时候，
你想统计下家庭作业的平均成绩，但是排除掉第一个和最后一个分数。如果只有四个分数，你可能就直接去简单的手动赋值，
但如果有 24 个呢？这时候星号表达式就派上用场了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">drop_first_last</span><span class="p">(</span><span class="n">grades</span><span class="p">):</span>
    <span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">middle</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">grades</span>
    <span class="k">return</span> <span class="n">avg</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
</pre></div>
</div>
<p>另外一种情况，假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。
你可以像下面这样分解这些记录：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Dave&#39;</span><span class="p">,</span> <span class="s1">&#39;dave@example.com&#39;</span><span class="p">,</span> <span class="s1">&#39;773-555-1212&#39;</span><span class="p">,</span> <span class="s1">&#39;847-555-1212&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="o">*</span><span class="n">phone_numbers</span> <span class="o">=</span> <span class="n">record</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">&#39;Dave&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span>
<span class="go">&#39;dave@example.com&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phone_numbers</span>
<span class="go">[&#39;773-555-1212&#39;, &#39;847-555-1212&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>值得注意的是上面解压出的 <code class="docutils literal"><span class="pre">phone_numbers</span></code> 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个）。
所以，任何使用到 <code class="docutils literal"><span class="pre">phone_numbers</span></code> 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。</p>
<p>星号表达式也能用在列表的开始部分。比如，你有一个公司前 8 个月销售数据的序列，
但是你想看下最近一个月数据和前面 7 个月的平均值的对比。你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">trailing_qtrs</span><span class="p">,</span> <span class="n">current_qtr</span> <span class="o">=</span> <span class="n">sales_record</span>
<span class="n">trailing_avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">trailing_qtrs</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">trailing_qtrs</span><span class="p">)</span>
<span class="k">return</span> <span class="n">avg_comparison</span><span class="p">(</span><span class="n">trailing_avg</span><span class="p">,</span> <span class="n">current_qtr</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是在 Python 解释器中执行的结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">*</span><span class="n">trailing</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trailing</span>
<span class="go">[10, 8, 7, 1, 9, 5, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">current</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。
通常，这些可迭代对象的元素结构有确定的规则（比如第 1 个元素后面都是电话号码），
星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。
而不是通过一些比较复杂的手段去获取这些关联的元素值。</p>
<p>值得注意的是，星号表达式在迭代元素为可变长元组的序列时是很有用的。
比如，下面是一个带有标签的元组序列：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">records</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="p">]</span>

<span class="k">def</span> <span class="nf">do_foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">do_bar</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;foo&#39;</span><span class="p">:</span>
        <span class="n">do_foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span>
        <span class="n">do_bar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>星号解压语法在字符串操作的时候也会很有用，比如字符串的分割。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uname</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">,</span> <span class="n">homedir</span><span class="p">,</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uname</span>
<span class="go">&#39;nobody&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homedir</span>
<span class="go">&#39;/var/empty&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sh</span>
<span class="go">&#39;/usr/bin/false&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有时候，你想解压一些元素后丢弃它们，你不能简单就使用 <code class="docutils literal"><span class="pre">*</span></code> ，
但是你可以使用一个普通的废弃名称，比如 <code class="docutils literal"><span class="pre">_</span></code> 或者 <code class="docutils literal"><span class="pre">ign</span></code> （ignore）。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">123.45</span><span class="p">,</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">2012</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span> <span class="o">=</span> <span class="n">record</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">&#39;ACME&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">year</span>
<span class="go">2012</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。比如，如果你有一个列表，
你可以很容易的将它分割成前后两部分：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">items</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">head</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tail</span>
<span class="go">[10, 7, 4, 5, 9]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你够聪明的话，还能用这种分割语法去巧妙的实现递归算法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">items</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">head</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="k">if</span> <span class="n">tail</span> <span class="k">else</span> <span class="n">head</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
<span class="go">36</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然后，由于语言层面的限制，递归并不是 Python 擅长的。
因此，最后那个递归演示仅仅是个好奇的探索罢了，对这个不要太认真了。</p>
</div>
</div>
<span id="document-c01/p03_keep_last_n_items"></span><div class="section" id="n">
<h3>1.3 保留最后 N 个元素<a class="headerlink" href="#n" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>保留有限历史记录正是 <code class="docutils literal"><span class="pre">collections.deque</span></code> 大显身手的时候。比如，下面的代码在多行上面做简单的文本匹配，
并返回匹配所在行的最后N行：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">previous_lines</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">history</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">line</span><span class="p">,</span> <span class="n">previous_lines</span>
        <span class="n">previous_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

<span class="c1"># Example use on a file</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;../../cookbook/somefile.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span><span class="p">,</span> <span class="n">prevlines</span> <span class="ow">in</span> <span class="n">search</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pline</span> <span class="ow">in</span> <span class="n">prevlines</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">pline</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>我们在写查询元素的代码时，通常会使用包含 <code class="docutils literal"><span class="pre">yield</span></code> 表达式的生成器函数，也就是我们上面示例代码中的那样。
这样可以将搜索过程代码和使用搜索结果代码解耦。如果你还不清楚什么是生成器，请参看 4.3 节。</p>
<p>使用 <code class="docutils literal"><span class="pre">deque(maxlen=N)</span></code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候，
最老的元素会自动被移除掉。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>
<span class="go">deque([1, 2, 3], maxlen=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>
<span class="go">deque([2, 3, 4], maxlen=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>
<span class="go">deque([3, 4, 5], maxlen=3)</span>
</pre></div>
</div>
<p>尽管你也可以手动在一个列表上实现这一的操作（比如增加、删除等等）。但是这里的队列方案会更加优雅并且运行得更快些。</p>
<p>更一般的， <code class="docutils literal"><span class="pre">deque</span></code> 类可以被用在任何你只需要一个简单队列数据结构的场合。
如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>
<span class="go">deque([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>
<span class="go">deque([4, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>
<span class="go">deque([4, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>在队列两端插入或删除元素时间复杂度都是 <code class="docutils literal"><span class="pre">O(1)</span></code> ，而在列表的开头插入或删除元素的时间复杂度为 <code class="docutils literal"><span class="pre">O(N)</span></code> 。</p>
</div>
</div>
<span id="document-c01/p04_find_largest_or_smallest_n_items"></span><div class="section" id="n">
<h3>1.4 查找最大或最小的 N 个元素<a class="headerlink" href="#n" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>怎样从一个集合中获得最大或者最小的 N 个元素列表？</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>heapq 模块有两个函数：<code class="docutils literal"><span class="pre">nlargest()</span></code> 和 <code class="docutils literal"><span class="pre">nsmallest()</span></code> 可以完美解决这个问题。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">nums</span><span class="p">))</span> <span class="c1"># Prints [42, 37, 23]</span>
<span class="k">print</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">nums</span><span class="p">))</span> <span class="c1"># Prints [-4, 1, 2]</span>
</pre></div>
</div>
<p>两个函数都能接受一个关键字参数，用于更复杂的数据结构中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">portfolio</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mf">91.1</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;AAPL&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mf">543.22</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;FB&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mf">21.09</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;HPQ&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mf">31.75</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;YHOO&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">45</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mf">16.35</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">75</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mf">115.65</span><span class="p">}</span>
<span class="p">]</span>
<span class="n">cheap</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">portfolio</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">])</span>
<span class="n">expensive</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">portfolio</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>译者注：上面代码在对每个元素进行对比的时候，会以 <code class="docutils literal"><span class="pre">price</span></code> 的值进行比较。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想在一个集合中查找最小或最大的 N 个元素，并且 N 小于集合元素数量，那么这些函数提供了很好的性能。
因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span>
<span class="go">[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>堆数据结构最重要的特征是 <code class="docutils literal"><span class="pre">heap[0]</span></code> 永远是最小的元素。并且剩余的元素可以很容易的通过调用 <code class="docutils literal"><span class="pre">heapq.heappop()</span></code> 方法得到，
该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是堆大小）。
比如，如果想要查找最小的 3 个元素，你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">-4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>当要查找的元素个数相对比较小的时候，函数 <code class="docutils literal"><span class="pre">nlargest()</span></code> 和 <code class="docutils literal"><span class="pre">nsmallest()</span></code> 是很合适的。
如果你仅仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 <code class="docutils literal"><span class="pre">min()</span></code> 和 <code class="docutils literal"><span class="pre">max()</span></code> 函数会更快些。
类似的，如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点
（ <code class="docutils literal"><span class="pre">sorted(items)[:N]</span></code> 或者是 <code class="docutils literal"><span class="pre">sorted(items)[-N:]</span></code> ）。
需要在正确场合使用函数 <code class="docutils literal"><span class="pre">nlargest()</span></code> 和 <code class="docutils literal"><span class="pre">nsmallest()</span></code> 才能发挥它们的优势
（如果 N 快接近集合大小了，那么使用排序操作会更好些）。</p>
<p>尽管你没有必要一定使用这里的方法，但是堆数据结构的实现是一个很有趣并且值得你深入学习的东西。
基本上只要是数据结构和算法书籍里面都会有提及到。
<code class="docutils literal"><span class="pre">heapq</span></code> 模块的官方文档里面也详细的介绍了堆数据结构底层的实现细节。</p>
</div>
</div>
<span id="document-c01/p05_implement_a_priority_queue"></span><div class="section" id="id1">
<h3>1.5 实现一个优先级队列<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>怎样实现一个按优先级排序的队列？ 并且在这个队列上面每次 pop 操作总是返回优先级最高的那个元素</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>下面的类利用 <code class="docutils literal"><span class="pre">heapq</span></code> 模块实现了一个简单的优先级队列：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">priority</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>下面是它的使用方式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Item</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s1">&#39;Item({!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s1">&#39;grok&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">Item(&#39;bar&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">Item(&#39;spam&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">Item(&#39;foo&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">Item(&#39;grok&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>仔细观察可以发现，第一个 <code class="docutils literal"><span class="pre">pop()</span></code> 操作返回优先级最高的元素。
另外注意到如果两个有着相同优先级的元素（ <code class="docutils literal"><span class="pre">foo</span></code> 和 <code class="docutils literal"><span class="pre">grok</span></code> ），pop 操作按照它们被插入到队列的顺序返回的。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一小节我们主要关注 <code class="docutils literal"><span class="pre">heapq</span></code> 模块的使用。
函数 <code class="docutils literal"><span class="pre">heapq.heappush()</span></code> 和 <code class="docutils literal"><span class="pre">heapq.heappop()</span></code> 分别在队列 <code class="docutils literal"><span class="pre">_queue</span></code> 上插入和删除第一个元素，
并且队列 <code class="docutils literal"><span class="pre">_queue</span></code> 保证第一个元素拥有最高优先级（ 1.4 节已经讨论过这个问题）。
<code class="docutils literal"><span class="pre">heappop()</span></code> 函数总是返回&#8221;最小的&#8221;的元素，这就是保证队列pop操作返回正确元素的关键。
另外，由于 push 和 pop 操作时间复杂度为 O(log N)，其中 N 是堆的大小，因此就算是 N 很大的时候它们运行速度也依旧很快。</p>
<p>在上面代码中，队列包含了一个 <code class="docutils literal"><span class="pre">(-priority,</span> <span class="pre">index,</span> <span class="pre">item)</span></code> 的元组。
优先级为负数的目的是使得元素按照优先级从高到低排序。
这个跟普通的按优先级从低到高排序的堆排序恰巧相反。</p>
<p><code class="docutils literal"><span class="pre">index</span></code> 变量的作用是保证同等优先级元素的正确排序。
通过保存一个不断增加的 <code class="docutils literal"><span class="pre">index</span></code> 下标变量，可以确保元素按照它们插入的顺序排序。
而且， <code class="docutils literal"><span class="pre">index</span></code> 变量也在相同优先级元素比较的时候起到重要作用。</p>
<p>为了阐明这些，先假定 <code class="docutils literal"><span class="pre">Item</span></code> 实例是不支持排序的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; a = Item(&#39;foo&#39;)
&gt;&gt;&gt; b = Item(&#39;bar&#39;)
&gt;&gt;&gt; a &lt; b
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
&gt;&gt;&gt;
</pre></div>
</div>
<p>如果你使用元组 <code class="docutils literal"><span class="pre">(priority,</span> <span class="pre">item)</span></code> ，只要两个元素的优先级不同就能比较。
但是如果两个元素优先级一样的话，那么比较操作就会跟之前一样出错：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; a = (1, Item(&#39;foo&#39;))
&gt;&gt;&gt; b = (5, Item(&#39;bar&#39;))
&gt;&gt;&gt; a &lt; b
True
&gt;&gt;&gt; c = (1, Item(&#39;grok&#39;))
&gt;&gt;&gt; a &lt; c
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
&gt;&gt;&gt;
</pre></div>
</div>
<p>通过引入另外的 <code class="docutils literal"><span class="pre">index</span></code> 变量组成三元组 <code class="docutils literal"><span class="pre">(priority,</span> <span class="pre">index,</span> <span class="pre">item)</span></code> ，就能很好的避免上面的错误，
因为不可能有两个元素有相同的 <code class="docutils literal"><span class="pre">index</span></code> 值。Python 在做元组比较时候，如果前面的比较已经可以确定结果了，
后面的比较操作就不会发生了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Item</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Item</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Item</span><span class="p">(</span><span class="s1">&#39;grok&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">c</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想在多个线程中使用同一个队列，那么你需要增加适当的锁和信号量机制。
可以查看 12.3 小节的例子演示是怎样做的。</p>
<p><code class="docutils literal"><span class="pre">heapq</span></code> 模块的官方文档有更详细的例子程序以及对于堆理论及其实现的详细说明。</p>
</div>
</div>
<span id="document-c01/p06_map_keys_to_multiple_values_in_dict"></span><div class="section" id="id1">
<h3>1.6 字典中的键映射多个值<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>怎样实现一个键对应多个值的字典（也叫 <code class="docutils literal"><span class="pre">multidict</span></code>）？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>一个字典就是一个键对应一个单值的映射。如果你想要一个键映射多个值，那么你就需要将这多个值放到另外的容器中，
比如列表或者集合里面。比如，你可以像下面这样构造这样的字典：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;a&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="s1">&#39;b&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">e</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;a&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;b&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>选择使用列表还是集合取决于你的实际需求。如果你想保持元素的插入顺序就应该使用列表，
如果想去掉重复元素就使用集合（并且不关心元素的顺序问题）。</p>
<p>你可以很方便的使用 <code class="docutils literal"><span class="pre">collections</span></code> 模块中的 <code class="docutils literal"><span class="pre">defaultdict</span></code> 来构造这样的字典。
<code class="docutils literal"><span class="pre">defaultdict</span></code> 的一个特征是它会自动初始化每个 <code class="docutils literal"><span class="pre">key</span></code> 刚开始对应的值，所以你只需要关注添加元素操作了。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>需要注意的是， <code class="docutils literal"><span class="pre">defaultdict</span></code> 会自动为将要访问的键（就算目前字典中并不存在这样的键）创建映射实体。
如果你并不需要这样的特性，你可以在一个普通的字典上使用 <code class="docutils literal"><span class="pre">setdefault()</span></code> 方法来代替。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># A regular dictionary</span>
<span class="n">d</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>但是很多程序员觉得 <code class="docutils literal"><span class="pre">setdefault()</span></code> 用起来有点别扭。因为每次调用都得创建一个新的初始值的实例（例子程序中的空列表 <code class="docutils literal"><span class="pre">[]</span></code> ）。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>一般来讲，创建一个多值映射字典是很简单的。但是，如果你选择自己实现的话，那么对于值的初始化可能会有点麻烦，
你可能会像下面这样来实现：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>如果使用 <code class="docutils literal"><span class="pre">defaultdict</span></code> 的话代码就更加简洁了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>这一小节所讨论的问题跟数据处理中的记录归类问题有大的关联。可以参考 1.15 小节的例子。</p>
</div>
</div>
<span id="document-c01/p07_keep_dict_in_order"></span><div class="section" id="id1">
<h3>1.7 字典排序<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了能控制一个字典中元素的顺序，你可以使用 <code class="docutils literal"><span class="pre">collections</span></code> 模块中的 <code class="docutils literal"><span class="pre">OrderedDict</span></code> 类。
在迭代操作的时候它会保持元素被插入时的顺序，示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;spam&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;grok&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># Outputs &quot;foo 1&quot;, &quot;bar 2&quot;, &quot;spam 3&quot;, &quot;grok 4&quot;</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
</pre></div>
</div>
<p>当你想要构建一个将来需要序列化或编码成其他格式的映射的时候， <code class="docutils literal"><span class="pre">OrderedDict</span></code> 是非常有用的。
比如，你想精确控制以 JSON 编码后字段的顺序，你可以先使用 <code class="docutils literal"><span class="pre">OrderedDict</span></code> 来构建这样的数据：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;{&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;spam&quot;: 3, &quot;grok&quot;: 4}&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">OrderedDict</span></code> 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候，
它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。</p>
<p>需要注意的是，一个 <code class="docutils literal"><span class="pre">OrderedDict</span></code> 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。
所以如果你要构建一个需要大量 <code class="docutils literal"><span class="pre">OrderedDict</span></code> 实例的数据结构的时候（比如读取 100,000 行 CSV 数据到一个 <code class="docutils literal"><span class="pre">OrderedDict</span></code> 列表中去），
那么你就得仔细权衡一下是否使用 <code class="docutils literal"><span class="pre">OrderedDict</span></code> 带来的好处要大过额外内存消耗的影响。</p>
</div>
</div>
<span id="document-c01/p08_calculating_with_dict"></span><div class="section" id="id1">
<h3>1.8 字典的运算<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>怎样在数据字典中执行一些计算操作（比如求最小值、最大值、排序等等）？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>考虑下面的股票名和价格映射字典：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">prices</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;ACME&#39;</span><span class="p">:</span> <span class="mf">45.23</span><span class="p">,</span>
    <span class="s1">&#39;AAPL&#39;</span><span class="p">:</span> <span class="mf">612.78</span><span class="p">,</span>
    <span class="s1">&#39;IBM&#39;</span><span class="p">:</span> <span class="mf">205.55</span><span class="p">,</span>
    <span class="s1">&#39;HPQ&#39;</span><span class="p">:</span> <span class="mf">37.20</span><span class="p">,</span>
    <span class="s1">&#39;FB&#39;</span><span class="p">:</span> <span class="mf">10.75</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为了对字典值执行计算操作，通常需要使用 <code class="docutils literal"><span class="pre">zip()</span></code> 函数先将键和值反转过来。
比如，下面是查找最小和最大股票价格和股票值的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">min_price</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">prices</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">prices</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="c1"># min_price is (10.75, &#39;FB&#39;)</span>
<span class="n">max_price</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">prices</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">prices</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="c1"># max_price is (612.78, &#39;AAPL&#39;)</span>
</pre></div>
</div>
<p>类似的，可以使用 <code class="docutils literal"><span class="pre">zip()</span></code> 和 <code class="docutils literal"><span class="pre">sorted()</span></code> 函数来排列字典数据：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">prices_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">prices</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">prices</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="c1"># prices_sorted is [(10.75, &#39;FB&#39;), (37.2, &#39;HPQ&#39;),</span>
<span class="c1">#                   (45.23, &#39;ACME&#39;), (205.55, &#39;IBM&#39;),</span>
<span class="c1">#                   (612.78, &#39;AAPL&#39;)]</span>
</pre></div>
</div>
<p>执行这些计算的时候，需要注意的是 <code class="docutils literal"><span class="pre">zip()</span></code> 函数创建的是一个只能访问一次的迭代器。
比如，下面的代码就会产生错误：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">prices_and_names</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prices</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">prices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">prices_and_names</span><span class="p">))</span> <span class="c1"># OK</span>
<span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">prices_and_names</span><span class="p">))</span> <span class="c1"># ValueError: max() arg is an empty sequence</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>如果你在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span> <span class="c1"># Returns &#39;AAPL&#39;</span>
<span class="nb">max</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span> <span class="c1"># Returns &#39;IBM&#39;</span>
</pre></div>
</div>
<p>这个结果并不是你想要的，因为你想要在字典的值集合上执行这些计算。
或许你会尝试着使用字典的 <code class="docutils literal"><span class="pre">values()</span></code> 方法来解决这个问题：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="n">prices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="c1"># Returns 10.75</span>
<span class="nb">max</span><span class="p">(</span><span class="n">prices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="c1"># Returns 612.78</span>
</pre></div>
</div>
<p>不幸的是，通常这个结果同样也不是你想要的。
你可能还想要知道对应的键的信息（比如那种股票价格是最低的？）。</p>
<p>你可以在 <code class="docutils literal"><span class="pre">min()</span></code> 和 <code class="docutils literal"><span class="pre">max()</span></code> 函数中提供 <code class="docutils literal"><span class="pre">key</span></code> 函数参数来获取最小值或最大值对应的键的信息。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="n">prices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">prices</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="c1"># Returns &#39;FB&#39;</span>
<span class="nb">max</span><span class="p">(</span><span class="n">prices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">prices</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="c1"># Returns &#39;AAPL&#39;</span>
</pre></div>
</div>
<p>但是，如果还想要得到最小值，你又得执行一次查找操作。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">min_value</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">prices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">prices</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span>
</pre></div>
</div>
<p>前面的 <code class="docutils literal"><span class="pre">zip()</span></code> 函数方案通过将字典&#8221;反转&#8221;为 (值，键) 元组序列来解决了上述问题。
当比较两个元组的时候，值会先进行比较，然后才是键。
这样的话你就能通过一条简单的语句就能很轻松的实现在字典上的求最值和排序操作了。</p>
<p>需要注意的是在计算操作中使用到了 (值，键) 对。当多个实体拥有相同的值的时候，键会决定返回结果。
比如，在执行 <code class="docutils literal"><span class="pre">min()</span></code> 和 <code class="docutils literal"><span class="pre">max()</span></code> 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prices</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;AAA&#39;</span> <span class="p">:</span> <span class="mf">45.23</span><span class="p">,</span> <span class="s1">&#39;ZZZ&#39;</span><span class="p">:</span> <span class="mf">45.23</span> <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">prices</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">prices</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="go">(45.23, &#39;AAA&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">prices</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">prices</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="go">(45.23, &#39;ZZZ&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c01/p09_find_commonalities_in_dicts"></span><div class="section" id="id1">
<h3>1.9 查找两字典的相同点<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>怎样在两个字典中寻寻找相同点（比如相同的键、相同的值等等）？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>考虑下面两个字典：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;x&#39;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span> <span class="p">:</span> <span class="mi">3</span>
<span class="p">}</span>

<span class="n">b</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;w&#39;</span> <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;x&#39;</span> <span class="p">:</span> <span class="mi">11</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span> <span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为了寻找两个字典的相同点，可以简单的在两字典的 <code class="docutils literal"><span class="pre">keys()</span></code> 或者 <code class="docutils literal"><span class="pre">items()</span></code> 方法返回结果上执行集合操作。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Find keys in common</span>
<span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1"># { &#39;x&#39;, &#39;y&#39; }</span>
<span class="c1"># Find keys in a that are not in b</span>
<span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1"># { &#39;z&#39; }</span>
<span class="c1"># Find (key,value) pairs in common</span>
<span class="n">a</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="c1"># { (&#39;y&#39;, 2) }</span>
</pre></div>
</div>
<p>这些操作也可以用于修改或者过滤字典元素。
比如，假如你想以现有字典构造一个排除几个指定键的新字典。
下面利用字典推导来实现这样的需求：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Make a new dictionary with certain keys removed</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">}}</span>
<span class="c1"># c is {&#39;x&#39;: 1, &#39;y&#39;: 2}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>一个字典就是一个键集合与值集合的映射关系。
字典的 <code class="docutils literal"><span class="pre">keys()</span></code> 方法返回一个展现键集合的键视图对象。
键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算。
所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个 set。</p>
<p>字典的 <code class="docutils literal"><span class="pre">items()</span></code> 方法返回一个包含 (键，值) 对的元素视图对象。
这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对。</p>
<p>尽管字典的 <code class="docutils literal"><span class="pre">values()</span></code> 方法也是类似，但是它并不支持这里介绍的集合操作。
某种程度上是因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题。
不过，如果你硬要在值上面执行这些集合操作的话，你可以先将值集合转换成 set，然后再执行集合运算就行了。</p>
</div>
</div>
<span id="document-c01/p10_remove_duplicates_from_seq_order"></span><div class="section" id="id1">
<h3>1.10 删除序列相同元素并保持顺序<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>怎样在一个序列上面保持元素顺序的同时消除重复的值？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果序列上的值都是 <code class="docutils literal"><span class="pre">hashable</span></code> 类型，那么可以很简单的利用集合或者生成器来解决这个问题。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dedupe</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是使用上述函数的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">[1, 5, 2, 9, 10]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这个方法仅仅在序列中元素为 <code class="docutils literal"><span class="pre">hashable</span></code> 的时候才管用。
如果你想消除元素不可哈希（比如 <code class="docutils literal"><span class="pre">dict</span></code> 类型）的序列中重复元素的话，你需要将上述代码稍微改变一下，就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dedupe</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">item</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>这里的key参数指定了一个函数，将序列元素转换成 <code class="docutils literal"><span class="pre">hashable</span></code> 类型。下面是它的用法示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])))</span>
<span class="go">[{&#39;x&#39;: 1, &#39;y&#39;: 2}, {&#39;x&#39;: 1, &#39;y&#39;: 3}, {&#39;x&#39;: 2, &#39;y&#39;: 4}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]))</span>
<span class="go">[{&#39;x&#39;: 1, &#39;y&#39;: 2}, {&#39;x&#39;: 2, &#39;y&#39;: 4}]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想基于单个字段、属性或者某个更大的数据结构来消除重复元素，第二种方案同样可以胜任。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>如果你仅仅就是想消除重复元素，通常可以简单的构造一个集合。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[1, 5, 2, 1, 9, 1, 5, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">{1, 2, 10, 5, 9}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然而，这种方法不能维护元素的顺序，生成的结果中的元素位置被打乱。而上面的方法可以避免这种情况。</p>
<p>在本节中我们使用了生成器函数让我们的函数更加通用，不仅仅是局限于列表处理。
比如，如果如果你想读取一个文件，消除重复行，你可以很容易像这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">somefile</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">dedupe</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>上述key函数参数模仿了 <code class="docutils literal"><span class="pre">sorted()</span></code> , <code class="docutils literal"><span class="pre">min()</span></code> 和 <code class="docutils literal"><span class="pre">max()</span></code> 等内置函数的相似功能。
可以参考 1.8 和 1.13 小节了解更多。</p>
</div>
</div>
<span id="document-c01/p11_naming_slice"></span><div class="section" id="id1">
<h3>1.11 命名切片<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序已经出现一大堆已无法直视的硬编码切片下标，然后你想清理下代码。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>假定你有一段代码要从一个记录字符串中几个固定位置提取出特定的数据字段（比如文件或类似格式）：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1">######    0123456789012345678901234567890123456789012345678901234567890&#39;</span>
<span class="n">record</span> <span class="o">=</span> <span class="s1">&#39;....................100 .......513.25 ..........&#39;</span>
<span class="n">cost</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">23</span><span class="p">])</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">31</span><span class="p">:</span><span class="mi">37</span><span class="p">])</span>
</pre></div>
</div>
<p>与其那样写，为什么不想这样命名切片呢：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">SHARES</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="n">PRICE</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">)</span>
<span class="n">cost</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="n">SHARES</span><span class="p">])</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="n">PRICE</span><span class="p">])</span>
</pre></div>
</div>
<p>第二种版本中，你避免了大量无法理解的硬编码下标，使得你的代码更加清晰可读了。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>一般来讲，代码中如果出现大量的硬编码下标值会使得可读性和可维护性大大降低。
比如，如果你回过来看看一年前你写的代码，你会摸着脑袋想那时候自己到底想干嘛啊。
这里的解决方案是一个很简单的方法让你更加清晰的表达代码到底要做什么。</p>
<p>内置的 <code class="docutils literal"><span class="pre">slice()</span></code> 函数创建了一个切片对象，可以被用在任何切片允许使用的地方。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="go">[2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span>
<span class="go">[0, 1, 10, 11, 4, 5, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">items</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span>
<span class="go">[0, 1, 4, 5, 6]</span>
</pre></div>
</div>
<p>如果你有一个切片对象a，你可以分别调用它的 <code class="docutils literal"><span class="pre">a.start</span></code> , <code class="docutils literal"><span class="pre">a.stop</span></code> , <code class="docutils literal"><span class="pre">a.step</span></code> 属性来获取更多的信息。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">start</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">stop</span>
<span class="go">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">step</span>
<span class="go">2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外，你还能通过调用切片的 <code class="docutils literal"><span class="pre">indices(size)</span></code> 方法将它映射到一个确定大小的序列上，
这个方法返回一个三元组 <code class="docutils literal"><span class="pre">(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> ，所有值都会被合适的缩小以满足边界限制，
从而使用的时候避免出现 <code class="docutils literal"><span class="pre">IndexError</span></code> 异常。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;HelloWorld&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="go">(5, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">W</span>
<span class="go">r</span>
<span class="go">d</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c01/p12_determine_most_freqently_items_in_seq"></span><div class="section" id="id1">
<h3>1.12 序列中出现次数最多的元素<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>怎样找出一个序列中出现次数最多的元素呢？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">collections.Counter</span></code> 类就是专门为这类问题而设计的，
它甚至有一个有用的 <code class="docutils literal"><span class="pre">most_common()</span></code> 方法直接给了你答案。</p>
<p>为了演示，先假设你有一个单词列表并且想找出哪个单词出现频率最高。你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">words</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;look&#39;</span><span class="p">,</span> <span class="s1">&#39;into&#39;</span><span class="p">,</span> <span class="s1">&#39;my&#39;</span><span class="p">,</span> <span class="s1">&#39;eyes&#39;</span><span class="p">,</span> <span class="s1">&#39;look&#39;</span><span class="p">,</span> <span class="s1">&#39;into&#39;</span><span class="p">,</span> <span class="s1">&#39;my&#39;</span><span class="p">,</span> <span class="s1">&#39;eyes&#39;</span><span class="p">,</span>
    <span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;eyes&#39;</span><span class="p">,</span> <span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;eyes&#39;</span><span class="p">,</span> <span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;eyes&#39;</span><span class="p">,</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;around&#39;</span><span class="p">,</span> <span class="s1">&#39;the&#39;</span><span class="p">,</span>
    <span class="s1">&#39;eyes&#39;</span><span class="p">,</span> <span class="s2">&quot;don&#39;t&quot;</span><span class="p">,</span> <span class="s1">&#39;look&#39;</span><span class="p">,</span> <span class="s1">&#39;around&#39;</span><span class="p">,</span> <span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;eyes&#39;</span><span class="p">,</span> <span class="s1">&#39;look&#39;</span><span class="p">,</span> <span class="s1">&#39;into&#39;</span><span class="p">,</span>
    <span class="s1">&#39;my&#39;</span><span class="p">,</span> <span class="s1">&#39;eyes&#39;</span><span class="p">,</span> <span class="s2">&quot;you&#39;re&quot;</span><span class="p">,</span> <span class="s1">&#39;under&#39;</span>
<span class="p">]</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="n">word_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
<span class="c1"># 出现频率最高的3个单词</span>
<span class="n">top_three</span> <span class="o">=</span> <span class="n">word_counts</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">top_three</span><span class="p">)</span>
<span class="c1"># Outputs [(&#39;eyes&#39;, 8), (&#39;the&#39;, 5), (&#39;look&#39;, 4)]</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>作为输入， <code class="docutils literal"><span class="pre">Counter</span></code> 对象可以接受任意的由可哈希（<code class="docutils literal"><span class="pre">hashable</span></code>）元素构成的序列对象。
在底层实现上，一个 <code class="docutils literal"><span class="pre">Counter</span></code> 对象就是一个字典，将元素映射到它出现的次数上。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">word_counts</span><span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">word_counts</span><span class="p">[</span><span class="s1">&#39;eyes&#39;</span><span class="p">]</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想手动增加计数，可以简单的用加法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">morewords</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;why&#39;</span><span class="p">,</span><span class="s1">&#39;are&#39;</span><span class="p">,</span><span class="s1">&#39;you&#39;</span><span class="p">,</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;looking&#39;</span><span class="p">,</span><span class="s1">&#39;in&#39;</span><span class="p">,</span><span class="s1">&#39;my&#39;</span><span class="p">,</span><span class="s1">&#39;eyes&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">morewords</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">word_counts</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">word_counts</span><span class="p">[</span><span class="s1">&#39;eyes&#39;</span><span class="p">]</span>
<span class="go">9</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>或者你可以使用 <code class="docutils literal"><span class="pre">update()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">word_counts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">morewords</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Counter</span></code> 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">morewords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">Counter({&#39;eyes&#39;: 8, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;into&#39;: 3, &#39;my&#39;: 3, &#39;around&#39;: 2,</span>
<span class="go">&quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;under&#39;: 1, &#39;not&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Counter({&#39;eyes&#39;: 1, &#39;looking&#39;: 1, &#39;are&#39;: 1, &#39;in&#39;: 1, &#39;not&#39;: 1, &#39;you&#39;: 1,</span>
<span class="go">&#39;my&#39;: 1, &#39;why&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Combine counts</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">Counter({&#39;eyes&#39;: 9, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;my&#39;: 4, &#39;into&#39;: 3, &#39;not&#39;: 2,</span>
<span class="go">&#39;around&#39;: 2, &quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;in&#39;: 1, &#39;why&#39;: 1,</span>
<span class="go">&#39;looking&#39;: 1, &#39;are&#39;: 1, &#39;under&#39;: 1, &#39;you&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Subtract counts</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">Counter({&#39;eyes&#39;: 7, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;into&#39;: 3, &#39;my&#39;: 2, &#39;around&#39;: 2,</span>
<span class="go">&quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;under&#39;: 1})</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>毫无疑问， <code class="docutils literal"><span class="pre">Counter</span></code> 对象在几乎所有需要制表或者计数数据的场合是非常有用的工具。
在解决这类问题的时候你应该优先选择它，而不是手动的利用字典去实现。</p>
</div>
</div>
<span id="document-c01/p13_sort_list_of_dicts_by_key"></span><div class="section" id="id1">
<h3>1.13 通过某个关键字排序一个字典列表<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个字典列表，你想根据某个或某几个字典字段来排序这个列表。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>通过使用 <code class="docutils literal"><span class="pre">operator</span></code> 模块的 <code class="docutils literal"><span class="pre">itemgetter</span></code> 函数，可以非常容易的排序这样的数据结构。
假设你从数据库中检索出来网站会员信息列表，并且以下列的数据结构返回：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;Brian&#39;</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Jones&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1003</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;David&#39;</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Beazley&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1002</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Cleese&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1001</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;Big&#39;</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Jones&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1004</span><span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
<p>根据任意的字典字段来排序输入结果行是很容易实现的，代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="n">rows_by_fname</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;fname&#39;</span><span class="p">))</span>
<span class="n">rows_by_uid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;uid&#39;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">rows_by_fname</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">rows_by_uid</span><span class="p">)</span>
</pre></div>
</div>
<p>代码的输出如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">[{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;Big&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1004</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Jones&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;Brian&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1003</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Jones&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;David&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1002</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Beazley&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1001</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Cleese&#39;</span><span class="p">}]</span>
<span class="p">[{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1001</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Cleese&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;David&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1002</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Beazley&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;Brian&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1003</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Jones&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;Big&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1004</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Jones&#39;</span><span class="p">}]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">itemgetter()</span></code> 函数也支持多个 keys，比如下面的代码</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rows_by_lfname</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;lname&#39;</span><span class="p">,</span><span class="s1">&#39;fname&#39;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">rows_by_lfname</span><span class="p">)</span>
</pre></div>
</div>
<p>会产生如下的输出：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">[{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;David&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1002</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Beazley&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1001</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Cleese&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;Big&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1004</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Jones&#39;</span><span class="p">},</span>
<span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="s1">&#39;Brian&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span><span class="p">:</span> <span class="mi">1003</span><span class="p">,</span> <span class="s1">&#39;lname&#39;</span><span class="p">:</span> <span class="s1">&#39;Jones&#39;</span><span class="p">}]</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在上面例子中， <code class="docutils literal"><span class="pre">rows</span></code> 被传递给接受一个关键字参数的 <code class="docutils literal"><span class="pre">sorted()</span></code> 内置函数。
这个参数是 <code class="docutils literal"><span class="pre">callable</span></code> 类型，并且从 <code class="docutils literal"><span class="pre">rows</span></code> 中接受一个单一元素，然后返回被用来排序的值。
<code class="docutils literal"><span class="pre">itemgetter()</span></code> 函数就是负责创建这个 <code class="docutils literal"><span class="pre">callable</span></code> 对象的。</p>
<p><code class="docutils literal"><span class="pre">operator.itemgetter()</span></code> 函数有一个被 <code class="docutils literal"><span class="pre">rows</span></code> 中的记录用来查找值的索引参数。可以是一个字典键名称，
一个整形值或者任何能够传入一个对象的 <code class="docutils literal"><span class="pre">__getitem__()</span></code> 方法的值。
如果你传入多个索引参数给 <code class="docutils literal"><span class="pre">itemgetter()</span></code> ，它生成的 <code class="docutils literal"><span class="pre">callable</span></code> 对象会返回一个包含所有元素值的元组，
并且 <code class="docutils literal"><span class="pre">sorted()</span></code> 函数会根据这个元组中元素顺序去排序。
但你想要同时在几个字段上面进行排序（比如通过姓和名来排序，也就是例子中的那样）的时候这种方法是很有用的。</p>
<p><code class="docutils literal"><span class="pre">itemgetter()</span></code> 有时候也可以用 <code class="docutils literal"><span class="pre">lambda</span></code> 表达式代替，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rows_by_fname</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">])</span>
<span class="n">rows_by_lfname</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;lname&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p>这种方案也不错。但是，使用 <code class="docutils literal"><span class="pre">itemgetter()</span></code> 方式会运行的稍微快点。因此，如果你对性能要求比较高的话就使用 <code class="docutils literal"><span class="pre">itemgetter()</span></code> 方式。</p>
<p>最后，不要忘了这节中展示的技术也同样适用于 <code class="docutils literal"><span class="pre">min()</span></code> 和 <code class="docutils literal"><span class="pre">max()</span></code> 等函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;uid&#39;</span><span class="p">))</span>
<span class="go">{&#39;fname&#39;: &#39;John&#39;, &#39;lname&#39;: &#39;Cleese&#39;, &#39;uid&#39;: 1001}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;uid&#39;</span><span class="p">))</span>
<span class="go">{&#39;fname&#39;: &#39;Big&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1004}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c01/p14_sort_objects_without_compare_support"></span><div class="section" id="id1">
<h3>1.14 排序不支持原生比较的对象<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想排序类型相同的对象，但是他们不支持原生的比较操作。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>内置的 <code class="docutils literal"><span class="pre">sorted()</span></code> 函数有一个关键字参数 <code class="docutils literal"><span class="pre">key</span></code> ，可以传入一个 <code class="docutils literal"><span class="pre">callable</span></code> 对象给它，
这个 <code class="docutils literal"><span class="pre">callable</span></code> 对象对每个传入的对象返回一个值，这个值会被 <code class="docutils literal"><span class="pre">sorted</span></code> 用来排序这些对象。
比如，如果你在应用程序里面有一个 <code class="docutils literal"><span class="pre">User</span></code> 实例序列，并且你希望通过他们的 <code class="docutils literal"><span class="pre">user_id</span></code> 属性进行排序，
你可以提供一个以 <code class="docutils literal"><span class="pre">User</span></code> 实例作为输入并输出对应 <code class="docutils literal"><span class="pre">user_id</span></code> 值的 <code class="docutils literal"><span class="pre">callable</span></code> 对象。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;User({})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sort_notcompare</span><span class="p">():</span>
    <span class="n">users</span> <span class="o">=</span> <span class="p">[</span><span class="n">User</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="n">User</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">User</span><span class="p">(</span><span class="mi">99</span><span class="p">)]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">user_id</span><span class="p">))</span>
</pre></div>
</div>
<p>另外一种方式是使用 <code class="docutils literal"><span class="pre">operator.attrgetter()</span></code> 来代替 lambda 函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">))</span>
<span class="go">[User(3), User(23), User(99)]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>选择使用 lambda 函数或者是 <code class="docutils literal"><span class="pre">attrgetter()</span></code> 可能取决于个人喜好。
但是， <code class="docutils literal"><span class="pre">attrgetter()</span></code> 函数通常会运行的快点，并且还能同时允许多个字段进行比较。
这个跟 <code class="docutils literal"><span class="pre">operator.itemgetter()</span></code> 函数作用于字典类型很类似（参考1.13小节）。
例如，如果 <code class="docutils literal"><span class="pre">User</span></code> 实例还有一个 <code class="docutils literal"><span class="pre">first_name</span></code> 和 <code class="docutils literal"><span class="pre">last_name</span></code> 属性，那么可以向下面这样排序：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">by_name</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;last_name&#39;</span><span class="p">,</span> <span class="s1">&#39;first_name&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>同样需要注意的是，这一小节用到的技术同样适用于像 <code class="docutils literal"><span class="pre">min()</span></code> 和 <code class="docutils literal"><span class="pre">max()</span></code> 之类的函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">))</span>
<span class="go">User(3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">))</span>
<span class="go">User(99)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c01/p15_group_records_based_on_field"></span><div class="section" id="id1">
<h3>1.15 通过某个字段将记录分组<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个字典或者实例的序列，然后你想根据某个特定的字段比如 <code class="docutils literal"><span class="pre">date</span></code> 来分组迭代访问。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">itertools.groupby()</span></code> 函数对于这样的数据分组操作非常实用。
为了演示，假设你已经有了下列的字典列表：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;5412 N CLARK&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/01/2012&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;5148 N CLARK&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/04/2012&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;5800 E 58TH&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/02/2012&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;2122 N CLARK&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/03/2012&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;5645 N RAVENSWOOD&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/02/2012&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;1060 W ADDISON&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/02/2012&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;4801 N BROADWAY&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/01/2012&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;1039 W GRANVILLE&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/04/2012&#39;</span><span class="p">},</span>
<span class="p">]</span>
</pre></div>
</div>
<p>现在假设你想在按 date 分组后的数据块上进行迭代。为了这样做，你首先需要按照指定的字段(这里就是 <code class="docutils literal"><span class="pre">date</span></code> )排序，
然后调用 <code class="docutils literal"><span class="pre">itertools.groupby()</span></code> 函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>

<span class="c1"># Sort by the desired field first</span>
<span class="n">rows</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">))</span>
<span class="c1"># Iterate in groups</span>
<span class="k">for</span> <span class="n">date</span><span class="p">,</span> <span class="n">items</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mo">07</span><span class="o">/</span><span class="mo">01</span><span class="o">/</span><span class="mi">2012</span>
  <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/01/2012&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;5412 N CLARK&#39;</span><span class="p">}</span>
  <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/01/2012&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;4801 N BROADWAY&#39;</span><span class="p">}</span>
<span class="mo">07</span><span class="o">/</span><span class="mo">02</span><span class="o">/</span><span class="mi">2012</span>
  <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/02/2012&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;5800 E 58TH&#39;</span><span class="p">}</span>
  <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/02/2012&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;5645 N RAVENSWOOD&#39;</span><span class="p">}</span>
  <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/02/2012&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;1060 W ADDISON&#39;</span><span class="p">}</span>
<span class="mo">07</span><span class="o">/</span><span class="mo">03</span><span class="o">/</span><span class="mi">2012</span>
  <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/03/2012&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;2122 N CLARK&#39;</span><span class="p">}</span>
<span class="mo">07</span><span class="o">/</span><span class="mo">04</span><span class="o">/</span><span class="mi">2012</span>
  <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/04/2012&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;5148 N CLARK&#39;</span><span class="p">}</span>
  <span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;07/04/2012&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;1039 W GRANVILLE&#39;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">groupby()</span></code> 函数扫描整个序列并且查找连续相同值（或者根据指定 key 函数返回值相同）的元素序列。
在每次迭代的时候，它会返回一个值和一个迭代器对象，
这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。</p>
<p>一个非常重要的准备步骤是要根据指定的字段将数据排序。
因为 <code class="docutils literal"><span class="pre">groupby()</span></code> 仅仅检查连续的元素，如果事先并没有排序完成的话，分组函数将得不到想要的结果。</p>
<p>如果你仅仅只是想根据 <code class="docutils literal"><span class="pre">date</span></code> 字段将数据分组到一个大的数据结构中去，并且允许随机访问，
那么你最好使用 <code class="docutils literal"><span class="pre">defaultdict()</span></code> 来构建一个多值字典，关于多值字典已经在 1.6 小节有过详细的介绍。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="n">rows_by_date</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
    <span class="n">rows_by_date</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>这样的话你可以很轻松的就能对每个指定日期访问对应的记录：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows_by_date</span><span class="p">[</span><span class="s1">&#39;07/01/2012&#39;</span><span class="p">]:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">{&#39;date&#39;: &#39;07/01/2012&#39;, &#39;address&#39;: &#39;5412 N CLARK&#39;}</span>
<span class="go">{&#39;date&#39;: &#39;07/01/2012&#39;, &#39;address&#39;: &#39;4801 N BROADWAY&#39;}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在上面这个例子中，我们没有必要先将记录排序。因此，如果对内存占用不是很关心，
这种方式会比先排序然后再通过 <code class="docutils literal"><span class="pre">groupby()</span></code> 函数迭代的方式运行得快一些。</p>
</div>
</div>
<span id="document-c01/p16_filter_sequence_elements"></span><div class="section" id="id1">
<h3>1.16 过滤序列元素<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个数据序列，想利用一些规则从中提取出需要的值或者是缩短序列</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>最简单的过滤序列元素的方法就是使用列表推导。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mylist</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[1, 4, 10, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mylist</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[-5, -7, -1]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用列表推导的一个潜在缺陷就是如果输入非常大的时候会产生一个非常大的结果集，占用大量内存。
如果你对内存比较敏感，那么你可以使用生成器表达式迭代产生过滤的元素。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mylist</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x1006a0eb0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">4</span>
<span class="go">10</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有时候，过滤规则比较复杂，不能简单的在列表推导或者生成器表达式中表达出来。
比如，假设过滤的时候需要处理一些异常或者其他复杂情况。这时候你可以将过滤代码放到一个函数中，
然后使用内建的 <code class="docutils literal"><span class="pre">filter()</span></code> 函数。示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;-3&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
<span class="n">ivals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_int</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">ivals</span><span class="p">)</span>
<span class="c1"># Outputs [&#39;1&#39;, &#39;2&#39;, &#39;-3&#39;, &#39;4&#39;, &#39;5&#39;]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">filter()</span></code> 函数创建了一个迭代器，因此如果你想得到一个列表的话，就得像示例那样使用 <code class="docutils literal"><span class="pre">list()</span></code> 去转换。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>列表推导和生成器表达式通常情况下是过滤数据最简单的方式。
其实它们还能在过滤的时候转换数据。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mylist</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[1.0, 2.0, 3.1622776601683795, 1.4142135623730951, 1.7320508075688772]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>过滤操作的一个变种就是将不符合条件的值用新的值代替，而不是丢弃它们。
比如，在一列数据中你可能不仅想找到正数，而且还想将不是正数的数替换成指定的数。
通过将过滤条件放到条件表达式中去，可以很容易的解决这个问题，就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">clip_neg</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clip_neg</span>
<span class="go">[1, 4, 0, 10, 0, 2, 3, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clip_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clip_pos</span>
<span class="go">[0, 0, -5, 0, -7, 0, 0, -1]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外一个值得关注的过滤工具就是 <code class="docutils literal"><span class="pre">itertools.compress()</span></code> ，
它以一个 <code class="docutils literal"><span class="pre">iterable</span></code> 对象和一个相对应的 <code class="docutils literal"><span class="pre">Boolean</span></code> 选择器序列作为输入参数。
然后输出 <code class="docutils literal"><span class="pre">iterable</span></code> 对象中对应选择器为 <code class="docutils literal"><span class="pre">True</span></code> 的元素。
当你需要用另外一个相关联的序列来过滤某个序列的时候，这个函数是非常有用的。
比如，假如现在你有下面两列数据：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">addresses</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;5412 N CLARK&#39;</span><span class="p">,</span>
    <span class="s1">&#39;5148 N CLARK&#39;</span><span class="p">,</span>
    <span class="s1">&#39;5800 E 58TH&#39;</span><span class="p">,</span>
    <span class="s1">&#39;2122 N CLARK&#39;</span><span class="p">,</span>
    <span class="s1">&#39;5645 N RAVENSWOOD&#39;</span><span class="p">,</span>
    <span class="s1">&#39;1060 W ADDISON&#39;</span><span class="p">,</span>
    <span class="s1">&#39;4801 N BROADWAY&#39;</span><span class="p">,</span>
    <span class="s1">&#39;1039 W GRANVILLE&#39;</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">counts</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>现在你想将那些对应 <code class="docutils literal"><span class="pre">count</span></code> 值大于5的地址全部输出，那么你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">compress</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">more5</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">more5</span>
<span class="go">[False, False, True, False, False, True, True, False]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">compress</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="n">more5</span><span class="p">))</span>
<span class="go">[&#39;5800 E 58TH&#39;, &#39;1060 W ADDISON&#39;, &#39;4801 N BROADWAY&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这里的关键点在于先创建一个 <code class="docutils literal"><span class="pre">Boolean</span></code> 序列，指示哪些元素符合条件。
然后 <code class="docutils literal"><span class="pre">compress()</span></code> 函数根据这个序列去选择输出对应位置为 <code class="docutils literal"><span class="pre">True</span></code> 的元素。</p>
<p>和 <code class="docutils literal"><span class="pre">filter()</span></code> 函数类似， <code class="docutils literal"><span class="pre">compress()</span></code> 也是返回的一个迭代器。因此，如果你需要得到一个列表，
那么你需要使用 <code class="docutils literal"><span class="pre">list()</span></code> 来将结果转换为列表类型。</p>
</div>
</div>
<span id="document-c01/p17_extract_subset_of_dict"></span><div class="section" id="id1">
<h3>1.17 从字典中提取子集<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想构造一个字典，它是另外一个字典的子集。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>最简单的方式是使用字典推导。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">prices</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;ACME&#39;</span><span class="p">:</span> <span class="mf">45.23</span><span class="p">,</span>
    <span class="s1">&#39;AAPL&#39;</span><span class="p">:</span> <span class="mf">612.78</span><span class="p">,</span>
    <span class="s1">&#39;IBM&#39;</span><span class="p">:</span> <span class="mf">205.55</span><span class="p">,</span>
    <span class="s1">&#39;HPQ&#39;</span><span class="p">:</span> <span class="mf">37.20</span><span class="p">,</span>
    <span class="s1">&#39;FB&#39;</span><span class="p">:</span> <span class="mf">10.75</span>
<span class="p">}</span>
<span class="c1"># Make a dictionary of all prices over 200</span>
<span class="n">p1</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">prices</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">}</span>
<span class="c1"># Make a dictionary of tech stocks</span>
<span class="n">tech_names</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;AAPL&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="s1">&#39;HPQ&#39;</span><span class="p">,</span> <span class="s1">&#39;MSFT&#39;</span><span class="p">}</span>
<span class="n">p2</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">prices</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tech_names</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>大多数情况下字典推导能做到的，通过创建一个元组序列然后把它传给 <code class="docutils literal"><span class="pre">dict()</span></code> 函数也能实现。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">p1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">prices</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<p>但是，字典推导方式表意更清晰，并且实际上也会运行的更快些
（在这个例子中，实际测试几乎比 <code class="docutils literal"><span class="pre">dcit()</span></code> 函数方式快整整一倍）。</p>
<p>有时候完成同一件事会有多种方式。比如，第二个例子程序也可以像这样重写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Make a dictionary of tech stocks</span>
<span class="n">tech_names</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;AAPL&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="s1">&#39;HPQ&#39;</span><span class="p">,</span> <span class="s1">&#39;MSFT&#39;</span> <span class="p">}</span>
<span class="n">p2</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span><span class="p">:</span><span class="n">prices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">prices</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">tech_names</span> <span class="p">}</span>
</pre></div>
</div>
<p>但是，运行时间测试结果显示这种方案大概比第一种方案慢 1.6 倍。
如果对程序运行性能要求比较高的话，需要花点时间去做计时测试。
关于更多计时和性能测试，可以参考 14.13 小节。</p>
</div>
</div>
<span id="document-c01/p18_map_names_to_sequence_elements"></span><div class="section" id="id1">
<h3>1.18 映射名称到序列元素<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读，
于是你想通过名称来访问元素。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">collections.namedtuple()</span></code> 函数通过使用一个普通的元组对象来帮你解决这个问题。
这个函数实际上是一个返回 Python 中标准元组类型子类的一个工厂方法。
你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。
代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Subscriber</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Subscriber&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;addr&#39;</span><span class="p">,</span> <span class="s1">&#39;joined&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">Subscriber</span><span class="p">(</span><span class="s1">&#39;jonesy@example.com&#39;</span><span class="p">,</span> <span class="s1">&#39;2012-10-19&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span>
<span class="go">Subscriber(addr=&#39;jonesy@example.com&#39;, joined=&#39;2012-10-19&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">addr</span>
<span class="go">&#39;jonesy@example.com&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">joined</span>
<span class="go">&#39;2012-10-19&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>尽管 <code class="docutils literal"><span class="pre">namedtuple</span></code> 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。
比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span><span class="p">,</span> <span class="n">joined</span> <span class="o">=</span> <span class="n">sub</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span>
<span class="go">&#39;jonesy@example.com&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">joined</span>
<span class="go">&#39;2012-10-19&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>命名元组的一个主要用途是将你的代码从下标操作中解脱出来。
因此，如果你从数据库调用中返回了一个很大的元组列表，通过下标去操作其中的元素，
当你在表中添加了新的列的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有这样的顾虑。</p>
<p>为了说明清楚，下面是使用普通元组的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_cost</span><span class="p">(</span><span class="n">records</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span>
</pre></div>
</div>
<p>下标操作通常会让代码表意不清晰，并且非常依赖记录的结构。
下面是使用命名元组的版本：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="n">Stock</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Stock&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">compute_cost</span><span class="p">(</span><span class="n">records</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="o">*</span><span class="n">rec</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">shares</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">price</span>
    <span class="k">return</span> <span class="n">total</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。
如果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效。
但是需要注意的是，不像字典那样，一个命名元组是不可更改的。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; s = Stock(&#39;ACME&#39;, 100, 123.45)
&gt;&gt;&gt; s
Stock(name=&#39;ACME&#39;, shares=100, price=123.45)
&gt;&gt;&gt; s.shares = 75
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can&#39;t set attribute
&gt;&gt;&gt;
</pre></div>
</div>
<p>如果你真的需要改变属性的值，那么可以使用命名元组实例的 <code class="docutils literal"><span class="pre">_replace()</span></code> 方法，
它会创建一个全新的命名元组并将对应的字段用新的值取代。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">shares</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">Stock(name=&#39;ACME&#39;, shares=75, price=123.45)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">_replace()</span></code> 方法还有一个很有用的特性就是当你的命名元组拥有可选或者缺失字段时候，
它是一个非常方便的填充数据的方法。
你可以先创建一个包含缺省值的原型元组，然后使用 <code class="docutils literal"><span class="pre">_replace()</span></code> 方法创建新的值被更新过的实例。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="n">Stock</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Stock&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">])</span>

<span class="c1"># Create a prototype instance</span>
<span class="n">stock_prototype</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

<span class="c1"># Function to convert a dictionary to a Stock</span>
<span class="k">def</span> <span class="nf">dict_to_stock</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">stock_prototype</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="o">**</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是它的使用方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mf">123.45</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_to_stock</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Stock(name=&#39;ACME&#39;, shares=100, price=123.45, date=None, time=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mf">123.45</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;12/17/2012&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_to_stock</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Stock(name=&#39;ACME&#39;, shares=100, price=123.45, date=&#39;12/17/2012&#39;, time=None)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后要说的是，如果你的目标是定义一个需要更新很多实例属性的高效数据结构，那么命名元组并不是你的最佳选择。
这时候你应该考虑定义一个包含 <code class="docutils literal"><span class="pre">__slots__</span></code> 方法的类（参考8.4小节）。</p>
</div>
</div>
<span id="document-c01/p19_transform_and_reduce_data_same_time"></span><div class="section" id="id1">
<h3>1.19 转换并同时计算数据<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要在数据序列上执行聚集函数（比如 <code class="docutils literal"><span class="pre">sum()</span></code> , <code class="docutils literal"><span class="pre">min()</span></code> , <code class="docutils literal"><span class="pre">max()</span></code> ），
但是首先你需要先转换或者过滤数据</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>一个非常优雅的方式去结合数据计算与转换就是使用一个生成器表达式参数。
比如，如果你想计算平方和，可以像下面这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是更多的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Determine if any .py files exist in a directory</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;dirname&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.py&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;There be python!&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Sorry, no python.&#39;</span><span class="p">)</span>
<span class="c1"># Output a tuple as CSV</span>
<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">123.45</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">))</span>
<span class="c1"># Data reduction across fields of a data structure</span>
<span class="n">portfolio</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;GOOG&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;YHOO&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">75</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;AOL&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;SCOX&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">65</span><span class="p">}</span>
<span class="p">]</span>
<span class="n">min_shares</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;shares&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">portfolio</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>上面的示例向你演示了当生成器表达式作为一个单独参数传递给函数时候的巧妙语法（你并不需要多加一个括号）。
比如，下面这些语句是等效的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">))</span> <span class="c1"># 显示的传递一个生成器表达式对象</span>
<span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">)</span> <span class="c1"># 更加优雅的实现方式，省略了括号</span>
</pre></div>
</div>
<p>使用一个生成器表达式作为参数会比先创建一个临时列表更加高效和优雅。
比如，如果你不使用生成器表达式的话，你可能会考虑使用下面的实现方式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">])</span>
</pre></div>
</div>
<p>这种方式同样可以达到想要的效果，但是它会多一个步骤，先创建一个额外的列表。
对于小型列表可能没什么关系，但是如果元素数量非常大的时候，
它会创建一个巨大的仅仅被使用一次就被丢弃的临时数据结构。而生成器方案会以迭代的方式转换数据，因此更省内存。</p>
<p>在使用一些聚集函数比如 <code class="docutils literal"><span class="pre">min()</span></code> 和 <code class="docutils literal"><span class="pre">max()</span></code> 的时候你可能更加倾向于使用生成器版本，
它们接受的一个 key 关键字参数或许对你很有帮助。
比如，在上面的证券例子中，你可能会考虑下面的实现版本：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Original: Returns 20</span>
<span class="n">min_shares</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;shares&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">portfolio</span><span class="p">)</span>
<span class="c1"># Alternative: Returns {&#39;name&#39;: &#39;AOL&#39;, &#39;shares&#39;: 20}</span>
<span class="n">min_shares</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;shares&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c01/p20_combine_multiple_map_to_single_map"></span><div class="section" id="id1">
<h3>1.20 合并多个字典或映射<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>现在有多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些操作，
比如查找值或者检查某些键是否存在。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>假如你有如下两个字典:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">4</span> <span class="p">}</span>
</pre></div>
</div>
<p>现在假设你必须在两个字典中执行查找操作（比如先从 <code class="docutils literal"><span class="pre">a</span></code> 中找，如果找不到再在 <code class="docutils literal"><span class="pre">b</span></code> 中找）。
一个非常简单的解决方案就是使用 <code class="docutils literal"><span class="pre">collections</span></code> 模块中的 <code class="docutils literal"><span class="pre">ChainMap</span></code> 类。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">ChainMap</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span> <span class="c1"># Outputs 1 (from a)</span>
<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span> <span class="c1"># Outputs 2 (from b)</span>
<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span> <span class="c1"># Outputs 3 (from a)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>一个 <code class="docutils literal"><span class="pre">ChainMap</span></code> 接受多个字典并将它们在逻辑上变为一个字典。
然后，这些字典并不是真的合并在一起了， <code class="docutils literal"><span class="pre">ChainMap</span></code> 类只是在内部创建了一个容纳这些字典的列表
并重新定义了一些常见的字典操作来遍历这个列表。大部分字典操作都是可以正常使用的，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">[1, 2, 3]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果出现重复键，那么第一次出现的映射值会被返回。
因此，例子程序中的 <code class="docutils literal"><span class="pre">c['z']</span></code> 总是会返回字典 <code class="docutils literal"><span class="pre">a</span></code> 中对应的值，而不是 <code class="docutils literal"><span class="pre">b</span></code> 中对应的值。</p>
<p>对于字典的更新或删除操作总是影响的是列表中第一个字典。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">{&#39;w&#39;: 40, &#39;z&#39;: 10}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">&quot;Key not found in the first mapping: &#39;y&#39;&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ChainMap</span></code> 对于编程语言中的作用范围变量（比如 <code class="docutils literal"><span class="pre">globals</span></code> , <code class="docutils literal"><span class="pre">locals</span></code> 等）是非常有用的。
事实上，有一些方法可以使它变得简单：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Add a new mapping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">new_child</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Add a new mapping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">new_child</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span>
<span class="go">ChainMap({&#39;x&#39;: 3}, {&#39;x&#39;: 2}, {&#39;x&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Discard last mapping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">parents</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Discard last mapping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">parents</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span>
<span class="go">ChainMap({&#39;x&#39;: 1})</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>作为 <code class="docutils literal"><span class="pre">ChainMap</span></code> 的替代，你可能会考虑使用 <code class="docutils literal"><span class="pre">update()</span></code> 方法将两个字典合并。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">4</span> <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这样也能行得通，但是它需要你创建一个完全不同的字典对象（或者是破坏现有字典结构）。
同时，如果原字典做了更新，这种改变不会反应到新的合并字典中去。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ChainMap</span></code> 使用原来的字典，它自己不创建新的字典。所以它并不会产生上面所说的结果，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">4</span> <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="c1"># Notice change to merged dicts</span>
<span class="go">42</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<span id="document-chapters/p02_strings_and_text"></span><div class="section" id="id1">
<h2>第二章：字符串和文本<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>几乎所有有用的程序都会涉及到某些文本处理，不管是解析数据还是产生输出。
这一章将重点关注文本的操作处理，比如提取字符串，搜索，替换以及解析等。
大部分的问题都能简单的调用字符串的内建方法完成。
但是，一些更为复杂的操作可能需要正则表达式或者强大的解析器，所有这些主题我们都会详细讲解。
并且在操作Unicode时候碰到的一些棘手的问题在这里也会被提及到。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c02/p01_split_string_on_multiple_delimiters"></span><div class="section" id="id1">
<h3>2.1 使用多个界定符分割字符串<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要将一个字符串分割为多个字段，但是分隔符(还有周围的空格)并不是固定的。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">string</span></code> 对象的 <code class="docutils literal"><span class="pre">split()</span></code> 方法只适应于非常简单的字符串分割情形，
它并不允许有多个分隔符或者是分隔符周围不确定的空格。
当你需要更加灵活的切割字符串的时候，最好使用 <code class="docutils literal"><span class="pre">re.split()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;asdf fjdk; afed, fjek,asdf, foo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[;,\s]\s*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
<span class="go">[&#39;asdf&#39;, &#39;fjdk&#39;, &#39;afed&#39;, &#39;fjek&#39;, &#39;asdf&#39;, &#39;foo&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>函数 <code class="docutils literal"><span class="pre">re.split()</span></code> 是非常实用的，因为它允许你为分隔符指定多个正则模式。
比如，在上面的例子中，分隔符可以是逗号，分号或者是空格，并且后面紧跟着任意个的空格。
只要这个模式被找到，那么匹配的分隔符两边的实体都会被当成是结果中的元素返回。
返回结果为一个字段列表，这个跟 <code class="docutils literal"><span class="pre">str.split()</span></code> 返回值类型是一样的。</p>
<p>当你使用 <code class="docutils literal"><span class="pre">re.split()</span></code> 函数时候，需要特别注意的是正则表达式中是否包含一个括号捕获分组。
如果使用了捕获分组，那么被匹配的文本也将出现在结果列表中。比如，观察一下这段代码运行后的结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fields</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(;|,|\s)\s*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fields</span>
<span class="go">[&#39;asdf&#39;, &#39; &#39;, &#39;fjdk&#39;, &#39;;&#39;, &#39;afed&#39;, &#39;,&#39;, &#39;fjek&#39;, &#39;,&#39;, &#39;asdf&#39;, &#39;,&#39;, &#39;foo&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>获取分割字符在某些情况下也是有用的。
比如，你可能想保留分割字符串，用来在后面重新构造一个新的输出字符串：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delimiters</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span>
<span class="go">[&#39;asdf&#39;, &#39;fjdk&#39;, &#39;afed&#39;, &#39;fjek&#39;, &#39;asdf&#39;, &#39;foo&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delimiters</span>
<span class="go">[&#39; &#39;, &#39;;&#39;, &#39;,&#39;, &#39;,&#39;, &#39;,&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Reform the line using the same delimiters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">d</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">delimiters</span><span class="p">))</span>
<span class="go">&#39;asdf fjdk;afed,fjek,asdf,foo&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你不想保留分割字符串到结果列表中去，但仍然需要使用到括号来分组正则表达式的话，
确保你的分组是非捕获分组，形如 <code class="docutils literal"><span class="pre">(?:...)</span></code> 。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?:,|;|\s)\s*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
<span class="go">[&#39;asdf&#39;, &#39;fjdk&#39;, &#39;afed&#39;, &#39;fjek&#39;, &#39;asdf&#39;, &#39;foo&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c02/p02_match_text_at_start_end"></span><div class="section" id="id1">
<h3>2.2 字符串开头或结尾匹配<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要通过指定的文本模式去检查字符串的开头或者结尾，比如文件名后缀，URL Scheme等等。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>检查字符串开头或结尾的一个简单方法是使用 <code class="docutils literal"><span class="pre">str.startswith()</span></code> 或者是 <code class="docutils literal"><span class="pre">str.endswith()</span></code> 方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;spam.txt&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.txt&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;file:&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://www.python.org&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http:&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想检查多种匹配可能，只需要将所有的匹配项放入到一个元组中去，
然后传给 <code class="docutils literal"><span class="pre">startswith()</span></code> 或者 <code class="docutils literal"><span class="pre">endswith()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filenames</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filenames</span>
<span class="go">[ &#39;Makefile&#39;, &#39;foo.c&#39;, &#39;bar.py&#39;, &#39;spam.c&#39;, &#39;spam.h&#39; ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filenames</span> <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.c&#39;</span><span class="p">,</span> <span class="s1">&#39;.h&#39;</span><span class="p">))</span> <span class="p">]</span>
<span class="go">[&#39;foo.c&#39;, &#39;spam.c&#39;, &#39;spam.h&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">any</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.py&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>下面是另一个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>

<span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;http:&#39;</span><span class="p">,</span> <span class="s1">&#39;https:&#39;</span><span class="p">,</span> <span class="s1">&#39;ftp:&#39;</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">urlopen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>奇怪的是，这个方法中必须要输入一个元组作为参数。
如果你恰巧有一个 <code class="docutils literal"><span class="pre">list</span></code> 或者 <code class="docutils literal"><span class="pre">set</span></code> 类型的选择项，
要确保传递参数前先调用 <code class="docutils literal"><span class="pre">tuple()</span></code> 将其转换为元组类型。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; choices = [&#39;http:&#39;, &#39;ftp:&#39;]
&gt;&gt;&gt; url = &#39;http://www.python.org&#39;
&gt;&gt;&gt; url.startswith(choices)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: startswith first arg must be str or a tuple of str, not list
&gt;&gt;&gt; url.startswith(tuple(choices))
True
&gt;&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">startswith()</span></code> 和 <code class="docutils literal"><span class="pre">endswith()</span></code> 方法提供了一个非常方便的方式去做字符串开头和结尾的检查。
类似的操作也可以使用切片来实现，但是代码看起来没有那么优雅。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;spam.txt&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;.txt&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://www.python.org&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;http:&#39;</span> <span class="ow">or</span> <span class="n">url</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;https:&#39;</span> <span class="ow">or</span> <span class="n">url</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ftp:&#39;</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你可以能还想使用正则表达式去实现，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://www.python.org&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;http:|https:|ftp:&#39;</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object at 0x101253098&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种方式也行得通，但是对于简单的匹配实在是有点小材大用了，本节中的方法更加简单并且运行会更快些。</p>
<p>最后提一下，当和其他操作比如普通数据聚合相结合的时候 <code class="docutils literal"><span class="pre">startswith()</span></code> 和 <code class="docutils literal"><span class="pre">endswith()</span></code> 方法是很不错的。
比如，下面这个语句检查某个文件夹中是否存在指定的文件类型：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.c&#39;</span><span class="p">,</span> <span class="s1">&#39;.h&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">listdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">)):</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c02/p03_match_strings_with_shell_wildcard"></span><div class="section" id="shell">
<h3>2.3 用Shell通配符匹配字符串<a class="headerlink" href="#shell" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想使用 <strong>Unix Shell</strong> 中常用的通配符(比如 <code class="docutils literal"><span class="pre">*.py</span></code> , <code class="docutils literal"><span class="pre">Dat[0-9]*.csv</span></code> 等)去匹配文本字符串</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">fnmatch</span></code> 模块提供了两个函数—— <code class="docutils literal"><span class="pre">fnmatch()</span></code> 和 <code class="docutils literal"><span class="pre">fnmatchcase()</span></code> ，可以用来实现这样的匹配。用法如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fnmatch</span> <span class="kn">import</span> <span class="n">fnmatch</span><span class="p">,</span> <span class="n">fnmatchcase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnmatch</span><span class="p">(</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;*.txt&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnmatch</span><span class="p">(</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;?oo.txt&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnmatch</span><span class="p">(</span><span class="s1">&#39;Dat45.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;Dat[0-9]*&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dat1.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;Dat2.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;config.ini&#39;</span><span class="p">,</span> <span class="s1">&#39;foo.py&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="n">fnmatch</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;Dat*.csv&#39;</span><span class="p">)]</span>
<span class="go">[&#39;Dat1.csv&#39;, &#39;Dat2.csv&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">fnmatch()</span></code> 函数使用底层操作系统的大小写敏感规则(不同的系统是不一样的)来匹配模式。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># On OS X (Mac)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnmatch</span><span class="p">(</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;*.TXT&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># On Windows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnmatch</span><span class="p">(</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;*.TXT&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你对这个区别很在意，可以使用 <code class="docutils literal"><span class="pre">fnmatchcase()</span></code> 来代替。它完全使用你的模式大小写匹配。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fnmatchcase</span><span class="p">(</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;*.TXT&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这两个函数通常会被忽略的一个特性是在处理非文件名的字符串时候它们也是很有用的。
比如，假设你有一个街道地址的列表数据：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">addresses</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;5412 N CLARK ST&#39;</span><span class="p">,</span>
    <span class="s1">&#39;1060 W ADDISON ST&#39;</span><span class="p">,</span>
    <span class="s1">&#39;1039 W GRANVILLE AVE&#39;</span><span class="p">,</span>
    <span class="s1">&#39;2122 N CLARK ST&#39;</span><span class="p">,</span>
    <span class="s1">&#39;4802 N BROADWAY&#39;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>
</div>
<p>你可以像这样写列表推导：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fnmatch</span> <span class="kn">import</span> <span class="n">fnmatchcase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">addr</span> <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">addresses</span> <span class="k">if</span> <span class="n">fnmatchcase</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="s1">&#39;* ST&#39;</span><span class="p">)]</span>
<span class="go">[&#39;5412 N CLARK ST&#39;, &#39;1060 W ADDISON ST&#39;, &#39;2122 N CLARK ST&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">addr</span> <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">addresses</span> <span class="k">if</span> <span class="n">fnmatchcase</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="s1">&#39;54[0-9][0-9] *CLARK*&#39;</span><span class="p">)]</span>
<span class="go">[&#39;5412 N CLARK ST&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">fnmatch()</span></code> 函数匹配能力介于简单的字符串方法和强大的正则表达式之间。
如果在数据处理操作中只需要简单的通配符就能完成的时候，这通常是一个比较合理的方案。</p>
<p>如果你的代码需要做文件名的匹配，最好使用 <code class="docutils literal"><span class="pre">glob</span></code> 模块。参考5.13小节。</p>
</div>
</div>
<span id="document-c02/p04_match_and_search_text"></span><div class="section" id="id1">
<h3>2.4 字符串匹配和搜索<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想匹配或者搜索特定模式的文本</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想匹配的是字面字符串，那么你通常只需要调用基本字符串方法就行，
比如 <code class="docutils literal"><span class="pre">str.find()</span></code> , <code class="docutils literal"><span class="pre">str.endswith()</span></code> , <code class="docutils literal"><span class="pre">str.startswith()</span></code> 或者类似的方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;yeah, but no, but yeah, but no, but yeah&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Exact match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">==</span> <span class="s1">&#39;yeah&#39;</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Match at start or end</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;yeah&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Search for the location of the first occurrence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="go">10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于复杂的匹配需要使用正则表达式和 <code class="docutils literal"><span class="pre">re</span></code> 模块。
为了解释正则表达式的基本原理，假设你想匹配数字格式的日期字符串比如 <code class="docutils literal"><span class="pre">11/27/2012</span></code> ，你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text1</span> <span class="o">=</span> <span class="s1">&#39;11/27/2012&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text2</span> <span class="o">=</span> <span class="s1">&#39;Nov 27, 2012&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Simple matching: \d+ means match one or more digits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+/\d+/\d+&#39;</span><span class="p">,</span> <span class="n">text1</span><span class="p">):</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">yes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+/\d+/\d+&#39;</span><span class="p">,</span> <span class="n">text2</span><span class="p">):</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">no</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想使用同一个模式去做多次匹配，你应该先将模式字符串预编译为模式对象。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+/\d+/\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">datepat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text1</span><span class="p">):</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">yes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">datepat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text2</span><span class="p">):</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">no</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">match()</span></code> 总是从字符串开始去匹配，如果你想查找字符串任意部分的模式出现位置，
使用 <code class="docutils literal"><span class="pre">findall()</span></code> 方法去代替。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Today is 11/27/2012. PyCon starts 3/13/2013.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="go">[&#39;11/27/2012&#39;, &#39;3/13/2013&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在定义正则式的时候，通常会利用括号去捕获分组。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)/(\d+)/(\d+)&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>捕获分组可以使得后面的处理更加简单，因为可以分别将每个组的内容提取出来。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">datepat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;11/27/2012&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;_sre.SRE_Match object at 0x1005d2750&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Extract the contents of each group</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;11/27/2012&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;27&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;2012&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;11&#39;, &#39;27&#39;, &#39;2012&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">year</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Find all matches (notice splitting into tuples)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span>
<span class="go">&#39;Today is 11/27/2012. PyCon starts 3/13/2013.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="go">[(&#39;11&#39;, &#39;27&#39;, &#39;2012&#39;), (&#39;3&#39;, &#39;13&#39;, &#39;2013&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">datepat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;{}-{}-{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">2012-11-27</span>
<span class="go">2013-3-13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">findall()</span></code> 方法会搜索文本并以列表形式返回所有的匹配。
如果你想以迭代方式返回匹配，可以使用 <code class="docutils literal"><span class="pre">finditer()</span></code> 方法来代替，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">datepat</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">(&#39;11&#39;, &#39;27&#39;, &#39;2012&#39;)</span>
<span class="go">(&#39;3&#39;, &#39;13&#39;, &#39;2013&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>关于正则表达式理论的教程已经超出了本书的范围。
不过，这一节阐述了使用re模块进行匹配和搜索文本的最基本方法。
核心步骤就是先使用 <code class="docutils literal"><span class="pre">re.compile()</span></code> 编译正则表达式字符串，
然后使用 <code class="docutils literal"><span class="pre">match()</span></code> , <code class="docutils literal"><span class="pre">findall()</span></code> 或者 <code class="docutils literal"><span class="pre">finditer()</span></code> 等方法。</p>
<p>当写正则式字符串的时候，相对普遍的做法是使用原始字符串比如 <code class="docutils literal"><span class="pre">r'(\d+)/(\d+)/(\d+)'</span></code> 。
这种字符串将不去解析反斜杠，这在正则表达式中是很有用的。
如果不这样做的话，你必须使用两个反斜杠，类似 <code class="docutils literal"><span class="pre">'(\\d+)/(\\d+)/(\\d+)'</span></code> 。</p>
<p>需要注意的是 <code class="docutils literal"><span class="pre">match()</span></code> 方法仅仅检查字符串的开始部分。它的匹配结果有可能并不是你期望的那样。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">datepat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;11/27/2012abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;_sre.SRE_Match object at 0x1005d27e8&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;11/27/2012&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想精确匹配，确保你的正则表达式以$结尾，就像这么这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)/(\d+)/(\d+)$&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;11/27/2012abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;11/27/2012&#39;</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object at 0x1005d2750&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后，如果你仅仅是做一次简单的文本匹配/搜索操作的话，可以略过编译部分，直接使用 <code class="docutils literal"><span class="pre">re</span></code> 模块级别的函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)/(\d+)/(\d+)&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">[(&#39;11&#39;, &#39;27&#39;, &#39;2012&#39;), (&#39;3&#39;, &#39;13&#39;, &#39;2013&#39;)]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但是需要注意的是，如果你打算做大量的匹配和搜索操作的话，最好先编译正则表达式，然后再重复使用它。
模块级别的函数会将最近编译过的模式缓存起来，因此并不会消耗太多的性能，
但是如果使用预编译模式的话，你将会减少查找和一些额外的处理损耗。</p>
</div>
</div>
<span id="document-c02/p05_search_and_replace_text"></span><div class="section" id="id1">
<h3>2.5 字符串搜索和替换<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在字符串中搜索和匹配指定的文本模式</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于简单的字面模式，直接使用 <code class="docutils literal"><span class="pre">str.replace()</span></code> 方法即可，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;yeah, but no, but yeah, but no, but yeah&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;yeah&#39;</span><span class="p">,</span> <span class="s1">&#39;yep&#39;</span><span class="p">)</span>
<span class="go">&#39;yep, but no, but yep, but no, but yep&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于复杂的模式，请使用 <code class="docutils literal"><span class="pre">re</span></code> 模块中的 <code class="docutils literal"><span class="pre">sub()</span></code> 函数。
为了说明这个，假设你想将形式为 <code class="docutils literal"><span class="pre">11/27/2012</span></code> 的日期字符串改成 <code class="docutils literal"><span class="pre">2012-11-27</span></code> 。示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Today is 11/27/2012. PyCon starts 3/13/2013.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)/(\d+)/(\d+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\3-\1-\2&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Today is 2012-11-27. PyCon starts 2013-3-13.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sub()</span></code> 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 <code class="docutils literal"><span class="pre">\3</span></code> 指向前面模式的捕获组号。</p>
<p>如果你打算用相同的模式做多次替换，考虑先编译它来提升性能。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)/(\d+)/(\d+)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\3-\1-\2&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Today is 2012-11-27. PyCon starts 2013-3-13.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于更加复杂的替换，可以传递一个替换回调函数来代替，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">calendar</span> <span class="kn">import</span> <span class="n">month_abbr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">change_date</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span><span class="n">mon_name</span> <span class="o">=</span> <span class="n">month_abbr</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))]</span>
<span class="gp">... </span><span class="k">return</span> <span class="s1">&#39;{} {} {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">mon_name</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datepat</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">change_date</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Today is 27 Nov 2012. PyCon starts 13 Mar 2013.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一个替换回调函数的参数是一个 <code class="docutils literal"><span class="pre">match</span></code> 对象，也就是 <code class="docutils literal"><span class="pre">match()</span></code> 或者 <code class="docutils literal"><span class="pre">find()</span></code> 返回的对象。
使用 <code class="docutils literal"><span class="pre">group()</span></code> 方法来提取特定的匹配部分。回调函数最后返回替换字符串。</p>
<p>如果除了替换后的结果外，你还想知道有多少替换发生了，可以使用 <code class="docutils literal"><span class="pre">re.subn()</span></code> 来代替。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">newtext</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">datepat</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\3-\1-\2&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newtext</span>
<span class="go">&#39;Today is 2012-11-27. PyCon starts 2013-3-13.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>关于正则表达式搜索和替换，上面演示的 <code class="docutils literal"><span class="pre">sub()</span></code> 方法基本已经涵盖了所有。
其实最难的部分就是编写正则表达式模式，这个最好是留给读者自己去练习了。</p>
</div>
</div>
<span id="document-c02/p06_search_replace_case_insensitive"></span><div class="section" id="id1">
<h3>2.6 字符串忽略大小写的搜索替换<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要以忽略大小写的方式搜索与替换文本字符串</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了在文本操作时忽略大小写，你需要在使用 <code class="docutils literal"><span class="pre">re</span></code> 模块的时候给这些操作提供 <code class="docutils literal"><span class="pre">re.IGNORECASE</span></code> 标志参数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;UPPER PYTHON, lower python, Mixed Python&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">[&#39;PYTHON&#39;, &#39;python&#39;, &#39;Python&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="s1">&#39;snake&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;UPPER snake, lower snake, Mixed snake&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后的那个例子揭示了一个小缺陷，替换字符串并不会自动跟被匹配字符串的大小写保持一致。
为了修复这个，你可能需要一个辅助函数，就像下面的这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">matchcase</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">word</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">text</span><span class="o">.</span><span class="n">islower</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">word</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">word</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">word</span>
    <span class="k">return</span> <span class="n">replace</span>
</pre></div>
</div>
<p>下面是使用上述函数的方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="n">matchcase</span><span class="p">(</span><span class="s1">&#39;snake&#39;</span><span class="p">),</span> <span class="n">text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;UPPER SNAKE, lower snake, Mixed Snake&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>译者注： <code class="docutils literal"><span class="pre">matchcase('snake')</span></code> 返回了一个回调函数(参数必须是 <code class="docutils literal"><span class="pre">match</span></code> 对象)，前面一节提到过，
<code class="docutils literal"><span class="pre">sub()</span></code> 函数除了接受替换字符串外，还能接受一个回调函数。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>对于一般的忽略大小写的匹配操作，简单的传递一个 <code class="docutils literal"><span class="pre">re.IGNORECASE</span></code> 标志参数就已经足够了。
但是需要注意的是，这个对于某些需要大小写转换的Unicode匹配可能还不够，
参考2.10小节了解更多细节。</p>
</div>
</div>
<span id="document-c02/p07_specify_regexp_for_shortest_match"></span><div class="section" id="id1">
<h3>2.7 最短匹配模式<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你正在试着用正则表达式匹配某个文本模式，但是它找到的是模式的最长可能匹配。
而你想修改它变成查找最短的可能匹配。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这个问题一般出现在需要匹配一对分隔符之间的文本的时候(比如引号包含的字符串)。
为了说明清楚，考虑如下的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">str_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\&quot;(.*)\&quot;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text1</span> <span class="o">=</span> <span class="s1">&#39;Computer says &quot;no.&quot;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
<span class="go">[&#39;no.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text2</span> <span class="o">=</span> <span class="s1">&#39;Computer says &quot;no.&quot; Phone says &quot;yes.&quot;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>
<span class="go">[&#39;no.&quot; Phone says &quot;yes.&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这个例子中，模式 <code class="docutils literal"><span class="pre">r'\&quot;(.*)\&quot;'</span></code> 的意图是匹配被双引号包含的文本。
但是在正则表达式中*操作符是贪婪的，因此匹配操作会查找最长的可能匹配。
于是在第二个例子中搜索 <code class="docutils literal"><span class="pre">text2</span></code> 的时候返回结果并不是我们想要的。</p>
<p>为了修正这个问题，可以在模式中的*操作符后面加上?修饰符，就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">str_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\&quot;(.*?)\&quot;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>
<span class="go">[&#39;no.&#39;, &#39;yes.&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这样就使得匹配变成非贪婪模式，从而得到最短的匹配，也就是我们想要的结果。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一节展示了在写包含点(.)字符的正则表达式的时候遇到的一些常见问题。
在一个模式字符串中，点(.)匹配除了换行外的任何字符。
然而，如果你将点(.)号放在开始与结束符(比如引号)之间的时候，那么匹配操作会查找符合模式的最长可能匹配。
这样通常会导致很多中间的被开始与结束符包含的文本被忽略掉，并最终被包含在匹配结果字符串中返回。
通过在 <code class="docutils literal"><span class="pre">*</span></code> 或者 <code class="docutils literal"><span class="pre">+</span></code> 这样的操作符后面添加一个 <code class="docutils literal"><span class="pre">?</span></code> 可以强制匹配算法改成寻找最短的可能匹配。</p>
</div>
</div>
<span id="document-c02/p08_regexp_for_multiline_partterns"></span><div class="section" id="id1">
<h3>2.8 多行匹配模式<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你正在试着使用正则表达式去匹配一大块的文本，而你需要跨越多行去匹配。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这个问题很典型的出现在当你用点(.)去匹配任意字符的时候，忘记了点(.)不能匹配换行符的事实。
比如，假设你想试着去匹配C语言分割的注释：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;/\*(.*?)\*/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text1</span> <span class="o">=</span> <span class="s1">&#39;/* this is a comment */&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text2</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;/* this is a</span>
<span class="gp">... </span><span class="s1">multiline comment */</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
<span class="go">[&#39; this is a comment &#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>
<span class="go">[]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了修正这个问题，你可以修改模式字符串，增加对换行的支持。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;/\*((?:.|\n)*?)\*/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>
<span class="go">[&#39; this is a\n multiline comment &#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这个模式中， <code class="docutils literal"><span class="pre">(?:.|\n)</span></code> 指定了一个非捕获组
(也就是它定义了一个仅仅用来做匹配，而不能通过单独捕获或者编号的组)。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">re.compile()</span></code> 函数接受一个标志参数叫 <code class="docutils literal"><span class="pre">re.DOTALL</span></code> ，在这里非常有用。
它可以让正则表达式中的点(.)匹配包括换行符在内的任意字符。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;/\*(.*?)\*/&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>
<span class="go">[&#39; this is a\n multiline comment &#39;]</span>
</pre></div>
</div>
<p>对于简单的情况使用 <code class="docutils literal"><span class="pre">re.DOTALL</span></code> 标记参数工作的很好，
但是如果模式非常复杂或者是为了构造字符串令牌而将多个模式合并起来(2.18节有详细描述)，
这时候使用这个标记参数就可能出现一些问题。
如果让你选择的话，最好还是定义自己的正则表达式模式，这样它可以在不需要额外的标记参数下也能工作的很好。</p>
</div>
</div>
<span id="document-c02/p09_normalize_unicode_text_to_regexp"></span><div class="section" id="unicode">
<h3>2.9 将Unicode文本标准化<a class="headerlink" href="#unicode" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你正在处理Unicode字符串，需要确保所有字符串在底层有相同的表示。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>在Unicode中，某些字符能够用多个合法的编码表示。为了说明，考虑下面的这个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="s1">&#39;Spicy Jalape</span><span class="se">\u00f1</span><span class="s1">o&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="s1">&#39;Spicy Jalapen</span><span class="se">\u0303</span><span class="s1">o&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span>
<span class="go">&#39;Spicy Jalapeño&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span>
<span class="go">&#39;Spicy Jalapeño&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
<span class="go">15</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这里的文本&#8221;Spicy Jalapeño&#8221;使用了两种形式来表示。
第一种使用整体字符&#8221;ñ&#8221;(U+00F1)，第二种使用拉丁字母&#8221;n&#8221;后面跟一个&#8221;~&#8221;的组合字符(U+0303)。</p>
<p>在需要比较字符串的程序中使用字符的多种表示会产生问题。
为了修正这个问题，你可以使用unicodedata模块先将文本标准化：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">unicodedata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFC&#39;</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t2</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFC&#39;</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">ascii</span><span class="p">(</span><span class="n">t1</span><span class="p">))</span>
<span class="go">&#39;Spicy Jalape\xf1o&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t3</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFD&#39;</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t4</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFD&#39;</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t3</span> <span class="o">==</span> <span class="n">t4</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">ascii</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
<span class="go">&#39;Spicy Jalapen\u0303o&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">normalize()</span></code> 第一个参数指定字符串标准化的方式。
NFC表示字符应该是整体组成(比如可能的话就使用单一编码)，而NFD表示字符应该分解为多个组合字符表示。</p>
<p>Python同样支持扩展的标准化形式NFKC和NFKD，它们在处理某些字符的时候增加了额外的兼容特性。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\ufb01</span><span class="s1">&#39;</span> <span class="c1"># A single character</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;ﬁ&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFD&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">&#39;ﬁ&#39;</span>
<span class="go"># Notice how the combined letters are broken apart here</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFKD&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">&#39;fi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFKC&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">&#39;fi&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>标准化对于任何需要以一致的方式处理Unicode文本的程序都是非常重要的。
当处理来自用户输入的字符串而你很难去控制编码的时候尤其如此。</p>
<p>在清理和过滤文本的时候字符的标准化也是很重要的。
比如，假设你想清除掉一些文本上面的变音符的时候(可能是为了搜索和匹配)：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFD&#39;</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t1</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">combining</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="go">&#39;Spicy Jalapeno&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后一个例子展示了 <code class="docutils literal"><span class="pre">unicodedata</span></code> 模块的另一个重要方面，也就是测试字符类的工具函数。
<code class="docutils literal"><span class="pre">combining()</span></code> 函数可以测试一个字符是否为和音字符。
在这个模块中还有其他函数用于查找字符类别，测试是否为数字字符等等。</p>
<p>Unicode显然是一个很大的主题。如果想更深入的了解关于标准化方面的信息，
请看考 <a class="reference external" href="http://www.unicode.org/faq/normalization.html">Unicode官网中关于这部分的说明</a>
Ned Batchelder在 <a class="reference external" href="http://nedbatchelder.com/text/unipain.html">他的网站</a>
上对Python的Unicode处理问题也有一个很好的介绍。</p>
</div>
</div>
<span id="document-c02/p10_work_with_unicode_in_regexp"></span><div class="section" id="unicode">
<h3>2.10 在正则式中使用Unicode<a class="headerlink" href="#unicode" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你正在使用正则表达式处理文本，但是关注的是Unicode字符处理。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>默认情况下 <code class="docutils literal"><span class="pre">re</span></code> 模块已经对一些Unicode字符类有了基本的支持。
比如， <code class="docutils literal"><span class="pre">\\d</span></code> 已经匹配任意的unicode数字字符了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ASCII digits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object at 0x1007d9ed0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Arabic digits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\u0661\u0662\u0663</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object at 0x101234030&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想在模式中包含指定的Unicode字符，你可以使用Unicode字符对应的转义序列(比如 <code class="docutils literal"><span class="pre">\uFFF</span></code> 或者 <code class="docutils literal"><span class="pre">\UFFFFFFF</span></code> )。
比如，下面是一个匹配几个不同阿拉伯编码页面中所有字符的正则表达式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arabic</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[</span><span class="se">\u0600</span><span class="s1">-</span><span class="se">\u06ff\u0750</span><span class="s1">-</span><span class="se">\u077f\u08a0</span><span class="s1">-</span><span class="se">\u08ff</span><span class="s1">]+&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当执行匹配和搜索操作的时候，最好是先标准化并且清理所有文本为标准化格式(参考2.9小节)。
但是同样也应该注意一些特殊情况，比如在忽略大小写匹配和大小写转换时的行为。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;stra</span><span class="se">\u00df</span><span class="s1">e&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;straße&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># Matches</span>
<span class="go">&lt;_sre.SRE_Match object at 0x10069d370&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span> <span class="c1"># Doesn&#39;t match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="c1"># Case folds</span>
<span class="go">&#39;STRASSE&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>混合使用Unicode和正则表达式通常会让你抓狂。
如果你真的打算这样做的话，最好考虑下安装第三方正则式库，
它们会为Unicode的大小写转换和其他大量有趣特性提供全面的支持，包括模糊匹配。</p>
</div>
</div>
<span id="document-c02/p11_strip_unwanted_characters"></span><div class="section" id="id1">
<h3>2.11 删除字符串中不需要的字符<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想去掉文本字符串开头，结尾或者中间不想要的字符，比如空白。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">strip()</span></code> 方法能用于删除开始或结尾的字符。 <code class="docutils literal"><span class="pre">lstrip()</span></code> 和 <code class="docutils literal"><span class="pre">rstrip()</span></code> 分别从左和从右执行删除操作。
默认情况下，这些方法会去除空白字符，但是你也可以指定其他字符。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Whitespace stripping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39; hello world </span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;hello world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;hello world \n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">&#39; hello world&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Character stripping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="s1">&#39;-----hello=====&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="go">&#39;hello=====&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;-=&#39;</span><span class="p">)</span>
<span class="go">&#39;hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这些 <code class="docutils literal"><span class="pre">strip()</span></code> 方法在读取和清理数据以备后续处理的时候是经常会被用到的。
比如，你可以用它们来去掉空格，引号和完成其他任务。</p>
<p>但是需要注意的是去除操作不会对字符串的中间的文本产生任何影响。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39; hello     world </span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;hello     world&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想处理中间的空格，那么你需要求助其他技术。比如使用 <code class="docutils literal"><span class="pre">replace()</span></code> 方法或者是用正则表达式替换。示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">&#39;helloworld&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">&#39;hello world&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>通常情况下你想将字符串 <code class="docutils literal"><span class="pre">strip</span></code> 操作和其他迭代操作相结合，比如从文件中读取多行数据。
如果是这样的话，那么生成器表达式就可以大显身手了。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p>在这里，表达式 <code class="docutils literal"><span class="pre">lines</span> <span class="pre">=</span> <span class="pre">(line.strip()</span> <span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">f)</span></code> 执行数据转换操作。
这种方式非常高效，因为它不需要预先读取所有数据放到一个临时的列表中去。
它仅仅只是创建一个生成器，并且每次返回行之前会先执行 <code class="docutils literal"><span class="pre">strip</span></code> 操作。</p>
<p>对于更高阶的strip，你可能需要使用 <code class="docutils literal"><span class="pre">translate()</span></code> 方法。请参阅下一节了解更多关于字符串清理的内容。</p>
</div>
</div>
<span id="document-c02/p12_sanitizing_clean_up_text"></span><div class="section" id="id1">
<h3>2.12 审查清理文本字符串<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>一些无聊的幼稚黑客在你的网站页面表单中输入文本&#8221;pýtĥöñ&#8221;，然后你想将这些字符清理掉。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>文本清理问题会涉及到包括文本解析与数据处理等一系列问题。
在非常简单的情形下，你可能会选择使用字符串函数(比如 <code class="docutils literal"><span class="pre">str.upper()</span></code> 和 <code class="docutils literal"><span class="pre">str.lower()</span></code> )将文本转为标准格式。
使用 <code class="docutils literal"><span class="pre">str.replace()</span></code> 或者 <code class="docutils literal"><span class="pre">re.sub()</span></code> 的简单替换操作能删除或者改变指定的字符序列。
你同样还可以使用2.9小节的 <code class="docutils literal"><span class="pre">unicodedata.normalize()</span></code> 函数将unicode文本标准化。</p>
<p>然后，有时候你可能还想在清理操作上更进一步。比如，你可能想消除整个区间上的字符或者去除变音符。
为了这样做，你可以使用经常会被忽视的 <code class="docutils literal"><span class="pre">str.translate()</span></code> 方法。
为了演示，假设你现在有下面这个凌乱的字符串：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;pýtĥöñ</span><span class="se">\f</span><span class="s1">is</span><span class="se">\t</span><span class="s1">awesome</span><span class="se">\r\n</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;pýtĥöñ\x0cis\tawesome\r\n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>第一步是清理空白字符。为了这样做，先创建一个小的转换表格然后使用 <code class="docutils literal"><span class="pre">translate()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remap</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span> <span class="p">:</span> <span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\f</span><span class="s1">&#39;</span><span class="p">)</span> <span class="p">:</span> <span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span> <span class="p">:</span> <span class="bp">None</span> <span class="c1"># Deleted</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">remap</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&#39;pýtĥöñ is awesome\n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正如你看的那样，空白字符 <code class="docutils literal"><span class="pre">\t</span></code> 和 <code class="docutils literal"><span class="pre">\f</span></code> 已经被重新映射到一个空格。回车字符r直接被删除。</p>
<p>你可以以这个表格为基础进一步构建更大的表格。比如，让我们删除所有的和音符：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">unicodedata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmb_chrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">maxunicode</span><span class="p">)</span>
<span class="gp">... </span>                        <span class="k">if</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">combining</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFD&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&#39;pýtĥöñ is awesome\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">cmb_chrs</span><span class="p">)</span>
<span class="go">&#39;python is awesome\n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>上面例子中，通过使用 <code class="docutils literal"><span class="pre">dict.fromkeys()</span></code> 方法构造一个字典，每个Unicode和音符作为键，对应的值全部为 <code class="docutils literal"><span class="pre">None</span></code> 。</p>
<p>然后使用 <code class="docutils literal"><span class="pre">unicodedata.normalize()</span></code> 将原始输入标准化为分解形式字符。
然后再调用 <code class="docutils literal"><span class="pre">translate</span></code> 函数删除所有重音符。
同样的技术也可以被用来删除其他类型的字符(比如控制字符等)。</p>
<p>作为另一个例子，这里构造一个将所有Unicode数字字符映射到对应的ASCII字符上的表格：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digitmap</span> <span class="o">=</span> <span class="p">{</span> <span class="n">c</span><span class="p">:</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">digit</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">maxunicode</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">category</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;Nd&#39;</span> <span class="p">}</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">digitmap</span><span class="p">)</span>
<span class="go">460</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Arabic digits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\u0661\u0662\u0663</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">digitmap</span><span class="p">)</span>
<span class="go">&#39;123&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另一种清理文本的技术涉及到I/O解码与编码函数。这里的思路是先对文本做一些初步的清理，
然后再结合 <code class="docutils literal"><span class="pre">encode()</span></code> 或者 <code class="docutils literal"><span class="pre">decode()</span></code> 操作来清除或修改它。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&#39;pýtĥöñ is awesome\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFD&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="go">&#39;python is awesome\n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这里的标准化操作将原来的文本分解为单独的和音符。接下来的ASCII编码/解码只是简单的一下子丢弃掉那些字符。
当然，这种方法仅仅只在最后的目标就是获取到文本对应ACSII表示的时候生效。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>文本字符清理一个最主要的问题应该是运行的性能。一般来讲，代码越简单运行越快。
对于简单的替换操作， <code class="docutils literal"><span class="pre">str.replace()</span></code> 方法通常是最快的，甚至在你需要多次调用的时候。
比如，为了清理空白字符，你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clean_spaces</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>如果你去测试的话，你就会发现这种方式会比使用 <code class="docutils literal"><span class="pre">translate()</span></code> 或者正则表达式要快很多。</p>
<p>另一方面，如果你需要执行任何复杂字符对字符的重新映射或者删除操作的话， <code class="docutils literal"><span class="pre">tanslate()</span></code> 方法会非常的快。</p>
<p>从大的方面来讲，对于你的应用程序来说性能是你不得不去自己研究的东西。
不幸的是，我们不可能给你建议一个特定的技术，使它能够适应所有的情况。
因此实际情况中需要你自己去尝试不同的方法并评估它。</p>
<p>尽管这一节集中讨论的是文本，但是类似的技术也可以适用于字节，包括简单的替换，转换和正则表达式。</p>
</div>
</div>
<span id="document-c02/p13_aligning_text_strings"></span><div class="section" id="id1">
<h3>2.13 字符串对齐<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想通过某种对齐方式来格式化字符串</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于基本的字符串对齐操作，可以使用字符串的 <code class="docutils literal"><span class="pre">ljust()</span></code> , <code class="docutils literal"><span class="pre">rjust()</span></code> 和 <code class="docutils literal"><span class="pre">center()</span></code> 方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&#39;Hello World         &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&#39;         Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&#39;    Hello World     &#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>所有这些方法都能接受一个可选的填充字符。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
<span class="go">&#39;=========Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="go">&#39;****Hello World*****&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal"><span class="pre">format()</span></code> 同样可以用来很容易的对齐字符串。
你要做的就是使用 <code class="docutils literal"><span class="pre">&lt;,&gt;</span></code> 或者 <code class="docutils literal"><span class="pre">^</span></code> 字符后面紧跟一个指定的宽度。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="s1">&#39;&gt;20&#39;</span><span class="p">)</span>
<span class="go">&#39;         Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="s1">&#39;&lt;20&#39;</span><span class="p">)</span>
<span class="go">&#39;Hello World         &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="s1">&#39;^20&#39;</span><span class="p">)</span>
<span class="go">&#39;    Hello World     &#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想指定一个非空格的填充字符，将它写到对齐字符的前面即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="s1">&#39;=&gt;20s&#39;</span><span class="p">)</span>
<span class="go">&#39;=========Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="s1">&#39;*^20s&#39;</span><span class="p">)</span>
<span class="go">&#39;****Hello World*****&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当格式化多个值的时候，这些格式代码也可以被用在 <code class="docutils literal"><span class="pre">format()</span></code> 方法中。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;{:&gt;10s} {:&gt;10s}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;World&#39;</span><span class="p">)</span>
<span class="go">&#39;     Hello      World&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">format()</span></code> 函数的一个好处是它不仅适用于字符串。它可以用来格式化任何值，使得它非常的通用。
比如，你可以用它来格式化数字：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">1.2345</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;&gt;10&#39;</span><span class="p">)</span>
<span class="go">&#39;    1.2345&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;^10.2f&#39;</span><span class="p">)</span>
<span class="go">&#39;   1.23   &#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在老的代码中，你经常会看到被用来格式化文本的 <code class="docutils literal"><span class="pre">%</span></code> 操作符。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%-20s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">text</span>
<span class="go">&#39;Hello World         &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%20s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">text</span>
<span class="go">&#39;         Hello World&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但是，在新版本代码中，你应该优先选择 <code class="docutils literal"><span class="pre">format()</span></code> 函数或者方法。
<code class="docutils literal"><span class="pre">format()</span></code> 要比 <code class="docutils literal"><span class="pre">%</span></code> 操作符的功能更为强大。
并且 <code class="docutils literal"><span class="pre">format()</span></code> 也比使用 <code class="docutils literal"><span class="pre">ljust()</span></code> , <code class="docutils literal"><span class="pre">rjust()</span></code> 或 <code class="docutils literal"><span class="pre">center()</span></code> 方法更通用，
因为它可以用来格式化任意对象，而不仅仅是字符串。</p>
<p>如果想要完全了解 <code class="docutils literal"><span class="pre">format()</span></code> 函数的有用特性，
请参考 <a class="reference external" href="https://docs.python.org/3/library/string.html#formatspec">在线Python文档</a></p>
</div>
</div>
<span id="document-c02/p14_combine_and_concatenate_strings"></span><div class="section" id="id1">
<h3>2.14 合并拼接字符串<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想将几个小的字符串合并为一个大的字符串</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想要合并的字符串是在一个序列或者 <code class="docutils literal"><span class="pre">iterable</span></code> 中，那么最快的方式就是使用 <code class="docutils literal"><span class="pre">join()</span></code> 方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Is&#39;</span><span class="p">,</span> <span class="s1">&#39;Chicago&#39;</span><span class="p">,</span> <span class="s1">&#39;Not&#39;</span><span class="p">,</span> <span class="s1">&#39;Chicago?&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
<span class="go">&#39;Is Chicago Not Chicago?&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
<span class="go">&#39;Is,Chicago,Not,Chicago?&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
<span class="go">&#39;IsChicagoNotChicago?&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>初看起来，这种语法看上去会比较怪，但是 <code class="docutils literal"><span class="pre">join()</span></code> 被指定为字符串的一个方法。
这样做的部分原因是你想去连接的对象可能来自各种不同的数据序列(比如列表，元组，字典，文件，集合或生成器等)，
如果在所有这些对象上都定义一个 <code class="docutils literal"><span class="pre">join()</span></code> 方法明显是冗余的。
因此你只需要指定你想要的分割字符串并调用他的 <code class="docutils literal"><span class="pre">join()</span></code> 方法去将文本片段组合起来。</p>
<p>如果你仅仅只是合并少数几个字符串，使用加号(+)通常已经足够了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;Is Chicago&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;Not Chicago?&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">&#39;Is Chicago Not Chicago?&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>加号(+)操作符在作为一些复杂字符串格式化的替代方案的时候通常也工作的很好，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;{} {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">Is Chicago Not Chicago?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="go">Is Chicago Not Chicago?</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想在源码中将两个字面字符串合并起来，你只需要简单的将它们放到一起，不需要用加号(+)。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span> <span class="s1">&#39;World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&#39;HelloWorld&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>字符串合并可能看上去并不需要用一整节来讨论。
但是不应该小看这个问题，程序员通常在字符串格式化的时候因为选择不当而给应用程序带来严重性能损失。</p>
<p>最重要的需要引起注意的是，当我们使用加号(+)操作符去连接大量的字符串的时候是非常低效率的，
因为加号连接会引起内存复制以及垃圾回收操作。
特别的，你永远都不应像下面这样写字符串连接代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">p</span>
</pre></div>
</div>
<p>这种写法会比使用 <code class="docutils literal"><span class="pre">join()</span></code> 方法运行的要慢一些，因为每一次执行+=操作的时候会创建一个新的字符串对象。
你最好是先收集所有的字符串片段然后再将它们连接起来。</p>
<p>一个相对比较聪明的技巧是利用生成器表达式(参考1.19小节)转换数据为字符串的同时合并字符串，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span>
<span class="go">&#39;ACME,50,91.1&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>同样还得注意不必要的字符串连接操作。有时候程序员在没有必要做连接操作的时候仍然多此一举。比如在打印的时候：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># Ugly</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]))</span> <span class="c1"># Still ugly</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="c1"># Better</span>
</pre></div>
</div>
<p>当混合使用I/O操作和字符串连接操作的时候，有时候需要仔细研究你的程序。
比如，考虑下面的两端代码片段：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Version 1 (string concatenation)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk1</span> <span class="o">+</span> <span class="n">chunk2</span><span class="p">)</span>

<span class="c1"># Version 2 (separate I/O operations)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk1</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk2</span><span class="p">)</span>
</pre></div>
</div>
<p>如果两个字符串很小，那么第一个版本性能会更好些，因为I/O系统调用天生就慢。
另外一方面，如果两个字符串很大，那么第二个版本可能会更加高效，
因为它避免了创建一个很大的临时结果并且要复制大量的内存块数据。
还是那句话，有时候是需要根据你的应用程序特点来决定应该使用哪种方案。</p>
<p>最后谈一下，如果你准备编写构建大量小字符串的输出代码，
你最好考虑下使用生成器函数，利用yield语句产生输出片段。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sample</span><span class="p">():</span>
    <span class="k">yield</span> <span class="s1">&#39;Is&#39;</span>
    <span class="k">yield</span> <span class="s1">&#39;Chicago&#39;</span>
    <span class="k">yield</span> <span class="s1">&#39;Not&#39;</span>
    <span class="k">yield</span> <span class="s1">&#39;Chicago?&#39;</span>
</pre></div>
</div>
<p>这种方法一个有趣的方面是它并没有对输出片段到底要怎样组织做出假设。
例如，你可以简单的使用 <code class="docutils literal"><span class="pre">join()</span></code> 方法将这些片段合并起来：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sample</span><span class="p">())</span>
</pre></div>
</div>
<p>或者你也可以将字符串片段重定向到I/O：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">():</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
</pre></div>
</div>
<p>再或者你还可以写出一些结合I/O操作的混合方案：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">):</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">maxsize</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">yield</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>

<span class="c1"># 结合文件操作</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">combine</span><span class="p">(</span><span class="n">sample</span><span class="p">(),</span> <span class="mi">32768</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
</pre></div>
</div>
<p>这里的关键点在于原始的生成器函数并不需要知道使用细节，它只负责生成字符串片段就行了。</p>
</div>
</div>
<span id="document-c02/p15_interpolating_variables_in_strings"></span><div class="section" id="id1">
<h3>2.15 字符串中插入变量<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想创建一个内嵌变量的字符串，变量被它的值所表示的字符串替换掉。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python并没有对在字符串中简单替换变量值提供直接的支持。
但是通过使用字符串的 <code class="docutils literal"><span class="pre">format()</span></code> 方法来解决这个问题。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;{name} has {n} messages.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Guido&#39;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
<span class="go">&#39;Guido has 37 messages.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>或者，如果要被替换的变量能在变量域中找到，
那么你可以结合使用 <code class="docutils literal"><span class="pre">format_map()</span></code> 和 <code class="docutils literal"><span class="pre">vars()</span></code> 。就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Guido&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="nb">vars</span><span class="p">())</span>
<span class="go">&#39;Guido has 37 messages.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">vars()</span></code> 还有一个有意思的特性就是它也适用于对象实例。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Info</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">,</span><span class="mi">37</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">&#39;Guido has 37 messages.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">format</span></code> 和 <code class="docutils literal"><span class="pre">format_map()</span></code> 的一个缺陷就是它们并不能很好的处理变量缺失的情况，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">KeyError</span>: <span class="n">&#39;n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一种避免这种错误的方法是另外定义一个含有 <code class="docutils literal"><span class="pre">__missing__()</span></code> 方法的字典对象，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">safesub</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot;防止key找不到&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="fm">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span>
</pre></div>
</div>
<p>现在你可以利用这个类包装输入后传递给 <code class="docutils literal"><span class="pre">format_map()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">n</span> <span class="c1"># Make sure n is undefined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">safesub</span><span class="p">(</span><span class="nb">vars</span><span class="p">()))</span>
<span class="go">&#39;Guido has {n} messages.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你发现自己在代码中频繁的执行这些步骤，你可以将变量替换步骤用一个工具函数封装起来。就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">safesub</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f_locals</span><span class="p">))</span>
</pre></div>
</div>
<p>现在你可以像下面这样写了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Guido&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;Hello {name}&#39;</span><span class="p">))</span>
<span class="go">Hello Guido</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;You have {n} messages.&#39;</span><span class="p">))</span>
<span class="go">You have 37 messages.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;Your favorite color is {color}&#39;</span><span class="p">))</span>
<span class="go">Your favorite color is {color}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>多年以来由于Python缺乏对变量替换的内置支持而导致了各种不同的解决方案。
作为本节中展示的一个可能的解决方案，你可以有时候会看到像下面这样的字符串格式化代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Guido&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;%(name) has %(n) messages.&#39;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
<span class="go">&#39;Guido has 37 messages.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你可能还会看到字符串模板的使用：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="s1">&#39;$name has $n messages.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="nb">vars</span><span class="p">())</span>
<span class="go">&#39;Guido has 37 messages.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然而， <code class="docutils literal"><span class="pre">format()</span></code> 和 <code class="docutils literal"><span class="pre">format_map()</span></code> 相比较上面这些方案而已更加先进，因此应该被优先选择。
使用 <code class="docutils literal"><span class="pre">format()</span></code> 方法还有一个好处就是你可以获得对字符串格式化的所有支持(对齐，填充，数字格式化等待)，
而这些特性是使用像模板字符串之类的方案不可能获得的。</p>
<p>本机还部分介绍了一些高级特性。映射或者字典类中鲜为人知的 <code class="docutils literal"><span class="pre">__missing__()</span></code> 方法可以让你定义如何处理缺失的值。
在 <code class="docutils literal"><span class="pre">SafeSub</span></code> 类中，这个方法被定义为对缺失的值返回一个占位符。
你可以发现缺失的值会出现在结果字符串中(在调试的时候可能很有用)，而不是产生一个 <code class="docutils literal"><span class="pre">KeyError</span></code> 异常。</p>
<p><code class="docutils literal"><span class="pre">sub()</span></code> 函数使用 <code class="docutils literal"><span class="pre">sys._getframe(1)</span></code> 返回调用者的栈帧。可以从中访问属性 <code class="docutils literal"><span class="pre">f_locals</span></code> 来获得局部变量。
毫无疑问绝大部分情况下在代码中去直接操作栈帧应该是不推荐的。
但是，对于像字符串替换工具函数而言它是非常有用的。
另外，值得注意的是 <code class="docutils literal"><span class="pre">f_locals</span></code> 是一个复制调用函数的本地变量的字典。
尽管你可以改变 <code class="docutils literal"><span class="pre">f_locals</span></code> 的内容，但是这个修改对于后面的变量访问没有任何影响。
所以，虽说访问一个栈帧看上去很邪恶，但是对它的任何操作不会覆盖和改变调用者本地变量的值。</p>
</div>
</div>
<span id="document-c02/p16_reformat_text_to_fixed_number_columns"></span><div class="section" id="id1">
<h3>2.16 以指定列宽格式化字符串<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一些长字符串，想以指定的列宽将它们重新格式化。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">textwrap</span></code> 模块来格式化字符串的输出。比如，假如你有下列的长字符串：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Look into my eyes, look into my eyes, the eyes, the eyes, </span><span class="se">\</span>
<span class="s2">the eyes, not around the eyes, don&#39;t look around the eyes, </span><span class="se">\</span>
<span class="s2">look into my eyes, you&#39;re under.&quot;</span>
</pre></div>
</div>
<p>下面演示使用 <code class="docutils literal"><span class="pre">textwrap</span></code> 格式化字符串的多种方式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">textwrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">70</span><span class="p">))</span>
<span class="go">Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,</span>
<span class="go">not around the eyes, don&#39;t look around the eyes, look into my eyes,</span>
<span class="go">you&#39;re under.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="go">Look into my eyes, look into my eyes,</span>
<span class="go">the eyes, the eyes, the eyes, not around</span>
<span class="go">the eyes, don&#39;t look around the eyes,</span>
<span class="go">look into my eyes, you&#39;re under.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">initial_indent</span><span class="o">=</span><span class="s1">&#39;    &#39;</span><span class="p">))</span>
<span class="go">    Look into my eyes, look into my</span>
<span class="go">eyes, the eyes, the eyes, the eyes, not</span>
<span class="go">around the eyes, don&#39;t look around the</span>
<span class="go">eyes, look into my eyes, you&#39;re under.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">subsequent_indent</span><span class="o">=</span><span class="s1">&#39;    &#39;</span><span class="p">))</span>
<span class="go">Look into my eyes, look into my eyes,</span>
<span class="go">    the eyes, the eyes, the eyes, not</span>
<span class="go">    around the eyes, don&#39;t look around</span>
<span class="go">    the eyes, look into my eyes, you&#39;re</span>
<span class="go">    under.</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">textwrap</span></code> 模块对于字符串打印是非常有用的，特别是当你希望输出自动匹配终端大小的时候。
你可以使用 <code class="docutils literal"><span class="pre">os.get_terminal_size()</span></code> 方法来获取终端的大小尺寸。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">get_terminal_size</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span>
<span class="go">80</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">fill()</span></code> 方法接受一些其他可选参数来控制tab，语句结尾等。
参阅 <a class="reference external" href="https://docs.python.org/3.3/library/textwrap.html#textwrap.TextWrapper">textwrap.TextWrapper文档</a> 获取更多内容。</p>
</div>
</div>
<span id="document-c02/p17_handle_html_xml_in_text"></span><div class="section" id="htmlxml">
<h3>2.17 在字符串中处理html和xml<a class="headerlink" href="#htmlxml" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想将HTML或者XML实体如 <code class="docutils literal"><span class="pre">&amp;entity;</span></code> 或 <code class="docutils literal"><span class="pre">&amp;#code;</span></code> 替换为对应的文本。
再者，你需要转换文本中特定的字符(比如&lt;, &gt;, 或 &amp;)。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>如果你想替换文本字符串中的 &#8216;&lt;&#8217; 或者 &#8216;&gt;&#8217; ，使用 <code class="docutils literal"><span class="pre">html.escape()</span></code> 函数可以很容易的完成。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">html</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="go">Elements are written as &amp;quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&amp;quot;.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Disable escaping of quotes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">quote</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">Elements are written as &quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&quot;.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你正在处理的是ASCII文本，并且想将非ASCII文本对应的编码实体嵌入进去，
可以给某些I/O函数传递参数 <code class="docutils literal"><span class="pre">errors='xmlcharrefreplace'</span></code> 来达到这个目。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Spicy Jalapeño&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;xmlcharrefreplace&#39;</span><span class="p">)</span>
<span class="go">b&#39;Spicy Jalape&amp;#241;o&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了替换文本中的编码实体，你需要使用另外一种方法。
如果你正在处理HTML或者XML文本，试着先使用一个合适的HTML或者XML解析器。
通常情况下，这些工具会自动替换这些编码值，你无需担心。</p>
<p>有时候，如果你接收到了一些含有编码值的原始文本，需要手动去做替换，
通常你只需要使用HTML或者XML解析器的一些相关工具函数/方法即可。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Spicy &amp;quot;Jalape&amp;#241;o&amp;quot.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">html.parser</span> <span class="kn">import</span> <span class="n">HTMLParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">HTMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">unescape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">&#39;Spicy &quot;Jalapeño&quot;.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="s1">&#39;The prompt is &amp;gt;&amp;gt;&amp;gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.sax.saxutils</span> <span class="kn">import</span> <span class="n">unescape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unescape</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">&#39;The prompt is &gt;&gt;&gt;&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在生成HTML或者XML文本的时候，如果正确的转换特殊标记字符是一个很容易被忽视的细节。
特别是当你使用 <code class="docutils literal"><span class="pre">print()</span></code> 函数或者其他字符串格式化来产生输出的时候。
使用像 <code class="docutils literal"><span class="pre">html.escape()</span></code> 的工具函数可以很容易的解决这类问题。</p>
<p>如果你想以其他方式处理文本，还有一些其他的工具函数比如 <code class="docutils literal"><span class="pre">xml.sax.saxutils.unescapge()</span></code> 可以帮助你。
然而，你应该先调研清楚怎样使用一个合适的解析器。
比如，如果你在处理HTML或XML文本，
使用某个解析模块比如 <code class="docutils literal"><span class="pre">html.parse</span></code> 或 <code class="docutils literal"><span class="pre">xml.etree.ElementTree</span></code> 已经帮你自动处理了相关的替换细节。</p>
</div>
</div>
<span id="document-c02/p18_tokenizing_text"></span><div class="section" id="id1">
<h3>2.18 字符串令牌解析<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个字符串，想从左至右将其解析为一个令牌流。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>假如你有下面这样一个文本字符串：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;foo = 23 + 42 * 10&#39;</span>
</pre></div>
</div>
<p>为了令牌化字符串，你不仅需要匹配模式，还得指定模式的类型。
比如，你可能想将字符串像下面这样转换为序列对：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tokens</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;NAME&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;EQ&#39;</span><span class="p">,</span><span class="s1">&#39;=&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;NUM&#39;</span><span class="p">,</span> <span class="s1">&#39;23&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;PLUS&#39;</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="p">),</span>
          <span class="p">(</span><span class="s1">&#39;NUM&#39;</span><span class="p">,</span> <span class="s1">&#39;42&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;NUM&#39;</span><span class="p">,</span> <span class="s1">&#39;10&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>为了执行这样的切分，第一步就是像下面这样利用命名捕获组的正则表达式来定义所有可能的令牌，包括空格：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="n">NAME</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)&#39;</span>
<span class="n">NUM</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;NUM&gt;\d+)&#39;</span>
<span class="n">PLUS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;PLUS&gt;\+)&#39;</span>
<span class="n">TIMES</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;TIMES&gt;\*)&#39;</span>
<span class="n">EQ</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;EQ&gt;=)&#39;</span>
<span class="n">WS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;WS&gt;\s+)&#39;</span>

<span class="n">master_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">NAME</span><span class="p">,</span> <span class="n">NUM</span><span class="p">,</span> <span class="n">PLUS</span><span class="p">,</span> <span class="n">TIMES</span><span class="p">,</span> <span class="n">EQ</span><span class="p">,</span> <span class="n">WS</span><span class="p">]))</span>
</pre></div>
</div>
<p>在上面的模式中， <code class="docutils literal"><span class="pre">?P&lt;TOKENNAME&gt;</span></code> 用于给一个模式命名，供后面使用。</p>
<p>下一步，为了令牌化，使用模式对象很少被人知道的 <code class="docutils literal"><span class="pre">scanner()</span></code> 方法。
这个方法会创建一个 <code class="docutils literal"><span class="pre">scanner</span></code> 对象，
在这个对象上不断的调用 <code class="docutils literal"><span class="pre">match()</span></code> 方法会一步步的扫描目标文本，每步一个匹配。
下面是演示一个 <code class="docutils literal"><span class="pre">scanner</span></code> 对象如何工作的交互式例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scanner</span> <span class="o">=</span> <span class="n">master_pat</span><span class="o">.</span><span class="n">scanner</span><span class="p">(</span><span class="s1">&#39;foo = 42&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scanner</span><span class="o">.</span><span class="n">match</span><span class="p">()</span>
<span class="go">&lt;_sre.SRE_Match object at 0x100677738&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">lastgroup</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">(&#39;NAME&#39;, &#39;foo&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scanner</span><span class="o">.</span><span class="n">match</span><span class="p">()</span>
<span class="go">&lt;_sre.SRE_Match object at 0x100677738&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">lastgroup</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">(&#39;WS&#39;, &#39; &#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scanner</span><span class="o">.</span><span class="n">match</span><span class="p">()</span>
<span class="go">&lt;_sre.SRE_Match object at 0x100677738&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">lastgroup</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">(&#39;EQ&#39;, &#39;=&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scanner</span><span class="o">.</span><span class="n">match</span><span class="p">()</span>
<span class="go">&lt;_sre.SRE_Match object at 0x100677738&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">lastgroup</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">(&#39;WS&#39;, &#39; &#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scanner</span><span class="o">.</span><span class="n">match</span><span class="p">()</span>
<span class="go">&lt;_sre.SRE_Match object at 0x100677738&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">lastgroup</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">(&#39;NUM&#39;, &#39;42&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scanner</span><span class="o">.</span><span class="n">match</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>实际使用这种技术的时候，可以很容易的像下面这样将上述代码打包到一个生成器中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_tokens</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="n">Token</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Token&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">scanner</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">scanner</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">scanner</span><span class="o">.</span><span class="n">match</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">lastgroup</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>

<span class="c1"># Example use</span>
<span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">generate_tokens</span><span class="p">(</span><span class="n">master_pat</span><span class="p">,</span> <span class="s1">&#39;foo = 42&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
<span class="c1"># Produces output</span>
<span class="c1"># Token(type=&#39;NAME&#39;, value=&#39;foo&#39;)</span>
<span class="c1"># Token(type=&#39;WS&#39;, value=&#39; &#39;)</span>
<span class="c1"># Token(type=&#39;EQ&#39;, value=&#39;=&#39;)</span>
<span class="c1"># Token(type=&#39;WS&#39;, value=&#39; &#39;)</span>
<span class="c1"># Token(type=&#39;NUM&#39;, value=&#39;42&#39;)</span>
</pre></div>
</div>
<p>如果你想过滤令牌流，你可以定义更多的生成器函数或者使用一个生成器表达式。
比如，下面演示怎样过滤所有的空白令牌：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span><span class="n">tok</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">generate_tokens</span><span class="p">(</span><span class="n">master_pat</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;WS&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>通常来讲令牌化是很多高级文本解析与处理的第一步。
为了使用上面的扫描方法，你需要记住这里一些重要的几点。
第一点就是你必须确认你使用正则表达式指定了所有输入中可能出现的文本序列。
如果有任何不可匹配的文本出现了，扫描就会直接停止。这也是为什么上面例子中必须指定空白字符令牌的原因。</p>
<p>令牌的顺序也是有影响的。 <code class="docutils literal"><span class="pre">re</span></code> 模块会按照指定好的顺序去做匹配。
因此，如果一个模式恰好是另一个更长模式的子字符串，那么你需要确定长模式写在前面。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">LT</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;LT&gt;&lt;)&#39;</span>
<span class="n">LE</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;LE&gt;&lt;=)&#39;</span>
<span class="n">EQ</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;EQ&gt;=)&#39;</span>

<span class="n">master_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">LE</span><span class="p">,</span> <span class="n">LT</span><span class="p">,</span> <span class="n">EQ</span><span class="p">]))</span> <span class="c1"># Correct</span>
<span class="c1"># master_pat = re.compile(&#39;|&#39;.join([LT, LE, EQ])) # Incorrect</span>
</pre></div>
</div>
<p>第二个模式是错的，因为它会将文本&lt;=匹配为令牌LT紧跟着EQ，而不是单独的令牌LE，这个并不是我们想要的结果。</p>
<p>最后，你需要留意下子字符串形式的模式。比如，假设你有如下两个模式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">PRINT</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;PRINT&gt;print)&#39;</span>
<span class="n">NAME</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)&#39;</span>

<span class="n">master_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">PRINT</span><span class="p">,</span> <span class="n">NAME</span><span class="p">]))</span>

<span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">generate_tokens</span><span class="p">(</span><span class="n">master_pat</span><span class="p">,</span> <span class="s1">&#39;printer&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>

<span class="c1"># Outputs :</span>
<span class="c1"># Token(type=&#39;PRINT&#39;, value=&#39;print&#39;)</span>
<span class="c1"># Token(type=&#39;NAME&#39;, value=&#39;er&#39;)</span>
</pre></div>
</div>
<p>关于更高阶的令牌化技术，你可能需要查看 <a class="reference external" href="http://pyparsing.wikispaces.com/">PyParsing</a>
或者 <a class="reference external" href="http://www.dabeaz.com/ply/index.html">PLY</a> 包。
一个调用PLY的例子在下一节会有演示。</p>
</div>
</div>
<span id="document-c02/p19_writing_recursive_descent_parser"></span><div class="section" id="id1">
<h3>2.19 实现一个简单的递归下降分析器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想根据一组语法规则解析文本并执行命令，或者构造一个代表输入的抽象语法树。
如果语法非常简单，你可以自己写这个解析器，而不是使用一些框架。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在这个问题中，我们集中讨论根据特殊语法去解析文本的问题。
为了这样做，你首先要以BNF或者EBNF形式指定一个标准语法。
比如，一个简单数学表达式语法可能像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">expr</span> <span class="o">+</span> <span class="n">term</span>
    <span class="o">|</span>   <span class="n">expr</span> <span class="o">-</span> <span class="n">term</span>
    <span class="o">|</span>   <span class="n">term</span>

<span class="n">term</span> <span class="p">::</span><span class="o">=</span> <span class="n">term</span> <span class="o">*</span> <span class="n">factor</span>
    <span class="o">|</span>   <span class="n">term</span> <span class="o">/</span> <span class="n">factor</span>
    <span class="o">|</span>   <span class="n">factor</span>

<span class="n">factor</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span> <span class="n">expr</span> <span class="p">)</span>
    <span class="o">|</span>   <span class="n">NUM</span>
</pre></div>
</div>
<p>或者，以EBNF形式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">term</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>

<span class="n">term</span> <span class="p">::</span><span class="o">=</span> <span class="n">factor</span> <span class="p">{</span> <span class="p">(</span><span class="o">*|/</span><span class="p">)</span> <span class="n">factor</span> <span class="p">}</span><span class="o">*</span>

<span class="n">factor</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span> <span class="n">expr</span> <span class="p">)</span>
    <span class="o">|</span>   <span class="n">NUM</span>
</pre></div>
</div>
<p>在EBNF中，被包含在 <code class="docutils literal"><span class="pre">{...}*</span></code> 中的规则是可选的。<a href="#id4"><span class="problematic" id="id5">*</span></a>代表0次或多次重复(跟正则表达式中意义是一样的)。</p>
<p>现在，如果你对BNF的工作机制还不是很明白的话，就把它当做是一组左右符号可相互替换的规则。
一般来讲，解析的原理就是你利用BNF完成多个替换和扩展以匹配输入文本和语法规则。
为了演示，假设你正在解析形如 <code class="docutils literal"><span class="pre">3</span> <span class="pre">+</span> <span class="pre">4</span> <span class="pre">*</span> <span class="pre">5</span></code> 的表达式。
这个表达式先要通过使用2.18节中介绍的技术分解为一组令牌流。
结果可能是像下列这样的令牌序列：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">NUM</span> <span class="o">+</span> <span class="n">NUM</span> <span class="o">*</span> <span class="n">NUM</span>
</pre></div>
</div>
<p>在此基础上， 解析动作会试着去通过替换操作匹配语法到输入令牌：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">expr</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">term</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">factor</span> <span class="p">{</span> <span class="p">(</span><span class="o">*|/</span><span class="p">)</span> <span class="n">factor</span> <span class="p">}</span><span class="o">*</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="p">{</span> <span class="p">(</span><span class="o">*|/</span><span class="p">)</span> <span class="n">factor</span> <span class="p">}</span><span class="o">*</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="o">+</span> <span class="n">term</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="o">+</span> <span class="n">factor</span> <span class="p">{</span> <span class="p">(</span><span class="o">*|/</span><span class="p">)</span> <span class="n">factor</span> <span class="p">}</span><span class="o">*</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="o">+</span> <span class="n">NUM</span> <span class="p">{</span> <span class="p">(</span><span class="o">*|/</span><span class="p">)</span> <span class="n">factor</span><span class="p">}</span><span class="o">*</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="o">+</span> <span class="n">NUM</span> <span class="o">*</span> <span class="n">factor</span> <span class="p">{</span> <span class="p">(</span><span class="o">*|/</span><span class="p">)</span> <span class="n">factor</span> <span class="p">}</span><span class="o">*</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="o">+</span> <span class="n">NUM</span> <span class="o">*</span> <span class="n">NUM</span> <span class="p">{</span> <span class="p">(</span><span class="o">*|/</span><span class="p">)</span> <span class="n">factor</span> <span class="p">}</span><span class="o">*</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="o">+</span> <span class="n">NUM</span> <span class="o">*</span> <span class="n">NUM</span> <span class="p">{</span> <span class="p">(</span><span class="o">+|-</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>
<span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">NUM</span> <span class="o">+</span> <span class="n">NUM</span> <span class="o">*</span> <span class="n">NUM</span>
</pre></div>
</div>
<p>下面所有的解析步骤可能需要花点时间弄明白，但是它们原理都是查找输入并试着去匹配语法规则。
第一个输入令牌是NUM，因此替换首先会匹配那个部分。
一旦匹配成功，就会进入下一个令牌+，以此类推。
当已经确定不能匹配下一个令牌的时候，右边的部分(比如 <code class="docutils literal"><span class="pre">{</span> <span class="pre">(*/)</span> <span class="pre">factor</span> <span class="pre">}*</span></code> )就会被清理掉。
在一个成功的解析中，整个右边部分会完全展开来匹配输入令牌流。</p>
<p>有了前面的知识背景，下面我们举一个简单示例来展示如何构建一个递归下降表达式求值程序：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- encoding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Topic: 下降解析器</span>
<span class="sd">Desc :</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="c1"># Token specification</span>
<span class="n">NUM</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;NUM&gt;\d+)&#39;</span>
<span class="n">PLUS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;PLUS&gt;\+)&#39;</span>
<span class="n">MINUS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;MINUS&gt;-)&#39;</span>
<span class="n">TIMES</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;TIMES&gt;\*)&#39;</span>
<span class="n">DIVIDE</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;DIVIDE&gt;/)&#39;</span>
<span class="n">LPAREN</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;LPAREN&gt;\()&#39;</span>
<span class="n">RPAREN</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;RPAREN&gt;\))&#39;</span>
<span class="n">WS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;WS&gt;\s+)&#39;</span>

<span class="n">master_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">NUM</span><span class="p">,</span> <span class="n">PLUS</span><span class="p">,</span> <span class="n">MINUS</span><span class="p">,</span> <span class="n">TIMES</span><span class="p">,</span>
                                  <span class="n">DIVIDE</span><span class="p">,</span> <span class="n">LPAREN</span><span class="p">,</span> <span class="n">RPAREN</span><span class="p">,</span> <span class="n">WS</span><span class="p">]))</span>
<span class="c1"># Tokenizer</span>
<span class="n">Token</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Token&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">generate_tokens</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">scanner</span> <span class="o">=</span> <span class="n">master_pat</span><span class="o">.</span><span class="n">scanner</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">scanner</span><span class="o">.</span><span class="n">match</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="n">Token</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">lastgroup</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;WS&#39;</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">tok</span>


<span class="c1"># Parser</span>
<span class="k">class</span> <span class="nc">ExpressionEvaluator</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Implementation of a recursive descent parser. Each method</span>
<span class="sd">    implements a single grammar rule. Use the ._accept() method</span>
<span class="sd">    to test and accept the current lookahead token. Use the ._expect()</span>
<span class="sd">    method to exactly match and discard the next token on on the input</span>
<span class="sd">    (or raise a SyntaxError if it doesn&#39;t match).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">generate_tokens</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tok</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Last symbol consumed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nexttok</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Next symbol tokenized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>  <span class="c1"># Load first lookahead token</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_advance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Advance one token ahead&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexttok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexttok</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toktype</span><span class="p">):</span>
        <span class="s1">&#39;Test and consume the next token if it matches toktype&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexttok</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexttok</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">toktype</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_expect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toktype</span><span class="p">):</span>
        <span class="s1">&#39;Consume next token if it matches toktype or raise SyntaxError&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept</span><span class="p">(</span><span class="n">toktype</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Expected &#39;</span> <span class="o">+</span> <span class="n">toktype</span><span class="p">)</span>

    <span class="c1"># Grammar rules follow</span>
    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;expression ::= term { (&#39;+&#39;|&#39;-&#39;) term }*&quot;</span>
        <span class="n">exprval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept</span><span class="p">(</span><span class="s1">&#39;PLUS&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept</span><span class="p">(</span><span class="s1">&#39;MINUS&#39;</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="o">.</span><span class="n">type</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;PLUS&#39;</span><span class="p">:</span>
                <span class="n">exprval</span> <span class="o">+=</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;MINUS&#39;</span><span class="p">:</span>
                <span class="n">exprval</span> <span class="o">-=</span> <span class="n">right</span>
        <span class="k">return</span> <span class="n">exprval</span>

    <span class="k">def</span> <span class="nf">term</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;term ::= factor { (&#39;*&#39;|&#39;/&#39;) factor }*&quot;</span>
        <span class="n">termval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept</span><span class="p">(</span><span class="s1">&#39;TIMES&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept</span><span class="p">(</span><span class="s1">&#39;DIVIDE&#39;</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="o">.</span><span class="n">type</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;TIMES&#39;</span><span class="p">:</span>
                <span class="n">termval</span> <span class="o">*=</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;DIVIDE&#39;</span><span class="p">:</span>
                <span class="n">termval</span> <span class="o">/=</span> <span class="n">right</span>
        <span class="k">return</span> <span class="n">termval</span>

    <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;factor ::= NUM | ( expr )&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept</span><span class="p">(</span><span class="s1">&#39;NUM&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept</span><span class="p">(</span><span class="s1">&#39;LPAREN&#39;</span><span class="p">):</span>
            <span class="n">exprval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expect</span><span class="p">(</span><span class="s1">&#39;RPAREN&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">exprval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Expected NUMBER or LPAREN&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">descent_parser</span><span class="p">():</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">ExpressionEvaluator</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2 + 3&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2 + 3 * 4&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2 + (3 + 4) * 5&#39;</span><span class="p">))</span>
    <span class="c1"># print(e.parse(&#39;2 + (3 + * 4)&#39;))</span>
    <span class="c1"># Traceback (most recent call last):</span>
    <span class="c1">#    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
    <span class="c1">#    File &quot;exprparse.py&quot;, line 40, in parse</span>
    <span class="c1">#    return self.expr()</span>
    <span class="c1">#    File &quot;exprparse.py&quot;, line 67, in expr</span>
    <span class="c1">#    right = self.term()</span>
    <span class="c1">#    File &quot;exprparse.py&quot;, line 77, in term</span>
    <span class="c1">#    termval = self.factor()</span>
    <span class="c1">#    File &quot;exprparse.py&quot;, line 93, in factor</span>
    <span class="c1">#    exprval = self.expr()</span>
    <span class="c1">#    File &quot;exprparse.py&quot;, line 67, in expr</span>
    <span class="c1">#    right = self.term()</span>
    <span class="c1">#    File &quot;exprparse.py&quot;, line 77, in term</span>
    <span class="c1">#    termval = self.factor()</span>
    <span class="c1">#    File &quot;exprparse.py&quot;, line 97, in factor</span>
    <span class="c1">#    raise SyntaxError(&quot;Expected NUMBER or LPAREN&quot;)</span>
    <span class="c1">#    SyntaxError: Expected NUMBER or LPAREN</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">descent_parser</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>讨论<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>文本解析是一个很大的主题， 一般会占用学生学习编译课程时刚开始的三周时间。
如果你在找寻关于语法，解析算法等相关的背景知识的话，你应该去看一下编译器书籍。
很显然，关于这方面的内容太多，不可能在这里全部展开。</p>
<p>尽管如此，编写一个递归下降解析器的整体思路是比较简单的。
开始的时候，你先获得所有的语法规则，然后将其转换为一个函数或者方法。
因此如果你的语法类似这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">term</span> <span class="p">{</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="o">|</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="n">term</span> <span class="p">}</span><span class="o">*</span>

<span class="n">term</span> <span class="p">::</span><span class="o">=</span> <span class="n">factor</span> <span class="p">{</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="o">|</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="n">factor</span> <span class="p">}</span><span class="o">*</span>

<span class="n">factor</span> <span class="p">::</span><span class="o">=</span> <span class="s1">&#39;(&#39;</span> <span class="n">expr</span> <span class="s1">&#39;)&#39;</span>
    <span class="o">|</span> <span class="n">NUM</span>
</pre></div>
</div>
<p>你应该首先将它们转换成一组像下面这样的方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpressionEvaluator</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">term</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>每个方法要完成的任务很简单 - 它必须从左至右遍历语法规则的每一部分，处理每个令牌。
从某种意义上讲，方法的目的就是要么处理完语法规则，要么产生一个语法错误。
为了这样做，需采用下面的这些实现方法：</p>
<ul class="simple">
<li>如果规则中的下个符号是另外一个语法规则的名字(比如term或factor)，就简单的调用同名的方法即可。
这就是该算法中&#8221;下降&#8221;的由来 - 控制下降到另一个语法规则中去。
有时候规则会调用已经执行的方法(比如，在 <code class="docutils literal"><span class="pre">factor</span> <span class="pre">::=</span> <span class="pre">'('expr</span> <span class="pre">')'</span></code> 中对expr的调用)。
这就是算法中&#8221;递归&#8221;的由来。</li>
<li>如果规则中下一个符号是个特殊符号(比如()，你得查找下一个令牌并确认是一个精确匹配)。
如果不匹配，就产生一个语法错误。这一节中的 <code class="docutils literal"><span class="pre">_expect()</span></code> 方法就是用来做这一步的。</li>
<li>如果规则中下一个符号为一些可能的选择项(比如 + 或 -)，
你必须对每一种可能情况检查下一个令牌，只有当它匹配一个的时候才能继续。
这也是本节示例中 <code class="docutils literal"><span class="pre">_accept()</span></code> 方法的目的。
它相当于_expect()方法的弱化版本，因为如果一个匹配找到了它会继续，
但是如果没找到，它不会产生错误而是回滚(允许后续的检查继续进行)。</li>
<li>对于有重复部分的规则(比如在规则表达式 <code class="docutils literal"><span class="pre">::=</span> <span class="pre">term</span> <span class="pre">{</span> <span class="pre">('+'|'-')</span> <span class="pre">term</span> <span class="pre">}*</span></code> 中)，
重复动作通过一个while循环来实现。
循环主体会收集或处理所有的重复元素直到没有其他元素可以找到。</li>
<li>一旦整个语法规则处理完成，每个方法会返回某种结果给调用者。
这就是在解析过程中值是怎样累加的原理。
比如，在表达式求值程序中，返回值代表表达式解析后的部分结果。
最后所有值会在最顶层的语法规则方法中合并起来。</li>
</ul>
<p>尽管向你演示的是一个简单的例子，递归下降解析器可以用来实现非常复杂的解析。
比如，Python语言本身就是通过一个递归下降解析器去解释的。
如果你对此感兴趣，你可以通过查看Python源码文件Grammar/Grammar来研究下底层语法机制。
看完你会发现，通过手动方式去实现一个解析器其实会有很多的局限和不足之处。</p>
<p>其中一个局限就是它们不能被用于包含任何左递归的语法规则中。比如，加入你需要翻译下面这样一个规则：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">items</span> <span class="p">::</span><span class="o">=</span> <span class="n">items</span> <span class="s1">&#39;,&#39;</span> <span class="n">item</span>
    <span class="o">|</span> <span class="n">item</span>
</pre></div>
</div>
<p>为了这样做，你可能会像下面这样使用 <code class="docutils literal"><span class="pre">items()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">itemsval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">itemsval</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="n">itemsval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">itemsval</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="p">]</span>
</pre></div>
</div>
<p>唯一的问题是这个方法根本不能工作，事实上，它会产生一个无限递归错误。</p>
<p>关于语法规则本身你可能也会碰到一些棘手的问题。
比如，你可能想知道下面这个简单扼语法是否表述得当：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">factor</span> <span class="p">{</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="o">|</span><span class="s1">&#39;-&#39;</span><span class="o">|</span><span class="s1">&#39;*&#39;</span><span class="o">|</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="n">factor</span> <span class="p">}</span><span class="o">*</span>

<span class="n">factor</span> <span class="p">::</span><span class="o">=</span> <span class="s1">&#39;(&#39;</span> <span class="n">expression</span> <span class="s1">&#39;)&#39;</span>
    <span class="o">|</span> <span class="n">NUM</span>
</pre></div>
</div>
<p>这个语法看上去没啥问题，但是它却不能察觉到标准四则运算中的运算符优先级。
比如，表达式 <code class="docutils literal"><span class="pre">&quot;3</span> <span class="pre">+</span> <span class="pre">4</span> <span class="pre">*</span> <span class="pre">5&quot;</span></code> 会得到35而不是期望的23.
分开使用&#8221;expr&#8221;和&#8221;term&#8221;规则可以让它正确的工作。</p>
<p>对于复杂的语法，你最好是选择某个解析工具比如PyParsing或者是PLY。
下面是使用PLY来重写表达式求值程序的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ply.lex</span> <span class="kn">import</span> <span class="n">lex</span>
<span class="kn">from</span> <span class="nn">ply.yacc</span> <span class="kn">import</span> <span class="n">yacc</span>

<span class="c1"># Token list</span>
<span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;NUM&#39;</span><span class="p">,</span> <span class="s1">&#39;PLUS&#39;</span><span class="p">,</span> <span class="s1">&#39;MINUS&#39;</span><span class="p">,</span> <span class="s1">&#39;TIMES&#39;</span><span class="p">,</span> <span class="s1">&#39;DIVIDE&#39;</span><span class="p">,</span> <span class="s1">&#39;LPAREN&#39;</span><span class="p">,</span> <span class="s1">&#39;RPAREN&#39;</span> <span class="p">]</span>
<span class="c1"># Ignored characters</span>
<span class="n">t_ignore</span> <span class="o">=</span> <span class="s1">&#39; </span><span class="se">\t\n</span><span class="s1">&#39;</span>
<span class="c1"># Token specifications (as regexs)</span>
<span class="n">t_PLUS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\+&#39;</span>
<span class="n">t_MINUS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;-&#39;</span>
<span class="n">t_TIMES</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\*&#39;</span>
<span class="n">t_DIVIDE</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;/&#39;</span>
<span class="n">t_LPAREN</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\(&#39;</span>
<span class="n">t_RPAREN</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\)&#39;</span>

<span class="c1"># Token processing functions</span>
<span class="k">def</span> <span class="nf">t_NUM</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="c1"># Error handler</span>
<span class="k">def</span> <span class="nf">t_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Bad character: {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">t</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Build the lexer</span>
<span class="n">lexer</span> <span class="o">=</span> <span class="n">lex</span><span class="p">()</span>

<span class="c1"># Grammar rules and handler functions</span>
<span class="k">def</span> <span class="nf">p_expr</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    expr : expr PLUS term</span>
<span class="sd">        | expr MINUS term</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">p_expr_term</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    expr : term</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">p_term</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    term : term TIMES factor</span>
<span class="sd">    | term DIVIDE factor</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">p_term_factor</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    term : factor</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">p_factor</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    factor : NUM</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">p_factor_group</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    factor : LPAREN expr RPAREN</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">p_error</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Syntax error&#39;</span><span class="p">)</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">yacc</span><span class="p">()</span>
</pre></div>
</div>
<p>这个程序中，所有代码都位于一个比较高的层次。你只需要为令牌写正则表达式和规则匹配时的高阶处理函数即可。
而实际的运行解析器，接受令牌等等底层动作已经被库函数实现了。</p>
<p>下面是一个怎样使用得到的解析对象的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2+3&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2+(3+4)*5&#39;</span><span class="p">)</span>
<span class="go">37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想在你的编程过程中来点挑战和刺激，编写解析器和编译器是个不错的选择。
再次，一本编译器的书籍会包含很多底层的理论知识。不过很多好的资源也可以在网上找到。
Python自己的ast模块也值得去看一下。</p>
</div>
</div>
<span id="document-c02/p20_perform_text_operations_on_byte_string"></span><div class="section" id="id1">
<h3>2.20 字节字符串上的字符串操作<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在字节字符串上执行普通的文本操作(比如移除，搜索和替换)。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>字节字符串同样也支持大部分和文本字符串一样的内置操作。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;Hello&#39;, b&#39;World&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;Hello Cruel&#39;</span><span class="p">)</span>
<span class="go">b&#39;Hello Cruel World&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这些操作同样也适用于字节数组。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">bytearray(b&#39;Hello&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[bytearray(b&#39;Hello&#39;), bytearray(b&#39;World&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;Hello Cruel&#39;</span><span class="p">)</span>
<span class="go">bytearray(b&#39;Hello Cruel World&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你可以使用正则表达式匹配字节字符串，但是正则表达式本身必须也是字节串。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt;
&gt;&gt;&gt; data = b&#39;FOO:BAR,SPAM&#39;
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.split(&#39;[:,]&#39;,data)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;/usr/local/lib/python3.3/re.py&quot;, line 191, in split
return _compile(pattern, flags).split(string, maxsplit)
TypeError: can&#39;t use a string pattern on a bytes-like object
&gt;&gt;&gt; re.split(b&#39;[:,]&#39;,data) # Notice: pattern as bytes
[b&#39;FOO&#39;, b&#39;BAR&#39;, b&#39;SPAM&#39;]
&gt;&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>大多数情况下，在文本字符串上的操作均可用于字节字符串。
然而，这里也有一些需要注意的不同点。首先，字节字符串的索引操作返回整数而不是单独字符。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;Hello World&#39;</span> <span class="c1"># Text string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;H&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;e&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span> <span class="c1"># Byte string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">72</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">101</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种语义上的区别会对于处理面向字节的字符数据有影响。</p>
<p>第二点，字节字符串不会提供一个美观的字符串表示，也不能很好的打印出来，除非它们先被解码为一个文本字符串。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">b&#39;Hello World&#39; # Observe b&#39;...&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
<span class="go">Hello World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>类似的，也不存在任何适用于字节字符串的格式化操作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="si">%10s</span><span class="s1"> </span><span class="si">%10d</span><span class="s1"> </span><span class="si">%10.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">490.1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">unsupported operand type(s) for %: &#39;bytes&#39; and &#39;tuple&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;{} {} {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">490.1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;bytes&#39; object has no attribute &#39;format&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想格式化字节字符串，你得先使用标准的文本字符串，然后将其编码为字节字符串。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;{:10s} {:10d} {:10.2f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">490.1</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="go">b&#39;ACME 100 490.10&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后需要注意的是，使用字节字符串可能会改变一些操作的语义，特别是那些跟文件系统有关的操作。
比如，如果你使用一个编码为字节的文件名，而不是一个普通的文本字符串，会禁用文件名的编码/解码。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Write a UTF-8 filename</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;jalape</span><span class="se">\xf1</span><span class="s1">o.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;spicy&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get a directory listing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="c1"># Text string (names are decoded)</span>
<span class="go">[&#39;jalapeño.txt&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="c1"># Byte string (names left as bytes)</span>
<span class="go">[b&#39;jalapen\xcc\x83o.txt&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意例子中的最后部分给目录名传递一个字节字符串是怎样导致结果中文件名以未解码字节返回的。
在目录中的文件名包含原始的UTF-8编码。
参考5.15小节获取更多文件名相关的内容。</p>
<p>最后提一点，一些程序员为了提升程序执行的速度会倾向于使用字节字符串而不是文本字符串。
尽管操作字节字符串确实会比文本更加高效(因为处理文本固有的Unicode相关开销)。
这样做通常会导致非常杂乱的代码。你会经常发现字节字符串并不能和Python的其他部分工作的很好，
并且你还得手动处理所有的编码/解码操作。
坦白讲，如果你在处理文本的话，就直接在程序中使用普通的文本字符串而不是字节字符串。不做死就不会死！</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p03_numbers_dates_times"></span><div class="section" id="id1">
<h2>第三章：数字日期和时间<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>在Python中执行整数和浮点数的数学运算时很简单的。
尽管如此，如果你需要执行分数、数组或者是日期和时间的运算的话，就得做更多的工作了。
本章集中讨论的就是这些主题。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c03/p01_round_number"></span><div class="section" id="id1">
<h3>3.1 数字的四舍五入<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想对浮点数执行指定精度的舍入运算。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于简单的舍入运算，使用内置的 <code class="docutils literal"><span class="pre">round(value,</span> <span class="pre">ndigits)</span></code> 函数即可。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="mf">1.23</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="mf">1.27</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="o">-</span><span class="mf">1.27</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">-1.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="mf">1.25361</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1.254</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当一个值刚好在两个边界的中间的时候， <code class="docutils literal"><span class="pre">round</span></code> 函数返回离它最近的偶数。
也就是说，对1.5或者2.5的舍入运算都会得到2。</p>
<p>传给 <code class="docutils literal"><span class="pre">round()</span></code> 函数的 <code class="docutils literal"><span class="pre">ndigits</span></code> 参数可以是负数，这种情况下，
舍入运算会作用在十位、百位、千位等上面。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1627731</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1627730</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1627700</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1628000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>不要将舍入和格式化输出搞混淆了。
如果你的目的只是简单的输出一定宽度的数，你不需要使用 <code class="docutils literal"><span class="pre">round()</span></code> 函数。
而仅仅只需要在格式化的时候指定精度即可。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">1.23456</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;0.2f&#39;</span><span class="p">)</span>
<span class="go">&#39;1.23&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;0.3f&#39;</span><span class="p">)</span>
<span class="go">&#39;1.235&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;value is {:0.3f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;value is 1.235&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>同样，不要试着去舍入浮点值来&#8221;修正&#8221;表面上看起来正确的问题。比如，你可能倾向于这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">2.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mf">4.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">6.300000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># &quot;Fix&quot; result (???)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">6.3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于大多数使用到浮点的程序，没有必要也不推荐这样做。
尽管在计算的时候会有一点点小的误差，但是这些小的误差是能被理解与容忍的。
如果不能允许这样的小误差(比如涉及到金融领域)，那么就得考虑使用 <code class="docutils literal"><span class="pre">decimal</span></code> 模块了，下一节我们会详细讨论。</p>
</div>
</div>
<span id="document-c03/p02_accurate_decimal_calculations"></span><div class="section" id="id1">
<h3>3.2 执行精确的浮点数运算<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要对浮点数执行精确的计算操作，并且不希望有任何小误差的出现。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>浮点数的一个普遍问题是它们并不能精确的表示十进制数。
并且，即使是最简单的数学运算也会产生小的误差，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">4.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mf">2.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">6.300000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mf">6.3</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这些错误是由底层CPU和IEEE 754标准通过自己的浮点单位去执行算术时的特征。
由于Python的浮点数据类型使用底层表示存储数据，因此你没办法去避免这样的误差。</p>
<p>如果你想更加精确(并能容忍一定的性能损耗)，你可以使用 <code class="docutils literal"><span class="pre">decimal</span></code> 模块：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;4.2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">Decimal(&#39;6.3&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="go">6.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.3&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>初看起来，上面的代码好像有点奇怪，比如我们用字符串来表示数字。
然而， <code class="docutils literal"><span class="pre">Decimal</span></code> 对象会像普通浮点数一样的工作(支持所有的常用数学运算)。
如果你打印它们或者在字符串格式化函数中使用它们，看起来跟普通数字没什么两样。</p>
<p><code class="docutils literal"><span class="pre">decimal</span></code> 模块的一个主要特征是允许你控制计算的每一方面，包括数字位数和四舍五入运算。
为了这样做，你先得创建一个本地上下文并更改它的设置，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">localcontext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.7&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0.7647058823529411764705882353</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0.765</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0.76470588235294117647058823529411764705882352941176</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">decimal</span></code> 模块实现了IBM的&#8221;通用小数运算规范&#8221;。不用说，有很多的配置选项这本书没有提到。</p>
<p>Python新手会倾向于使用 <code class="docutils literal"><span class="pre">decimal</span></code> 模块来处理浮点数的精确运算。
然而，先理解你的应用程序目的是非常重要的。
如果你是在做科学计算或工程领域的计算、电脑绘图，或者是科学领域的大多数运算，
那么使用普通的浮点类型是比较普遍的做法。
其中一个原因是，在真实世界中很少会要求精确到普通浮点数能提供的17位精度。
因此，计算过程中的那么一点点的误差是被允许的。
第二点就是，原生的浮点数计算要快的多-有时候你在执行大量运算的时候速度也是非常重要的。</p>
<p>即便如此，你却不能完全忽略误差。数学家花了大量时间去研究各类算法，有些处理误差会比其他方法更好。
你也得注意下减法删除以及大数和小数的加分运算所带来的影响。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.23e+18</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.23e+18</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="c1"># Notice how 1 disappears</span>
<span class="go">0.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>上面的错误可以利用 <code class="docutils literal"><span class="pre">math.fsum()</span></code> 所提供的更精确计算能力来解决：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">fsum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然而，对于其他的算法，你应该仔细研究它并理解它的误差产生来源。</p>
<p>总的来说， <code class="docutils literal"><span class="pre">decimal</span></code> 模块主要用在涉及到金融的领域。
在这类程序中，哪怕是一点小小的误差在计算过程中蔓延都是不允许的。
因此， <code class="docutils literal"><span class="pre">decimal</span></code> 模块为解决这类问题提供了方法。
当Python和数据库打交道的时候也通常会遇到 <code class="docutils literal"><span class="pre">Decimal</span></code> 对象，并且，通常也是在处理金融数据的时候。</p>
</div>
</div>
<span id="document-c03/p03_format_numbers_for_output"></span><div class="section" id="id1">
<h3>3.3 数字的格式化输出<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要将数字格式化后输出，并控制数字的位数、对齐、千位分隔符和其他的细节。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>格式化输出单个数字的时候，可以使用内置的 <code class="docutils literal"><span class="pre">format()</span></code> 函数，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">1234.56789</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Two decimal places of accuracy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;0.2f&#39;</span><span class="p">)</span>
<span class="go">&#39;1234.57&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Right justified in 10 chars, one-digit accuracy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;&gt;10.1f&#39;</span><span class="p">)</span>
<span class="go">&#39;    1234.6&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Left justified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;&lt;10.1f&#39;</span><span class="p">)</span>
<span class="go">&#39;1234.6    &#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Centered</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;^10.1f&#39;</span><span class="p">)</span>
<span class="go">&#39;  1234.6  &#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Inclusion of thousands separator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">&#39;1,234.56789&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;0,.1f&#39;</span><span class="p">)</span>
<span class="go">&#39;1,234.6&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想使用指数记法，将f改成e或者E(取决于指数输出的大小写形式)。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="go">&#39;1.234568e+03&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;0.2E&#39;</span><span class="p">)</span>
<span class="go">&#39;1.23E+03&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>同时指定宽度和精度的一般形式是 <code class="docutils literal"><span class="pre">'[&lt;&gt;^]?width[,]?(.digits)?'</span></code> ，
其中 <code class="docutils literal"><span class="pre">width</span></code> 和 <code class="docutils literal"><span class="pre">digits</span></code> 为整数，？代表可选部分。
同样的格式也被用在字符串的 <code class="docutils literal"><span class="pre">format()</span></code> 方法中。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;The value is {:0,.2f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;The value is 1,234.57&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>数字格式化输出通常是比较简单的。上面演示的技术同时适用于浮点数和 <code class="docutils literal"><span class="pre">decimal</span></code> 模块中的 <code class="docutils literal"><span class="pre">Decimal</span></code> 数字对象。</p>
<p>当指定数字的位数后，结果值会根据 <code class="docutils literal"><span class="pre">round()</span></code> 函数同样的规则进行四舍五入后返回。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">1234.56789</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;0.1f&#39;</span><span class="p">)</span>
<span class="go">&#39;1234.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;0.1f&#39;</span><span class="p">)</span>
<span class="go">&#39;-1234.6&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>包含千位符的格式化跟本地化没有关系。
如果你需要根据地区来显示千位符，你需要自己去调查下 <code class="docutils literal"><span class="pre">locale</span></code> 模块中的函数了。
你同样也可以使用字符串的 <code class="docutils literal"><span class="pre">translate()</span></code> 方法来交换千位符。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swap_separators</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span><span class="s1">&#39;.&#39;</span> <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">swap_separators</span><span class="p">)</span>
<span class="go">&#39;1.234,56789&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在很多Python代码中会看到使用%来格式化数字的，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%0.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span>
<span class="go">&#39;1234.57&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%10.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span>
<span class="go">&#39;    1234.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%-10.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span>
<span class="go">&#39;1234.6    &#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种格式化方法也是可行的，不过比更加先进的 <code class="docutils literal"><span class="pre">format()</span></code> 要差一点。
比如，在使用%操作符格式化数字的时候，一些特性(添加千位符)并不能被支持。</p>
</div>
</div>
<span id="document-c03/p04_binary_octal_hexadecimal_int"></span><div class="section" id="id1">
<h3>3.4 二八十六进制整数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要转换或者输出使用二进制，八进制或十六进制表示的整数。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了将整数转换为二进制、八进制或十六进制的文本串，
可以分别使用 <code class="docutils literal"><span class="pre">bin()</span></code> , <code class="docutils literal"><span class="pre">oct()</span></code> 或 <code class="docutils literal"><span class="pre">hex()</span></code> 函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;0b10011010010&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;0o2322&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;0x4d2&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外，如果你不想输出 <code class="docutils literal"><span class="pre">0b</span></code> , <code class="docutils literal"><span class="pre">0o</span></code> 或者 <code class="docutils literal"><span class="pre">0x</span></code> 的前缀的话，可以使用 <code class="docutils literal"><span class="pre">format()</span></code> 函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">&#39;10011010010&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">&#39;2322&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">&#39;4d2&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>整数是有符号的，所以如果你在处理负数的话，输出结果会包含一个负号。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1234</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">&#39;-10011010010&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">&#39;-4d2&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想产生一个无符号值，你需要增加一个指示最大位长度的值。比如为了显示32位的值，可以像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1234</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">&#39;11111111111111111111101100101110&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">&#39;fffffb2e&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了以不同的进制转换整数字符串，简单的使用带有进制的 <code class="docutils literal"><span class="pre">int()</span></code> 函数即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;4d2&#39;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="go">1234</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;10011010010&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">1234</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>大多数情况下处理二进制、八进制和十六进制整数是很简单的。
只要记住这些转换属于整数和其对应的文本表示之间的转换即可。永远只有一种整数类型。</p>
<p>最后，使用八进制的程序员有一点需要注意下。
Python指定八进制数的语法跟其他语言稍有不同。比如，如果你像下面这样指定八进制，会出现语法错误：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="s1">&#39;script.py&#39;</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span>
<span class="go">    File &quot;&lt;stdin&gt;&quot;, line 1</span>
<span class="go">        os.chmod(&#39;script.py&#39;, 0755)</span>
<span class="go">                            ^</span>
<span class="go">SyntaxError: invalid token</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>需确保八进制数的前缀是 <code class="docutils literal"><span class="pre">0o</span></code> ，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="s1">&#39;script.py&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="n">o755</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c03/p05_pack_unpack_large_int_from_bytes"></span><div class="section" id="id1">
<h3>3.5 字节到大整数的打包与解包<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个字节字符串并想将它解压成一个整数。或者，你需要将一个大整数转换为一个字节字符串。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>假设你的程序需要处理一个拥有128位长的16个元素的字节字符串。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x12</span><span class="s1">4V</span><span class="se">\x00</span><span class="s1">x</span><span class="se">\x90\xab\x00\xcd\xef\x01\x00</span><span class="s1">#</span><span class="se">\x00</span><span class="s1">4&#39;</span>
</pre></div>
</div>
<p>为了将bytes解析为整数，使用 <code class="docutils literal"><span class="pre">int.from_bytes()</span></code> 方法，并像下面这样指定字节顺序：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">69120565665751139577663547927094891008</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">94522842520747284487117727783387188</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了将一个大整数转换为一个字节字符串，使用 <code class="docutils literal"><span class="pre">int.to_bytes()</span></code> 方法，并像下面这样指定字节数和字节顺序：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">94522842520747284487117727783387188</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">b&#39;4\x00#\x00\x01\xef\xcd\x00\xab\x90x\x00V4\x12\x00&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>大整数和字节字符串之间的转换操作并不常见。
然而，在一些应用领域有时候也会出现，比如密码学或者网络。
例如，IPv6网络地址使用一个128位的整数表示。
如果你要从一个数据记录中提取这样的值的时候，你就会面对这样的问题。</p>
<p>作为一种替代方案，你可能想使用6.11小节中所介绍的 <code class="docutils literal"><span class="pre">struct</span></code> 模块来解压字节。
这样也行得通，不过利用 <code class="docutils literal"><span class="pre">struct</span></code> 模块来解压对于整数的大小是有限制的。
因此，你可能想解压多个字节串并将结果合并为最终的结果，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">b&#39;\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="p">,</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&gt;QQ&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">+</span> <span class="n">lo</span>
<span class="go">94522842520747284487117727783387188</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>字节顺序规则(little或big)仅仅指定了构建整数时的字节的低位高位排列方式。
我们从下面精心构造的16进制数的表示中可以很容易的看出来：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mh">0x01020304</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x01\x02\x03\x04&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x04\x03\x02\x01&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你试着将一个整数打包为字节字符串，那么它就不合适了，你会得到一个错误。
如果需要的话，你可以使用 <code class="docutils literal"><span class="pre">int.bit_length()</span></code> 方法来决定需要多少字节位来存储这个值。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; x = 523 ** 23
&gt;&gt;&gt; x
335381300113661875107536852714019056160355655333978849017944067
&gt;&gt;&gt; x.to_bytes(16, &#39;little&#39;)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
OverflowError: int too big to convert
&gt;&gt;&gt; x.bit_length()
208
&gt;&gt;&gt; nbytes, rem = divmod(x.bit_length(), 8)
&gt;&gt;&gt; if rem:
... nbytes += 1
...
&gt;&gt;&gt;
&gt;&gt;&gt; x.to_bytes(nbytes, &#39;little&#39;)
b&#39;\x03X\xf1\x82iT\x96\xac\xc7c\x16\xf3\xb9\xcf...\xd0&#39;
&gt;&gt;&gt;
</pre></div>
</div>
</div>
</div>
<span id="document-c03/p06_complex_math"></span><div class="section" id="id1">
<h3>3.6 复数的数学运算<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你写的最新的网络认证方案代码遇到了一个难题，并且你唯一的解决办法就是使用复数空间。
再或者是你仅仅需要使用复数来执行一些计算操作。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>复数可以用使用函数 <code class="docutils literal"><span class="pre">complex(real,</span> <span class="pre">imag)</span></code> 或者是带有后缀j的浮点数来指定。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">5j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">(2+4j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">(3-5j)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对应的实部、虚部和共轭复数可以很容易的获取。就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
<span class="go">(2-4j)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外，所有常见的数学运算都可以工作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">(5-1j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">(26+2j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
<span class="go">(-0.4117647058823529+0.6470588235294118j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4.47213595499958</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果要执行其他的复数函数比如正弦、余弦或平方根，使用 <code class="docutils literal"><span class="pre">cmath</span></code> 模块：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cmath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmath</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(24.83130584894638-11.356612711218174j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmath</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(-11.36423470640106-24.814651485634187j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmath</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(-4.829809383269385-5.5920560936409816j)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>Python中大部分与数学相关的模块都能处理复数。
比如如果你使用 <code class="docutils literal"><span class="pre">numpy</span></code> ，可以很容易的构造一个复数数组并在这个数组上执行各种操作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">+</span><span class="mi">3j</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">5j</span><span class="p">,</span> <span class="mi">6</span><span class="o">-</span><span class="mi">7j</span><span class="p">,</span> <span class="mi">8</span><span class="o">+</span><span class="mi">9j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 2.+3.j, 4.+5.j, 6.-7.j, 8.+9.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span>
<span class="go">array([ 4.+3.j, 6.+5.j, 8.-7.j, 10.+9.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 9.15449915 -4.16890696j, -56.16227422 -48.50245524j,</span>
<span class="go">        -153.20827755-526.47684926j, 4008.42651446-589.49948373j])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Python的标准数学函数确实情况下并不能产生复数值，因此你的代码中不可能会出现复数返回值。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ValueError</span>: <span class="n">math domain error</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想生成一个复数返回结果，你必须显示的使用 <code class="docutils literal"><span class="pre">cmath</span></code> 模块，或者在某个支持复数的库中声明复数类型的使用。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cmath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1j</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c03/p07_infinity_and_nan"></span><div class="section" id="nan">
<h3>3.7 无穷大与NaN<a class="headerlink" href="#nan" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想创建或测试正无穷、负无穷或NaN(非数字)的浮点数。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>Python并没有特殊的语法来表示这些特殊的浮点值，但是可以使用 <code class="docutils literal"><span class="pre">float()</span></code> 来创建它们。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">nan</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了测试这些值的存在，使用 <code class="docutils literal"><span class="pre">math.isinf()</span></code> 和 <code class="docutils literal"><span class="pre">math.isnan()</span></code> 函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>想了解更多这些特殊浮点值的信息，可以参考IEEE 754规范。
然而，也有一些地方需要你特别注意，特别是跟比较和操作符相关的时候。</p>
<p>无穷大数在执行数学计算的时候会传播，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="mi">45</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">10</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="o">/</span> <span class="n">a</span>
<span class="go">0.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但是有些操作时未定义的并会返回一个NaN结果。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">/</span><span class="n">a</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">nan</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>NaN值会在所有操作中传播，而不会产生异常。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">+</span> <span class="mi">23</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">/</span> <span class="mi">2</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">*</span> <span class="mi">2</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">nan</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>NaN值的一个特别的地方时它们之间的比较操作总是返回False。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="ow">is</span> <span class="n">d</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>由于这个原因，测试一个NaN值得唯一安全的方法就是使用 <code class="docutils literal"><span class="pre">math.isnan()</span></code> ，也就是上面演示的那样。</p>
<p>有时候程序员想改变Python默认行为，在返回无穷大或NaN结果的操作中抛出异常。
<code class="docutils literal"><span class="pre">fpectl</span></code> 模块可以用来改变这种行为，但是它在标准的Python构建中并没有被启用，它是平台相关的，
并且针对的是专家级程序员。可以参考在线的Python文档获取更多的细节。</p>
</div>
</div>
<span id="document-c03/p08_calculating_with_fractions"></span><div class="section" id="id1">
<h3>3.8 分数运算<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你进入时间机器，突然发现你正在做小学家庭作业，并涉及到分数计算问题。
或者你可能需要写代码去计算在你的木工工厂中的测量值。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">fractions</span></code> 模块可以被用来执行包含分数的数学运算。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="go">27/16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="go">35/64</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Getting numerator/denominator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">numerator</span>
<span class="go">35</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">denominator</span>
<span class="go">64</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Converting to a float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">0.546875</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Limiting the denominator of a value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">4/7</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Converting a float to a fraction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">3.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">Fraction(15, 4)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在大多数程序中一般不会出现分数的计算问题，但是有时候还是需要用到的。
比如，在一个允许接受分数形式的测试单位并以分数形式执行运算的程序中，
直接使用分数可以减少手动转换为小数或浮点数的工作。</p>
</div>
</div>
<span id="document-c03/p09_calculating_with_large_num_arrays"></span><div class="section" id="id1">
<h3>3.9 大型数组运算<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要在大数据集(比如数组或网格)上面执行计算。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>涉及到数组的重量级运算操作，可以使用 <code class="docutils literal"><span class="pre">NumPy</span></code> 库。
<code class="docutils literal"><span class="pre">NumPy</span></code> 的一个主要特征是它会给Python提供一个数组对象，相比标准的Python列表而已更适合用来做数学运算。
下面是一个简单的小例子，向你展示标准列表对象和 <code class="docutils literal"><span class="pre">NumPy</span></code> 数组对象之间的差别：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Python lists</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="go">[1, 2, 3, 4, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="mi">10</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">can only concatenate list (not &quot;int&quot;) to list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Numpy arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">*</span> <span class="mi">2</span>
<span class="go">array([2, 4, 6, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">+</span> <span class="mi">10</span>
<span class="go">array([11, 12, 13, 14])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">+</span> <span class="n">ay</span>
<span class="go">array([ 6, 8, 10, 12])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">*</span> <span class="n">ay</span>
<span class="go">array([ 5, 12, 21, 32])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正如所见，两种方案中数组的基本数学运算结果并不相同。
特别的， <code class="docutils literal"><span class="pre">NumPy</span></code> 中的标量运算(比如 <code class="docutils literal"><span class="pre">ax</span> <span class="pre">*</span> <span class="pre">2</span></code> 或 <code class="docutils literal"><span class="pre">ax</span> <span class="pre">+</span> <span class="pre">10</span></code> )会作用在每一个元素上。
另外，当两个操作数都是数组的时候执行元素对等位置计算，并最终生成一个新的数组。</p>
<p>对整个数组中所有元素同时执行数学运算可以使得作用在整个数组上的函数运算简单而又快速。
比如，如果你想计算多项式的值，可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span><span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">7</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="go">array([ 8, 15, 28, 47])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">NumPy</span></code> 还为数组操作提供了大量的通用函数，这些函数可以作为 <code class="docutils literal"><span class="pre">math</span></code> 模块中类似函数的替代。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="go">array([ 1. , 1.41421356, 1.73205081, 2. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="go">array([ 0.54030231, -0.41614684, -0.9899925 , -0.65364362])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用这些通用函数要比循环数组并使用 <code class="docutils literal"><span class="pre">math</span></code> 模块中的函数执行计算要快的多。
因此，只要有可能的话尽量选择 <code class="docutils literal"><span class="pre">NumPy</span></code> 的数组方案。</p>
<p>底层实现中， <code class="docutils literal"><span class="pre">NumPy</span></code> 数组使用了C或者Fortran语言的机制分配内存。
也就是说，它们是一个非常大的连续的并由同类型数据组成的内存区域。
所以，你可以构造一个比普通Python列表大的多的数组。
比如，如果你想构造一个10,000*10,000的浮点数二维网格，很轻松：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mi">10000</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span>
<span class="go">    array([[ 0., 0., 0., ..., 0., 0., 0.],</span>
<span class="go">    [ 0., 0., 0., ..., 0., 0., 0.],</span>
<span class="go">    [ 0., 0., 0., ..., 0., 0., 0.],</span>
<span class="go">    ...,</span>
<span class="go">    [ 0., 0., 0., ..., 0., 0., 0.],</span>
<span class="go">    [ 0., 0., 0., ..., 0., 0., 0.],</span>
<span class="go">    [ 0., 0., 0., ..., 0., 0., 0.]])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>所有的普通操作还是会同时作用在所有元素上：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">+=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span>
<span class="go">array([[ 10., 10., 10., ..., 10., 10., 10.],</span>
<span class="go">    [ 10., 10., 10., ..., 10., 10., 10.],</span>
<span class="go">    [ 10., 10., 10., ..., 10., 10., 10.],</span>
<span class="go">    ...,</span>
<span class="go">    [ 10., 10., 10., ..., 10., 10., 10.],</span>
<span class="go">    [ 10., 10., 10., ..., 10., 10., 10.],</span>
<span class="go">    [ 10., 10., 10., ..., 10., 10., 10.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
<span class="go">array([[-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,</span>
<span class="go">        -0.54402111, -0.54402111],</span>
<span class="go">    [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,</span>
<span class="go">        -0.54402111, -0.54402111],</span>
<span class="go">    [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,</span>
<span class="go">        -0.54402111, -0.54402111],</span>
<span class="go">    ...,</span>
<span class="go">    [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,</span>
<span class="go">        -0.54402111, -0.54402111],</span>
<span class="go">    [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,</span>
<span class="go">        -0.54402111, -0.54402111],</span>
<span class="go">    [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,</span>
<span class="go">        -0.54402111, -0.54402111]])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>关于 <code class="docutils literal"><span class="pre">NumPy</span></code> 有一点需要特别的主意，那就是它扩展Python列表的索引功能 - 特别是对于多维数组。
为了说明清楚，先构造一个简单的二维数组并试着做些试验：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 1, 2, 3, 4],</span>
<span class="go">[ 5, 6, 7, 8],</span>
<span class="go">[ 9, 10, 11, 12]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Select row 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([5, 6, 7, 8])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Select column 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([ 2, 6, 10])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Select a subregion and change it</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[ 6, 7],</span>
<span class="go">        [10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 1, 2, 3, 4],</span>
<span class="go">        [ 5, 16, 17, 8],</span>
<span class="go">        [ 9, 20, 21, 12]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Broadcast a row vector across an operation on all rows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">103</span><span class="p">]</span>
<span class="go">array([[101, 103, 105, 107],</span>
<span class="go">        [105, 117, 119, 111],</span>
<span class="go">        [109, 121, 123, 115]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 1, 2, 3, 4],</span>
<span class="go">        [ 5, 16, 17, 8],</span>
<span class="go">        [ 9, 20, 21, 12]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Conditional assignment on an array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([[ 1, 2, 3, 4],</span>
<span class="go">        [ 5, 10, 10, 8],</span>
<span class="go">        [ 9, 10, 10, 10]])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">NumPy</span></code> 是Python领域中很多科学与工程库的基础，同时也是被广泛使用的最大最复杂的模块。
即便如此，在刚开始的时候通过一些简单的例子和玩具程序也能帮我们完成一些有趣的事情。</p>
<p>通常我们导入 <code class="docutils literal"><span class="pre">NumPy</span></code> 模块的时候会使用语句 <code class="docutils literal"><span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></code> 。
这样的话你就不用再你的程序里面一遍遍的敲入 <code class="docutils literal"><span class="pre">numpy</span></code> ，只需要输入 <code class="docutils literal"><span class="pre">np</span></code> 就行了，节省了不少时间。</p>
<p>如果想获取更多的信息，你当然得去 <code class="docutils literal"><span class="pre">NumPy</span></code> 官网逛逛了，网址是： <a class="reference external" href="http://www.numpy.org">http://www.numpy.org</a></p>
</div>
</div>
<span id="document-c03/p10_matrix_and_linear_algebra_calculation"></span><div class="section" id="id1">
<h3>3.10 矩阵与线性代数运算<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要执行矩阵和线性代数运算，比如矩阵乘法、寻找行列式、求解线性方程组等等。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<blockquote>
<div><code class="docutils literal"><span class="pre">NumPy</span></code> 库有一个矩阵对象可以用来解决这个问题。</div></blockquote>
<p>矩阵类似于3.9小节中数组对象，但是遵循线性代数的计算规则。下面的一个例子展示了矩阵的一些基本特性：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[ 1, -2, 3],</span>
<span class="go">        [ 0, 4, 5],</span>
<span class="go">        [ 7, 8, -9]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Return transpose</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">T</span>
<span class="go">matrix([[ 1, 0, 7],</span>
<span class="go">        [-2, 4, 8],</span>
<span class="go">        [ 3, 5, -9]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Return inverse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">I</span>
<span class="go">matrix([[ 0.33043478, -0.02608696, 0.09565217],</span>
<span class="go">        [-0.15217391, 0.13043478, 0.02173913],</span>
<span class="go">        [ 0.12173913, 0.09565217, -0.0173913 ]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a vector and multiply</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span>
<span class="go">matrix([[2],</span>
<span class="go">        [3],</span>
<span class="go">        [4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">*</span> <span class="n">v</span>
<span class="go">matrix([[ 8],</span>
<span class="go">        [32],</span>
<span class="go">        [ 2]])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以在 <code class="docutils literal"><span class="pre">numpy.linalg</span></code> 子包中找到更多的操作函数，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.linalg</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Determinant</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">-229.99999999999983</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Eigenvalues</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([-13.11474312, 2.75956154, 6.35518158])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Solve for x in mx = v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">matrix([[ 0.96521739],</span>
<span class="go">        [ 0.17391304],</span>
<span class="go">        [ 0.46086957]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">*</span> <span class="n">x</span>
<span class="go">matrix([[ 2.],</span>
<span class="go">        [ 3.],</span>
<span class="go">        [ 4.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span>
<span class="go">matrix([[2],</span>
<span class="go">        [3],</span>
<span class="go">        [4]])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>很显然线性代数是个非常大的主题，已经超出了本书能讨论的范围。
但是，如果你需要操作数组和向量的话， <code class="docutils literal"><span class="pre">NumPy</span></code> 是一个不错的入口点。
可以访问 <code class="docutils literal"><span class="pre">NumPy</span></code> 官网 <a class="reference external" href="http://www.numpy.org">http://www.numpy.org</a> 获取更多信息。</p>
</div>
</div>
<span id="document-c03/p11_pick_things_at_random"></span><div class="section" id="id1">
<h3>3.11 随机选择<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想从一个序列中随机抽取若干元素，或者想生成几个随机数。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">random</span></code> 模块有大量的函数用来产生随机数和随机选择元素。
比如，要想从一个序列中随机的抽取一个元素，可以使用 <code class="docutils literal"><span class="pre">random.choice()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">6</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了提取出N个不同元素的样本用来做进一步的操作，可以使用 <code class="docutils literal"><span class="pre">random.sample()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[6, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[4, 3, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[5, 4, 1]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你仅仅只是想打乱序列中元素的顺序，可以使用 <code class="docutils literal"><span class="pre">random.shuffle()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span>
<span class="go">[2, 4, 6, 5, 3, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span>
<span class="go">[3, 5, 2, 1, 6, 4]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>生成随机整数，请使用 <code class="docutils literal"><span class="pre">random.randint()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了生成0到1范围内均匀分布的浮点数，使用 <code class="docutils literal"><span class="pre">random.random()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
<span class="go">0.9406677561675867</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
<span class="go">0.133129581343897</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
<span class="go">0.4144991136919316</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果要获取N位随机位(二进制)的整数，使用 <code class="docutils literal"><span class="pre">random.getrandbits()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="go">335837000776573622800628485064121869519521710558559406913275</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">random</span></code> 模块使用 <em>Mersenne Twister</em> 算法来计算生成随机数。这是一个确定性算法，
但是你可以通过 <code class="docutils literal"><span class="pre">random.seed()</span></code> 函数修改初始化种子。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">()</span> <span class="c1"># Seed based on system time or os.urandom()</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span> <span class="c1"># Seed based on integer given</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;bytedata&#39;</span><span class="p">)</span> <span class="c1"># Seed based on byte data</span>
</pre></div>
</div>
<p>除了上述介绍的功能，random模块还包含基于均匀分布、高斯分布和其他分布的随机数生成函数。
比如， <code class="docutils literal"><span class="pre">random.uniform()</span></code> 计算均匀分布随机数， <code class="docutils literal"><span class="pre">random.gauss()</span></code> 计算正态分布随机数。
对于其他的分布情况请参考在线文档。</p>
<p>在 <code class="docutils literal"><span class="pre">random</span></code> 模块中的函数不应该用在和密码学相关的程序中。
如果你确实需要类似的功能，可以使用ssl模块中相应的函数。
比如， <code class="docutils literal"><span class="pre">ssl.RAND_bytes()</span></code> 可以用来生成一个安全的随机字节序列。</p>
</div>
</div>
<span id="document-c03/p12_convert_days_to_seconds_and_others"></span><div class="section" id="id1">
<h3>3.12 基本的日期与时间转换<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要执行简单的时间转换，比如天到秒，小时到分钟等的转换。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了执行不同时间单位的转换和计算，请使用 <code class="docutils literal"><span class="pre">datetime</span></code> 模块。
比如，为了表示一个时间段，可以创建一个 <code class="docutils literal"><span class="pre">timedelta</span></code> 实例，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">hours</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">days</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">seconds</span>
<span class="go">37800</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">seconds</span> <span class="o">/</span> <span class="mi">3600</span>
<span class="go">10.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3600</span>
<span class="go">58.5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想表示指定的日期和时间，先创建一个 <code class="docutils literal"><span class="pre">datetime</span></code> 实例然后使用标准的数学运算来操作它们。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="go">2012-10-03 00:00:00</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">days</span>
<span class="go">89</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
<span class="go">2012-12-21 14:54:43.094063</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">now</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="go">2012-12-21 15:04:43.094063</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在计算的时候，需要注意的是 <code class="docutils literal"><span class="pre">datetime</span></code> 会自动处理闰年。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">datetime.timedelta(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">days</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">days</span>
<span class="go">1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>对大多数基本的日期和时间处理问题， <code class="docutils literal"><span class="pre">datetime</span></code> 模块已经足够了。
如果你需要执行更加复杂的日期操作，比如处理时区，模糊时间范围，节假日计算等等，
可以考虑使用 <a class="reference external" href="http://pypi.python.org/pypi/python-dateutil">dateutil模块</a></p>
<p>许多类似的时间计算可以使用 <code class="docutils literal"><span class="pre">dateutil.relativedelta()</span></code> 函数代替。
但是，有一点需要注意的就是，它会在处理月份(还有它们的天数差距)的时候填充间隙。看例子最清楚：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; a = datetime(2012, 9, 23)
&gt;&gt;&gt; a + timedelta(months=1)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;months&#39; is an invalid keyword argument for this function
&gt;&gt;&gt;
&gt;&gt;&gt; from dateutil.relativedelta import relativedelta
&gt;&gt;&gt; a + relativedelta(months=+1)
datetime.datetime(2012, 10, 23, 0, 0)
&gt;&gt;&gt; a + relativedelta(months=+4)
datetime.datetime(2013, 1, 23, 0, 0)
&gt;&gt;&gt;
&gt;&gt;&gt; # Time between two dates
&gt;&gt;&gt; b = datetime(2012, 12, 21)
&gt;&gt;&gt; d = b - a
&gt;&gt;&gt; d
datetime.timedelta(89)
&gt;&gt;&gt; d = relativedelta(b, a)
&gt;&gt;&gt; d
relativedelta(months=+2, days=+28)
&gt;&gt;&gt; d.months
2
&gt;&gt;&gt; d.days
28
&gt;&gt;&gt;
</pre></div>
</div>
</div>
</div>
<span id="document-c03/p13_determine_last_friday_date"></span><div class="section" id="id1">
<h3>3.13 计算最后一个周五的日期<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要查找星期中某一天最后出现的日期，比如星期五。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python的 <code class="docutils literal"><span class="pre">datetime</span></code> 模块中有工具函数和类可以帮助你执行这样的计算。
下面是对类似这样的问题的一个通用解决方案：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- encoding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Topic: 最后的周五</span>
<span class="sd">Desc :</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

<span class="n">weekdays</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Monday&#39;</span><span class="p">,</span> <span class="s1">&#39;Tuesday&#39;</span><span class="p">,</span> <span class="s1">&#39;Wednesday&#39;</span><span class="p">,</span> <span class="s1">&#39;Thursday&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Friday&#39;</span><span class="p">,</span> <span class="s1">&#39;Saturday&#39;</span><span class="p">,</span> <span class="s1">&#39;Sunday&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">get_previous_byday</span><span class="p">(</span><span class="n">dayname</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
    <span class="n">day_num</span> <span class="o">=</span> <span class="n">start_date</span><span class="o">.</span><span class="n">weekday</span><span class="p">()</span>
    <span class="n">day_num_target</span> <span class="o">=</span> <span class="n">weekdays</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dayname</span><span class="p">)</span>
    <span class="n">days_ago</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span> <span class="o">+</span> <span class="n">day_num</span> <span class="o">-</span> <span class="n">day_num_target</span><span class="p">)</span> <span class="o">%</span> <span class="mi">7</span>
    <span class="k">if</span> <span class="n">days_ago</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">days_ago</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">target_date</span> <span class="o">=</span> <span class="n">start_date</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">days_ago</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">target_date</span>
</pre></div>
</div>
<p>在交互式解释器中使用如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span> <span class="c1"># For reference</span>
<span class="go">datetime.datetime(2012, 8, 28, 22, 4, 30, 263076)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_previous_byday</span><span class="p">(</span><span class="s1">&#39;Monday&#39;</span><span class="p">)</span>
<span class="go">datetime.datetime(2012, 8, 27, 22, 3, 57, 29045)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_previous_byday</span><span class="p">(</span><span class="s1">&#39;Tuesday&#39;</span><span class="p">)</span> <span class="c1"># Previous week, not today</span>
<span class="go">datetime.datetime(2012, 8, 21, 22, 4, 12, 629771)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_previous_byday</span><span class="p">(</span><span class="s1">&#39;Friday&#39;</span><span class="p">)</span>
<span class="go">datetime.datetime(2012, 8, 24, 22, 5, 9, 911393)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可选的 <code class="docutils literal"><span class="pre">start_date</span></code> 参数可以由另外一个 <code class="docutils literal"><span class="pre">datetime</span></code> 实例来提供。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_previous_byday</span><span class="p">(</span><span class="s1">&#39;Sunday&#39;</span><span class="p">,</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
<span class="go">datetime.datetime(2012, 12, 16, 0, 0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>上面的算法原理是这样的：先将开始日期和目标日期映射到星期数组的位置上(星期一索引为0)，
然后通过模运算计算出目标日期要经过多少天才能到达开始日期。然后用开始日期减去那个时间差即得到结果日期。</p>
<p>如果你要像这样执行大量的日期计算的话，你最好安装第三方包 <code class="docutils literal"><span class="pre">python-dateutil</span></code> 来代替。
比如，下面是是使用 <code class="docutils literal"><span class="pre">dateutil</span></code> 模块中的 <code class="docutils literal"><span class="pre">relativedelta()</span></code> 函数执行同样的计算：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dateutil.relativedelta</span> <span class="kn">import</span> <span class="n">relativedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dateutil.rrule</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">2012-12-23 16:31:52.718111</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Next Friday</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">weekday</span><span class="o">=</span><span class="n">FR</span><span class="p">))</span>
<span class="go">2012-12-28 16:31:52.718111</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Last Friday</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">weekday</span><span class="o">=</span><span class="n">FR</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
<span class="go">2012-12-21 16:31:52.718111</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c03/p14_date_range_for_current_month"></span><div class="section" id="id1">
<h3>3.14 计算当前月份的日期范围<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的代码需要在当前月份中循环每一天，想找到一个计算这个日期范围的高效方法。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在这样的日期上循环并需要事先构造一个包含所有日期的列表。
你可以先计算出开始日期和结束日期，
然后在你步进的时候使用 <code class="docutils literal"><span class="pre">datetime.timedelta</span></code> 对象递增这个日期变量即可。</p>
<p>下面是一个接受任意 <code class="docutils literal"><span class="pre">datetime</span></code> 对象并返回一个由当前月份开始日和下个月开始日组成的元组对象。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">import</span> <span class="nn">calendar</span>

<span class="k">def</span> <span class="nf">get_month_range</span><span class="p">(</span><span class="n">start_date</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">days_in_month</span> <span class="o">=</span> <span class="n">calendar</span><span class="o">.</span><span class="n">monthrange</span><span class="p">(</span><span class="n">start_date</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">start_date</span><span class="o">.</span><span class="n">month</span><span class="p">)</span>
    <span class="n">end_date</span> <span class="o">=</span> <span class="n">start_date</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">days_in_month</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">)</span>
</pre></div>
</div>
<p>有了这个就可以很容易的在返回的日期范围上面做循环操作了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_day</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first_day</span><span class="p">,</span> <span class="n">last_day</span> <span class="o">=</span> <span class="n">get_month_range</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">first_day</span> <span class="o">&lt;</span> <span class="n">last_day</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">first_day</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">first_day</span> <span class="o">+=</span> <span class="n">a_day</span>
<span class="gp">...</span>
<span class="go">2012-08-01</span>
<span class="go">2012-08-02</span>
<span class="go">2012-08-03</span>
<span class="go">2012-08-04</span>
<span class="go">2012-08-05</span>
<span class="go">2012-08-06</span>
<span class="go">2012-08-07</span>
<span class="go">2012-08-08</span>
<span class="go">2012-08-09</span>
<span class="go">#... and so on...</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>上面的代码先计算出一个对应月份第一天的日期。
一个快速的方法就是使用 <code class="docutils literal"><span class="pre">date</span></code> 或 <code class="docutils literal"><span class="pre">datetime</span></code> 对象的 <code class="docutils literal"><span class="pre">replace()</span></code> 方法简单的将 <code class="docutils literal"><span class="pre">days</span></code> 属性设置成1即可。
<code class="docutils literal"><span class="pre">replace()</span></code> 方法一个好处就是它会创建和你开始传入对象类型相同的对象。
所以，如果输入参数是一个 <code class="docutils literal"><span class="pre">date</span></code> 实例，那么结果也是一个 <code class="docutils literal"><span class="pre">date</span></code> 实例。
同样的，如果输入是一个 <code class="docutils literal"><span class="pre">datetime</span></code> 实例，那么你得到的就是一个 <code class="docutils literal"><span class="pre">datetime</span></code> 实例。</p>
<p>然后，使用 <code class="docutils literal"><span class="pre">calendar.monthrange()</span></code> 函数来找出该月的总天数。
任何时候只要你想获得日历信息，那么 <code class="docutils literal"><span class="pre">calendar</span></code> 模块就非常有用了。
<code class="docutils literal"><span class="pre">monthrange()</span></code> 函数会返回包含星期和该月天数的元组。</p>
<p>一旦该月的天数已知了，那么结束日期就可以通过在开始日期上面加上这个天数获得。
有个需要注意的是结束日期并不包含在这个日期范围内(事实上它是下个月的开始日期)。
这个和Python的 <code class="docutils literal"><span class="pre">slice</span></code> 与 <code class="docutils literal"><span class="pre">range</span></code> 操作行为保持一致，同样也不包含结尾。</p>
<p>为了在日期范围上循环，要使用到标准的数学和比较操作。
比如，可以利用 <code class="docutils literal"><span class="pre">timedelta</span></code> 实例来递增日期，小于号&lt;用来检查一个日期是否在结束日期之前。</p>
<p>理想情况下，如果能为日期迭代创建一个同内置的 <code class="docutils literal"><span class="pre">range()</span></code> 函数一样的函数就好了。
幸运的是，可以使用一个生成器来很容易的实现这个目标：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">date_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">step</span>
</pre></div>
</div>
<p>下面是使用这个生成器的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">date_range</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
<span class="go">                        timedelta(hours=6)):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">2012-09-01 00:00:00</span>
<span class="go">2012-09-01 06:00:00</span>
<span class="go">2012-09-01 12:00:00</span>
<span class="go">2012-09-01 18:00:00</span>
<span class="go">2012-09-02 00:00:00</span>
<span class="go">2012-09-02 06:00:00</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种实现之所以这么简单，还得归功于Python中的日期和时间能够使用标准的数学和比较操作符来进行运算。</p>
</div>
</div>
<span id="document-c03/p15_convert_strings_into_datetimes"></span><div class="section" id="id1">
<h3>3.15 字符串转换为日期<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的应用程序接受字符串格式的输入，但是你想将它们转换为 <code class="docutils literal"><span class="pre">datetime</span></code> 对象以便在上面执行非字符串操作。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用Python的标准模块 <code class="docutils literal"><span class="pre">datetime</span></code> 可以很容易的解决这个问题。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;2012-09-20&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span>
<span class="go">datetime.timedelta(3, 77824, 177393)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">datetime.strptime()</span></code> 方法支持很多的格式化代码，
比如 <code class="docutils literal"><span class="pre">%Y</span></code> 代表4位数年份， <code class="docutils literal"><span class="pre">%m</span></code> 代表两位数月份。
还有一点值得注意的是这些格式化占位符也可以反过来使用，将日期输出为指定的格式字符串形式。</p>
<p>比如，假设你的代码中生成了一个 <code class="docutils literal"><span class="pre">datetime</span></code> 对象，
你想将它格式化为漂亮易读形式后放在自动生成的信件或者报告的顶部：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span>
<span class="go">datetime.datetime(2012, 9, 23, 21, 37, 4, 177393)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nice_z</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="s1">&#39;%A %B </span><span class="si">%d</span><span class="s1">, %Y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nice_z</span>
<span class="go">&#39;Sunday September 23, 2012&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>还有一点需要注意的是， <code class="docutils literal"><span class="pre">strptime()</span></code> 的性能要比你想象中的差很多，
因为它是使用纯Python实现，并且必须处理所有的系统本地设置。
如果你要在代码中需要解析大量的日期并且已经知道了日期字符串的确切格式，可以自己实现一套解析方案来获取更好的性能。
比如，如果你已经知道所以日期格式是 <code class="docutils literal"><span class="pre">YYYY-MM-DD</span></code> ，你可以像下面这样实现一个解析函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="k">def</span> <span class="nf">parse_ymd</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">year_s</span><span class="p">,</span> <span class="n">mon_s</span><span class="p">,</span> <span class="n">day_s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">year_s</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mon_s</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">day_s</span><span class="p">))</span>
</pre></div>
</div>
<p>实际测试中，这个函数比 <code class="docutils literal"><span class="pre">datetime.strptime()</span></code> 快7倍多。
如果你要处理大量的涉及到日期的数据的话，那么最好考虑下这个方案！</p>
</div>
</div>
<span id="document-c03/p16_manipulate_dates_involving_timezone"></span><div class="section" id="id1">
<h3>3.16 结合时区的日期操作<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个安排在2012年12月21日早上9:30的电话会议，地点在芝加哥。
而你的朋友在印度的班加罗尔，那么他应该在当地时间几点参加这个会议呢？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对几乎所有涉及到时区的问题，你都应该使用 <code class="docutils literal"><span class="pre">pytz</span></code> 模块。这个包提供了Olson时区数据库，
它是时区信息的事实上的标准，在很多语言和操作系统里面都可以找到。</p>
<p><code class="docutils literal"><span class="pre">pytz</span></code> 模块一个主要用途是将 <code class="docutils literal"><span class="pre">datetime</span></code> 库创建的简单日期对象本地化。
比如，下面如何表示一个芝加哥时间的示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pytz</span> <span class="kn">import</span> <span class="n">timezone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">2012-12-21 09:30:00</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Localize the date for Chicago</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">central</span> <span class="o">=</span> <span class="n">timezone</span><span class="p">(</span><span class="s1">&#39;US/Central&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc_d</span> <span class="o">=</span> <span class="n">central</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">loc_d</span><span class="p">)</span>
<span class="go">2012-12-21 09:30:00-06:00</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一旦日期被本地化了， 它就可以转换为其他时区的时间了。
为了得到班加罗尔对应的时间，你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Convert to Bangalore time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bang_d</span> <span class="o">=</span> <span class="n">loc_d</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">timezone</span><span class="p">(</span><span class="s1">&#39;Asia/Kolkata&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">bang_d</span><span class="p">)</span>
<span class="go">2012-12-21 21:00:00+05:30</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你打算在本地化日期上执行计算，你需要特别注意夏令时转换和其他细节。
比如，在2013年，美国标准夏令时时间开始于本地时间3月13日凌晨2:00(在那时，时间向前跳过一小时)。
如果你正在执行本地计算，你会得到一个错误。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc_d</span> <span class="o">=</span> <span class="n">central</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">loc_d</span><span class="p">)</span>
<span class="go">2013-03-10 01:45:00-06:00</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">later</span> <span class="o">=</span> <span class="n">loc_d</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">later</span><span class="p">)</span>
<span class="go">2013-03-10 02:15:00-06:00 # WRONG! WRONG!</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>结果错误是因为它并没有考虑在本地时间中有一小时的跳跃。
为了修正这个错误，可以使用时区对象 <code class="docutils literal"><span class="pre">normalize()</span></code> 方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">later</span> <span class="o">=</span> <span class="n">central</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">loc_d</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">30</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">later</span><span class="p">)</span>
<span class="go">2013-03-10 03:15:00-05:00</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>为了不让你被这些东东弄的晕头转向，处理本地化日期的通常的策略先将所有日期转换为UTC时间，
并用它来执行所有的中间存储和操作。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">loc_d</span><span class="p">)</span>
<span class="go">2013-03-10 01:45:00-06:00</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">utc_d</span> <span class="o">=</span> <span class="n">loc_d</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">utc_d</span><span class="p">)</span>
<span class="go">2013-03-10 07:45:00+00:00</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一旦转换为UTC，你就不用去担心跟夏令时相关的问题了。
因此，你可以跟之前一样放心的执行常见的日期计算。
当你想将输出变为本地时间的时候，使用合适的时区去转换下就行了。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">later_utc</span> <span class="o">=</span> <span class="n">utc_d</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">later_utc</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">central</span><span class="p">))</span>
<span class="go">2013-03-10 03:15:00-05:00</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当涉及到时区操作的时候，有个问题就是我们如何得到时区的名称。
比如，在这个例子中，我们如何知道“Asia/Kolkata”就是印度对应的时区名呢？
为了查找，可以使用ISO 3166国家代码作为关键字去查阅字典 <code class="docutils literal"><span class="pre">pytz.country_timezones</span></code> 。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pytz</span><span class="o">.</span><span class="n">country_timezones</span><span class="p">[</span><span class="s1">&#39;IN&#39;</span><span class="p">]</span>
<span class="go">[&#39;Asia/Kolkata&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注：当你阅读到这里的时候，有可能 <code class="docutils literal"><span class="pre">pytz</span></code> 模块已经不再建议使用了，因为PEP431提出了更先进的时区支持。
但是这里谈到的很多问题还是有参考价值的(比如使用UTC日期的建议等)。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p04_iterators_and_generators"></span><div class="section" id="id1">
<h2>第四章：迭代器与生成器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>迭代是Python最强大的功能之一。初看起来，你可能会简单的认为迭代只不过是处理序列中元素的一种方法。
然而，绝非仅仅就是如此，还有很多你可能不知道的，
比如创建你自己的迭代器对象，在itertools模块中使用有用的迭代模式，构造生成器函数等等。
这一章目的就是向你展示跟迭代有关的各种常见问题。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c04/p01_manually_consuming_iterator"></span><div class="section" id="id1">
<h3>4.1 手动遍历迭代器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想遍历一个可迭代对象中的所有元素，但是却不想使用for循环。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了手动的遍历可迭代对象，使用 <code class="docutils literal"><span class="pre">next()</span></code> 函数并在代码中捕获 <code class="docutils literal"><span class="pre">StopIteration</span></code> 异常。
比如，下面的例子手动读取一个文件中的所有行：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">manual_iter</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
<p>通常来讲， <code class="docutils literal"><span class="pre">StopIteration</span></code> 用来指示迭代的结尾。
然而，如果你手动使用上面演示的 <code class="docutils literal"><span class="pre">next()</span></code> 函数的话，你还可以通过返回一个指定值来标记结尾，比如 <code class="docutils literal"><span class="pre">None</span></code> 。
下面是示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>大多数情况下，我们会使用 <code class="docutils literal"><span class="pre">for</span></code> 循环语句用来遍历一个可迭代对象。
但是，偶尔也需要对迭代做更加精确的控制，这时候了解底层迭代机制就显得尤为重要了。</p>
<p>下面的交互示例向我们演示了迭代期间所发生的基本细节：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="c1"># Invokes items.__iter__()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Run the iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="c1"># Invokes it.__next__()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">StopIteration</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>本章接下来几小节会更深入的讲解迭代相关技术，前提是你先要理解基本的迭代协议机制。
所以确保你已经把这章的内容牢牢记在心中。</p>
</div>
</div>
<span id="document-c04/p02_delegating_iteration"></span><div class="section" id="id1">
<h3>4.2 代理迭代<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你构建了一个自定义容器对象，里面包含有列表、元组或其他可迭代对象。
你想直接在你的这个新容器对象上执行迭代操作。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>实际上你只需要定义一个 <code class="docutils literal"><span class="pre">__iter__()</span></code> 方法，将迭代操作代理到容器内部的对象上去。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Node({!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>

<span class="c1"># Example</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">child1</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">child2</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
    <span class="c1"># Outputs Node(1), Node(2)</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
</pre></div>
</div>
<p>在上面代码中， <code class="docutils literal"><span class="pre">__iter__()</span></code> 方法只是简单的将迭代请求传递给内部的 <code class="docutils literal"><span class="pre">_children</span></code> 属性。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>Python的迭代器协议需要 <code class="docutils literal"><span class="pre">__iter__()</span></code> 方法返回一个实现了 <code class="docutils literal"><span class="pre">__next__()</span></code> 方法的迭代器对象。
如果你只是迭代遍历其他容器的内容，你无须担心底层是怎样实现的。你所要做的只是传递迭代请求既可。</p>
<p>这里的 <code class="docutils literal"><span class="pre">iter()</span></code> 函数的使用简化了代码，
<code class="docutils literal"><span class="pre">iter(s)</span></code> 只是简单的通过调用 <code class="docutils literal"><span class="pre">s.__iter__()</span></code> 方法来返回对应的迭代器对象，
就跟 <code class="docutils literal"><span class="pre">len(s)</span></code> 会调用 <code class="docutils literal"><span class="pre">s.__len__()</span></code> 原理是一样的。</p>
</div>
</div>
<span id="document-c04/p03_create_new_iteration_with_generators"></span><div class="section" id="id1">
<h3>4.3 使用生成器创建新的迭代模式<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想实现一个自定义迭代模式，跟普通的内置函数比如 <code class="docutils literal"><span class="pre">range()</span></code> , <code class="docutils literal"><span class="pre">reversed()</span></code> 不一样。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想实现一种新的迭代模式，使用一个生成器函数来定义它。
下面是一个生产某个范围内浮点数的生成器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">frange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">increment</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">increment</span>
</pre></div>
</div>
<p>为了使用这个函数，
你可以用for循环迭代它或者使用其他接受一个可迭代对象的函数(比如 <code class="docutils literal"><span class="pre">sum()</span></code> , <code class="docutils literal"><span class="pre">list()</span></code> 等)。示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">0.5</span>
<span class="go">1.0</span>
<span class="go">1.5</span>
<span class="go">2.0</span>
<span class="go">2.5</span>
<span class="go">3.0</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">frange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">))</span>
<span class="go">[0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>一个函数中需要有一个 <code class="docutils literal"><span class="pre">yield</span></code> 语句即可将其转换为一个生成器。
跟普通函数不同的是，生成器只能用于迭代操作。
下面是一个实验，向你展示这样的函数底层工作机制：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Starting to count from&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">n</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Done!&#39;</span><span class="p">)</span>
<span class="gp">...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create the generator, notice no output appears</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">&lt;generator object countdown at 0x1006a0af0&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Run to first yield and emit a value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">Starting to count from 3</span>
<span class="go">3</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Run to the next yield</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">2</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Run to next yield</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Run to next yield (iteration stops)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">Done!</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">StopIteration</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一个生成器函数主要特征是它只会回应在迭代中使用到的 <em>next</em> 操作。
一旦生成器函数返回退出，迭代终止。我们在迭代中通常使用的for语句会自动处理这些细节，所以你无需担心。</p>
</div>
</div>
<span id="document-c04/p04_implement_iterator_protocol"></span><div class="section" id="id1">
<h3>4.4 实现迭代器协议<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想构建一个能支持迭代操作的自定义对象，并希望找到一个能实现迭代协议的简单方法。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>目前为止，在一个对象上实现迭代最简单的方式是使用一个生成器函数。
在4.2小节中，使用Node类来表示树形数据结构。你可能想实现一个以深度优先方式遍历树形节点的生成器。
下面是代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Node({!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">depth_first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">c</span><span class="o">.</span><span class="n">depth_first</span><span class="p">()</span>

<span class="c1"># Example</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">child1</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">child2</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
    <span class="n">child1</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">child1</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">child2</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">depth_first</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
    <span class="c1"># Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)</span>
</pre></div>
</div>
<p>在这段代码中，<code class="docutils literal"><span class="pre">depth_first()</span></code> 方法简单直观。
它首先返回自己本身并迭代每一个子节点并
通过调用子节点的 <code class="docutils literal"><span class="pre">depth_first()</span></code> 方法(使用 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 语句)返回对应元素。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>Python的迭代协议要求一个 <code class="docutils literal"><span class="pre">__iter__()</span></code> 方法返回一个特殊的迭代器对象，
这个迭代器对象实现了 <code class="docutils literal"><span class="pre">__next__()</span></code> 方法并通过 <code class="docutils literal"><span class="pre">StopIteration</span></code> 异常标识迭代的完成。
但是，实现这些通常会比较繁琐。
下面我们演示下这种方式，如何使用一个关联迭代器类重新实现 <code class="docutils literal"><span class="pre">depth_first()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node2</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Node({!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">depth_first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DepthFirstIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DepthFirstIterator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Depth-first traversal</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node</span> <span class="o">=</span> <span class="n">start_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children_iter</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_child_iter</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Return myself if just started; create an iterator for children</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children_iter</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node</span>
        <span class="c1"># If processing a child, return its next item</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_iter</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nextchild</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_iter</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">nextchild</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_child_iter</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Advance to the next child and start its iteration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_child_iter</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children_iter</span><span class="p">)</span><span class="o">.</span><span class="n">depth_first</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">DepthFirstIterator</span></code> 类和上面使用生成器的版本工作原理类似，
但是它写起来很繁琐，因为迭代器必须在迭代处理过程中维护大量的状态信息。
坦白来讲，没人愿意写这么晦涩的代码。将你的迭代器定义为一个生成器后一切迎刃而解。</p>
</div>
</div>
<span id="document-c04/p05_iterating_in_reverse"></span><div class="section" id="id1">
<h3>4.5 反向迭代<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想反方向迭代一个序列</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用内置的 <code class="docutils literal"><span class="pre">reversed()</span></code> 函数，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">4</span>
<span class="go">3</span>
<span class="go">2</span>
<span class="go">1</span>
</pre></div>
</div>
<p>反向迭代仅仅当对象的大小可预先确定或者对象实现了 <code class="docutils literal"><span class="pre">__reversed__()</span></code> 的特殊方法时才能生效。
如果两者都不符合，那你必须先将对象转换为一个列表才行，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Print a file backwards</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>要注意的是如果可迭代对象元素很多的话，将其预先转换为一个列表要消耗大量的内存。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>很多程序员并不知道可以通过在自定义类上实现 <code class="docutils literal"><span class="pre">__reversed__()</span></code> 方法来实现反向迭代。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Countdown</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>

    <span class="c1"># Forward iterator</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">n</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Reverse iterator</span>
    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">n</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">Countdown</span><span class="p">(</span><span class="mi">30</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span>
<span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="n">Countdown</span><span class="p">(</span><span class="mi">30</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span>
</pre></div>
</div>
<p>定义一个反向迭代器可以使得代码非常的高效，
因为它不再需要将数据填充到一个列表中然后再去反向迭代这个列表。</p>
</div>
</div>
<span id="document-c04/p06_define_generator_func_with_extra_state"></span><div class="section" id="id1">
<h3>4.6 带有外部状态的生成器函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想定义一个生成器函数，但是它会调用某个你想暴露给用户使用的外部状态值。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想让你的生成器暴露外部状态给用户，
别忘了你可以简单的将它实现为一个类，然后把生成器函数放到 <code class="docutils literal"><span class="pre">__iter__()</span></code> 方法中过去。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">linehistory</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">histlen</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">histlen</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lineno</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">line</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>为了使用这个类，你可以将它当做是一个普通的生成器函数。
然而，由于可以创建一个实例对象，于是你可以访问内部属性值，
比如 <code class="docutils literal"><span class="pre">history</span></code> 属性或者是 <code class="docutils literal"><span class="pre">clear()</span></code> 方法。代码示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">linehistory</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;python&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">hline</span> <span class="ow">in</span> <span class="n">lines</span><span class="o">.</span><span class="n">history</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{}:{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lineno</span><span class="p">,</span> <span class="n">hline</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>关于生成器，很容易掉进函数无所不能的陷阱。
如果生成器函数需要跟你的程序其他部分打交道的话(比如暴露属性值，允许通过方法调用来控制等等)，
可能会导致你的代码异常的复杂。
如果是这种情况的话，可以考虑使用上面介绍的定义类的方式。
在 <code class="docutils literal"><span class="pre">__iter__()</span></code> 方法中定义你的生成器不会改变你任何的算法逻辑。
由于它是类的一部分，所以允许你定义各种属性和方法来供用户使用。</p>
<p>一个需要注意的小地方是，如果你在迭代操作时不使用for循环语句，那么你得先调用 <code class="docutils literal"><span class="pre">iter()</span></code> 函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="n">linehistory</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;linehistory&#39; object is not an iterator</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Call iter() first, then start iterating</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;hello world\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;this is a test\n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c04/p07_taking_slice_of_iterator"></span><div class="section" id="id1">
<h3>4.7 迭代器切片<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想得到一个由迭代器生成的切片对象，但是标准切片操作并不能做到。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>函数 <code class="docutils literal"><span class="pre">itertools.islice()</span></code> 正好适用于在迭代器和生成器上做切片操作。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">n</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;generator&#39; object is not subscriptable</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Now using islice()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">10</span>
<span class="go">11</span>
<span class="go">12</span>
<span class="go">13</span>
<span class="go">14</span>
<span class="go">15</span>
<span class="go">16</span>
<span class="go">17</span>
<span class="go">18</span>
<span class="go">19</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引)。
函数 <code class="docutils literal"><span class="pre">islice()</span></code> 返回一个可以生成指定元素的迭代器，它通过遍历并丢弃直到切片开始索引位置的所有元素。
然后才开始一个个的返回元素，并直到切片结束索引位置。</p>
<p>这里要着重强调的一点是 <code class="docutils literal"><span class="pre">islice()</span></code> 会消耗掉传入的迭代器中的数据。
必须考虑到迭代器是不可逆的这个事实。
所以如果你需要之后再次访问这个迭代器的话，那你就得先将它里面的数据放入一个列表中。</p>
</div>
</div>
<span id="document-c04/p08_skip_first_part_of_iterable"></span><div class="section" id="id1">
<h3>4.8 跳过可迭代对象的开始部分<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想遍历一个可迭代对象，但是它开始的某些元素你并不感兴趣，想跳过它们。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">itertools</span></code> 模块中有一些函数可以完成这个任务。
首先介绍的是 <code class="docutils literal"><span class="pre">itertools.dropwhile()</span></code> 函数。使用时，你给它传递一个函数对象和一个可迭代对象。
它会返回一个迭代器对象，丢弃原有序列中直到函数返回Flase之前的所有元素，然后返回后面所有元素。</p>
<p>为了演示，假定你在读取一个开始部分是几行注释的源文件。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">##</span>
<span class="go"># User Database</span>
<span class="go">#</span>
<span class="go"># Note that this file is consulted directly only when the system is running</span>
<span class="go"># in single-user mode. At other times, this information is provided by</span>
<span class="go"># Open Directory.</span>
<span class="gp">...</span>
<span class="go">##</span>
<span class="go">nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false</span>
<span class="go">root:*:0:0:System Administrator:/var/root:/bin/sh</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想跳过开始部分的注释行的话，可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">dropwhile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">dropwhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">),</span> <span class="n">f</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false</span>
<span class="go">root:*:0:0:System Administrator:/var/root:/bin/sh</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这个例子是基于根据某个测试函数跳过开始的元素。
如果你已经明确知道了要跳过的元素的个数的话，那么可以使用 <code class="docutils literal"><span class="pre">itertools.islice()</span></code> 来代替。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">4</span>
<span class="go">10</span>
<span class="go">15</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这个例子中， <code class="docutils literal"><span class="pre">islice()</span></code> 函数最后那个 <code class="docutils literal"><span class="pre">None</span></code> 参数指定了你要获取从第3个到最后的所有元素，
如果 <code class="docutils literal"><span class="pre">None</span></code> 和3的位置对调，意思就是仅仅获取前三个元素恰恰相反，
(这个跟切片的相反操作 <code class="docutils literal"><span class="pre">[3:]</span></code> 和 <code class="docutils literal"><span class="pre">[:3]</span></code> 原理是一样的)。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>函数 <code class="docutils literal"><span class="pre">dropwhile()</span></code> 和 <code class="docutils literal"><span class="pre">islice()</span></code> 其实就是两个帮助函数，为的就是避免写出下面这种冗余代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># Skip over initial comments</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
            <span class="k">break</span>

    <span class="c1"># Process remaining lines</span>
    <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
        <span class="c1"># Replace with useful processing</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>跳过一个可迭代对象的开始部分跟通常的过滤是不同的。
比如，上述代码的第一个部分可能会这样重写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这样写确实可以跳过开始部分的注释行，但是同样也会跳过文件中其他所有的注释行。
换句话讲，我们的解决方案是仅仅跳过开始部分满足测试条件的行，在那以后，所有的元素不再进行测试和过滤了。</p>
<p>最后需要着重强调的一点是，本节的方案适用于所有可迭代对象，包括那些事先不能确定大小的，
比如生成器，文件及其类似的对象。</p>
</div>
</div>
<span id="document-c04/p09_iterate_over_combination_or_permutation"></span><div class="section" id="id1">
<h3>4.9 排列组合的迭代<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想迭代遍历一个集合中元素的所有可能的排列或组合</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>itertools模块提供了三个函数来解决这类问题。
其中一个是 <code class="docutils literal"><span class="pre">itertools.permutations()</span></code> ，
它接受一个集合并产生一个元组序列，每个元组由集合中所有元素的一个可能排列组成。
也就是说通过打乱集合中元素排列顺序生成一个元组，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;a&#39;, &#39;c&#39;, &#39;b&#39;)</span>
<span class="go">(&#39;b&#39;, &#39;a&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;b&#39;, &#39;c&#39;, &#39;a&#39;)</span>
<span class="go">(&#39;c&#39;, &#39;a&#39;, &#39;b&#39;)</span>
<span class="go">(&#39;c&#39;, &#39;b&#39;, &#39;a&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想得到指定长度的所有排列，你可以传递一个可选的长度参数。就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;)</span>
<span class="go">(&#39;a&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;b&#39;, &#39;a&#39;)</span>
<span class="go">(&#39;b&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;c&#39;, &#39;a&#39;)</span>
<span class="go">(&#39;c&#39;, &#39;b&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">itertools.combinations()</span></code> 可得到输入集合中元素的所有的组合。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;)</span>
<span class="go">(&#39;a&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;b&#39;, &#39;c&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;a&#39;,)</span>
<span class="go">(&#39;b&#39;,)</span>
<span class="go">(&#39;c&#39;,)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于 <code class="docutils literal"><span class="pre">combinations()</span></code> 来讲，元素的顺序已经不重要了。
也就是说，组合 <code class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b')</span></code> 跟 <code class="docutils literal"><span class="pre">('b',</span> <span class="pre">'a')</span></code> 其实是一样的(最终只会输出其中一个)。</p>
<p>在计算组合的时候，一旦元素被选取就会从候选中剔除掉(比如如果元素&#8217;a&#8217;已经被选取了，那么接下来就不会再考虑它了)。
而函数 <code class="docutils literal"><span class="pre">itertools.combinations_with_replacement()</span></code> 允许同一个元素被选择多次，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;a&#39;, &#39;a&#39;, &#39;a&#39;)</span>
<span class="go">(&#39;a&#39;, &#39;a&#39;, &#39;b&#39;)</span>
<span class="go">(&#39;a&#39;, &#39;a&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;, &#39;b&#39;)</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;a&#39;, &#39;c&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;b&#39;, &#39;b&#39;, &#39;b&#39;)</span>
<span class="go">(&#39;b&#39;, &#39;b&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;b&#39;, &#39;c&#39;, &#39;c&#39;)</span>
<span class="go">(&#39;c&#39;, &#39;c&#39;, &#39;c&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一小节我们向你展示的仅仅是 <code class="docutils literal"><span class="pre">itertools</span></code> 模块的一部分功能。
尽管你也可以自己手动实现排列组合算法，但是这样做得要花点脑力。
当我们碰到看上去有些复杂的迭代问题时，最好可以先去看看itertools模块。
如果这个问题很普遍，那么很有可能会在里面找到解决方案！</p>
</div>
</div>
<span id="document-c04/p10_iterate_over_index_value_pairs_of_sequence"></span><div class="section" id="id1">
<h3>4.10 序列上索引值迭代<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在迭代一个序列的同时跟踪正在被处理的元素索引。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>内置的 <code class="docutils literal"><span class="pre">enumerate()</span></code> 函数可以很好的解决这个问题：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">my_list</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 a</span>
<span class="go">1 b</span>
<span class="go">2 c</span>
</pre></div>
</div>
<p>为了按传统行号输出(行号从1开始)，你可以传递一个开始参数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">my_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 a</span>
<span class="go">2 b</span>
<span class="go">3 c</span>
</pre></div>
</div>
<p>这种情况在你遍历文件时想在错误消息中使用行号定位时候非常有用：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_data</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="o">...</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Line {}: Parse error: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lineno</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">enumerate()</span></code> 对于跟踪某些值在列表中出现的位置是很有用的。
所以，如果你想将一个文件中出现的单词映射到它出现的行号上去，可以很容易的利用 <code class="docutils literal"><span class="pre">enumerate()</span></code> 来完成：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">word_summary</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;myfile.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
    <span class="c1"># Create a list of words in current line</span>
    <span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">word_summary</span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你处理完文件后打印 <code class="docutils literal"><span class="pre">word_summary</span></code> ，会发现它是一个字典(准确来讲是一个 <code class="docutils literal"><span class="pre">defaultdict</span></code> )，
对于每个单词有一个 <code class="docutils literal"><span class="pre">key</span></code> ，每个 <code class="docutils literal"><span class="pre">key</span></code> 对应的值是一个由这个单词出现的行号组成的列表。
如果某个单词在一行中出现过两次，那么这个行号也会出现两次，
同时也可以作为文本的一个简单统计。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>当你想额外定义一个计数变量的时候，使用 <code class="docutils literal"><span class="pre">enumerate()</span></code> 函数会更加简单。你可能会像下面这样写代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># Process line</span>
    <span class="o">...</span>
    <span class="n">lineno</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>但是如果使用 <code class="docutils literal"><span class="pre">enumerate()</span></code> 函数来代替就显得更加优雅了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="c1"># Process line</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">enumerate()</span></code> 函数返回的是一个 <code class="docutils literal"><span class="pre">enumerate</span></code> 对象实例，
它是一个迭代器，返回连续的包含一个计数和一个值的元组，
元组中的值通过在传入序列上调用 <code class="docutils literal"><span class="pre">next()</span></code> 返回。</p>
<p>还有一点可能并不很重要，但是也值得注意，
有时候当你在一个已经解压后的元组序列上使用 <code class="docutils literal"><span class="pre">enumerate()</span></code> 函数时很容易调入陷阱。
你得像下面正确的方式这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="p">]</span>

<span class="c1"># Correct!</span>
<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="o">...</span>
<span class="c1"># Error!</span>
<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c04/p11_iterate_over_multiple_sequences_simultaneously"></span><div class="section" id="id1">
<h3>4.11 同时迭代多个序列<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想同时迭代多个序列，每次分别从一个序列中取一个元素。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了同时迭代多个序列，使用 <code class="docutils literal"><span class="pre">zip()</span></code> 函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xpts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ypts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">101</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xpts</span><span class="p">,</span> <span class="n">ypts</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 101</span>
<span class="go">5 78</span>
<span class="go">4 37</span>
<span class="go">2 15</span>
<span class="go">10 62</span>
<span class="go">7 99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">zip(a,</span> <span class="pre">b)</span></code> 会生成一个可返回元组 <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></code> 的迭代器，其中x来自a，y来自b。
一旦其中某个序列到底结尾，迭代宣告结束。
因此迭代长度跟参数中最短序列长度一致。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, &#39;w&#39;)</span>
<span class="go">(2, &#39;x&#39;)</span>
<span class="go">(3, &#39;y&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果这个不是你想要的效果，那么还可以使用 <code class="docutils literal"><span class="pre">itertools.zip_longest()</span></code> 函数来代替。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, &#39;w&#39;)</span>
<span class="go">(2, &#39;x&#39;)</span>
<span class="go">(3, &#39;y&#39;)</span>
<span class="go">(None, &#39;z&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, &#39;w&#39;)</span>
<span class="go">(2, &#39;x&#39;)</span>
<span class="go">(3, &#39;y&#39;)</span>
<span class="go">(0, &#39;z&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>当你想成对处理数据的时候 <code class="docutils literal"><span class="pre">zip()</span></code> 函数是很有用的。
比如，假设你头列表和一个值列表，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">490.1</span><span class="p">]</span>
</pre></div>
</div>
<p>使用zip()可以让你将它们打包并生成一个字典：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">headers</span><span class="p">,</span><span class="n">values</span><span class="p">))</span>
</pre></div>
</div>
<p>或者你也可以像下面这样产生输出：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">headers</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>虽然不常见，但是 <code class="docutils literal"><span class="pre">zip()</span></code> 可以接受多于两个的序列的参数。
这时候所生成的结果元组中元素个数跟输入序列个数一样。比如;</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, 10, &#39;x&#39;)</span>
<span class="go">(2, 11, &#39;y&#39;)</span>
<span class="go">(3, 12, &#39;z&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后强调一点就是， <code class="docutils literal"><span class="pre">zip()</span></code> 会创建一个迭代器来作为结果返回。
如果你需要将结对的值存储在列表中，要使用 <code class="docutils literal"><span class="pre">list()</span></code> 函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">&lt;zip object at 0x1007001b8&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="go">[(1, 10), (2, 11), (3, 12)]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c04/p12_iterate_on_items_in_separate_containers"></span><div class="section" id="id1">
<h3>4.12 不同集合上元素的迭代<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在多个对象执行相同的操作，但是这些对象在不同的容器中，你希望代码在不失可读性的情况下避免写重复的循环。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">itertools.chain()</span></code> 方法可以用来简化这个任务。
它接受一个可迭代对象列表作为输入，并返回一个迭代器，有效的屏蔽掉在多个容器中迭代细节。
为了演示清楚，考虑下面这个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">x</span>
<span class="go">y</span>
<span class="go">z</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">chain()</span></code> 的一个常见场景是当你想对不同的集合中所有元素执行某些操作的时候。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Various working sets of items</span>
<span class="n">active_items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">inactive_items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># Iterate over all items</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">active_items</span><span class="p">,</span> <span class="n">inactive_items</span><span class="p">):</span>
    <span class="c1"># Process item</span>
</pre></div>
</div>
<p>这种解决方案要比像下面这样使用两个单独的循环更加优雅，</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">active_items</span><span class="p">:</span>
    <span class="c1"># Process item</span>
    <span class="o">...</span>

<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inactive_items</span><span class="p">:</span>
    <span class="c1"># Process item</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">itertools.chain()</span></code> 接受一个或多个可迭代对象最为输入参数。
然后创建一个迭代器，依次连续的返回每个可迭代对象中的元素。
这种方式要比先将序列合并再迭代要高效的多。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Inefficent</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># Better</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>第一种方案中， <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> 操作会创建一个全新的序列并要求a和b的类型一致。
<code class="docutils literal"><span class="pre">chian()</span></code> 不会有这一步，所以如果输入序列非常大的时候会很省内存。
并且当可迭代对象类型不一样的时候 <code class="docutils literal"><span class="pre">chain()</span></code> 同样可以很好的工作。</p>
</div>
</div>
<span id="document-c04/p13_create_data_processing_pipelines"></span><div class="section" id="id1">
<h3>4.13 创建数据处理管道<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想以数据管道(类似Unix管道)的方式迭代处理数据。
比如，你有个大量的数据需要处理，但是不能将它们一次性放入内存中。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>生成器函数是一个实现管道机制的好办法。
为了演示，假定你要处理一个非常大的日志文件目录：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">/</span>
    <span class="n">access</span><span class="o">-</span><span class="n">log</span><span class="o">-</span><span class="mf">012007.</span><span class="n">gz</span>
    <span class="n">access</span><span class="o">-</span><span class="n">log</span><span class="o">-</span><span class="mf">022007.</span><span class="n">gz</span>
    <span class="n">access</span><span class="o">-</span><span class="n">log</span><span class="o">-</span><span class="mf">032007.</span><span class="n">gz</span>
    <span class="o">...</span>
    <span class="n">access</span><span class="o">-</span><span class="n">log</span><span class="o">-</span><span class="mo">01200</span><span class="mi">8</span>
<span class="n">bar</span><span class="o">/</span>
    <span class="n">access</span><span class="o">-</span><span class="n">log</span><span class="o">-</span><span class="mf">092007.</span><span class="n">bz2</span>
    <span class="o">...</span>
    <span class="n">access</span><span class="o">-</span><span class="n">log</span><span class="o">-</span><span class="mo">02200</span><span class="mi">8</span>
</pre></div>
</div>
<p>假设每个日志文件包含这样的数据：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mf">124.115</span><span class="o">.</span><span class="mf">6.12</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">10</span><span class="o">/</span><span class="n">Jul</span><span class="o">/</span><span class="mi">2012</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">50</span> <span class="o">-</span><span class="mo">0500</span><span class="p">]</span> <span class="s2">&quot;GET /robots.txt ...&quot;</span> <span class="mi">200</span> <span class="mi">71</span>
<span class="mf">210.212</span><span class="o">.</span><span class="mf">209.67</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">10</span><span class="o">/</span><span class="n">Jul</span><span class="o">/</span><span class="mi">2012</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">51</span> <span class="o">-</span><span class="mo">0500</span><span class="p">]</span> <span class="s2">&quot;GET /ply/ ...&quot;</span> <span class="mi">200</span> <span class="mi">11875</span>
<span class="mf">210.212</span><span class="o">.</span><span class="mf">209.67</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">10</span><span class="o">/</span><span class="n">Jul</span><span class="o">/</span><span class="mi">2012</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">51</span> <span class="o">-</span><span class="mo">0500</span><span class="p">]</span> <span class="s2">&quot;GET /favicon.ico ...&quot;</span> <span class="mi">404</span> <span class="mi">369</span>
<span class="mf">61.135</span><span class="o">.</span><span class="mf">216.105</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">10</span><span class="o">/</span><span class="n">Jul</span><span class="o">/</span><span class="mi">2012</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mo">04</span> <span class="o">-</span><span class="mo">0500</span><span class="p">]</span> <span class="s2">&quot;GET /blog/atom.xml ...&quot;</span> <span class="mi">304</span> <span class="o">-</span>
<span class="o">...</span>
</pre></div>
</div>
<p>为了处理这些文件，你可以定义一个由多个执行特定任务独立任务的简单生成器函数组成的容器。就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">def</span> <span class="nf">gen_find</span><span class="p">(</span><span class="n">filepat</span><span class="p">,</span> <span class="n">top</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find all filenames in a directory tree that match a shell wildcard pattern</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">dirlist</span><span class="p">,</span> <span class="n">filelist</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">top</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">filelist</span><span class="p">,</span> <span class="n">filepat</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">gen_opener</span><span class="p">(</span><span class="n">filenames</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Open a sequence of filenames one at a time producing a file object.</span>
<span class="sd">    The file is closed immediately when proceeding to the next iteration.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.gz&#39;</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.bz2&#39;</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">f</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">gen_concatenate</span><span class="p">(</span><span class="n">iterators</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Chain a sequence of iterators together into a single sequence.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterators</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">it</span>

<span class="k">def</span> <span class="nf">gen_grep</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Look for a regex pattern in a sequence of lines</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">line</span>
</pre></div>
</div>
<p>现在你可以很容易的将这些函数连起来创建一个处理管道。
比如，为了查找包含单词python的所有日志行，你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">lognames</span> <span class="o">=</span> <span class="n">gen_find</span><span class="p">(</span><span class="s1">&#39;access-log*&#39;</span><span class="p">,</span> <span class="s1">&#39;www&#39;</span><span class="p">)</span>
<span class="n">files</span> <span class="o">=</span> <span class="n">gen_opener</span><span class="p">(</span><span class="n">lognames</span><span class="p">)</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">gen_concatenate</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
<span class="n">pylines</span> <span class="o">=</span> <span class="n">gen_grep</span><span class="p">(</span><span class="s1">&#39;(?i)python&#39;</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">pylines</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p>如果将来的时候你想扩展管道，你甚至可以在生成器表达式中包装数据。
比如，下面这个版本计算出传输的字节数并计算其总和。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">lognames</span> <span class="o">=</span> <span class="n">gen_find</span><span class="p">(</span><span class="s1">&#39;access-log*&#39;</span><span class="p">,</span> <span class="s1">&#39;www&#39;</span><span class="p">)</span>
<span class="n">files</span> <span class="o">=</span> <span class="n">gen_opener</span><span class="p">(</span><span class="n">lognames</span><span class="p">)</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">gen_concatenate</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
<span class="n">pylines</span> <span class="o">=</span> <span class="n">gen_grep</span><span class="p">(</span><span class="s1">&#39;(?i)python&#39;</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
<span class="n">bytecolumn</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">pylines</span><span class="p">)</span>
<span class="nb">bytes</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bytecolumn</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total&#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">bytes</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>以管道方式处理数据可以用来解决各类其他问题，包括解析，读取实时数据，定时轮询等。</p>
<p>为了理解上述代码，重点是要明白 <code class="docutils literal"><span class="pre">yield</span></code> 语句作为数据的生产者而 <code class="docutils literal"><span class="pre">for</span></code> 循环语句作为数据的消费者。
当这些生成器被连在一起后，每个 <code class="docutils literal"><span class="pre">yield</span></code> 会将一个单独的数据元素传递给迭代处理管道的下一阶段。
在例子最后部分， <code class="docutils literal"><span class="pre">sum()</span></code> 函数是最终的程序驱动者，每次从生成器管道中提取出一个元素。</p>
<p>这种方式一个非常好的特点是每个生成器函数很小并且都是独立的。这样的话就很容易编写和维护它们了。
很多时候，这些函数如果比较通用的话可以在其他场景重复使用。
并且最终将这些组件组合起来的代码看上去非常简单，也很容易理解。</p>
<p>使用这种方式的内存效率也不得不提。上述代码即便是在一个超大型文件目录中也能工作的很好。
事实上，由于使用了迭代方式处理，代码运行过程中只需要很小很小的内存。</p>
<p>在调用 <code class="docutils literal"><span class="pre">gen_concatenate()</span></code> 函数的时候你可能会有些不太明白。
这个函数的目的是将输入序列拼接成一个很长的行序列。
<code class="docutils literal"><span class="pre">itertools.chain()</span></code> 函数同样有类似的功能，但是它需要将所有可迭代对象最为参数传入。
在上面这个例子中，你可能会写类似这样的语句 <code class="docutils literal"><span class="pre">lines</span> <span class="pre">=</span> <span class="pre">itertools.chain(*files)</span></code> ，
这将导致 <code class="docutils literal"><span class="pre">gen_opener()</span></code> 生成器被提前全部消费掉。
但由于 <code class="docutils literal"><span class="pre">gen_opener()</span></code> 生成器每次生成一个打开过的文件，
等到下一个迭代步骤时文件就关闭了，因此 <code class="docutils literal"><span class="pre">chain()</span></code> 在这里不能这样使用。
上面的方案可以避免这种情况。</p>
<p><code class="docutils literal"><span class="pre">gen_concatenate()</span></code> 函数中出现过 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 语句，它将 <code class="docutils literal"><span class="pre">yield</span></code> 操作代理到父生成器上去。
语句 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">it</span></code> 简单的返回生成器 <code class="docutils literal"><span class="pre">it</span></code> 所产生的所有值。
关于这个我们在4.14小节会有更进一步的描述。</p>
<p>最后还有一点需要注意的是，管道方式并不是万能的。
有时候你想立即处理所有数据。
然而，即便是这种情况，使用生成器管道也可以将这类问题从逻辑上变为工作流的处理方式。</p>
<p><em>David Beazley</em> 在他的
<a class="reference external" href="http://www.dabeaz.com/generators/">Generator Tricks for Systems Programmers</a>
教程中对于这种技术有非常深入的讲解。可以参考这个教程获取更多的信息。</p>
</div>
</div>
<span id="document-c04/p14_flattening_nested_sequence"></span><div class="section" id="id1">
<h3>4.14 展开嵌套的序列<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想将一个多层嵌套的序列展开成一个单层列表</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>可以写一个包含 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 语句的递归生成器来轻松解决这个问题。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">ignore_types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ignore_types</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">x</span>

<span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">8</span><span class="p">]</span>
<span class="c1"># Produces 1 2 3 4 5 6 7 8</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>在上面代码中， <code class="docutils literal"><span class="pre">isinstance(x,</span> <span class="pre">Iterable)</span></code> 检查某个元素是否是可迭代的。
如果是的话， <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 就会返回所有子例程的值。最终返回结果就是一个没有嵌套的简单序列了。</p>
<p>额外的参数 <code class="docutils literal"><span class="pre">ignore_types</span></code> 和检测语句 <code class="docutils literal"><span class="pre">isinstance(x,</span> <span class="pre">ignore_types)</span></code>
用来将字符串和字节排除在可迭代对象外，防止将它们再展开成单个的字符。
这样的话字符串数组就能最终返回我们所期望的结果了。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dave&#39;</span><span class="p">,</span> <span class="s1">&#39;Paula&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Thomas&#39;</span><span class="p">,</span> <span class="s1">&#39;Lewis&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Dave</span>
<span class="go">Paula</span>
<span class="go">Thomas</span>
<span class="go">Lewis</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>语句 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 在你想在生成器中调用其他生成器作为子例程的时候非常有用。
如果你不使用它的话，那么就必须写额外的 <code class="docutils literal"><span class="pre">for</span></code> 循环了。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">ignore_types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ignore_types</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
<p>尽管只改了一点点，但是 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 语句看上去感觉更好，并且也使得代码更简洁清爽。</p>
<p>之前提到的对于字符串和字节的额外检查是为了防止将它们再展开成单个字符。
如果还有其他你不想展开的类型，修改参数 <code class="docutils literal"><span class="pre">ignore_types</span></code> 即可。</p>
<p>最后要注意的一点是， <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 在涉及到基于协程和生成器的并发编程中扮演着更加重要的角色。
可以参考12.12小节查看另外一个例子。</p>
</div>
</div>
<span id="document-c04/p15_iterate_in_sorted_order_over_merged_sorted_iterables"></span><div class="section" id="id1">
<h3>4.15 顺序迭代合并后的排序迭代对象<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一系列排序序列，想将它们合并后得到一个排序序列并在上面迭代遍历。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">heapq.merge()</span></code> 函数可以帮你解决这个问题。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">heapq</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
<span class="go">7</span>
<span class="go">10</span>
<span class="go">11</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">heapq.merge</span></code> 可迭代特性意味着它不会立马读取所有序列。
这就意味着你可以在非常长的序列中使用它，而不会有太大的开销。
比如，下面是一个例子来演示如何合并两个排序文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sorted_file_1&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file1</span><span class="p">,</span> \
    <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sorted_file_2&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file2</span><span class="p">,</span> \
    <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;merged_file&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">heapq</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">file1</span><span class="p">,</span> <span class="n">file2</span><span class="p">):</span>
        <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p>有一点要强调的是 <code class="docutils literal"><span class="pre">heapq.merge()</span></code> 需要所有输入序列必须是排过序的。
特别的，它并不会预先读取所有数据到堆栈中或者预先排序，也不会对输入做任何的排序检测。
它仅仅是检查所有序列的开始部分并返回最小的那个，这个过程一直会持续直到所有输入序列中的元素都被遍历完。</p>
</div>
</div>
<span id="document-c04/p16_replace_infinite_while_loops_with_iterator"></span><div class="section" id="while">
<h3>4.16 迭代器代替while无限循环<a class="headerlink" href="#while" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你在代码中使用 <code class="docutils literal"><span class="pre">while</span></code> 循环来迭代处理数据，因为它需要调用某个函数或者和一般迭代模式不同的测试条件。
能不能用迭代器来重写这个循环呢？</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>一个常见的IO操作程序可能会想下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">CHUNKSIZE</span> <span class="o">=</span> <span class="mi">8192</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">CHUNKSIZE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">process_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>这种代码通常可以使用 <code class="docutils literal"><span class="pre">iter()</span></code> 来代替，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reader2</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">CHUNKSIZE</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="k">pass</span>
        <span class="c1"># process_data(data)</span>
</pre></div>
</div>
<p>如果你怀疑它到底能不能正常工作，可以试验下一个简单的例子。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false</span>
<span class="go">root:*:0:0:System Administrator:/var/root:/bin/sh</span>
<span class="go">daemon:*:1:1:System Services:/var/root:/usr/bin/false</span>
<span class="go">_uucp:*:4:4:Unix to Unix Copy Protocol:/var/spool/uucp:/usr/sbin/uucico</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">iter</span></code> 函数一个鲜为人知的特性是它接受一个可选的 <code class="docutils literal"><span class="pre">callable</span></code> 对象和一个标记(结尾)值作为输入参数。
当以这种方式使用的时候，它会创建一个迭代器， 这个迭代器会不断调用 <code class="docutils literal"><span class="pre">callable</span></code> 对象直到返回值和标记值相等为止。</p>
<p>这种特殊的方法对于一些特定的会被重复调用的函数很有效果，比如涉及到I/O调用的函数。
举例来讲，如果你想从套接字或文件中以数据块的方式读取数据，通常你得要不断重复的执行 <code class="docutils literal"><span class="pre">read()</span></code> 或 <code class="docutils literal"><span class="pre">recv()</span></code> ，
并在后面紧跟一个文件结尾测试来决定是否终止。这节中的方案使用一个简单的 <code class="docutils literal"><span class="pre">iter()</span></code> 调用就可以将两者结合起来了。
其中 <code class="docutils literal"><span class="pre">lambda</span></code> 函数参数是为了创建一个无参的 <code class="docutils literal"><span class="pre">callable</span></code> 对象，并为 <code class="docutils literal"><span class="pre">recv</span></code> 或 <code class="docutils literal"><span class="pre">read()</span></code> 方法提供了 <code class="docutils literal"><span class="pre">size</span></code> 参数。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p05_files_and_io"></span><div class="section" id="io">
<h2>第五章：文件与IO<a class="headerlink" href="#io" title="永久链接至标题">¶</a></h2>
<p>所有程序都要处理输入和输出。
这一章将涵盖处理不同类型的文件，包括文本和二进制文件，文件编码和其他相关的内容。
对文件名和目录的操作也会涉及到。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c05/p01_read_write_text_data"></span><div class="section" id="id1">
<h3>5.1 读写文本数据<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要读写各种不同编码的文本数据，比如ASCII，UTF-8或UTF-16编码等。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用带有 <code class="docutils literal"><span class="pre">rt</span></code> 模式的 <code class="docutils literal"><span class="pre">open()</span></code> 函数读取文本文件。如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Read the entire file as a single string</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># Iterate over the lines of the file</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># process line</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>类似的，为了写入一个文本文件，使用带有 <code class="docutils literal"><span class="pre">wt</span></code> 模式的 <code class="docutils literal"><span class="pre">open()</span></code> 函数，
如果之前文件内容存在则清除并覆盖掉。如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Write chunks of text data</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>
    <span class="o">...</span>

<span class="c1"># Redirected print statement</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">line1</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">line2</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果是在已存在文件中添加内容，使用模式为 <code class="docutils literal"><span class="pre">at</span></code> 的 <code class="docutils literal"><span class="pre">open()</span></code> 函数。</p>
<p>文件的读写操作默认使用系统编码，可以通过调用 <code class="docutils literal"><span class="pre">sys.getdefaultencoding()</span></code> 来得到。
在大多数机器上面都是utf-8编码。如果你已经知道你要读写的文本是其他编码方式，
那么可以通过传递一个可选的 <code class="docutils literal"><span class="pre">encoding</span></code> 参数给open()函数。如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;latin-1&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Python支持非常多的文本编码。几个常见的编码是ascii, latin-1, utf-8和utf-16。
在web应用程序中通常都使用的是UTF-8。
ascii对应从U+0000到U+007F范围内的7位字符。
latin-1是字节0-255到U+0000至U+00FF范围内Unicode字符的直接映射。
当读取一个未知编码的文本时使用latin-1编码永远不会产生解码错误。
使用latin-1编码读取一个文件的时候也许不能产生完全正确的文本解码数据，
但是它也能从中提取出足够多的有用数据。同时，如果你之后将数据回写回去，原先的数据还是会保留的。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>读写文本文件一般来讲是比较简单的。但是也几点是需要注意的。
首先，在例子程序中的with语句给被使用到的文件创建了一个上下文环境，
但 <code class="docutils literal"><span class="pre">with</span></code> 控制块结束时，文件会自动关闭。你也可以不使用 <code class="docutils literal"><span class="pre">with</span></code> 语句，但是这时候你就必须记得手动关闭文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>另外一个问题是关于换行符的识别问题，在Unix和Windows中是不一样的(分别是 <code class="docutils literal"><span class="pre">\n</span></code> 和 <code class="docutils literal"><span class="pre">\r\n</span></code> )。
默认情况下，Python会以统一模式处理换行符。
这种模式下，在读取文本的时候，Python可以识别所有的普通换行符并将其转换为单个 <code class="docutils literal"><span class="pre">\n</span></code> 字符。
类似的，在输出时会将换行符 <code class="docutils literal"><span class="pre">\n</span></code> 转换为系统默认的换行符。
如果你不希望这种默认的处理方式，可以给 <code class="docutils literal"><span class="pre">open()</span></code> 函数传入参数 <code class="docutils literal"><span class="pre">newline=''</span></code> ，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Read with disabled newline translation</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>为了说明两者之间的差异，下面我在Unix机器上面读取一个Windows上面的文本文件，里面的内容是 <code class="docutils literal"><span class="pre">hello</span> <span class="pre">world!\r\n</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Newline translation enabled (the default)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;hello.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;hello world!\n&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Newline translation disabled</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;hello.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;hello world!\r\n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后一个问题就是文本文件中可能出现的编码错误。
但你读取或者写入一个文本文件时，你可能会遇到一个编码或者解码错误。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sample.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/encodings/ascii.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">26</span><span class="p">,</span> <span class="ow">in</span> <span class="n">decode</span>
        <span class="k">return</span> <span class="n">codecs</span><span class="o">.</span><span class="n">ascii_decode</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">UnicodeDecodeError</span>: <span class="n">&#39;ascii&#39; codec can&#39;t decode byte 0xc3 in position</span>
<span class="go">12: ordinal not in range(128)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果出现这个错误，通常表示你读取文本时指定的编码不正确。
你最好仔细阅读说明并确认你的文件编码是正确的(比如使用UTF-8而不是Latin-1编码或其他)。
如果编码错误还是存在的话，你可以给 <code class="docutils literal"><span class="pre">open()</span></code> 函数传递一个可选的 <code class="docutils literal"><span class="pre">errors</span></code> 参数来处理这些错误。
下面是一些处理常见错误的方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Replace bad chars with Unicode U+fffd replacement char</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sample.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;Spicy Jalape?o!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Ignore bad chars entirely</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sample.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;Spicy Jalapeo!&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你经常使用 <code class="docutils literal"><span class="pre">errors</span></code> 参数来处理编码错误，可能会让你的生活变得很糟糕。
对于文本处理的首要原则是确保你总是使用的是正确编码。当模棱两可的时候，就使用默认的设置(通常都是UTF-8)。</p>
</div>
</div>
<span id="document-c05/p02_printing_to_file"></span><div class="section" id="id1">
<h3>5.2 打印输出至文件中<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想将 <code class="docutils literal"><span class="pre">print()</span></code> 函数的输出重定向到一个文件中去。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在 <code class="docutils literal"><span class="pre">print()</span></code> 函数中指定 <code class="docutils literal"><span class="pre">file</span></code> 关键字参数，像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;d:/work/test.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hello World!&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>关于输出重定向到文件中就这些了。但是有一点要注意的就是文件必须是以文本模式打开。
如果文件是二进制模式的话，打印就会出错。</p>
</div>
</div>
<span id="document-c05/p03_print_with_different_separator_or_line_ending"></span><div class="section" id="id1">
<h3>5.3 使用其他分隔符或行终止符打印<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想使用 <code class="docutils literal"><span class="pre">print()</span></code> 函数输出数据，但是想改变默认的分隔符或者行尾符。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>可以使用在 <code class="docutils literal"><span class="pre">print()</span></code> 函数中使用 <code class="docutils literal"><span class="pre">sep</span></code> 和 <code class="docutils literal"><span class="pre">end</span></code> 关键字参数，以你想要的方式输出。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.5</span><span class="p">)</span>
<span class="go">ACME 50 91.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.5</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">ACME,50,91.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.5</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;!!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">ACME,50,91.5!!</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">end</span></code> 参数也可以在输出中禁止换行。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 1 2 3 4 &gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>当你想使用非空格分隔符来输出数据的时候，给 <code class="docutils literal"><span class="pre">print()</span></code> 函数传递一个 <code class="docutils literal"><span class="pre">sep</span></code> 参数是最简单的方案。
有时候你会看到一些程序员会使用 <code class="docutils literal"><span class="pre">str.join()</span></code> 来完成同样的事情。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span><span class="s1">&#39;50&#39;</span><span class="p">,</span><span class="s1">&#39;91.5&#39;</span><span class="p">)))</span>
<span class="go">ACME,50,91.5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">str.join()</span></code> 的问题在于它仅仅适用于字符串。这意味着你通常需要执行另外一些转换才能让它正常工作。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">sequence item 1: expected str instance, int found</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">row</span><span class="p">))</span>
<span class="go">ACME,50,91.5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你当然可以不用那么麻烦，只需要像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">ACME,50,91.5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c05/p04_read_write_binary_data"></span><div class="section" id="id1">
<h3>5.4 读写字节数据<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想读写二进制文件，比如图片，声音文件等等。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用模式为 <code class="docutils literal"><span class="pre">rb</span></code> 或 <code class="docutils literal"><span class="pre">wb</span></code> 的 <code class="docutils literal"><span class="pre">open()</span></code> 函数来读取或写入二进制数据。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Read the entire file as a single byte string</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># Write binary data to a file</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在读取二进制数据时，需要指明的是所有返回的数据都是字节字符串格式的，而不是文本字符串。
类似的，在写入的时候，必须保证参数是以字节形式对外暴露数据的对象(比如字节字符串，字节数组对象等)。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在读取二进制数据的时候，字节字符串和文本字符串的语义差异可能会导致一个潜在的陷阱。
特别需要注意的是，索引和迭代动作返回的是字节的值而不是字节字符串。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Text string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="s1">&#39;Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;H&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">H</span>
<span class="go">e</span>
<span class="go">l</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Byte string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">72</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">72</span>
<span class="go">101</span>
<span class="go">108</span>
<span class="go">108</span>
<span class="go">111</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想从二进制模式的文件中读取或写入文本数据，必须确保要进行解码和编码操作。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Hello World&#39;</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>二进制I/O还有一个鲜为人知的特性就是数组和C结构体类型能直接被写入，而不需要中间转换为自己对象。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">array</span>
<span class="n">nums</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.bin&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</pre></div>
</div>
<p>这个适用于任何实现了被称之为&#8221;缓冲接口&#8221;的对象，这种对象会直接暴露其底层的内存缓冲区给能处理它的操作。
二进制数据的写入就是这类操作之一。</p>
<p>很多对象还允许通过使用文件对象的 <code class="docutils literal"><span class="pre">readinto()</span></code> 方法直接读取二进制数据到其底层的内存中去。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array(&#39;i&#39;, [1, 2, 3, 4, 0, 0, 0, 0])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但是使用这种技术的时候需要格外小心，因为它通常具有平台相关性，并且可能会依赖字长和字节顺序(高位优先和低位优先)。
可以查看5.9小节中另外一个读取二进制数据到可修改缓冲区的例子。</p>
</div>
</div>
<span id="document-c05/p05_write_to_file_not_exist"></span><div class="section" id="id1">
<h3>5.5 文件不存在才能写入<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想像一个文件中写入数据，但是前提必须是这个文件在文件系统上不存在。
也就是不允许覆盖已存在的文件内容。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>可以在 <code class="docutils literal"><span class="pre">open()</span></code> 函数中使用 <code class="docutils literal"><span class="pre">x</span></code> 模式来代替 <code class="docutils literal"><span class="pre">w</span></code> 模式的方法来解决这个问题。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; with open(&#39;somefile&#39;, &#39;wt&#39;) as f:
...     f.write(&#39;Hello\n&#39;)
...
&gt;&gt;&gt; with open(&#39;somefile&#39;, &#39;xt&#39;) as f:
...     f.write(&#39;Hello\n&#39;)
...
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
FileExistsError: [Errno 17] File exists: &#39;somefile&#39;
&gt;&gt;&gt;
</pre></div>
</div>
<p>如果文件是二进制的，使用 <code class="docutils literal"><span class="pre">xb</span></code> 来代替 <code class="docutils literal"><span class="pre">xt</span></code></p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一小节演示了在写文件时通常会遇到的一个问题的完美解决方案(不小心覆盖一个已存在的文件)。
一个替代方案是先测试这个文件是否存在，像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;somefile&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;File already exists!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">File already exists!</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>显而易见，使用x文件模式更加简单。要注意的是x模式是一个Python3对 <code class="docutils literal"><span class="pre">open()</span></code> 函数特有的扩展。
在Python的旧版本或者是Python实现的底层C函数库中都是没有这个模式的。</p>
</div>
</div>
<span id="document-c05/p06_io_operations_on_string"></span><div class="section" id="i-o">
<h3>5.6 字符串的I/O操作<a class="headerlink" href="#i-o" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想使用操作类文件对象的程序来操作文本或二进制字符串。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">io.StringIO()</span></code> 和 <code class="docutils literal"><span class="pre">io.BytesIO()</span></code> 类来创建类文件对象操作字符串数据。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Hello World</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;This is a test&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get all of the data written so far</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;Hello World\nThis is a test\n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Wrap a file interface around an existing string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">World</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;Hell&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;o\nWorld\n&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">io.StringIO</span></code> 只能用于文本。如果你要操作二进制数据，要使用 <code class="docutils literal"><span class="pre">io.BytesIO</span></code> 类来代替。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;binary data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">b&#39;binary data&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>当你想模拟一个普通的文件的时候 <code class="docutils literal"><span class="pre">StringIO</span></code> 和 <code class="docutils literal"><span class="pre">BytesIO</span></code> 类是很有用的。
比如，在单元测试中，你可以使用 <code class="docutils literal"><span class="pre">StringIO</span></code> 来创建一个包含测试数据的类文件对象，
这个对象可以被传给某个参数为普通文件对象的函数。</p>
<p>需要注意的是， <code class="docutils literal"><span class="pre">StringIO</span></code> 和 <code class="docutils literal"><span class="pre">BytesIO</span></code> 实例并没有正确的整数类型的文件描述符。
因此，它们不能在那些需要使用真实的系统级文件如文件，管道或者是套接字的程序中使用。</p>
</div>
</div>
<span id="document-c05/p07_read_write_compressed_datafiles"></span><div class="section" id="id1">
<h3>5.7 读写压缩文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想读写一个gzip或bz2格式的压缩文件。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">gzip</span></code> 和 <code class="docutils literal"><span class="pre">bz2</span></code> 模块可以很容易的处理这些文件。
两个模块都为 <code class="docutils literal"><span class="pre">open()</span></code> 函数提供了另外的实现来解决这个问题。
比如，为了以文本形式读取压缩文件，可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># gzip compression</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somefile.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># bz2 compression</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="k">with</span> <span class="n">bz2</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somefile.bz2&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>类似的，为了写入压缩数据，可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># gzip compression</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somefile.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

<span class="c1"># bz2 compression</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="k">with</span> <span class="n">bz2</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somefile.bz2&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>如上，所有的I/O操作都使用文本模式并执行Unicode的编码/解码。
类似的，如果你想操作二进制数据，使用 <code class="docutils literal"><span class="pre">rb</span></code> 或者 <code class="docutils literal"><span class="pre">wb</span></code> 文件模式即可。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>大部分情况下读写压缩数据都是很简单的。但是要注意的是选择一个正确的文件模式是非常重要的。
如果你不指定模式，那么默认的就是二进制模式，如果这时候程序想要接受的是文本数据，那么就会出错。
<code class="docutils literal"><span class="pre">gzip.open()</span></code> 和 <code class="docutils literal"><span class="pre">bz2.open()</span></code> 接受跟内置的 <code class="docutils literal"><span class="pre">open()</span></code> 函数一样的参数，
包括 <code class="docutils literal"><span class="pre">encoding</span></code>，<code class="docutils literal"><span class="pre">errors</span></code>，<code class="docutils literal"><span class="pre">newline</span></code> 等等。</p>
<p>当写入压缩数据时，可以使用 <code class="docutils literal"><span class="pre">compresslevel</span></code> 这个可选的关键字参数来指定一个压缩级别。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somefile.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">,</span> <span class="n">compresslevel</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>默认的等级是9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。</p>
<p>最后一点， <code class="docutils literal"><span class="pre">gzip.open()</span></code> 和 <code class="docutils literal"><span class="pre">bz2.open()</span></code> 还有一个很少被知道的特性，
它们可以作用在一个已存在并以二进制模式打开的文件上。比如，下面代码是可行的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gzip</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">g</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>这样就允许 <code class="docutils literal"><span class="pre">gzip</span></code> 和 <code class="docutils literal"><span class="pre">bz2</span></code> 模块可以工作在许多类文件对象上，比如套接字，管道和内存中文件等。</p>
</div>
</div>
<span id="document-c05/p08_iterate_over_fixed_sized_records"></span><div class="section" id="id1">
<h3>5.8 固定大小记录的文件迭代<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在一个固定长度记录或者数据块的集合上迭代，而不是在一个文件中一行一行的迭代。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>通过下面这个小技巧使用 <code class="docutils literal"><span class="pre">iter</span></code> 和 <code class="docutils literal"><span class="pre">functools.partial()</span></code> 函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="n">RECORD_SIZE</span> <span class="o">=</span> <span class="mi">32</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile.data&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">records</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="n">RECORD_SIZE</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>这个例子中的 <code class="docutils literal"><span class="pre">records</span></code> 对象是一个可迭代对象，它会不断的产生固定大小的数据块，直到文件末尾。
要注意的是如果总记录大小不是块大小的整数倍的话，最后一个返回元素的字节数会比期望值少。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">iter()</span></code> 函数有一个鲜为人知的特性就是，如果你给它传递一个可调用对象和一个标记值，它会创建一个迭代器。
这个迭代器会一直调用传入的可调用对象直到它返回标记值为止，这时候迭代终止。</p>
<p>在例子中， <code class="docutils literal"><span class="pre">functools.partial</span></code> 用来创建一个每次被调用时从文件中读取固定数目字节的可调用对象。
标记值 <code class="docutils literal"><span class="pre">b''</span></code> 就是当到达文件结尾时的返回值。</p>
<p>最后再提一点，上面的例子中的文件时以二进制模式打开的。
如果是读取固定大小的记录，这通常是最普遍的情况。
而对于文本文件，一行一行的读取(默认的迭代行为)更普遍点。</p>
</div>
</div>
<span id="document-c05/p09_read_binary_data_into_mutable_buffer"></span><div class="section" id="id1">
<h3>5.9 读取二进制数据到可变缓冲区中<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想直接读取二进制数据到一个可变缓冲区中，而不需要做任何的中间复制操作。
或者你想原地修改数据并将它写回到一个文件中去。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了读取数据到一个可变数组中，使用文件对象的 <code class="docutils literal"><span class="pre">readinto()</span></code> 方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os.path</span>

<span class="k">def</span> <span class="nf">read_into_buffer</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">buf</span>
</pre></div>
</div>
<p>下面是一个演示这个函数使用方法的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Write a sample file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sample.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">read_into_buffer</span><span class="p">(</span><span class="s1">&#39;sample.bin&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span>
<span class="go">bytearray(b&#39;Hello World&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;Hallo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span>
<span class="go">bytearray(b&#39;Hallo World&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;newsample.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">11</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>文件对象的 <code class="docutils literal"><span class="pre">readinto()</span></code> 方法能被用来为预先分配内存的数组填充数据，甚至包括由 <code class="docutils literal"><span class="pre">array</span></code> 模块或 <code class="docutils literal"><span class="pre">numpy</span></code> 库创建的数组。
和普通 <code class="docutils literal"><span class="pre">read()</span></code> 方法不同的是， <code class="docutils literal"><span class="pre">readinto()</span></code> 填充已存在的缓冲区而不是为新对象重新分配内存再返回它们。
因此，你可以使用它来避免大量的内存分配操作。
比如，如果你读取一个由相同大小的记录组成的二进制文件时，你可以像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">record_size</span> <span class="o">=</span> <span class="mi">32</span> <span class="c1"># Size of each record (adjust value)</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">record_size</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">record_size</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># Use the contents of buf</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>另外有一个有趣特性就是 <code class="docutils literal"><span class="pre">memoryview</span></code> ，
它可以通过零复制的方式对已存在的缓冲区执行切片操作，甚至还能修改它的内容。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span>
<span class="go">bytearray(b&#39;Hello World&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span>
<span class="go">&lt;memory at 0x100681390&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="p">[:]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;WORLD&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span>
<span class="go">bytearray(b&#39;Hello WORLD&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">f.readinto()</span></code> 时需要注意的是，你必须检查它的返回值，也就是实际读取的字节数。</p>
<p>如果字节数小于缓冲区大小，表明数据被截断或者被破坏了(比如你期望每次读取指定数量的字节)。</p>
<p>最后，留心观察其他函数库和模块中和 <code class="docutils literal"><span class="pre">into</span></code> 相关的函数(比如 <code class="docutils literal"><span class="pre">recv_into()</span></code> ， <code class="docutils literal"><span class="pre">pack_into()</span></code> 等)。
Python的很多其他部分已经能支持直接的I/O或数据访问操作，这些操作可被用来填充或修改数组和缓冲区内容。</p>
<p>关于解析二进制结构和 <code class="docutils literal"><span class="pre">memoryviews</span></code> 使用方法的更高级例子，请参考6.12小节。</p>
</div>
</div>
<span id="document-c05/p10_memory_mapping_binary_files"></span><div class="section" id="id1">
<h3>5.10 内存映射的二进制文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想内存映射一个二进制文件到一个可变字节数组中，目的可能是为了随机访问它的内容或者是原地做些修改。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">mmap</span></code> 模块来内存映射文件。
下面是一个工具函数，向你演示了如何打开一个文件并以一种便捷方式内存映射这个文件。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">mmap</span>

<span class="k">def</span> <span class="nf">memory_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">mmap</span><span class="o">.</span><span class="n">ACCESS_WRITE</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">access</span><span class="p">)</span>
</pre></div>
</div>
<p>为了使用这个函数，你需要有一个已创建并且内容不为空的文件。
下面是一个例子，教你怎样初始创建一个文件并将其内容扩充到指定大小：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>下面是一个利用 <code class="docutils literal"><span class="pre">memory_map()</span></code> 函数类内存映射文件内容的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">memory_map</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">1000000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Reassign a slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Verify that changes were made</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">b&#39;Hello World&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">mmap()</span></code> 返回的 <code class="docutils literal"><span class="pre">mmap</span></code> 对象同样也可以作为一个上下文管理器来使用，
这时候底层的文件会被自动关闭。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">memory_map</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1000000</span>
<span class="go">b&#39;Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">closed</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>默认情况下， <code class="docutils literal"><span class="pre">memeory_map()</span></code> 函数打开的文件同时支持读和写操作。
任何的修改内容都会复制回原来的文件中。
如果需要只读的访问模式，可以给参数 <code class="docutils literal"><span class="pre">access</span></code> 赋值为 <code class="docutils literal"><span class="pre">mmap.ACCESS_READ</span></code> 。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">memory_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mmap</span><span class="o">.</span><span class="n">ACCESS_READ</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你想在本地修改数据，但是又不想将修改写回到原始文件中，可以使用 <code class="docutils literal"><span class="pre">mmap.ACCESS_COPY</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">memory_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mmap</span><span class="o">.</span><span class="n">ACCESS_COPY</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>为了随机访问文件的内容，使用 <code class="docutils literal"><span class="pre">mmap</span></code> 将文件映射到内存中是一个高效和优雅的方法。
例如，你无需打开一个文件并执行大量的 <code class="docutils literal"><span class="pre">seek()</span></code> ， <code class="docutils literal"><span class="pre">read()</span></code> ， <code class="docutils literal"><span class="pre">write()</span></code> 调用，
只需要简单的映射文件并使用切片操作访问数据即可。</p>
<p>一般来讲， <code class="docutils literal"><span class="pre">mmap()</span></code> 所暴露的内存看上去就是一个二进制数组对象。
但是，你可以使用一个内存视图来解析其中的数据。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">memory_map</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Memoryview of unsigned integers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">b&#39;\x07\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x07\x01\x00\x00</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">263</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>需要强调的一点是，内存映射一个文件并不会导致整个文件被读取到内存中。
也就是说，文件并没有被复制到内存缓存或数组中。相反，操作系统仅仅为文件内容保留了一段虚拟内存。
当你访问文件的不同区域时，这些区域的内容才根据需要被读取并映射到内存区域中。
而那些从没被访问到的部分还是留在磁盘上。所有这些过程是透明的，在幕后完成！</p>
<p>如果多个Python解释器内存映射同一个文件，得到的 <code class="docutils literal"><span class="pre">mmap</span></code> 对象能够被用来在解释器直接交换数据。
也就是说，所有解释器都能同时读写数据，并且其中一个解释器所做的修改会自动呈现在其他解释器中。
很明显，这里需要考虑同步的问题。但是这种方法有时候可以用来在管道或套接字间传递数据。</p>
<p>这一小节中函数尽量写得很通用，同时适用于Unix和Windows平台。
要注意的是使用 <code class="docutils literal"><span class="pre">mmap()</span></code> 函数时会在底层有一些平台的差异性。
另外，还有一些选项可以用来创建匿名的内存映射区域。
如果你对这个感兴趣，确保你仔细研读了Python文档中
<a class="reference external" href="http://docs.python.org/3/library/mmap.html">这方面的内容</a> 。</p>
</div>
</div>
<span id="document-c05/p11_manipulating_pathnames"></span><div class="section" id="id1">
<h3>5.11 文件路径名的操作<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要使用路径名来获取文件名，目录名，绝对路径等等。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">os.path</span></code> 模块中的函数来操作路径名。
下面是一个交互式例子来演示一些关键的特性：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;/Users/beazley/Data/data.csv&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the last component of the path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="go">&#39;data.csv&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the directory name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="go">&#39;/Users/beazley/Data&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Join path components together</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;tmp&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
<span class="go">&#39;tmp/data/data.csv&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Expand the user&#39;s home directory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;~/Data/data.csv&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="go">&#39;/Users/beazley/Data/data.csv&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Split the file extension</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="go">(&#39;~/Data/data&#39;, &#39;.csv&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>对于任何的文件名的操作，你都应该使用 <code class="docutils literal"><span class="pre">os.path</span></code> 模块，而不是使用标准字符串操作来构造自己的代码。
特别是为了可移植性考虑的时候更应如此，
因为 <code class="docutils literal"><span class="pre">os.path</span></code> 模块知道Unix和Windows系统之间的差异并且能够可靠地处理类似 <code class="docutils literal"><span class="pre">Data/data.csv</span></code>
和 <code class="docutils literal"><span class="pre">Data\data.csv</span></code> 这样的文件名。
其次，你真的不应该浪费时间去重复造轮子。通常最好是直接使用已经为你准备好的功能。</p>
<p>要注意的是 <code class="docutils literal"><span class="pre">os.path</span></code> 还有更多的功能在这里并没有列举出来。
可以查阅官方文档来获取更多与文件测试，符号链接等相关的函数说明。</p>
</div>
</div>
<span id="document-c05/p12_test_for_the_existence_of_file"></span><div class="section" id="id1">
<h3>5.12 测试文件是否存在<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想测试一个文件或目录是否存在。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">os.path</span></code> 模块来测试一个文件或目录是否存在。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;/tmp/spam&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你还能进一步测试这个文件时什么类型的。
在下面这些测试中，如果测试的文件不存在的时候，结果都会返回False：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Is a regular file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Is a directory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Is a symbolic link</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="s1">&#39;/usr/local/bin/python3&#39;</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the file linked to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="s1">&#39;/usr/local/bin/python3&#39;</span><span class="p">)</span>
<span class="go">&#39;/usr/local/bin/python3.3&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你还想获取元数据(比如文件大小或者是修改日期)，也可以使用 <code class="docutils literal"><span class="pre">os.path</span></code> 模块来解决：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
<span class="go">3669</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
<span class="go">1272478234.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">))</span>
<span class="go">&#39;Wed Apr 28 13:10:34 2010&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">os.path</span></code> 来进行文件测试是很简单的。
在写这些脚本时，可能唯一需要注意的就是你需要考虑文件权限的问题，特别是在获取元数据时候。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="s1">&#39;/Users/guido/Desktop/foo.txt&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/genericpath.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">49</span><span class="p">,</span> <span class="ow">in</span> <span class="n">getsize</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span>
<span class="gr">PermissionError</span>: <span class="n">[Errno 13] Permission denied: &#39;/Users/guido/Desktop/foo.txt&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c05/p13_get_directory_listing"></span><div class="section" id="id1">
<h3>5.13 获取文件夹中的文件列表<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想获取文件系统中某个目录下的所有文件列表。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">os.listdir()</span></code> 函数来获取某个目录中的文件列表：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="n">names</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>结果会返回目录中所有文件列表，包括所有文件，子目录，符号链接等等。
如果你需要通过某种方式过滤数据，可以考虑结合 <code class="docutils literal"><span class="pre">os.path</span></code> 库中的一些函数来使用列表推导。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os.path</span>

<span class="c1"># Get all regular files</span>
<span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">))]</span>

<span class="c1"># Get all dirs</span>
<span class="n">dirnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">))]</span>
</pre></div>
</div>
<p>字符串的 <code class="docutils literal"><span class="pre">startswith()</span></code> 和 <code class="docutils literal"><span class="pre">endswith()</span></code> 方法对于过滤一个目录的内容也是很有用的。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pyfiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.py&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>对于文件名的匹配，你可能会考虑使用 <code class="docutils literal"><span class="pre">glob</span></code> 或 <code class="docutils literal"><span class="pre">fnmatch</span></code> 模块。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">glob</span>
<span class="n">pyfiles</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;somedir/*.py&#39;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">fnmatch</span> <span class="kn">import</span> <span class="n">fnmatch</span>
<span class="n">pyfiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fnmatch</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;*.py&#39;</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>获取目录中的列表是很容易的，但是其返回结果只是目录中实体名列表而已。
如果你还想获取其他的元信息，比如文件大小，修改时间等等，
你或许还需要使用到 <code class="docutils literal"><span class="pre">os.path</span></code> 模块中的函数或着 <code class="docutils literal"><span class="pre">os.stat()</span></code> 函数来收集数据。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Example of getting a directory listing</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">glob</span>

<span class="n">pyfiles</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.py&#39;</span><span class="p">)</span>

<span class="c1"># Get file sizes and modification dates</span>
<span class="n">name_sz_date</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pyfiles</span><span class="p">]</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mtime</span> <span class="ow">in</span> <span class="n">name_sz_date</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mtime</span><span class="p">)</span>

<span class="c1"># Alternative: Get file metadata</span>
<span class="n">file_metadata</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pyfiles</span><span class="p">]</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">file_metadata</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">st_mtime</span><span class="p">)</span>
</pre></div>
</div>
<p>最后还有一点要注意的就是，有时候在处理文件名编码问题时候可能会出现一些问题。
通常来讲，函数 <code class="docutils literal"><span class="pre">os.listdir()</span></code> 返回的实体列表会根据系统默认的文件名编码来解码。
但是有时候也会碰到一些不能正常解码的文件名。
关于文件名的处理问题，在5.14和5.15小节有更详细的讲解。</p>
</div>
</div>
<span id="document-c05/p14_bypassing_filename_encoding"></span><div class="section" id="id1">
<h3>5.14 忽略文件名编码<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想使用原始文件名执行文件的I/O操作，也就是说文件名并没有经过系统默认编码去解码或编码过。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>默认情况下，所有的文件名都会根据 <code class="docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code> 返回的文本编码来编码或解码。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getfilesystemencoding</span><span class="p">()</span>
<span class="go">&#39;utf-8&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果因为某种原因你想忽略这种编码，可以使用一个原始字节字符串来指定一个文件名即可。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Wrte a file using a unicode filename</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;jalape</span><span class="se">\xf1</span><span class="s1">o.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Spicy!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Directory listing (decoded)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="go">[&#39;jalapeño.txt&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Directory listing (raw)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="c1"># Note: byte string</span>
<span class="go">[b&#39;jalapen\xcc\x83o.txt&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Open file with raw filename</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;jalapen</span><span class="se">\xcc\x83</span><span class="s1">o.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">Spicy!</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正如你所见，在最后两个操作中，当你给文件相关函数如 <code class="docutils literal"><span class="pre">open()</span></code> 和 <code class="docutils literal"><span class="pre">os.listdir()</span></code>
传递字节字符串时，文件名的处理方式会稍有不同。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>通常来讲，你不需要担心文件名的编码和解码，普通的文件名操作应该就没问题了。
但是，有些操作系统允许用户通过偶然或恶意方式去创建名字不符合默认编码的文件。
这些文件名可能会神秘地中断那些需要处理大量文件的Python程序。</p>
<p>读取目录并通过原始未解码方式处理文件名可以有效的避免这样的问题，
尽管这样会带来一定的编程难度。</p>
<p>关于打印不可解码的文件名，请参考5.15小节。</p>
</div>
</div>
<span id="document-c05/p15_printing_bad_filenames"></span><div class="section" id="id1">
<h3>5.15 打印不合法的文件名<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序获取了一个目录中的文件名列表，但是当它试着去打印文件名的时候程序崩溃，
出现了 <code class="docutils literal"><span class="pre">UnicodeEncodeError</span></code> 异常和一条奇怪的消息—— <code class="docutils literal"><span class="pre">surrogates</span> <span class="pre">not</span> <span class="pre">allowed</span></code> 。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>当打印未知的文件名时，使用下面的方法可以避免这样的错误：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bad_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">bad_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一小节讨论的是在编写必须处理文件系统的程序时一个不太常见但又很棘手的问题。
默认情况下，Python假定所有文件名都已经根据 <code class="docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code> 的值编码过了。
但是，有一些文件系统并没有强制要求这样做，因此允许创建文件名没有正确编码的文件。
这种情况不太常见，但是总会有些用户冒险这样做或者是无意之中这样做了(
可能是在一个有缺陷的代码中给 <code class="docutils literal"><span class="pre">open()</span></code> 函数传递了一个不合规范的文件名)。</p>
<p>当执行类似 <code class="docutils literal"><span class="pre">os.listdir()</span></code> 这样的函数时，这些不合规范的文件名就会让Python陷入困境。
一方面，它不能仅仅只是丢弃这些不合格的名字。而另一方面，它又不能将这些文件名转换为正确的文本字符串。
Python对这个问题的解决方案是从文件名中获取未解码的字节值比如 <code class="docutils literal"><span class="pre">\xhh</span></code>
并将它映射成Unicode字符 <code class="docutils literal"><span class="pre">\udchh</span></code> 表示的所谓的&#8221;代理编码&#8221;。
下面一个例子演示了当一个不合格目录列表中含有一个文件名为bäd.txt(使用Latin-1而不是UTF-8编码)时的样子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span>
<span class="go">[&#39;spam.py&#39;, &#39;b\udce4d.txt&#39;, &#39;foo.txt&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你有代码需要操作文件名或者将文件名传递给 <code class="docutils literal"><span class="pre">open()</span></code> 这样的函数，一切都能正常工作。
只有当你想要输出文件名时才会碰到些麻烦(比如打印输出到屏幕或日志文件等)。
特别的，当你想打印上面的文件名列表时，你的程序就会崩溃：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">spam.py</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">UnicodeEncodeError</span>: <span class="n">&#39;utf-8&#39; codec can&#39;t encode character &#39;\udce4&#39; in</span>
<span class="go">position 1: surrogates not allowed</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>程序崩溃的原因就是字符 <code class="docutils literal"><span class="pre">\udce4</span></code> 是一个非法的Unicode字符。
它其实是一个被称为代理字符对的双字符组合的后半部分。
由于缺少了前半部分，因此它是个非法的Unicode。
所以，唯一能成功输出的方法就是当遇到不合法文件名时采取相应的补救措施。
比如可以将上述代码修改如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
<span class="gp">... </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">bad_filename</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">spam.py</span>
<span class="go">b\udce4d.txt</span>
<span class="go">foo.txt</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">bad_filename()</span></code> 函数中怎样处置取决于你自己。
另外一个选择就是通过某种方式重新编码，示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bad_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getfilesystemencoding</span><span class="p">(),</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;surrogateescape&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">temp</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;latin-1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>译者注:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>surrogateescape:
这种是Python在绝大部分面向OS的API中所使用的错误处理器，
它能以一种优雅的方式处理由操作系统提供的数据的编码问题。
在解码出错时会将出错字节存储到一个很少被使用到的Unicode编码范围内。
在编码时将那些隐藏值又还原回原先解码失败的字节序列。
它不仅对于OS API非常有用，也能很容易的处理其他情况下的编码错误。
</pre></div>
</div>
<p>使用这个版本产生的输出如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">bad_filename</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">spam.py</span>
<span class="go">bäd.txt</span>
<span class="go">foo.txt</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这一小节主题可能会被大部分读者所忽略。但是如果你在编写依赖文件名和文件系统的关键任务程序时，
就必须得考虑到这个。否则你可能会在某个周末被叫到办公室去调试一些令人费解的错误。</p>
</div>
</div>
<span id="document-c05/p16_add_change_encoding_of_already_open_file"></span><div class="section" id="id1">
<h3>5.16 增加或改变已打开文件的编码<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在不关闭一个已打开的文件前提下增加或改变它的Unicode编码。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想给一个以二进制模式打开的文件添加Unicode编码/解码方式，
可以使用 <code class="docutils literal"><span class="pre">io.TextIOWrapper()</span></code> 对象包装它。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="kn">import</span> <span class="nn">io</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">TextIOWrapper</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你想修改一个已经打开的文本模式的文件的编码方式，可以先使用 <code class="docutils literal"><span class="pre">detach()</span></code> 方法移除掉已存在的文本编码层，
并使用新的编码方式代替。下面是一个在 <code class="docutils literal"><span class="pre">sys.stdout</span></code> 上修改编码方式的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">encoding</span>
<span class="go">&#39;UTF-8&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">TextIOWrapper</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;latin-1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">encoding</span>
<span class="go">&#39;latin-1&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这样做可能会中断你的终端，这里仅仅是为了演示而已。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>I/O系统由一系列的层次构建而成。你可以试着运行下面这个操作一个文本文件的例子来查看这种层次：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sample.txt&#39;</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;_io.TextIOWrapper name=&#39;sample.txt&#39; mode=&#39;w&#39; encoding=&#39;UTF-8&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">buffer</span>
<span class="go">&lt;_io.BufferedWriter name=&#39;sample.txt&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">raw</span>
<span class="go">&lt;_io.FileIO name=&#39;sample.txt&#39; mode=&#39;wb&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这个例子中，<code class="docutils literal"><span class="pre">io.TextIOWrapper</span></code> 是一个编码和解码Unicode的文本处理层，
<code class="docutils literal"><span class="pre">io.BufferedWriter</span></code> 是一个处理二进制数据的带缓冲的I/O层，
<code class="docutils literal"><span class="pre">io.FileIO</span></code> 是一个表示操作系统底层文件描述符的原始文件。
增加或改变文本编码会涉及增加或改变最上面的 <code class="docutils literal"><span class="pre">io.TextIOWrapper</span></code> 层。</p>
<p>一般来讲，像上面例子这样通过访问属性值来直接操作不同的层是很不安全的。
例如，如果你试着使用下面这样的技术改变编码看看会发生什么：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;_io.TextIOWrapper name=&#39;sample.txt&#39; mode=&#39;w&#39; encoding=&#39;UTF-8&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">TextIOWrapper</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;latin-1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;_io.TextIOWrapper name=&#39;sample.txt&#39; encoding=&#39;latin-1&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ValueError</span>: <span class="n">I/O operation on closed file.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>结果出错了，因为f的原始值已经被破坏了并关闭了底层的文件。</p>
<p><code class="docutils literal"><span class="pre">detach()</span></code> 方法会断开文件的最顶层并返回第二层，之后最顶层就没什么用了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sample.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;_io.TextIOWrapper name=&#39;sample.txt&#39; mode=&#39;w&#39; encoding=&#39;UTF-8&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&lt;_io.BufferedWriter name=&#39;sample.txt&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ValueError</span>: <span class="n">underlying buffer has been detached</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一旦断开最顶层后，你就可以给返回结果添加一个新的最顶层。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">TextIOWrapper</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;latin-1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;_io.TextIOWrapper name=&#39;sample.txt&#39; encoding=&#39;latin-1&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>尽管已经向你演示了改变编码的方法，
但是你还可以利用这种技术来改变文件行处理、错误机制以及文件处理的其他方面。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">TextIOWrapper</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;xmlcharrefreplace&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Jalape</span><span class="se">\u00f1</span><span class="s1">o&#39;</span><span class="p">)</span>
<span class="go">Jalape&amp;#241;o</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意下最后输出中的非ASCII字符 <code class="docutils literal"><span class="pre">ñ</span></code> 是如何被 <code class="docutils literal"><span class="pre">&amp;#241;</span></code> 取代的。</p>
</div>
</div>
<span id="document-c05/p17_write_bytes_to_text_file"></span><div class="section" id="id1">
<h3>5.17 将字节写入文本文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在文本模式打开的文件中写入原始的字节数据。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>将字节数据直接写入文件的缓冲区即可，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">must be str, not bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Hello</span>
<span class="go">5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>类似的，能够通过读取文本文件的 <code class="docutils literal"><span class="pre">buffer</span></code> 属性来读取二进制数据。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>I/O系统以层级结构的形式构建而成。
文本文件是通过在一个拥有缓冲的二进制模式文件上增加一个Unicode编码/解码层来创建。
<code class="docutils literal"><span class="pre">buffer</span></code> 属性指向对应的底层文件。如果你直接访问它的话就会绕过文本编码/解码层。</p>
<p>本小节例子展示的 <code class="docutils literal"><span class="pre">sys.stdout</span></code> 可能看起来有点特殊。
默认情况下，<code class="docutils literal"><span class="pre">sys.stdout</span></code> 总是以文本模式打开的。
但是如果你在写一个需要打印二进制数据到标准输出的脚本的话，你可以使用上面演示的技术来绕过文本编码层。</p>
</div>
</div>
<span id="document-c05/p18_wrap_existing_file_descriptor_as_file_object"></span><div class="section" id="id1">
<h3>5.18 将文件描述符包装成文件对象<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个对应于操作系统上一个已打开的I/O通道(比如文件、管道、套接字等)的整型文件描述符，
你想将它包装成一个更高层的Python文件对象。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>一个文件描述符和一个打开的普通文件是不一样的。
文件描述符仅仅是一个由操作系统指定的整数，用来指代某个系统的I/O通道。
如果你碰巧有这么一个文件描述符，你可以通过使用 <code class="docutils literal"><span class="pre">open()</span></code> 函数来将其包装为一个Python的文件对象。
你仅仅只需要使用这个整数值的文件描述符作为第一个参数来代替文件名即可。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Open a low-level file descriptor</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_CREAT</span><span class="p">)</span>

<span class="c1"># Turn into a proper file</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello world</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>当高层的文件对象被关闭或者破坏的时候，底层的文件描述符也会被关闭。
如果这个并不是你想要的结果，你可以给 <code class="docutils literal"><span class="pre">open()</span></code> 函数传递一个可选的 <code class="docutils literal"><span class="pre">colsefd=False</span></code> 。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Create a file object, but don&#39;t close underlying fd when done</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在Unix系统中，这种包装文件描述符的技术可以很方便的将一个类文件接口作用于一个以不同方式打开的I/O通道上，
如管道、套接字等。举例来讲，下面是一个操作管道的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>

    <span class="c1"># Make text-mode file wrappers for socket reading/writing</span>
    <span class="n">client_in</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">client_sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;latin-1&#39;</span><span class="p">,</span>
                <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">client_out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">client_sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="s1">&#39;wt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;latin-1&#39;</span><span class="p">,</span>
                <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c1"># Echo lines back to the client using file I/O</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">client_in</span><span class="p">:</span>
        <span class="n">client_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">client_out</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="n">client_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">echo_client</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
</pre></div>
</div>
<p>需要重点强调的一点是，上面的例子仅仅是为了演示内置的 <code class="docutils literal"><span class="pre">open()</span></code> 函数的一个特性，并且也只适用于基于Unix的系统。
如果你想将一个类文件接口作用在一个套接字并希望你的代码可以跨平台，请使用套接字对象的 <code class="docutils literal"><span class="pre">makefile()</span></code> 方法。
但是如果不考虑可移植性的话，那上面的解决方案会比使用 <code class="docutils literal"><span class="pre">makefile()</span></code> 性能更好一点。</p>
<p>你也可以使用这种技术来构造一个别名，允许以不同于第一次打开文件的方式使用它。
例如，下面演示如何创建一个文件对象，它允许你输出二进制数据到标准输出(通常以文本模式打开)：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="c1"># Create a binary-mode file for stdout</span>
<span class="n">bstdout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="s1">&#39;wb&#39;</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">bstdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">bstdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<p>尽管可以将一个已存在的文件描述符包装成一个正常的文件对象，
但是要注意的是并不是所有的文件模式都被支持，并且某些类型的文件描述符可能会有副作用
(特别是涉及到错误处理、文件结尾条件等等的时候)。
在不同的操作系统上这种行为也是不一样，特别的，上面的例子都不能在非Unix系统上运行。
我说了这么多，意思就是让你充分测试自己的实现代码，确保它能按照期望工作。</p>
</div>
</div>
<span id="document-c05/p19_make_temporary_files_and_directories"></span><div class="section" id="id1">
<h3>5.19 创建临时文件和文件夹<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要在程序执行时创建一个临时文件或目录，并希望使用完之后可以自动销毁掉。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">tempfile</span></code> 模块中有很多的函数可以完成这任务。
为了创建一个匿名的临时文件，可以使用 <code class="docutils literal"><span class="pre">tempfile.TemporaryFile</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">TemporaryFile</span>

<span class="k">with</span> <span class="n">TemporaryFile</span><span class="p">(</span><span class="s1">&#39;w+t&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># Read/write to the file</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Hello World</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Testing</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Seek back to beginning and read the data</span>
    <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># Temporary file is destroyed</span>
</pre></div>
</div>
<p>或者，如果你喜欢，你还可以像这样使用临时文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">TemporaryFile</span><span class="p">(</span><span class="s1">&#39;w+t&#39;</span><span class="p">)</span>
<span class="c1"># Use the temporary file</span>
<span class="o">...</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c1"># File is destroyed</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">TemporaryFile()</span></code> 的第一个参数是文件模式，通常来讲文本模式使用 <code class="docutils literal"><span class="pre">w+t</span></code> ，二进制模式使用 <code class="docutils literal"><span class="pre">w+b</span></code> 。
这个模式同时支持读和写操作，在这里是很有用的，因为当你关闭文件去改变模式的时候，文件实际上已经不存在了。
<code class="docutils literal"><span class="pre">TemporaryFile()</span></code> 另外还支持跟内置的 <code class="docutils literal"><span class="pre">open()</span></code> 函数一样的参数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">TemporaryFile</span><span class="p">(</span><span class="s1">&#39;w+t&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>在大多数Unix系统上，通过 <code class="docutils literal"><span class="pre">TemporaryFile()</span></code> 创建的文件都是匿名的，甚至连目录都没有。
如果你想打破这个限制，可以使用 <code class="docutils literal"><span class="pre">NamedTemporaryFile()</span></code> 来代替。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">NamedTemporaryFile</span>

<span class="k">with</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w+t&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;filename is:&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="o">...</span>

<span class="c1"># File automatically destroyed</span>
</pre></div>
</div>
<p>这里，被打开文件的 <code class="docutils literal"><span class="pre">f.name</span></code> 属性包含了该临时文件的文件名。
当你需要将文件名传递给其他代码来打开这个文件的时候，这个就很有用了。
和 <code class="docutils literal"><span class="pre">TemporaryFile()</span></code> 一样，结果文件关闭时会被自动删除掉。
如果你不想这么做，可以传递一个关键字参数 <code class="docutils literal"><span class="pre">delete=False</span></code> 即可。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w+t&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;filename is:&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>为了创建一个临时目录，可以使用 <code class="docutils literal"><span class="pre">tempfile.TemporaryDirectory()</span></code> 。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">TemporaryDirectory</span>

<span class="k">with</span> <span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">dirname</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;dirname is:&#39;</span><span class="p">,</span> <span class="n">dirname</span><span class="p">)</span>
    <span class="c1"># Use the directory</span>
    <span class="o">...</span>
<span class="c1"># Directory and all contents destroyed</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">TemporaryFile()</span></code> 、<code class="docutils literal"><span class="pre">NamedTemporaryFile()</span></code> 和 <code class="docutils literal"><span class="pre">TemporaryDirectory()</span></code> 函数
应该是处理临时文件目录的最简单的方式了，因为它们会自动处理所有的创建和清理步骤。
在一个更低的级别，你可以使用 <code class="docutils literal"><span class="pre">mkstemp()</span></code> 和 <code class="docutils literal"><span class="pre">mkdtemp()</span></code> 来创建临时文件和目录。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">()</span>
<span class="go">(3, &#39;/var/folders/7W/7WZl5sfZEF0pljrEB1UMWE+++TI/-Tmp-/tmp7fefhv&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
<span class="go">&#39;/var/folders/7W/7WZl5sfZEF0pljrEB1UMWE+++TI/-Tmp-/tmp5wvcv6&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但是，这些函数并不会做进一步的管理了。
例如，函数 <code class="docutils literal"><span class="pre">mkstemp()</span></code> 仅仅就返回一个原始的OS文件描述符，你需要自己将它转换为一个真正的文件对象。
同样你还需要自己清理这些文件。</p>
<p>通常来讲，临时文件在系统默认的位置被创建，比如 <code class="docutils literal"><span class="pre">/var/tmp</span></code> 或类似的地方。
为了获取真实的位置，可以使用 <code class="docutils literal"><span class="pre">tempfile.gettempdir()</span></code> 函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">()</span>
<span class="go">&#39;/var/folders/7W/7WZl5sfZEF0pljrEB1UMWE+++TI/-Tmp-&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>所有和临时文件相关的函数都允许你通过使用关键字参数
<code class="docutils literal"><span class="pre">prefix</span></code> 、<code class="docutils literal"><span class="pre">suffix</span></code> 和 <code class="docutils literal"><span class="pre">dir</span></code> 来自定义目录以及命名规则。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;mytemp&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;/tmp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;/tmp/mytemp8ee899.txt&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后还有一点，尽可能以最安全的方式使用 <code class="docutils literal"><span class="pre">tempfile</span></code> 模块来创建临时文件。
包括仅给当前用户授权访问以及在文件创建过程中采取措施避免竞态条件。
要注意的是不同的平台可能会不一样。因此你最好阅读
<a class="reference external" href="https://docs.python.org/3/library/tempfile.html">官方文档</a> 来了解更多的细节。</p>
</div>
</div>
<span id="document-c05/p20_communicating_with_serial_ports"></span><div class="section" id="id1">
<h3>5.20 与串行端口的数据通信<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想通过串行端口读写数据，典型场景就是和一些硬件设备打交道(比如一个机器人或传感器)。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>尽管你可以通过使用Python内置的I/O模块来完成这个任务，但对于串行通信最好的选择是使用
<a class="reference external" href="http://pyserial.sourceforge.net/">pySerial包</a> 。
这个包的使用非常简单，先安装pySerial，使用类似下面这样的代码就能很容易的打开一个串行端口：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">serial</span>
<span class="n">ser</span> <span class="o">=</span> <span class="n">serial</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span><span class="s1">&#39;/dev/tty.usbmodem641&#39;</span><span class="p">,</span> <span class="c1"># Device name varies</span>
                    <span class="n">baudrate</span><span class="o">=</span><span class="mi">9600</span><span class="p">,</span>
                    <span class="n">bytesize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                    <span class="n">parity</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span>
                    <span class="n">stopbits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>设备名对于不同的设备和操作系统是不一样的。
比如，在Windows系统上，你可以使用0, 1等表示的一个设备来打开通信端口&#8221;COM0&#8221;和&#8221;COM1&#8221;。
一旦端口打开，那就可以使用 <code class="docutils literal"><span class="pre">read()</span></code>，<code class="docutils literal"><span class="pre">readline()</span></code> 和 <code class="docutils literal"><span class="pre">write()</span></code> 函数读写数据了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ser</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;G1 X50 Y50</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</pre></div>
</div>
<p>大多数情况下，简单的串口通信从此变得十分简单。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>尽管表面上看起来很简单，其实串口通信有时候也是挺麻烦的。
推荐你使用第三方包如 <code class="docutils literal"><span class="pre">pySerial</span></code> 的一个原因是它提供了对高级特性的支持
(比如超时，控制流，缓冲区刷新，握手协议等等)。举个例子，如果你想启用 <code class="docutils literal"><span class="pre">RTS-CTS</span></code> 握手协议，
你只需要给 <code class="docutils literal"><span class="pre">Serial()</span></code> 传递一个 <code class="docutils literal"><span class="pre">rtscts=True</span></code> 的参数即可。
其官方文档非常完善，因此我在这里极力推荐这个包。</p>
<p>时刻记住所有涉及到串口的I/O都是二进制模式的。因此，确保你的代码使用的是字节而不是文本
(或有时候执行文本的编码/解码操作)。
另外当你需要创建二进制编码的指令或数据包的时候，<code class="docutils literal"><span class="pre">struct</span></code> 模块也是非常有用的。</p>
</div>
</div>
<span id="document-c05/p21_serializing_python_objects"></span><div class="section" id="python">
<h3>5.21 序列化Python对象<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你需要将一个Python对象序列化为一个字节流，以便将它保存到一个文件、存储到数据库或者通过网络传输它。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>对于序列化最普遍的做法就是使用 <code class="docutils literal"><span class="pre">pickle</span></code> 模块。为了将一个对象保存到一个文件中，可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">data</span> <span class="o">=</span> <span class="o">...</span> <span class="c1"># Some Python object</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>为了将一个对象转储为一个字符串，可以使用 <code class="docutils literal"><span class="pre">pickle.dumps()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>为了从字节流中恢复一个对象，使用 <code class="docutils literal"><span class="pre">picle.load()</span></code> 或 <code class="docutils literal"><span class="pre">pickle.loads()</span></code> 函数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Restore from a file</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somefile&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="c1"># Restore from a string</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于大多数应用程序来讲，<code class="docutils literal"><span class="pre">dump()</span></code> 和 <code class="docutils literal"><span class="pre">load()</span></code> 函数的使用就是你有效使用 <code class="docutils literal"><span class="pre">pickle</span></code> 模块所需的全部了。
它可适用于绝大部分Python数据类型和用户自定义类的对象实例。
如果你碰到某个库可以让你在数据库中保存/恢复Python对象或者是通过网络传输对象的话，
那么很有可能这个库的底层就使用了 <code class="docutils literal"><span class="pre">pickle</span></code> 模块。</p>
<p><code class="docutils literal"><span class="pre">pickle</span></code> 是一种Python特有的自描述的数据编码。
通过自描述，被序列化后的数据包含每个对象开始和结束以及它的类型信息。
因此，你无需担心对象记录的定义，它总是能工作。
举个例子，如果要处理多个对象，你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somedata&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="s1">&#39;Apple&#39;</span><span class="p">,</span> <span class="s1">&#39;Pear&#39;</span><span class="p">,</span> <span class="s1">&#39;Banana&#39;</span><span class="p">},</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;somedata&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">&#39;hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">{&#39;Apple&#39;, &#39;Pear&#39;, &#39;Banana&#39;}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你还能序列化函数，类，还有接口，但是结果数据仅仅将它们的名称编码成对应的代码对象。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">)</span>
<span class="go">b&#39;\x80\x03cmath\ncos\nq\x00.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当数据反序列化回来的时候，会先假定所有的源数据时可用的。
模块、类和函数会自动按需导入进来。对于Python数据被不同机器上的解析器所共享的应用程序而言，
数据的保存可能会有问题，因为所有的机器都必须访问同一个源代码。</p>
<p>注</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>千万不要对不信任的数据使用pickle.load()。
pickle在加载时有一个副作用就是它会自动加载相应模块并构造实例对象。
但是某个坏人如果知道pickle的工作原理，
他就可以创建一个恶意的数据导致Python执行随意指定的系统命令。
因此，一定要保证pickle只在相互之间可以认证对方的解析器的内部使用。
</pre></div>
</div>
<p>有些类型的对象是不能被序列化的。这些通常是那些依赖外部系统状态的对象，
比如打开的文件，网络连接，线程，进程，栈帧等等。
用户自定义类可以通过提供 <code class="docutils literal"><span class="pre">__getstate__()</span></code> 和 <code class="docutils literal"><span class="pre">__setstate__()</span></code> 方法来绕过这些限制。
如果定义了这两个方法，<code class="docutils literal"><span class="pre">pickle.dump()</span></code> 就会调用 <code class="docutils literal"><span class="pre">__getstate__()</span></code> 获取序列化的对象。
类似的，<code class="docutils literal"><span class="pre">__setstate__()</span></code> 在反序列化时被调用。为了演示这个工作原理，
下面是一个在内部定义了一个线程但仍然可以序列化和反序列化的类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># countdown.py</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="k">class</span> <span class="nc">Countdown</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thr</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thr</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thr</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;T-minus&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>试着运行下面的序列化试验代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">countdown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">countdown</span><span class="o">.</span><span class="n">Countdown</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">30</span>
<span class="go">T-minus 29</span>
<span class="go">T-minus 28</span>
<span class="gp">...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># After a few moments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;cstate.p&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>然后退出Python解析器并重启后再试验下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;cstate.p&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">countdown.Countdown object at 0x10069e2d0&gt;</span>
<span class="go">T-minus 19</span>
<span class="go">T-minus 18</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>你可以看到线程又奇迹般的重生了，从你第一次序列化它的地方又恢复过来。</p>
<p><code class="docutils literal"><span class="pre">pickle</span></code> 对于大型的数据结构比如使用 <code class="docutils literal"><span class="pre">array</span></code> 或 <code class="docutils literal"><span class="pre">numpy</span></code>
模块创建的二进制数组效率并不是一个高效的编码方式。
如果你需要移动大量的数组数据，你最好是先在一个文件中将其保存为数组数据块或使用更高级的标准编码方式如HDF5
(需要第三方库的支持)。</p>
<p>由于 <code class="docutils literal"><span class="pre">pickle</span></code> 是Python特有的并且附着在源码上，所有如果需要长期存储数据的时候不应该选用它。
例如，如果源码变动了，你所有的存储数据可能会被破坏并且变得不可读取。
坦白来讲，对于在数据库和存档文件中存储数据时，你最好使用更加标准的数据编码格式如XML，CSV或JSON。
这些编码格式更标准，可以被不同的语言支持，并且也能很好的适应源码变更。</p>
<p>最后一点要注意的是  <code class="docutils literal"><span class="pre">pickle</span></code> 有大量的配置选项和一些棘手的问题。
对于最常见的使用场景，你不需要去担心这个，但是如果你要在一个重要的程序中使用pickle去做序列化的话，
最好去查阅一下 <a class="reference external" href="https://docs.python.org/3/library/pickle.html">官方文档</a> 。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p06_data_encoding_and_process"></span><div class="section" id="id1">
<h2>第六章：数据编码和处理<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>这一章主要讨论使用Python处理各种不同方式编码的数据，比如CSV文件，JSON，XML和二进制包装记录。
和数据结构那一章不同的是，这章不会讨论特殊的算法问题，而是关注于怎样获取和存储这些格式的数据。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c06/p01_read_write_csv_data"></span><div class="section" id="csv">
<h3>6.1 读写CSV数据<a class="headerlink" href="#csv" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想读写一个CSV格式的文件。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>对于大多数的CSV格式的数据读写问题，都可以使用 <code class="docutils literal"><span class="pre">csv</span></code> 库。
例如：假设你在一个名叫stocks.csv文件中有一些股票市场数据，就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Symbol</span><span class="p">,</span><span class="n">Price</span><span class="p">,</span><span class="n">Date</span><span class="p">,</span><span class="n">Time</span><span class="p">,</span><span class="n">Change</span><span class="p">,</span><span class="n">Volume</span>
<span class="s2">&quot;AA&quot;</span><span class="p">,</span><span class="mf">39.48</span><span class="p">,</span><span class="s2">&quot;6/11/2007&quot;</span><span class="p">,</span><span class="s2">&quot;9:36am&quot;</span><span class="p">,</span><span class="o">-</span><span class="mf">0.18</span><span class="p">,</span><span class="mi">181800</span>
<span class="s2">&quot;AIG&quot;</span><span class="p">,</span><span class="mf">71.38</span><span class="p">,</span><span class="s2">&quot;6/11/2007&quot;</span><span class="p">,</span><span class="s2">&quot;9:36am&quot;</span><span class="p">,</span><span class="o">-</span><span class="mf">0.15</span><span class="p">,</span><span class="mi">195500</span>
<span class="s2">&quot;AXP&quot;</span><span class="p">,</span><span class="mf">62.58</span><span class="p">,</span><span class="s2">&quot;6/11/2007&quot;</span><span class="p">,</span><span class="s2">&quot;9:36am&quot;</span><span class="p">,</span><span class="o">-</span><span class="mf">0.46</span><span class="p">,</span><span class="mi">935000</span>
<span class="s2">&quot;BA&quot;</span><span class="p">,</span><span class="mf">98.31</span><span class="p">,</span><span class="s2">&quot;6/11/2007&quot;</span><span class="p">,</span><span class="s2">&quot;9:36am&quot;</span><span class="p">,</span><span class="o">+</span><span class="mf">0.12</span><span class="p">,</span><span class="mi">104800</span>
<span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="mf">53.08</span><span class="p">,</span><span class="s2">&quot;6/11/2007&quot;</span><span class="p">,</span><span class="s2">&quot;9:36am&quot;</span><span class="p">,</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span><span class="mi">360900</span>
<span class="s2">&quot;CAT&quot;</span><span class="p">,</span><span class="mf">78.29</span><span class="p">,</span><span class="s2">&quot;6/11/2007&quot;</span><span class="p">,</span><span class="s2">&quot;9:36am&quot;</span><span class="p">,</span><span class="o">-</span><span class="mf">0.23</span><span class="p">,</span><span class="mi">225400</span>
</pre></div>
</div>
<p>下面向你展示如何将这些数据读取为一个元组的序列：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">csv</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stocks.csv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f_csv</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f_csv</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">f_csv</span><span class="p">:</span>
        <span class="c1"># Process row</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>在上面的代码中， <code class="docutils literal"><span class="pre">row</span></code> 会是一个列表。因此，为了访问某个字段，你需要使用下标，如 <code class="docutils literal"><span class="pre">row[0]</span></code> 访问Symbol， <code class="docutils literal"><span class="pre">row[4]</span></code> 访问Change。</p>
<p>由于这种下标访问通常会引起混淆，你可以考虑使用命名元组。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stock.csv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f_csv</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">headings</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f_csv</span><span class="p">)</span>
    <span class="n">Row</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Row&#39;</span><span class="p">,</span> <span class="n">headings</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f_csv</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
        <span class="c1"># Process row</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>它允许你使用列名如 <code class="docutils literal"><span class="pre">row.Symbol</span></code> 和 <code class="docutils literal"><span class="pre">row.Change</span></code> 代替下标访问。
需要注意的是这个只有在列名是合法的Python标识符的时候才生效。如果不是的话，
你可能需要修改下原始的列名(如将非标识符字符替换成下划线之类的)。</p>
<p>另外一个选择就是将数据读取到一个字典序列中去。可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">csv</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stocks.csv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f_csv</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">DictReader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">f_csv</span><span class="p">:</span>
        <span class="c1"># process row</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>在这个版本中，你可以使用列名去访问每一行的数据了。比如，<code class="docutils literal"><span class="pre">row['Symbol']</span></code> 或者 <code class="docutils literal"><span class="pre">row['Change']</span></code></p>
<p>为了写入CSV数据，你仍然可以使用csv模块，不过这时候先创建一个 <code class="docutils literal"><span class="pre">writer</span></code> 对象。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Symbol&#39;</span><span class="p">,</span><span class="s1">&#39;Price&#39;</span><span class="p">,</span><span class="s1">&#39;Date&#39;</span><span class="p">,</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span><span class="s1">&#39;Change&#39;</span><span class="p">,</span><span class="s1">&#39;Volume&#39;</span><span class="p">]</span>
<span class="n">rows</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;AA&#39;</span><span class="p">,</span> <span class="mf">39.48</span><span class="p">,</span> <span class="s1">&#39;6/11/2007&#39;</span><span class="p">,</span> <span class="s1">&#39;9:36am&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.18</span><span class="p">,</span> <span class="mi">181800</span><span class="p">),</span>
         <span class="p">(</span><span class="s1">&#39;AIG&#39;</span><span class="p">,</span> <span class="mf">71.38</span><span class="p">,</span> <span class="s1">&#39;6/11/2007&#39;</span><span class="p">,</span> <span class="s1">&#39;9:36am&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.15</span><span class="p">,</span> <span class="mi">195500</span><span class="p">),</span>
         <span class="p">(</span><span class="s1">&#39;AXP&#39;</span><span class="p">,</span> <span class="mf">62.58</span><span class="p">,</span> <span class="s1">&#39;6/11/2007&#39;</span><span class="p">,</span> <span class="s1">&#39;9:36am&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.46</span><span class="p">,</span> <span class="mi">935000</span><span class="p">),</span>
       <span class="p">]</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stocks.csv&#39;</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f_csv</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">f_csv</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span>
    <span class="n">f_csv</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你有一个字典序列的数据，可以像这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Symbol&#39;</span><span class="p">,</span> <span class="s1">&#39;Price&#39;</span><span class="p">,</span> <span class="s1">&#39;Date&#39;</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Change&#39;</span><span class="p">,</span> <span class="s1">&#39;Volume&#39;</span><span class="p">]</span>
<span class="n">rows</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;Symbol&#39;</span><span class="p">:</span><span class="s1">&#39;AA&#39;</span><span class="p">,</span> <span class="s1">&#39;Price&#39;</span><span class="p">:</span><span class="mf">39.48</span><span class="p">,</span> <span class="s1">&#39;Date&#39;</span><span class="p">:</span><span class="s1">&#39;6/11/2007&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Time&#39;</span><span class="p">:</span><span class="s1">&#39;9:36am&#39;</span><span class="p">,</span> <span class="s1">&#39;Change&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.18</span><span class="p">,</span> <span class="s1">&#39;Volume&#39;</span><span class="p">:</span><span class="mi">181800</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;Symbol&#39;</span><span class="p">:</span><span class="s1">&#39;AIG&#39;</span><span class="p">,</span> <span class="s1">&#39;Price&#39;</span><span class="p">:</span> <span class="mf">71.38</span><span class="p">,</span> <span class="s1">&#39;Date&#39;</span><span class="p">:</span><span class="s1">&#39;6/11/2007&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Time&#39;</span><span class="p">:</span><span class="s1">&#39;9:36am&#39;</span><span class="p">,</span> <span class="s1">&#39;Change&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.15</span><span class="p">,</span> <span class="s1">&#39;Volume&#39;</span><span class="p">:</span> <span class="mi">195500</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;Symbol&#39;</span><span class="p">:</span><span class="s1">&#39;AXP&#39;</span><span class="p">,</span> <span class="s1">&#39;Price&#39;</span><span class="p">:</span> <span class="mf">62.58</span><span class="p">,</span> <span class="s1">&#39;Date&#39;</span><span class="p">:</span><span class="s1">&#39;6/11/2007&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Time&#39;</span><span class="p">:</span><span class="s1">&#39;9:36am&#39;</span><span class="p">,</span> <span class="s1">&#39;Change&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.46</span><span class="p">,</span> <span class="s1">&#39;Volume&#39;</span><span class="p">:</span> <span class="mi">935000</span><span class="p">},</span>
        <span class="p">]</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stocks.csv&#39;</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f_csv</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">DictWriter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
    <span class="n">f_csv</span><span class="o">.</span><span class="n">writeheader</span><span class="p">()</span>
    <span class="n">f_csv</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>你应该总是优先选择csv模块分割或解析CSV数据。例如，你可能会像编写类似下面这样的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stocks.csv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
    <span class="c1"># process row</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>使用这种方式的一个缺点就是你仍然需要去处理一些棘手的细节问题。
比如，如果某些字段值被引号包围，你不得不去除这些引号。
另外，如果一个被引号包围的字段碰巧含有一个逗号，那么程序就会因为产生一个错误大小的行而出错。</p>
<p>默认情况下，<code class="docutils literal"><span class="pre">csv</span></code> 库可识别Microsoft Excel所使用的CSV编码规则。
这或许也是最常见的形式，并且也会给你带来最好的兼容性。
然而，如果你查看csv的文档，就会发现有很多种方法将它应用到其他编码格式上(如修改分割字符等)。
例如，如果你想读取以tab分割的数据，可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Example of reading tab-separated values</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stock.tsv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f_tsv</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">f_tsv</span><span class="p">:</span>
        <span class="c1"># Process row</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>如果你正在读取CSV数据并将它们转换为命名元组，需要注意对列名进行合法性认证。
例如，一个CSV格式文件有一个包含非法标识符的列头行，类似下面这样：</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Street Address,Num-Premises,Latitude,Longitude 5412 N CLARK,10,41.980262,-87.668452
</pre></div>
</div>
<p>这样最终会导致在创建一个命名元组时产生一个 <code class="docutils literal"><span class="pre">ValueError</span></code> 异常而失败。
为了解决这问题，你可能不得不先去修正列标题。
例如，可以像下面这样在非法标识符上使用一个正则表达式替换：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stock.csv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f_csv</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[^a-zA-Z_]&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">next</span><span class="p">(</span><span class="n">f_csv</span><span class="p">)</span> <span class="p">]</span>
    <span class="n">Row</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Row&#39;</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f_csv</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
        <span class="c1"># Process row</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>还有重要的一点需要强调的是，csv产生的数据都是字符串类型的，它不会做任何其他类型的转换。
如果你需要做这样的类型转换，你必须自己手动去实现。
下面是一个在CSV数据上执行其他类型转换的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">col_types</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stocks.csv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f_csv</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f_csv</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">f_csv</span><span class="p">:</span>
        <span class="c1"># Apply conversions to the row items</span>
        <span class="n">row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">convert</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">col_types</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>另外，下面是一个转换字典中特定字段的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Reading as dicts with type conversion&#39;</span><span class="p">)</span>
<span class="n">field_types</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;Price&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;Change&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;Volume&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="p">]</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;stocks.csv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv</span><span class="o">.</span><span class="n">DictReader</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">conversion</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">conversion</span> <span class="ow">in</span> <span class="n">field_types</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>通常来讲，你可能并不想过多去考虑这些转换问题。
在实际情况中，CSV文件都或多或少有些缺失的数据，被破坏的数据以及其它一些让转换失败的问题。
因此，除非你的数据确实有保障是准确无误的，否则你必须考虑这些问题(你可能需要增加合适的错误处理机制)。</p>
<p>最后，如果你读取CSV数据的目的是做数据分析和统计的话，
你可能需要看一看 <code class="docutils literal"><span class="pre">Pandas</span></code> 包。<code class="docutils literal"><span class="pre">Pandas</span></code> 包含了一个非常方便的函数叫 <code class="docutils literal"><span class="pre">pandas.read_csv()</span></code> ，
它可以加载CSV数据到一个 <code class="docutils literal"><span class="pre">DataFrame</span></code> 对象中去。
然后利用这个对象你就可以生成各种形式的统计、过滤数据以及执行其他高级操作了。
在6.13小节中会有这样一个例子。</p>
</div>
</div>
<span id="document-c06/p02_read-write_json_data"></span><div class="section" id="json">
<h3>6.2 读写JSON数据<a class="headerlink" href="#json" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想读写JSON(JavaScript Object Notation)编码格式的数据。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">json</span></code> 模块提供了一种很简单的方式来编码和解码JSON数据。
其中两个主要的函数是 <code class="docutils literal"><span class="pre">json.dumps()</span></code> 和 <code class="docutils literal"><span class="pre">json.loads()</span></code> ，
要比其他序列化函数库如pickle的接口少得多。
下面演示如何将一个Python数据结构转换为JSON：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">json</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="s1">&#39;ACME&#39;</span><span class="p">,</span>
    <span class="s1">&#39;shares&#39;</span> <span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="s1">&#39;price&#39;</span> <span class="p">:</span> <span class="mf">542.23</span>
<span class="p">}</span>

<span class="n">json_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>下面演示如何将一个JSON编码的字符串转换回一个Python数据结构：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_str</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你要处理的是文件而不是字符串，你可以使用 <code class="docutils literal"><span class="pre">json.dump()</span></code> 和 <code class="docutils literal"><span class="pre">json.load()</span></code> 来编码和解码JSON数据。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Writing JSON data</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.json&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

<span class="c1"># Reading data back</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.json&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>JSON编码支持的基本数据类型为 <code class="docutils literal"><span class="pre">None</span></code> ， <code class="docutils literal"><span class="pre">bool</span></code> ， <code class="docutils literal"><span class="pre">int</span></code> ， <code class="docutils literal"><span class="pre">float</span></code> 和 <code class="docutils literal"><span class="pre">str</span></code> ，
以及包含这些类型数据的lists，tuples和dictionaries。
对于dictionaries，keys需要是字符串类型(字典中任何非字符串类型的key在编码时会先转换为字符串)。
为了遵循JSON规范，你应该只编码Python的lists和dictionaries。
而且，在web应用程序中，顶层对象被编码为一个字典是一个标准做法。</p>
<p>JSON编码的格式对于Python语法而已几乎是完全一样的，除了一些小的差异之外。
比如，True会被映射为true，False被映射为false，而None会被映射为null。
下面是一个例子，演示了编码后的字符串效果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="go">&#39;false&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;Hello&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;{&quot;b&quot;: &quot;Hello&quot;, &quot;c&quot;: null, &quot;a&quot;: true}&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你试着去检查JSON解码后的数据，你通常很难通过简单的打印来确定它的结构，
特别是当数据的嵌套结构层次很深或者包含大量的字段时。
为了解决这个问题，可以考虑使用pprint模块的 <code class="docutils literal"><span class="pre">pprint()</span></code> 函数来代替普通的 <code class="docutils literal"><span class="pre">print()</span></code> 函数。
它会按照key的字母顺序并以一种更加美观的方式输出。
下面是一个演示如何漂亮的打印输出Twitter上搜索结果的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://search.twitter.com/search.json?q=python&amp;rpp=5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resp</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
<span class="go">{&#39;completed_in&#39;: 0.074,</span>
<span class="go">&#39;max_id&#39;: 264043230692245504,</span>
<span class="go">&#39;max_id_str&#39;: &#39;264043230692245504&#39;,</span>
<span class="go">&#39;next_page&#39;: &#39;?page=2&amp;max_id=264043230692245504&amp;q=python&amp;rpp=5&#39;,</span>
<span class="go">&#39;page&#39;: 1,</span>
<span class="go">&#39;query&#39;: &#39;python&#39;,</span>
<span class="go">&#39;refresh_url&#39;: &#39;?since_id=264043230692245504&amp;q=python&#39;,</span>
<span class="go">&#39;results&#39;: [{&#39;created_at&#39;: &#39;Thu, 01 Nov 2012 16:36:26 +0000&#39;,</span>
<span class="go">            &#39;from_user&#39;: ...</span>
<span class="go">            },</span>
<span class="go">            {&#39;created_at&#39;: &#39;Thu, 01 Nov 2012 16:36:14 +0000&#39;,</span>
<span class="go">            &#39;from_user&#39;: ...</span>
<span class="go">            },</span>
<span class="go">            {&#39;created_at&#39;: &#39;Thu, 01 Nov 2012 16:36:13 +0000&#39;,</span>
<span class="go">            &#39;from_user&#39;: ...</span>
<span class="go">            },</span>
<span class="go">            {&#39;created_at&#39;: &#39;Thu, 01 Nov 2012 16:36:07 +0000&#39;,</span>
<span class="go">            &#39;from_user&#39;: ...</span>
<span class="go">            }</span>
<span class="go">            {&#39;created_at&#39;: &#39;Thu, 01 Nov 2012 16:36:04 +0000&#39;,</span>
<span class="go">            &#39;from_user&#39;: ...</span>
<span class="go">            }],</span>
<span class="go">&#39;results_per_page&#39;: 5,</span>
<span class="go">&#39;since_id&#39;: 0,</span>
<span class="go">&#39;since_id_str&#39;: &#39;0&#39;}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一般来讲，JSON解码会根据提供的数据创建dicts或lists。
如果你想要创建其他类型的对象，可以给 <code class="docutils literal"><span class="pre">json.loads()</span></code> 传递object_pairs_hook或object_hook参数。
例如，下面是演示如何解码JSON数据并在一个OrderedDict中保留其顺序的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;{&quot;name&quot;: &quot;ACME&quot;, &quot;shares&quot;: 50, &quot;price&quot;: 490.1}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object_pairs_hook</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">OrderedDict([(&#39;name&#39;, &#39;ACME&#39;), (&#39;shares&#39;, 50), (&#39;price&#39;, 490.1)])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>下面是如何将一个JSON字典转换为一个Python对象例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">JSONObject</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object_hook</span><span class="o">=</span><span class="n">JSONObject</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;ACME&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">shares</span>
<span class="go">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">price</span>
<span class="go">490.1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后一个例子中，JSON解码后的字典作为一个单个参数传递给 <code class="docutils literal"><span class="pre">__init__()</span></code> 。
然后，你就可以随心所欲的使用它了，比如作为一个实例字典来直接使用它。</p>
<p>在编码JSON的时候，还有一些选项很有用。
如果你想获得漂亮的格式化字符串后输出，可以使用 <code class="docutils literal"><span class="pre">json.dumps()</span></code> 的indent参数。
它会使得输出和pprint()函数效果类似。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">{&quot;price&quot;: 542.23, &quot;name&quot;: &quot;ACME&quot;, &quot;shares&quot;: 100}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="go">{</span>
<span class="go">    &quot;price&quot;: 542.23,</span>
<span class="go">    &quot;name&quot;: &quot;ACME&quot;,</span>
<span class="go">    &quot;shares&quot;: 100</span>
<span class="go">}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对象实例通常并不是JSON可序列化的。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/json/__init__.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">226</span><span class="p">,</span> <span class="ow">in</span> <span class="n">dumps</span>
        <span class="k">return</span> <span class="n">_default_encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/json/encoder.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">187</span><span class="p">,</span> <span class="ow">in</span> <span class="n">encode</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterencode</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">_one_shot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/json/encoder.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">245</span><span class="p">,</span> <span class="ow">in</span> <span class="n">iterencode</span>
        <span class="k">return</span> <span class="n">_iterencode</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/json/encoder.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">169</span><span class="p">,</span> <span class="ow">in</span> <span class="n">default</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is not JSON serializable&quot;</span><span class="p">)</span>
<span class="gr">TypeError</span>: <span class="n">&lt;__main__.Point object at 0x1006f2650&gt; is not JSON serializable</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想序列化对象实例，你可以提供一个函数，它的输入是一个实例，返回一个可序列化的字典。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">serialize_instance</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;__classname__&#39;</span> <span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="p">}</span>
    <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>如果你想反过来获取这个实例，可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Dictionary mapping names to known classes</span>
<span class="n">classes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;Point&#39;</span> <span class="p">:</span> <span class="n">Point</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">unserialize_object</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="n">clsname</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;__classname__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">clsname</span><span class="p">:</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">classes</span><span class="p">[</span><span class="n">clsname</span><span class="p">]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="c1"># Make instance without calling __init__</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>下面是如何使用这些函数的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">serialize_instance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;{&quot;__classname__&quot;: &quot;Point&quot;, &quot;y&quot;: 3, &quot;x&quot;: 2}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object_hook</span><span class="o">=</span><span class="n">unserialize_object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&lt;__main__.Point object at 0x1017577d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">y</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">json</span></code> 模块还有很多其他选项来控制更低级别的数字、特殊值如NaN等的解析。
可以参考官方文档获取更多细节。</p>
</div>
</div>
<span id="document-c06/p03_parse_simple_xml_data"></span><div class="section" id="xml">
<h3>6.3 解析简单的XML数据<a class="headerlink" href="#xml" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想从一个简单的XML文档中提取数据。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>可以使用 <code class="docutils literal"><span class="pre">xml.etree.ElementTree</span></code> 模块从简单的XML文档中提取数据。
为了演示，假设你想解析Planet Python上的RSS源。下面是相应的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>
<span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">parse</span>

<span class="c1"># Download the RSS feed and parse it</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://planet.python.org/rss20.xml&#39;</span><span class="p">)</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c1"># Extract and output tags of interest</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">iterfind</span><span class="p">(</span><span class="s1">&#39;channel/item&#39;</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)</span>
    <span class="n">date</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;pubDate&#39;</span><span class="p">)</span>
    <span class="n">link</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;link&#39;</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
</pre></div>
</div>
<p>运行上面的代码，输出结果类似这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Steve</span> <span class="n">Holden</span><span class="p">:</span> <span class="n">Python</span> <span class="k">for</span> <span class="n">Data</span> <span class="n">Analysis</span>
<span class="n">Mon</span><span class="p">,</span> <span class="mi">19</span> <span class="n">Nov</span> <span class="mi">2012</span> <span class="mo">02</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">51</span> <span class="o">+</span><span class="mo">0000</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">holdenweb</span><span class="o">.</span><span class="n">blogspot</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="mi">2012</span><span class="o">/</span><span class="mi">11</span><span class="o">/</span><span class="n">python</span><span class="o">-</span><span class="k">for</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="n">analysis</span><span class="o">.</span><span class="n">html</span>

<span class="n">Vasudev</span> <span class="n">Ram</span><span class="p">:</span> <span class="n">The</span> <span class="n">Python</span> <span class="n">Data</span> <span class="n">model</span> <span class="p">(</span><span class="k">for</span> <span class="n">v2</span> <span class="ow">and</span> <span class="n">v3</span><span class="p">)</span>
<span class="n">Sun</span><span class="p">,</span> <span class="mi">18</span> <span class="n">Nov</span> <span class="mi">2012</span> <span class="mi">22</span><span class="p">:</span><span class="mo">06</span><span class="p">:</span><span class="mi">47</span> <span class="o">+</span><span class="mo">0000</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">jugad2</span><span class="o">.</span><span class="n">blogspot</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="mi">2012</span><span class="o">/</span><span class="mi">11</span><span class="o">/</span><span class="n">the</span><span class="o">-</span><span class="n">python</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">html</span>

<span class="n">Python</span> <span class="n">Diary</span><span class="p">:</span> <span class="n">Been</span> <span class="n">playing</span> <span class="n">around</span> <span class="k">with</span> <span class="n">Object</span> <span class="n">Databases</span>
<span class="n">Sun</span><span class="p">,</span> <span class="mi">18</span> <span class="n">Nov</span> <span class="mi">2012</span> <span class="mi">20</span><span class="p">:</span><span class="mi">40</span><span class="p">:</span><span class="mi">29</span> <span class="o">+</span><span class="mo">0000</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">pythondiary</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">blog</span><span class="o">/</span><span class="n">Nov</span><span class="o">.</span><span class="mi">18</span><span class="p">,</span><span class="mi">2012</span><span class="o">/</span><span class="n">been</span><span class="o">-...-</span><span class="nb">object</span><span class="o">-</span><span class="n">databases</span><span class="o">.</span><span class="n">html</span>

<span class="n">Vasudev</span> <span class="n">Ram</span><span class="p">:</span> <span class="n">Wakari</span><span class="p">,</span> <span class="n">Scientific</span> <span class="n">Python</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">cloud</span>
<span class="n">Sun</span><span class="p">,</span> <span class="mi">18</span> <span class="n">Nov</span> <span class="mi">2012</span> <span class="mi">20</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span><span class="mi">41</span> <span class="o">+</span><span class="mo">0000</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">jugad2</span><span class="o">.</span><span class="n">blogspot</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="mi">2012</span><span class="o">/</span><span class="mi">11</span><span class="o">/</span><span class="n">wakari</span><span class="o">-</span><span class="n">scientific</span><span class="o">-</span><span class="n">python</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">cloud</span><span class="o">.</span><span class="n">html</span>

<span class="n">Jesse</span> <span class="n">Jiryu</span> <span class="n">Davis</span><span class="p">:</span> <span class="n">Toro</span><span class="p">:</span> <span class="n">synchronization</span> <span class="n">primitives</span> <span class="k">for</span> <span class="n">Tornado</span> <span class="n">coroutines</span>
<span class="n">Sun</span><span class="p">,</span> <span class="mi">18</span> <span class="n">Nov</span> <span class="mi">2012</span> <span class="mi">20</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">49</span> <span class="o">+</span><span class="mo">0000</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">feedproxy</span><span class="o">.</span><span class="n">google</span><span class="o">.</span><span class="n">com</span><span class="o">/~</span><span class="n">r</span><span class="o">/</span><span class="n">EmptysquarePython</span><span class="o">/~</span><span class="mi">3</span><span class="o">/</span><span class="n">_DOZT2Kd0hQ</span><span class="o">/</span>
</pre></div>
</div>
<p>很显然，如果你想做进一步的处理，你需要替换 <code class="docutils literal"><span class="pre">print()</span></code> 语句来完成其他有趣的事。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在很多应用程序中处理XML编码格式的数据是很常见的。
不仅因为XML在Internet上面已经被广泛应用于数据交换，
同时它也是一种存储应用程序数据的常用格式(比如字处理，音乐库等)。
接下来的讨论会先假定读者已经对XML基础比较熟悉了。</p>
<p>在很多情况下，当使用XML来仅仅存储数据的时候，对应的文档结构非常紧凑并且直观。
例如，上面例子中的RSS订阅源类似于下面的格式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;rss version=&quot;2.0&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;&gt;
    &lt;channel&gt;
        &lt;title&gt;Planet Python&lt;/title&gt;
        &lt;link&gt;http://planet.python.org/&lt;/link&gt;
        &lt;language&gt;en&lt;/language&gt;
        &lt;description&gt;Planet Python - http://planet.python.org/&lt;/description&gt;
        &lt;item&gt;
            &lt;title&gt;Steve Holden: Python for Data Analysis&lt;/title&gt;
            &lt;guid&gt;http://holdenweb.blogspot.com/...-data-analysis.html&lt;/guid&gt;
            &lt;link&gt;http://holdenweb.blogspot.com/...-data-analysis.html&lt;/link&gt;
            &lt;description&gt;...&lt;/description&gt;
            &lt;pubDate&gt;Mon, 19 Nov 2012 02:13:51 +0000&lt;/pubDate&gt;
        &lt;/item&gt;
        &lt;item&gt;
            &lt;title&gt;Vasudev Ram: The Python Data model (for v2 and v3)&lt;/title&gt;
            &lt;guid&gt;http://jugad2.blogspot.com/...-data-model.html&lt;/guid&gt;
            &lt;link&gt;http://jugad2.blogspot.com/...-data-model.html&lt;/link&gt;
            &lt;description&gt;...&lt;/description&gt;
            &lt;pubDate&gt;Sun, 18 Nov 2012 22:06:47 +0000&lt;/pubDate&gt;
        &lt;/item&gt;
        &lt;item&gt;
            &lt;title&gt;Python Diary: Been playing around with Object Databases&lt;/title&gt;
            &lt;guid&gt;http://www.pythondiary.com/...-object-databases.html&lt;/guid&gt;
            &lt;link&gt;http://www.pythondiary.com/...-object-databases.html&lt;/link&gt;
            &lt;description&gt;...&lt;/description&gt;
            &lt;pubDate&gt;Sun, 18 Nov 2012 20:40:29 +0000&lt;/pubDate&gt;
        &lt;/item&gt;
        ...
    &lt;/channel&gt;
&lt;/rss&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">xml.etree.ElementTree.parse()</span></code> 函数解析整个XML文档并将其转换成一个文档对象。
然后，你就能使用 <code class="docutils literal"><span class="pre">find()</span></code> 、<code class="docutils literal"><span class="pre">iterfind()</span></code> 和 <code class="docutils literal"><span class="pre">findtext()</span></code> 等方法来搜索特定的XML元素了。
这些函数的参数就是某个指定的标签名，例如 <code class="docutils literal"><span class="pre">channel/item</span></code> 或 <code class="docutils literal"><span class="pre">title</span></code> 。</p>
<p>每次指定某个标签时，你需要遍历整个文档结构。每次搜索操作会从一个起始元素开始进行。
同样，每次操作所指定的标签名也是起始元素的相对路径。
例如，执行 <code class="docutils literal"><span class="pre">doc.iterfind('channel/item')</span></code> 来搜索所有在 <code class="docutils literal"><span class="pre">channel</span></code> 元素下面的 <code class="docutils literal"><span class="pre">item</span></code> 元素。
<code class="docutils literal"><span class="pre">doc</span></code> 代表文档的最顶层(也就是第一级的 <code class="docutils literal"><span class="pre">rss</span></code> 元素)。
然后接下来的调用 <code class="docutils literal"><span class="pre">item.findtext()</span></code> 会从已找到的 <code class="docutils literal"><span class="pre">item</span></code> 元素位置开始搜索。</p>
<p><code class="docutils literal"><span class="pre">ElementTree</span></code> 模块中的每个元素有一些重要的属性和方法，在解析的时候非常有用。
<code class="docutils literal"><span class="pre">tag</span></code> 属性包含了标签的名字，<code class="docutils literal"><span class="pre">text</span></code> 属性包含了内部的文本，而 <code class="docutils literal"><span class="pre">get()</span></code> 方法能获取属性值。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span>
<span class="go">&lt;xml.etree.ElementTree.ElementTree object at 0x101339510&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;channel/title&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">&lt;Element &#39;title&#39; at 0x10135b310&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">tag</span>
<span class="go">&#39;title&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">text</span>
<span class="go">&#39;Planet Python&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;some_attribute&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有一点要强调的是 <code class="docutils literal"><span class="pre">xml.etree.ElementTree</span></code> 并不是XML解析的唯一方法。
对于更高级的应用程序，你需要考虑使用 <code class="docutils literal"><span class="pre">lxml</span></code> 。
它使用了和ElementTree同样的编程接口，因此上面的例子同样也适用于lxml。
你只需要将刚开始的import语句换成 <code class="docutils literal"><span class="pre">from</span> <span class="pre">lxml.etree</span> <span class="pre">import</span> <span class="pre">parse</span></code> 就行了。
<code class="docutils literal"><span class="pre">lxml</span></code> 完全遵循XML标准，并且速度也非常快，同时还支持验证，XSLT，和XPath等特性。</p>
</div>
</div>
<span id="document-c06/p04_parse_huge_xml_files_incrementally"></span><div class="section" id="xml">
<h3>6.4 增量式解析大型XML文件<a class="headerlink" href="#xml" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想使用尽可能少的内存从一个超大的XML文档中提取数据。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>任何时候只要你遇到增量式的数据处理时，第一时间就应该想到迭代器和生成器。
下面是一个很简单的函数，只使用很少的内存就能增量式的处理一个大型XML文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">iterparse</span>

<span class="k">def</span> <span class="nf">parse_and_remove</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="n">path_parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">iterparse</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">))</span>
    <span class="c1"># Skip the root element</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

    <span class="n">tag_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">elem_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="n">tag_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="n">elem_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tag_stack</span> <span class="o">==</span> <span class="n">path_parts</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">elem</span>
                <span class="n">elem_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tag_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">elem_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
</pre></div>
</div>
<p>为了测试这个函数，你需要先有一个大型的XML文件。
通常你可以在政府网站或公共数据网站上找到这样的文件。
例如，你可以下载XML格式的芝加哥城市道路坑洼数据库。
在写这本书的时候，下载文件已经包含超过100,000行数据，编码格式类似于下面这样：</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>&lt;response&gt;
    &lt;row&gt;
        &lt;row ...&gt;
            &lt;creation_date&gt;2012-11-18T00:00:00&lt;/creation_date&gt;
            &lt;status&gt;Completed&lt;/status&gt;
            &lt;completion_date&gt;2012-11-18T00:00:00&lt;/completion_date&gt;
            &lt;service_request_number&gt;12-01906549&lt;/service_request_number&gt;
            &lt;type_of_service_request&gt;Pot Hole in Street&lt;/type_of_service_request&gt;
            &lt;current_activity&gt;Final Outcome&lt;/current_activity&gt;
            &lt;most_recent_action&gt;CDOT Street Cut ... Outcome&lt;/most_recent_action&gt;
            &lt;street_address&gt;4714 S TALMAN AVE&lt;/street_address&gt;
            &lt;zip&gt;60632&lt;/zip&gt;
            &lt;x_coordinate&gt;1159494.68618856&lt;/x_coordinate&gt;
            &lt;y_coordinate&gt;1873313.83503384&lt;/y_coordinate&gt;
            &lt;ward&gt;14&lt;/ward&gt;
            &lt;police_district&gt;9&lt;/police_district&gt;
            &lt;community_area&gt;58&lt;/community_area&gt;
            &lt;latitude&gt;41.808090232127896&lt;/latitude&gt;
            &lt;longitude&gt;-87.69053684711305&lt;/longitude&gt;
            &lt;location latitude=&quot;41.808090232127896&quot;
            longitude=&quot;-87.69053684711305&quot; /&gt;
        &lt;/row&gt;
        &lt;row ...&gt;
            &lt;creation_date&gt;2012-11-18T00:00:00&lt;/creation_date&gt;
            &lt;status&gt;Completed&lt;/status&gt;
            &lt;completion_date&gt;2012-11-18T00:00:00&lt;/completion_date&gt;
            &lt;service_request_number&gt;12-01906695&lt;/service_request_number&gt;
            &lt;type_of_service_request&gt;Pot Hole in Street&lt;/type_of_service_request&gt;
            &lt;current_activity&gt;Final Outcome&lt;/current_activity&gt;
            &lt;most_recent_action&gt;CDOT Street Cut ... Outcome&lt;/most_recent_action&gt;
            &lt;street_address&gt;3510 W NORTH AVE&lt;/street_address&gt;
            &lt;zip&gt;60647&lt;/zip&gt;
            &lt;x_coordinate&gt;1152732.14127696&lt;/x_coordinate&gt;
            &lt;y_coordinate&gt;1910409.38979075&lt;/y_coordinate&gt;
            &lt;ward&gt;26&lt;/ward&gt;
            &lt;police_district&gt;14&lt;/police_district&gt;
            &lt;community_area&gt;23&lt;/community_area&gt;
            &lt;latitude&gt;41.91002084292946&lt;/latitude&gt;
            &lt;longitude&gt;-87.71435952353961&lt;/longitude&gt;
            &lt;location latitude=&quot;41.91002084292946&quot;
            longitude=&quot;-87.71435952353961&quot; /&gt;
        &lt;/row&gt;
    &lt;/row&gt;
&lt;/response&gt;
</pre></div>
</div>
<p>假设你想写一个脚本来按照坑洼报告数量排列邮编号码。你可以像这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">parse</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="n">potholes_by_zip</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

<span class="n">doc</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="s1">&#39;potholes.xml&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">pothole</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">iterfind</span><span class="p">(</span><span class="s1">&#39;row/row&#39;</span><span class="p">):</span>
    <span class="n">potholes_by_zip</span><span class="p">[</span><span class="n">pothole</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;zip&#39;</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">zipcode</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">potholes_by_zip</span><span class="o">.</span><span class="n">most_common</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">zipcode</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
</pre></div>
</div>
<p>这个脚本唯一的问题是它会先将整个XML文件加载到内存中然后解析。
在我的机器上，为了运行这个程序需要用到450MB左右的内存空间。
如果使用如下代码，程序只需要修改一点点：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="n">potholes_by_zip</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">parse_and_remove</span><span class="p">(</span><span class="s1">&#39;potholes.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;row/row&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">pothole</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">potholes_by_zip</span><span class="p">[</span><span class="n">pothole</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;zip&#39;</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">zipcode</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">potholes_by_zip</span><span class="o">.</span><span class="n">most_common</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">zipcode</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
</pre></div>
</div>
<p>结果是：这个版本的代码运行时只需要7MB的内存&#8211;大大节约了内存资源。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这一节的技术会依赖 <code class="docutils literal"><span class="pre">ElementTree</span></code> 模块中的两个核心功能。
第一，<code class="docutils literal"><span class="pre">iterparse()</span></code> 方法允许对XML文档进行增量操作。
使用时，你需要提供文件名和一个包含下面一种或多种类型的事件列表：
<code class="docutils literal"><span class="pre">start</span></code> , <code class="docutils literal"><span class="pre">end</span></code>, <code class="docutils literal"><span class="pre">start-ns</span></code> 和 <code class="docutils literal"><span class="pre">end-ns</span></code> 。
由 <code class="docutils literal"><span class="pre">iterparse()</span></code> 创建的迭代器会产生形如 <code class="docutils literal"><span class="pre">(event,</span> <span class="pre">elem)</span></code> 的元组，
其中 <code class="docutils literal"><span class="pre">event</span></code> 是上述事件列表中的某一个，而 <code class="docutils literal"><span class="pre">elem</span></code> 是相应的XML元素。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">iterparse</span><span class="p">(</span><span class="s1">&#39;potholes.xml&#39;</span><span class="p">,(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span><span class="s1">&#39;end&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">(&#39;start&#39;, &lt;Element &#39;response&#39; at 0x100771d60&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">(&#39;start&#39;, &lt;Element &#39;row&#39; at 0x100771e68&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">(&#39;start&#39;, &lt;Element &#39;row&#39; at 0x100771fc8&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">(&#39;start&#39;, &lt;Element &#39;creation_date&#39; at 0x100771f18&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">(&#39;end&#39;, &lt;Element &#39;creation_date&#39; at 0x100771f18&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">(&#39;start&#39;, &lt;Element &#39;status&#39; at 0x1006a7f18&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">(&#39;end&#39;, &lt;Element &#39;status&#39; at 0x1006a7f18&gt;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">start</span></code> 事件在某个元素第一次被创建并且还没有被插入其他数据(如子元素)时被创建。
而 <code class="docutils literal"><span class="pre">end</span></code> 事件在某个元素已经完成时被创建。
尽管没有在例子中演示， <code class="docutils literal"><span class="pre">start-ns</span></code> 和 <code class="docutils literal"><span class="pre">end-ns</span></code> 事件被用来处理XML文档命名空间的声明。</p>
<p>这本节例子中， <code class="docutils literal"><span class="pre">start</span></code> 和 <code class="docutils literal"><span class="pre">end</span></code> 事件被用来管理元素和标签栈。
栈代表了文档被解析时的层次结构，
还被用来判断某个元素是否匹配传给函数 <code class="docutils literal"><span class="pre">parse_and_remove()</span></code> 的路径。
如果匹配，就利用 <code class="docutils literal"><span class="pre">yield</span></code> 语句向调用者返回这个元素。</p>
<p>在 <code class="docutils literal"><span class="pre">yield</span></code> 之后的下面这个语句才是使得程序占用极少内存的ElementTree的核心特性：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">elem_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
</pre></div>
</div>
<p>这个语句使得之前由 <code class="docutils literal"><span class="pre">yield</span></code> 产生的元素从它的父节点中删除掉。
假设已经没有其它的地方引用这个元素了，那么这个元素就被销毁并回收内存。</p>
<p>对节点的迭代式解析和删除的最终效果就是一个在文档上高效的增量式清扫过程。
文档树结构从始自终没被完整的创建过。尽管如此，还是能通过上述简单的方式来处理这个XML数据。</p>
<p>这种方案的主要缺陷就是它的运行性能了。
我自己测试的结果是，读取整个文档到内存中的版本的运行速度差不多是增量式处理版本的两倍快。
但是它却使用了超过后者60倍的内存。
因此，如果你更关心内存使用量的话，那么增量式的版本完胜。</p>
</div>
</div>
<span id="document-c06/p05_turning_dictionary_into_xml"></span><div class="section" id="xml">
<h3>6.5 将字典转换为XML<a class="headerlink" href="#xml" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想使用一个Python字典存储数据，并将它转换成XML格式。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>尽管 <code class="docutils literal"><span class="pre">xml.etree.ElementTree</span></code> 库通常用来做解析工作，其实它也可以创建XML文档。
例如，考虑如下这个函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">Element</span>

<span class="k">def</span> <span class="nf">dict_to_xml</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Turn a simple dict of key/value pairs into XML</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="n">elem</span> <span class="o">=</span> <span class="n">Element</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">Element</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">child</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">elem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="k">return</span> <span class="n">elem</span>
</pre></div>
</div>
<p>下面是一个使用例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;GOOG&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span><span class="mf">490.1</span> <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">dict_to_xml</span><span class="p">(</span><span class="s1">&#39;stock&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">&lt;Element &#39;stock&#39; at 0x1004b64c8&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>转换结果是一个 <code class="docutils literal"><span class="pre">Element</span></code> 实例。对于I/O操作，使用 <code class="docutils literal"><span class="pre">xml.etree.ElementTree</span></code> 中的 <code class="docutils literal"><span class="pre">tostring()</span></code>
函数很容易就能将它转换成一个字节字符串。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">tostring</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tostring</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">b&#39;&lt;stock&gt;&lt;price&gt;490.1&lt;/price&gt;&lt;shares&gt;100&lt;/shares&gt;&lt;name&gt;GOOG&lt;/name&gt;&lt;/stock&gt;&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想给某个元素添加属性值，可以使用 <code class="docutils literal"><span class="pre">set()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span><span class="s1">&#39;1234&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tostring</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">b&#39;&lt;stock _id=&quot;1234&quot;&gt;&lt;price&gt;490.1&lt;/price&gt;&lt;shares&gt;100&lt;/shares&gt;&lt;name&gt;GOOG&lt;/name&gt;</span>
<span class="go">&lt;/stock&gt;&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你还想保持元素的顺序，可以考虑构造一个 <code class="docutils literal"><span class="pre">OrderedDict</span></code> 来代替一个普通的字典。请参考1.7小节。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>当创建XML的时候，你被限制只能构造字符串类型的值。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dict_to_xml_str</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Turn a simple dict of key/value pairs into XML</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;{}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;{0}&gt;{1}&lt;/{0}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">))</span>
    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;/{}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
</pre></div>
</div>
<p>问题是如果你手动的去构造的时候可能会碰到一些麻烦。例如，当字典的值中包含一些特殊字符的时候会怎样呢？</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="s1">&#39;&lt;spam&gt;&#39;</span> <span class="p">}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># String creation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_to_xml_str</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;&lt;item&gt;&lt;name&gt;&lt;spam&gt;&lt;/name&gt;&lt;/item&gt;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Proper XML creation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">dict_to_xml</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tostring</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">b&#39;&lt;item&gt;&lt;name&gt;&amp;lt;spam&amp;gt;&lt;/name&gt;&lt;/item&gt;&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意到程序的后面那个例子中，字符 &#8216;&lt;&#8217; 和 &#8216;&gt;&#8217; 被替换成了 <code class="docutils literal"><span class="pre">&amp;lt;</span></code> 和 <code class="docutils literal"><span class="pre">&amp;gt;</span></code></p>
<p>下面仅供参考，如果你需要手动去转换这些字符，
可以使用 <code class="docutils literal"><span class="pre">xml.sax.saxutils</span></code> 中的 <code class="docutils literal"><span class="pre">escape()</span></code>  和 <code class="docutils literal"><span class="pre">unescape()</span></code> 函数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.sax.saxutils</span> <span class="kn">import</span> <span class="n">escape</span><span class="p">,</span> <span class="n">unescape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;&lt;spam&gt;&#39;</span><span class="p">)</span>
<span class="go">&#39;&amp;lt;spam&amp;gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unescape</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">&#39;&lt;spam&gt;&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>除了能创建正确的输出外，还有另外一个原因推荐你创建 <code class="docutils literal"><span class="pre">Element</span></code> 实例而不是字符串，
那就是使用字符串组合构造一个更大的文档并不是那么容易。
而 <code class="docutils literal"><span class="pre">Element</span></code> 实例可以不用考虑解析XML文本的情况下通过多种方式被处理。
也就是说，你可以在一个高级数据结构上完成你所有的操作，并在最后以字符串的形式将其输出。</p>
</div>
</div>
<span id="document-c06/p06_parse_modify_rewrite_xml"></span><div class="section" id="xml">
<h3>6.6 解析和修改XML<a class="headerlink" href="#xml" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想读取一个XML文档，对它最一些修改，然后将结果写回XML文档。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">xml.etree.ElementTree</span></code> 模块可以很容易的处理这些任务。
第一步是以通常的方式来解析这个文档。例如，假设你有一个名为 <code class="docutils literal"><span class="pre">pred.xml</span></code> 的文档，类似下面这样：</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;stop&gt;</span>
    <span class="nt">&lt;id&gt;</span>14791<span class="nt">&lt;/id&gt;</span>
    <span class="nt">&lt;nm&gt;</span>Clark <span class="ni">&amp;amp;</span> Balmoral<span class="nt">&lt;/nm&gt;</span>
    <span class="nt">&lt;sri&gt;</span>
        <span class="nt">&lt;rt&gt;</span>22<span class="nt">&lt;/rt&gt;</span>
        <span class="nt">&lt;d&gt;</span>North Bound<span class="nt">&lt;/d&gt;</span>
        <span class="nt">&lt;dd&gt;</span>North Bound<span class="nt">&lt;/dd&gt;</span>
    <span class="nt">&lt;/sri&gt;</span>
    <span class="nt">&lt;cr&gt;</span>22<span class="nt">&lt;/cr&gt;</span>
    <span class="nt">&lt;pre&gt;</span>
        <span class="nt">&lt;pt&gt;</span>5 MIN<span class="nt">&lt;/pt&gt;</span>
        <span class="nt">&lt;fd&gt;</span>Howard<span class="nt">&lt;/fd&gt;</span>
        <span class="nt">&lt;v&gt;</span>1378<span class="nt">&lt;/v&gt;</span>
        <span class="nt">&lt;rn&gt;</span>22<span class="nt">&lt;/rn&gt;</span>
    <span class="nt">&lt;/pre&gt;</span>
    <span class="nt">&lt;pre&gt;</span>
        <span class="nt">&lt;pt&gt;</span>15 MIN<span class="nt">&lt;/pt&gt;</span>
        <span class="nt">&lt;fd&gt;</span>Howard<span class="nt">&lt;/fd&gt;</span>
        <span class="nt">&lt;v&gt;</span>1867<span class="nt">&lt;/v&gt;</span>
        <span class="nt">&lt;rn&gt;</span>22<span class="nt">&lt;/rn&gt;</span>
    <span class="nt">&lt;/pre&gt;</span>
<span class="nt">&lt;/stop&gt;</span>
</pre></div>
</div>
<p>下面是一个利用 <code class="docutils literal"><span class="pre">ElementTree</span></code> 来读取这个文档并对它做一些修改的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">parse</span><span class="p">,</span> <span class="n">Element</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="s1">&#39;pred.xml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span>
<span class="go">&lt;Element &#39;stop&#39; at 0x100770cb0&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Remove a few elements</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sri&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;cr&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Insert a new element after &lt;nm&gt;...&lt;/nm&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">getchildren</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;nm&#39;</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Element</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is a test&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Write back to a file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;newpred.xml&#39;</span><span class="p">,</span> <span class="n">xml_declaration</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>处理结果是一个像下面这样新的XML文件：</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&#39;1.0&#39; encoding=&#39;us-ascii&#39;?&gt;</span>
<span class="nt">&lt;stop&gt;</span>
    <span class="nt">&lt;id&gt;</span>14791<span class="nt">&lt;/id&gt;</span>
    <span class="nt">&lt;nm&gt;</span>Clark <span class="ni">&amp;amp;</span> Balmoral<span class="nt">&lt;/nm&gt;</span>
    <span class="nt">&lt;spam&gt;</span>This is a test<span class="nt">&lt;/spam&gt;</span>
    <span class="nt">&lt;pre&gt;</span>
        <span class="nt">&lt;pt&gt;</span>5 MIN<span class="nt">&lt;/pt&gt;</span>
        <span class="nt">&lt;fd&gt;</span>Howard<span class="nt">&lt;/fd&gt;</span>
        <span class="nt">&lt;v&gt;</span>1378<span class="nt">&lt;/v&gt;</span>
        <span class="nt">&lt;rn&gt;</span>22<span class="nt">&lt;/rn&gt;</span>
    <span class="nt">&lt;/pre&gt;</span>
    <span class="nt">&lt;pre&gt;</span>
        <span class="nt">&lt;pt&gt;</span>15 MIN<span class="nt">&lt;/pt&gt;</span>
        <span class="nt">&lt;fd&gt;</span>Howard<span class="nt">&lt;/fd&gt;</span>
        <span class="nt">&lt;v&gt;</span>1867<span class="nt">&lt;/v&gt;</span>
        <span class="nt">&lt;rn&gt;</span>22<span class="nt">&lt;/rn&gt;</span>
    <span class="nt">&lt;/pre&gt;</span>
<span class="nt">&lt;/stop&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>修改一个XML文档结构是很容易的，但是你必须牢记的是所有的修改都是针对父节点元素，
将它作为一个列表来处理。例如，如果你删除某个元素，通过调用父节点的 <code class="docutils literal"><span class="pre">remove()</span></code> 方法从它的直接父节点中删除。
如果你插入或增加新的元素，你同样使用父节点元素的 <code class="docutils literal"><span class="pre">insert()</span></code> 和 <code class="docutils literal"><span class="pre">append()</span></code> 方法。
还能对元素使用索引和切片操作，比如 <code class="docutils literal"><span class="pre">element[i]</span></code> 或 <code class="docutils literal"><span class="pre">element[i:j]</span></code></p>
<p>如果你需要创建新的元素，可以使用本节方案中演示的 <code class="docutils literal"><span class="pre">Element</span></code> 类。我们在6.5小节已经详细讨论过了。</p>
</div>
</div>
<span id="document-c06/p07_parse_xml_documents_with_namespaces"></span><div class="section" id="xml">
<h3>6.7 利用命名空间解析XML文档<a class="headerlink" href="#xml" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想解析某个XML文档，文档中使用了XML命名空间。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>考虑下面这个使用了命名空间的文档：</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;top&gt;</span>
    <span class="nt">&lt;author&gt;</span>David Beazley<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;content&gt;</span>
        <span class="nt">&lt;html</span> <span class="na">xmlns=</span><span class="s">&quot;http://www.w3.org/1999/xhtml&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;head&gt;</span>
                <span class="nt">&lt;title&gt;</span>Hello World<span class="nt">&lt;/title&gt;</span>
            <span class="nt">&lt;/head&gt;</span>
            <span class="nt">&lt;body&gt;</span>
                <span class="nt">&lt;h1&gt;</span>Hello World!<span class="nt">&lt;/h1&gt;</span>
            <span class="nt">&lt;/body&gt;</span>
        <span class="nt">&lt;/html&gt;</span>
    <span class="nt">&lt;/content&gt;</span>
<span class="nt">&lt;/top&gt;</span>
</pre></div>
</div>
<p>如果你解析这个文档并执行普通的查询，你会发现这个并不是那么容易，因为所有步骤都变得相当的繁琐。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Some queries that work</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;author&#39;</span><span class="p">)</span>
<span class="go">&#39;David Beazley&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;content&#39;</span><span class="p">)</span>
<span class="go">&lt;Element &#39;content&#39; at 0x100776ec0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A query involving a namespace (doesn&#39;t work)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;content/html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Works if fully qualified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;content/{http://www.w3.org/1999/xhtml}html&#39;</span><span class="p">)</span>
<span class="go">&lt;Element &#39;{http://www.w3.org/1999/xhtml}html&#39; at 0x1007767e0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Doesn&#39;t work</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;content/{http://www.w3.org/1999/xhtml}html/head/title&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fully qualified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;content/{http://www.w3.org/1999/xhtml}html/&#39;</span>
<span class="gp">... </span><span class="s1">&#39;{http://www.w3.org/1999/xhtml}head/{http://www.w3.org/1999/xhtml}title&#39;</span><span class="p">)</span>
<span class="go">&#39;Hello World&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你可以通过将命名空间处理逻辑包装为一个工具类来简化这个过程：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">XMLNamespaces</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespaces</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">uri</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">uri</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">uri</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespaces</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;{&#39;</span><span class="o">+</span><span class="n">uri</span><span class="o">+</span><span class="s1">&#39;}&#39;</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namespaces</span><span class="p">)</span>
</pre></div>
</div>
<p>通过下面的方式使用这个类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span> <span class="o">=</span> <span class="n">XMLNamespaces</span><span class="p">(</span><span class="n">html</span><span class="o">=</span><span class="s1">&#39;http://www.w3.org/1999/xhtml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">ns</span><span class="p">(</span><span class="s1">&#39;content/{html}html&#39;</span><span class="p">))</span>
<span class="go">&lt;Element &#39;{http://www.w3.org/1999/xhtml}html&#39; at 0x1007767e0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="n">ns</span><span class="p">(</span><span class="s1">&#39;content/{html}html/{html}head/{html}title&#39;</span><span class="p">))</span>
<span class="go">&#39;Hello World&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>解析含有命名空间的XML文档会比较繁琐。
上面的 <code class="docutils literal"><span class="pre">XMLNamespaces</span></code> 仅仅是允许你使用缩略名代替完整的URI将其变得稍微简洁一点。</p>
<p>很不幸的是，在基本的 <code class="docutils literal"><span class="pre">ElementTree</span></code> 解析中没有任何途径获取命名空间的信息。
但是，如果你使用 <code class="docutils literal"><span class="pre">iterparse()</span></code> 函数的话就可以获取更多关于命名空间处理范围的信息。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">iterparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">evt</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">iterparse</span><span class="p">(</span><span class="s1">&#39;ns2.xml&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="s1">&#39;start-ns&#39;</span><span class="p">,</span> <span class="s1">&#39;end-ns&#39;</span><span class="p">)):</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">evt</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">end &lt;Element &#39;author&#39; at 0x10110de10&gt;</span>
<span class="go">start-ns (&#39;&#39;, &#39;http://www.w3.org/1999/xhtml&#39;)</span>
<span class="go">end &lt;Element &#39;{http://www.w3.org/1999/xhtml}title&#39; at 0x1011131b0&gt;</span>
<span class="go">end &lt;Element &#39;{http://www.w3.org/1999/xhtml}head&#39; at 0x1011130a8&gt;</span>
<span class="go">end &lt;Element &#39;{http://www.w3.org/1999/xhtml}h1&#39; at 0x101113310&gt;</span>
<span class="go">end &lt;Element &#39;{http://www.w3.org/1999/xhtml}body&#39; at 0x101113260&gt;</span>
<span class="go">end &lt;Element &#39;{http://www.w3.org/1999/xhtml}html&#39; at 0x10110df70&gt;</span>
<span class="go">end-ns None</span>
<span class="go">end &lt;Element &#39;content&#39; at 0x10110de68&gt;</span>
<span class="go">end &lt;Element &#39;top&#39; at 0x10110dd60&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elem</span> <span class="c1"># This is the topmost element</span>
<span class="go">&lt;Element &#39;top&#39; at 0x10110dd60&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后一点，如果你要处理的XML文本除了要使用到其他高级XML特性外，还要使用到命名空间，
建议你最好是使用 <code class="docutils literal"><span class="pre">lxml</span></code> 函数库来代替 <code class="docutils literal"><span class="pre">ElementTree</span></code> 。
例如，<code class="docutils literal"><span class="pre">lxml</span></code> 对利用DTD验证文档、更好的XPath支持和一些其他高级XML特性等都提供了更好的支持。
这一小节其实只是教你如何让XML解析稍微简单一点。</p>
</div>
</div>
<span id="document-c06/p08_interact_with_relational_database"></span><div class="section" id="id1">
<h3>6.8 与关系型数据库的交互<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在关系型数据库中查询、增加或删除记录。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python中表示多行数据的标准方式是一个由元组构成的序列。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">stocks</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;GOOG&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">490.1</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;AAPL&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">545.75</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;FB&#39;</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mf">7.45</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;HPQ&#39;</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mf">33.2</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>依据PEP249，通过这种形式提供数据，
可以很容易的使用Python标准数据库API和关系型数据库进行交互。
所有数据库上的操作都通过SQL查询语句来完成。每一行输入输出数据用一个元组来表示。</p>
<p>为了演示说明，你可以使用Python标准库中的 <code class="docutils literal"><span class="pre">sqlite3</span></code> 模块。
如果你使用的是一个不同的数据库(比如MySql、Postgresql或者ODBC)，
还得安装相应的第三方模块来提供支持。
不过相应的编程接口几乎都是一样的，除了一点点细微差别外。</p>
<p>第一步是连接到数据库。通常你要执行 <code class="docutils literal"><span class="pre">connect()</span></code> 函数，
给它提供一些数据库名、主机、用户名、密码和其他必要的一些参数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;database.db&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了处理数据，下一步你需要创建一个游标。
一旦你有了游标，那么你就可以执行SQL查询语句了。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;create table portfolio (symbol text, shares integer, price real)&#39;</span><span class="p">)</span>
<span class="go">&lt;sqlite3.Cursor object at 0x10067a730&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了向数据库表中插入多条记录，使用类似下面这样的语句：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s1">&#39;insert into portfolio values (?,?,?)&#39;</span><span class="p">,</span> <span class="n">stocks</span><span class="p">)</span>
<span class="go">&lt;sqlite3.Cursor object at 0x10067a730&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了执行某个查询，使用像下面这样的语句：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from portfolio&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;GOOG&#39;, 100, 490.1)</span>
<span class="go">(&#39;AAPL&#39;, 50, 545.75)</span>
<span class="go">(&#39;FB&#39;, 150, 7.45)</span>
<span class="go">(&#39;HPQ&#39;, 75, 33.2)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想接受用户输入作为参数来执行查询操作，必须确保你使用下面这样的占位符``?``来进行引用参数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">min_price</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from portfolio where price &gt;= ?&#39;</span><span class="p">,</span>
<span class="go">                          (min_price,)):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;GOOG&#39;, 100, 490.1)</span>
<span class="go">(&#39;AAPL&#39;, 50, 545.75)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在比较低的级别上和数据库交互是非常简单的。
你只需提供SQL语句并调用相应的模块就可以更新或提取数据了。
虽说如此，还是有一些比较棘手的细节问题需要你逐个列出去解决。</p>
<p>一个难点是数据库中的数据和Python类型直接的映射。
对于日期类型，通常可以使用 <code class="docutils literal"><span class="pre">datetime</span></code> 模块中的 <code class="docutils literal"><span class="pre">datetime</span></code> 实例，
或者可能是 <code class="docutils literal"><span class="pre">time</span></code> 模块中的系统时间戳。
对于数字类型，特别是使用到小数的金融数据，可以用 <code class="docutils literal"><span class="pre">decimal</span></code> 模块中的 <code class="docutils literal"><span class="pre">Decimal</span></code> 实例来表示。
不幸的是，对于不同的数据库而言具体映射规则是不一样的，你必须参考相应的文档。</p>
<p>另外一个更加复杂的问题就是SQL语句字符串的构造。
你千万不要使用Python字符串格式化操作符(如%)或者 <code class="docutils literal"><span class="pre">.format()</span></code> 方法来创建这样的字符串。
如果传递给这些格式化操作符的值来自于用户的输入，那么你的程序就很有可能遭受SQL注入攻击(参考 <a class="reference external" href="http://xkcd.com/327">http://xkcd.com/327</a> )。
查询语句中的通配符 <code class="docutils literal"><span class="pre">?</span></code> 指示后台数据库使用它自己的字符串替换机制，这样更加的安全。</p>
<p>不幸的是，不同的数据库后台对于通配符的使用是不一样的。大部分模块使用 <code class="docutils literal"><span class="pre">?</span></code> 或 <code class="docutils literal"><span class="pre">%s</span></code> ，
还有其他一些使用了不同的符号，比如:0或:1来指示参数。
同样的，你还是得去参考你使用的数据库模块相应的文档。
一个数据库模块的 <code class="docutils literal"><span class="pre">paramstyle</span></code> 属性包含了参数引用风格的信息。</p>
<p>对于简单的数据库数据的读写问题，使用数据库API通常非常简单。
如果你要处理更加复杂的问题，建议你使用更加高级的接口，比如一个对象关系映射ORM所提供的接口。
类似 <code class="docutils literal"><span class="pre">SQLAlchemy</span></code> 这样的库允许你使用Python类来表示一个数据库表，
并且能在隐藏底层SQL的情况下实现各种数据库的操作。</p>
</div>
</div>
<span id="document-c06/p09_decode_encode_hexadecimal_digits"></span><div class="section" id="id1">
<h3>6.9 编码和解码十六进制数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想将一个十六进制字符串解码成一个字节字符串或者将一个字节字符串编码成一个十六进制字符串。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你只是简单的解码或编码一个十六进制的原始字符串，可以使用　<code class="docutils literal"><span class="pre">binascii</span></code> 模块。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initial byte string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Encode as hex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">binascii</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">b2a_hex</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span>
<span class="go">b&#39;68656c6c6f&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Decode back to bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binascii</span><span class="o">.</span><span class="n">a2b_hex</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">b&#39;hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>类似的功能同样可以在 <code class="docutils literal"><span class="pre">base64</span></code> 模块中找到。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">base64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b16encode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span>
<span class="go">b&#39;68656C6C6F&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base64</span><span class="o">.</span><span class="n">b16decode</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">b&#39;hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>大部分情况下，通过使用上述的函数来转换十六进制是很简单的。
上面两种技术的主要不同在于大小写的处理。
函数 <code class="docutils literal"><span class="pre">base64.b16decode()</span></code> 和 <code class="docutils literal"><span class="pre">base64.b16encode()</span></code> 只能操作大写形式的十六进制字母，
而 <code class="docutils literal"><span class="pre">binascii</span></code> 模块中的函数大小写都能处理。</p>
<p>还有一点需要注意的是编码函数所产生的输出总是一个字节字符串。
如果想强制以Unicode形式输出，你需要增加一个额外的界面步骤。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b16encode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">b&#39;68656C6C6F&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
<span class="go">68656C6C6F</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在解码十六进制数时，函数 <code class="docutils literal"><span class="pre">b16decode()</span></code> 和 <code class="docutils literal"><span class="pre">a2b_hex()</span></code> 可以接受字节或unicode字符串。
但是，unicode字符串必须仅仅只包含ASCII编码的十六进制数。</p>
</div>
</div>
<span id="document-c06/p10_decode_encode_base64"></span><div class="section" id="base64">
<h3>6.10 编码解码Base64数据<a class="headerlink" href="#base64" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你需要使用Base64格式解码或编码二进制数据。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">base64</span></code> 模块中有两个函数 <code class="docutils literal"><span class="pre">b64encode()</span></code> and <code class="docutils literal"><span class="pre">b64decode()</span></code> 可以帮你解决这个问题。例如;</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Some byte data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">base64</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Encode as Base64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">b&#39;aGVsbG8=&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Decode from Base64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">b&#39;hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Base64编码仅仅用于面向字节的数据比如字节字符串和字节数组。
此外，编码处理的输出结果总是一个字节字符串。
如果你想混合使用Base64编码的数据和Unicode文本，你必须添加一个额外的解码步骤。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&#39;aGVsbG8=&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当解码Base64的时候，字节字符串和Unicode文本都可以作为参数。
但是，Unicode字符串只能包含ASCII字符。</p>
</div>
</div>
<span id="document-c06/p11_read_write_binary_arrays_of_structures"></span><div class="section" id="id1">
<h3>6.11 读写二进制数组数据<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想读写一个二进制数组的结构化数据到Python元组中。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>可以使用 <code class="docutils literal"><span class="pre">struct</span></code> 模块处理二进制数据。
下面是一段示例代码将一个Python元组列表写入一个二进制文件，并使用 <code class="docutils literal"><span class="pre">struct</span></code> 将每个元组编码为一个结构体。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">Struct</span>
<span class="k">def</span> <span class="nf">write_records</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write a sequence of tuples to a binary file of structures.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">record_struct</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">record_struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>

<span class="c1"># Example</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">records</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span>
                <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">7.8</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">),</span>
                <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mf">13.4</span><span class="p">,</span> <span class="mf">56.7</span><span class="p">)</span> <span class="p">]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.b&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">write_records</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="s1">&#39;&lt;idd&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>有很多种方法来读取这个文件并返回一个元组列表。
首先，如果你打算以块的形式增量读取文件，你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">Struct</span>

<span class="k">def</span> <span class="nf">read_records</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="n">record_struct</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">record_struct</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">record_struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">)</span>

<span class="c1"># Example</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.b&#39;</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">read_records</span><span class="p">(</span><span class="s1">&#39;&lt;idd&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
            <span class="c1"># Process rec</span>
            <span class="o">...</span>
</pre></div>
</div>
<p>如果你想将整个文件一次性读取到一个字节字符串中，然后在分片解析。那么你可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">Struct</span>

<span class="k">def</span> <span class="nf">unpack_records</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">record_struct</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">record_struct</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">record_struct</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

<span class="c1"># Example</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.b&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">unpack_records</span><span class="p">(</span><span class="s1">&#39;&lt;idd&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># Process rec</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>两种情况下的结果都是一个可返回用来创建该文件的原始元组的可迭代对象。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>对于需要编码和解码二进制数据的程序而言，通常会使用 <code class="docutils literal"><span class="pre">struct</span></code> 模块。
为了声明一个新的结构体，只需要像这样创建一个 <code class="docutils literal"><span class="pre">Struct</span></code> 实例即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Little endian 32-bit integer, two double precision floats</span>
<span class="n">record_struct</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="s1">&#39;&lt;idd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>结构体通常会使用一些结构码值i, d, f等
[参考 <a class="reference external" href="https://docs.python.org/3/library/struct.html">Python文档</a> ]。
这些代码分别代表某个特定的二进制数据类型如32位整数，64位浮点数，32位浮点数等。
第一个字符 <code class="docutils literal"><span class="pre">&lt;</span></code> 指定了字节顺序。在这个例子中，它表示&#8221;低位在前&#8221;。
更改这个字符为 <code class="docutils literal"><span class="pre">&gt;</span></code> 表示高位在前，或者是 <code class="docutils literal"><span class="pre">!</span></code> 表示网络字节顺序。</p>
<p>产生的 <code class="docutils literal"><span class="pre">Struct</span></code> 实例有很多属性和方法用来操作相应类型的结构。
<code class="docutils literal"><span class="pre">size</span></code> 属性包含了结构的字节数，这在I/O操作时非常有用。
<code class="docutils literal"><span class="pre">pack()</span></code> 和 <code class="docutils literal"><span class="pre">unpack()</span></code> 方法被用来打包和解包数据。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">Struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record_struct</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="s1">&#39;&lt;idd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record_struct</span><span class="o">.</span><span class="n">size</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record_struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="go">b&#39;\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record_struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">(1, 2.0, 3.0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有时候你还会看到 <code class="docutils literal"><span class="pre">pack()</span></code> 和 <code class="docutils literal"><span class="pre">unpack()</span></code> 操作以模块级别函数被调用，类似下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;idd&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="go">b&#39;\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;idd&#39;</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
<span class="go">(1, 2.0, 3.0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这样可以工作，但是感觉没有实例方法那么优雅，特别是在你代码中同样的结构出现在多个地方的时候。
通过创建一个 <code class="docutils literal"><span class="pre">Struct</span></code> 实例，格式代码只会指定一次并且所有的操作被集中处理。
这样一来代码维护就变得更加简单了(因为你只需要改变一处代码即可)。</p>
<p>读取二进制结构的代码要用到一些非常有趣而优美的编程技巧。
在函数　<code class="docutils literal"><span class="pre">read_records</span></code> 中，<code class="docutils literal"><span class="pre">iter()</span></code> 被用来创建一个返回固定大小数据块的迭代器，参考5.8小节。
这个迭代器会不断的调用一个用户提供的可调用对象(比如 <code class="docutils literal"><span class="pre">lambda:</span> <span class="pre">f.read(record_struct.size)</span></code> )，
直到它返回一个特殊的值(如b&#8217;&#8216;)，这时候迭代停止。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.b&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunks</span>
<span class="go">&lt;callable_iterator object at 0x10069e6d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">chk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">chk</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">b&#39;\x01\x00\x00\x00ffffff\x02@\x00\x00\x00\x00\x00\x00\x12@&#39;</span>
<span class="go">b&#39;\x06\x00\x00\x00333333\x1f@\x00\x00\x00\x00\x00\x00&quot;@&#39;</span>
<span class="go">b&#39;\x0c\x00\x00\x00\xcd\xcc\xcc\xcc\xcc\xcc*@\x9a\x99\x99\x99\x99YL@&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如你所见，创建一个可迭代对象的一个原因是它能允许使用一个生成器推导来创建记录。
如果你不使用这种技术，那么代码可能会像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read_records</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="n">record_struct</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">chk</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">record_struct</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chk</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">yield</span> <span class="n">record_struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">chk</span><span class="p">)</span>
</pre></div>
</div>
<p>在函数 <code class="docutils literal"><span class="pre">unpack_records()</span></code> 中使用了另外一种方法 <code class="docutils literal"><span class="pre">unpack_from()</span></code> 。
<code class="docutils literal"><span class="pre">unpack_from()</span></code> 对于从一个大型二进制数组中提取二进制数据非常有用，
因为它不会产生任何的临时对象或者进行内存复制操作。
你只需要给它一个字节字符串(或数组)和一个字节偏移量，它会从那个位置开始直接解包数据。</p>
<p>如果你使用 <code class="docutils literal"><span class="pre">unpack()</span></code> 来代替 <code class="docutils literal"><span class="pre">unpack_from()</span></code> ，
你需要修改代码来构造大量的小的切片以及进行偏移量的计算。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">unpack_records</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">record_struct</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">record_struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">record_struct</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">record_struct</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</pre></div>
</div>
<p>这种方案除了代码看上去很复杂外，还得做很多额外的工作，因为它执行了大量的偏移量计算，
复制数据以及构造小的切片对象。
如果你准备从读取到的一个大型字节字符串中解包大量的结构体的话，<code class="docutils literal"><span class="pre">unpack_from()</span></code> 会表现的更出色。</p>
<p>在解包的时候，<code class="docutils literal"><span class="pre">collections</span></code> 模块中的命名元组对象或许是你想要用到的。
它可以让你给返回元组设置属性名称。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="n">Record</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Record&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.p&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">records</span> <span class="o">=</span> <span class="p">(</span><span class="n">Record</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">read_records</span><span class="p">(</span><span class="s1">&#39;&lt;idd&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>

<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你的程序需要处理大量的二进制数据，你最好使用 <code class="docutils literal"><span class="pre">numpy</span></code> 模块。
例如，你可以将一个二进制数据读取到一个结构化数组中而不是一个元组列表中。就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.b&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;i,&lt;d,&lt;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span>
<span class="go">array([(1, 2.3, 4.5), (6, 7.8, 9.0), (12, 13.4, 56.7)],</span>
<span class="go">dtype=[(&#39;f0&#39;, &#39;&lt;i4&#39;), (&#39;f1&#39;, &#39;&lt;f8&#39;), (&#39;f2&#39;, &#39;&lt;f8&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(1, 2.3, 4.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">(6, 7.8, 9.0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后提一点，如果你需要从已知的文件格式(如图片格式，图形文件，HDF5等)中读取二进制数据时，
先检查看看Python是不是已经提供了现存的模块。因为不到万不得已没有必要去重复造轮子。</p>
</div>
</div>
<span id="document-c06/p12_read_nested_and_variable_sized_binary_structures"></span><div class="section" id="id1">
<h3>6.12 读取嵌套和可变长二进制数据<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要读取包含嵌套或者可变长记录集合的复杂二进制格式的数据。这些数据可能包含图片、视频、电子地图文件等。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">struct</span></code> 模块可被用来编码/解码几乎所有类型的二进制的数据结构。为了解释清楚这种数据，假设你用下面的Python数据结构
来表示一个组成一系列多边形的点的集合：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">polys</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span> <span class="p">],</span>
    <span class="p">[</span> <span class="p">(</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">),</span> <span class="p">(</span><span class="mf">5.1</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">)</span> <span class="p">],</span>
    <span class="p">[</span> <span class="p">(</span><span class="mf">3.4</span><span class="p">,</span> <span class="mf">6.3</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mf">4.6</span><span class="p">,</span> <span class="mf">9.2</span><span class="p">)</span> <span class="p">],</span>
<span class="p">]</span>
</pre></div>
</div>
<p>现在假设这个数据被编码到一个以下列头部开始的二进制文件中去了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>+------+--------+------------------------------------+
|Byte  | Type   |  Description                       |
+======+========+====================================+
|0     | int    |  文件代码（0x1234，小端）          |
+------+--------+------------------------------------+
|4     | double |  x 的最小值（小端）                |
+------+--------+------------------------------------+
|12    | double |  y 的最小值（小端）                |
+------+--------+------------------------------------+
|20    | double |  x 的最大值（小端）                |
+------+--------+------------------------------------+
|28    | double |  y 的最大值（小端）                |
+------+--------+------------------------------------+
|36    | int    |  三角形数量（小端）                |
+------+--------+------------------------------------+
</pre></div>
</div>
<p>紧跟着头部是一系列的多边形记录，编码格式如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>+------+--------+-------------------------------------------+
|Byte  | Type   |  Description                              |
+======+========+===========================================+
|0     | int    |  记录长度（N字节）                        |
+------+--------+-------------------------------------------+
|4-N   | Points |  (X,Y) 坐标，以浮点数表示                 |
+------+--------+-------------------------------------------+
</pre></div>
</div>
<p>为了写这样的文件，你可以使用如下的Python代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="k">def</span> <span class="nf">write_polys</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">polys</span><span class="p">):</span>
    <span class="c1"># Determine bounding box</span>
    <span class="n">flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">polys</span><span class="p">))</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">)</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">)</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">)</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;iddddi&#39;</span><span class="p">,</span> <span class="mh">0x1234</span><span class="p">,</span>
                            <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span>
                            <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">*</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;&lt;dd&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;dd&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">pt</span><span class="p">))</span>
</pre></div>
</div>
<p>将数据读取回来的时候，可以利用函数 <code class="docutils literal"><span class="pre">struct.unpack()</span></code> ，代码很相似，基本就是上面写操作的逆序。如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read_polys</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Read the header</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
        <span class="n">file_code</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">num_polys</span> <span class="o">=</span> \
            <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;iddddi&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_polys</span><span class="p">):</span>
            <span class="n">pbytes</span><span class="p">,</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pbytes</span> <span class="o">//</span> <span class="mi">16</span><span class="p">):</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;dd&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
                <span class="n">poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polys</span>
</pre></div>
</div>
<p>尽管这个代码可以工作，但是里面混杂了很多读取、解包数据结构和其他细节的代码。如果用这样的代码来处理真实的数据文件，
那未免也太繁杂了点。因此很显然应该有另一种解决方法可以简化这些步骤，让程序员只关注自最重要的事情。</p>
<p>在本小节接下来的部分，我会逐步演示一个更加优秀的解析字节数据的方案。
目标是可以给程序员提供一个高级的文件格式化方法，并简化读取和解包数据的细节。但是我要先提醒你，
本小节接下来的部分代码应该是整本书中最复杂最高级的例子，使用了大量的面向对象编程和元编程技术。
一定要仔细的阅读我们的讨论部分，另外也要参考下其他章节内容。</p>
<p>首先，当读取字节数据的时候，通常在文件开始部分会包含文件头和其他的数据结构。
尽管struct模块可以解包这些数据到一个元组中去，另外一种表示这种信息的方式就是使用一个类。
就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span>

<span class="k">class</span> <span class="nc">StructField</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Descriptor representing a simple structure field</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">r</span>

<span class="k">class</span> <span class="nc">Structure</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytedata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">bytedata</span><span class="p">)</span>
</pre></div>
</div>
<p>这里我们使用了一个描述器来表示每个结构字段，每个描述器包含一个结构兼容格式的代码以及一个字节偏移量，
存储在内部的内存缓冲中。在 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法中，<code class="docutils literal"><span class="pre">struct.unpack_from()</span></code>
函数被用来从缓冲中解包一个值，省去了额外的分片或复制操作步骤。</p>
<p><code class="docutils literal"><span class="pre">Structure</span></code> 类就是一个基础类，接受字节数据并存储在内部的内存缓冲中，并被 <code class="docutils literal"><span class="pre">StructField</span></code> 描述器使用。
这里使用了 <code class="docutils literal"><span class="pre">memoryview()</span></code> ，我们会在后面详细讲解它是用来干嘛的。</p>
<p>使用这个代码，你现在就能定义一个高层次的结构对象来表示上面表格信息所期望的文件格式。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PolyHeader</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">file_code</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
    <span class="n">num_polys</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="mi">36</span><span class="p">)</span>
</pre></div>
</div>
<p>下面的例子利用这个类来读取之前我们写入的多边形数据的头部数据：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;polys.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">file_code</span> <span class="o">==</span> <span class="mh">0x1234</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min_x</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min_y</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max_x</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max_y</span>
<span class="go">9.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这个很有趣，不过这种方式还是有一些烦人的地方。首先，尽管你获得了一个类接口的便利，
但是这个代码还是有点臃肿，还需要使用者指定很多底层的细节(比如重复使用 <code class="docutils literal"><span class="pre">StructField</span></code> ，指定偏移量等)。
另外，返回的结果类同样确实一些便利的方法来计算结构的总数。</p>
<p>任何时候只要你遇到了像这样冗余的类定义，你应该考虑下使用类装饰器或元类。
元类有一个特性就是它能够被用来填充许多低层的实现细节，从而释放使用者的负担。
下面我来举个例子，使用元类稍微改造下我们的 <code class="docutils literal"><span class="pre">Structure</span></code> 类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StructureMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Metaclass that automatically creates StructField descriptors</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_fields_&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">byte_order</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">format</span><span class="p">,</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">format</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span><span class="s1">&#39;!&#39;</span><span class="p">,</span><span class="s1">&#39;@&#39;</span><span class="p">)):</span>
                <span class="n">byte_order</span> <span class="o">=</span> <span class="n">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">format</span> <span class="o">=</span> <span class="n">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">format</span> <span class="o">=</span> <span class="n">byte_order</span> <span class="o">+</span> <span class="n">format</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">StructField</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;struct_size&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Structure</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">StructureMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytedata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">bytedata</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">struct_size</span><span class="p">))</span>
</pre></div>
</div>
<p>使用新的 <code class="docutils literal"><span class="pre">Structure</span></code> 类，你可以像下面这样定义一个结构：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PolyHeader</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_code&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_y&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_y&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;num_polys&#39;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>正如你所见，这样写就简单多了。我们添加的类方法 <code class="docutils literal"><span class="pre">from_file()</span></code>
让我们在不需要知道任何数据的大小和结构的情况下就能轻松的从文件中读取数据。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;polys.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">file_code</span> <span class="o">==</span> <span class="mh">0x1234</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min_x</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min_y</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max_x</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max_y</span>
<span class="go">9.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一旦你开始使用了元类，你就可以让它变得更加智能。例如，假设你还想支持嵌套的字节结构，
下面是对前面元类的一个小的改进，提供了一个新的辅助描述器来达到想要的效果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NestedStruct</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Descriptor representing a nested structure</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">struct_type</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">struct_type</span> <span class="o">=</span> <span class="n">struct_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">struct_type</span><span class="o">.</span><span class="n">struct_size</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">struct_type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># Save resulting structure back on instance to avoid</span>
            <span class="c1"># further recomputation of this step</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

<span class="k">class</span> <span class="nc">StructureMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Metaclass that automatically creates StructField descriptors</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_fields_&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">byte_order</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">format</span><span class="p">,</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">StructureMeta</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span>
                        <span class="n">NestedStruct</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">format</span><span class="o">.</span><span class="n">struct_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">format</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span><span class="s1">&#39;!&#39;</span><span class="p">,</span><span class="s1">&#39;@&#39;</span><span class="p">)):</span>
                    <span class="n">byte_order</span> <span class="o">=</span> <span class="n">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">format</span> <span class="o">=</span> <span class="n">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">format</span> <span class="o">=</span> <span class="n">byte_order</span> <span class="o">+</span> <span class="n">format</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">StructField</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;struct_size&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>在这段代码中，<code class="docutils literal"><span class="pre">NestedStruct</span></code> 描述器被用来叠加另外一个定义在某个内存区域上的结构。
它通过将原始内存缓冲进行切片操作后实例化给定的结构类型。由于底层的内存缓冲区是通过一个内存视图初始化的，
所以这种切片操作不会引发任何的额外的内存复制。相反，它仅仅就是之前的内存的一个叠加而已。
另外，为了防止重复实例化，通过使用和8.10小节同样的技术，描述器保存了该实例中的内部结构对象。</p>
<p>使用这个新的修正版，你就可以像下面这样编写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="p">]</span>

<span class="k">class</span> <span class="nc">PolyHeader</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_code&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">),</span> <span class="c1"># nested struct</span>
        <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">),</span> <span class="c1"># nested struct</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;num_polys&#39;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>令人惊讶的是，它也能按照预期的正常工作，我们实际操作下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;polys.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">file_code</span> <span class="o">==</span> <span class="mh">0x1234</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min</span> <span class="c1"># Nested structure</span>
<span class="go">&lt;__main__.Point object at 0x1006a48d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span>
<span class="go">9.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>到目前为止，一个处理定长记录的框架已经写好了。但是如果组件记录是变长的呢？
比如，多边形文件包含变长的部分。</p>
<p>一种方案是写一个类来表示字节数据，同时写一个工具函数来通过多少方式解析内容。跟6.11小节的代码很类似：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SizedRecord</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytedata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">bytedata</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">size_fmt</span><span class="p">,</span> <span class="n">includes_size</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">sz_nbytes</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">size_fmt</span><span class="p">)</span>
        <span class="n">sz_bytes</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">sz_nbytes</span><span class="p">)</span>
        <span class="n">sz</span><span class="p">,</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">size_fmt</span><span class="p">,</span> <span class="n">sz_bytes</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">sz</span> <span class="o">-</span> <span class="n">includes_size</span> <span class="o">*</span> <span class="n">sz_nbytes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iter_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">s</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">,</span> <span class="n">off</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">StructureMeta</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">struct_size</span>
            <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">),</span> <span class="n">size</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">off</span><span class="p">:</span><span class="n">off</span><span class="o">+</span><span class="n">size</span><span class="p">]</span>
                <span class="k">yield</span> <span class="n">code</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>类方法 <code class="docutils literal"><span class="pre">SizedRecord.from_file()</span></code> 是一个工具，用来从一个文件中读取带大小前缀的数据块，
这也是很多文件格式常用的方式。作为输入，它接受一个包含大小编码的结构格式编码，并且也是自己形式。
可选的 <code class="docutils literal"><span class="pre">includes_size</span></code> 参数指定了字节数是否包含头部大小。
下面是一个例子教你怎样使用从多边形文件中读取单独的多边形数据：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;polys.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polydata</span> <span class="o">=</span> <span class="p">[</span> <span class="n">SizedRecord</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&lt;i&#39;</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polydata</span>
<span class="go">[&lt;__main__.SizedRecord object at 0x1006a4d50&gt;,</span>
<span class="go">&lt;__main__.SizedRecord object at 0x1006a4f50&gt;,</span>
<span class="go">&lt;__main__.SizedRecord object at 0x10070da90&gt;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以看出，<code class="docutils literal"><span class="pre">SizedRecord</span></code> 实例的内容还没有被解析出来。
可以使用 <code class="docutils literal"><span class="pre">iter_as()</span></code> 方法来达到目的，这个方法接受一个结构格式化编码或者是 <code class="docutils literal"><span class="pre">Structure</span></code> 类作为输入。
这样子可以很灵活的去解析数据，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polydata</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Polygon&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">iter_as</span><span class="p">(</span><span class="s1">&#39;&lt;dd&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Polygon 0</span>
<span class="go">(1.0, 2.5)</span>
<span class="go">(3.5, 4.0)</span>
<span class="go">(2.5, 1.5)</span>
<span class="go">Polygon 1</span>
<span class="go">(7.0, 1.2)</span>
<span class="go">(5.1, 3.0)</span>
<span class="go">(0.5, 7.5)</span>
<span class="go">(0.8, 9.0)</span>
<span class="go">Polygon 2</span>
<span class="go">(3.4, 6.3)</span>
<span class="go">(1.2, 0.5)</span>
<span class="go">(4.6, 9.2)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polydata</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Polygon&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">iter_as</span><span class="p">(</span><span class="n">Point</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Polygon 0</span>
<span class="go">1.0 2.5</span>
<span class="go">3.5 4.0</span>
<span class="go">2.5 1.5</span>
<span class="go">Polygon 1</span>
<span class="go">7.0 1.2</span>
<span class="go">5.1 3.0</span>
<span class="go">0.5 7.5</span>
<span class="go">0.8 9.0</span>
<span class="go">Polygon 2</span>
<span class="go">3.4 6.3</span>
<span class="go">1.2 0.5</span>
<span class="go">4.6 9.2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>将所有这些结合起来，下面是一个 <code class="docutils literal"><span class="pre">read_polys()</span></code> 函数的另外一个修正版：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="p">]</span>

<span class="k">class</span> <span class="nc">PolyHeader</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_code&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;num_polys&#39;</span><span class="p">)</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">read_polys</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span><span class="p">):</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">SizedRecord</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&lt;i&#39;</span><span class="p">)</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rec</span><span class="o">.</span><span class="n">iter_as</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polys</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一节向你展示了许多高级的编程技术，包括描述器，延迟计算，元类，类变量和内存视图。
然而，它们都为了同一个特定的目标服务。</p>
<p>上面的实现的一个主要特征是它是基于懒解包的思想。当一个 <code class="docutils literal"><span class="pre">Structure</span></code> 实例被创建时，
<code class="docutils literal"><span class="pre">__init__()</span></code> 仅仅只是创建一个字节数据的内存视图，没有做其他任何事。
特别的，这时候并没有任何的解包或者其他与结构相关的操作发生。
这样做的一个动机是你可能仅仅只对一个字节记录的某一小部分感兴趣。我们只需要解包你需要访问的部分，而不是整个文件。</p>
<p>为了实现懒解包和打包，需要使用 <code class="docutils literal"><span class="pre">StructField</span></code> 描述器类。
用户在 <code class="docutils literal"><span class="pre">_fields_</span></code> 中列出来的每个属性都会被转化成一个 <code class="docutils literal"><span class="pre">StructField</span></code> 描述器，
它将相关结构格式码和偏移值保存到存储缓存中。元类 <code class="docutils literal"><span class="pre">StructureMeta</span></code> 在多个结构类被定义时自动创建了这些描述器。
我们使用元类的一个主要原因是它使得用户非常方便的通过一个高层描述就能指定结构格式，而无需考虑低层的细节问题。</p>
<p><code class="docutils literal"><span class="pre">StructureMeta</span></code> 的一个很微妙的地方就是它会固定字节数据顺序。
也就是说，如果任意的属性指定了一个字节顺序(&lt;表示低位优先 或者 &gt;表示高位优先)，
那后面所有字段的顺序都以这个顺序为准。这么做可以帮助避免额外输入，但是在定义的中间我们仍然可能切换顺序的。
比如，你可能有一些比较复杂的结构，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ShapeFile</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;&gt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_code&#39;</span><span class="p">),</span> <span class="c1"># Big endian</span>
        <span class="p">(</span><span class="s1">&#39;20s&#39;</span><span class="p">,</span> <span class="s1">&#39;unused&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_length&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;version&#39;</span><span class="p">),</span> <span class="c1"># Little endian</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;shape_type&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_y&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_y&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_z&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_z&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_m&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_m&#39;</span><span class="p">)</span> <span class="p">]</span>
</pre></div>
</div>
<p>之前我们提到过，<code class="docutils literal"><span class="pre">memoryview()</span></code> 的使用可以帮助我们避免内存的复制。
当结构存在嵌套的时候，<code class="docutils literal"><span class="pre">memoryviews</span></code> 可以叠加同一内存区域上定义的机构的不同部分。
这个特性比较微妙，但是它关注的是内存视图与普通字节数组的切片操作行为。
如果你在一个字节字符串或字节数组上执行切片操作，你通常会得到一个数据的拷贝。
而内存视图切片不是这样的，它仅仅是在已存在的内存上面叠加而已。因此，这种方式更加高效。</p>
<p>还有很多相关的章节可以帮助我们扩展这里讨论的方案。
参考8.13小节使用描述器构建一个类型系统。
8.10小节有更多关于延迟计算属性值的讨论，并且跟NestedStruct描述器的实现也有关。
9.19小节有一个使用元类来初始化类成员的例子，和 <code class="docutils literal"><span class="pre">StructureMeta</span></code> 类非常相似。
Python的 <code class="docutils literal"><span class="pre">ctypes</span></code> 源码同样也很有趣，它提供了对定义数据结构、数据结构嵌套这些相似功能的支持。</p>
</div>
</div>
<span id="document-c06/p13_summarizing_and_perform_statistics"></span><div class="section" id="id1">
<h3>6.13 数据的累加与统计操作<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要处理一个很大的数据集并需要计算数据总和或其他统计量。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于任何涉及到统计、时间序列以及其他相关技术的数据分析问题，都可以考虑使用 <a class="reference external" href="http://pandas.pydata.org/">Pandas库</a> 。</p>
<p>为了让你先体验下，下面是一个使用Pandas来分析芝加哥城市的
<a class="reference external" href="https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Rodent-Baiting/97t6-zrhs">老鼠和啮齿类动物数据库</a> 的例子。
在我写这篇文章的时候，这个数据库是一个拥有大概74,000行数据的CSV文件。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read a CSV file, skipping last line</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rats</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;rats.csv&#39;</span><span class="p">,</span> <span class="n">skip_footer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rats</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">Int64Index: 74055 entries, 0 to 74054</span>
<span class="go">Data columns:</span>
<span class="go">Creation Date 74055 non-null values</span>
<span class="go">Status 74055 non-null values</span>
<span class="go">Completion Date 72154 non-null values</span>
<span class="go">Service Request Number 74055 non-null values</span>
<span class="go">Type of Service Request 74055 non-null values</span>
<span class="go">Number of Premises Baited 65804 non-null values</span>
<span class="go">Number of Premises with Garbage 65600 non-null values</span>
<span class="go">Number of Premises with Rats 65752 non-null values</span>
<span class="go">Current Activity 66041 non-null values</span>
<span class="go">Most Recent Action 66023 non-null values</span>
<span class="go">Street Address 74055 non-null values</span>
<span class="go">ZIP Code 73584 non-null values</span>
<span class="go">X Coordinate 74043 non-null values</span>
<span class="go">Y Coordinate 74043 non-null values</span>
<span class="go">Ward 74044 non-null values</span>
<span class="go">Police District 74044 non-null values</span>
<span class="go">Community Area 74044 non-null values</span>
<span class="go">Latitude 74043 non-null values</span>
<span class="go">Longitude 74043 non-null values</span>
<span class="go">Location 74043 non-null values</span>
<span class="go">dtypes: float64(11), object(9)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Investigate range of values for a certain field</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rats</span><span class="p">[</span><span class="s1">&#39;Current Activity&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="go">array([nan, Dispatch Crew, Request Sanitation Inspector], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Filter the data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">crew_dispatched</span> <span class="o">=</span> <span class="n">rats</span><span class="p">[</span><span class="n">rats</span><span class="p">[</span><span class="s1">&#39;Current Activity&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Dispatch Crew&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">crew_dispatched</span><span class="p">)</span>
<span class="go">65676</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Find 10 most rat-infested ZIP codes in Chicago</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">crew_dispatched</span><span class="p">[</span><span class="s1">&#39;ZIP Code&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()[:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">60647 3837</span>
<span class="go">60618 3530</span>
<span class="go">60614 3284</span>
<span class="go">60629 3251</span>
<span class="go">60636 2801</span>
<span class="go">60657 2465</span>
<span class="go">60641 2238</span>
<span class="go">60609 2206</span>
<span class="go">60651 2152</span>
<span class="go">60632 2071</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Group by completion date</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dates</span> <span class="o">=</span> <span class="n">crew_dispatched</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;Completion Date&#39;</span><span class="p">)</span>
<span class="go">&lt;pandas.core.groupby.DataFrameGroupBy object at 0x10d0a2a10&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>
<span class="go">472</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Determine counts on each day</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">date_counts</span> <span class="o">=</span> <span class="n">dates</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">date_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">Completion Date</span>
<span class="go">01/03/2011 4</span>
<span class="go">01/03/2012 125</span>
<span class="go">01/04/2011 54</span>
<span class="go">01/04/2012 38</span>
<span class="go">01/05/2011 78</span>
<span class="go">01/05/2012 100</span>
<span class="go">01/06/2011 100</span>
<span class="go">01/06/2012 58</span>
<span class="go">01/07/2011 1</span>
<span class="go">01/09/2012 12</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Sort the counts</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">date_counts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">date_counts</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]</span>
<span class="go">Completion Date</span>
<span class="go">10/12/2012 313</span>
<span class="go">10/21/2011 314</span>
<span class="go">09/20/2011 316</span>
<span class="go">10/26/2011 319</span>
<span class="go">02/22/2011 325</span>
<span class="go">10/26/2012 333</span>
<span class="go">03/17/2011 336</span>
<span class="go">10/13/2011 378</span>
<span class="go">10/14/2011 391</span>
<span class="go">10/07/2011 457</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>嗯，看样子2011年10月7日对老鼠们来说是个很忙碌的日子啊！^_^</p>
</div>
<div class="section" id="id5">
<h4>讨论<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>Pandas是一个拥有很多特性的大型函数库，我在这里不可能介绍完。
但是只要你需要去分析大型数据集合、对数据分组、计算各种统计量或其他类似任务的话，这个函数库真的值得你去看一看。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p07_functions"></span><div class="section" id="id1">
<h2>第七章：函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>使用 <code class="docutils literal"><span class="pre">def</span></code> 语句定义函数是所有程序的基础。
本章的目标是讲解一些更加高级和不常见的函数定义与使用模式。
涉及到的内容包括默认参数、任意数量参数、强制关键字参数、注解和闭包。
另外，一些高级的控制流和利用回调函数传递数据的技术在这里也会讲解到。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c07/p01_functions_that_accept_any_number_arguments"></span><div class="section" id="id1">
<h3>7.1 可接受任意数量参数的函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想构造一个可接受任意数量参数的函数。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了能让一个函数接受任意数量的位置参数，可以使用一个*参数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">avg</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rest</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">))</span>

<span class="c1"># Sample use</span>
<span class="n">avg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># 1.5</span>
<span class="n">avg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># 2.5</span>
</pre></div>
</div>
<p>在这个例子中，rest是由所有其他位置参数组成的元组。然后我们在代码中把它当成了一个序列来进行后续的计算。</p>
<p>为了接受任意数量的关键字参数，使用一个以**开头的参数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">html</span>

<span class="k">def</span> <span class="nf">make_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
    <span class="n">keyvals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; </span><span class="si">%s</span><span class="s1">=&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">attr_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">keyvals</span><span class="p">)</span>
    <span class="n">element</span> <span class="o">=</span> <span class="s1">&#39;&lt;{name}{attrs}&gt;{value}&lt;/{name}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">attrs</span><span class="o">=</span><span class="n">attr_str</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">element</span>

<span class="c1"># Example</span>
<span class="c1"># Creates &#39;&lt;item size=&quot;large&quot; quantity=&quot;6&quot;&gt;Albatross&lt;/item&gt;&#39;</span>
<span class="n">make_element</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">,</span> <span class="s1">&#39;Albatross&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;large&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Creates &#39;&lt;p&gt;&amp;lt;spam&amp;gt;&lt;/p&gt;&#39;</span>
<span class="n">make_element</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;spam&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在这里，attrs是一个包含所有被传入进来的关键字参数的字典。</p>
<p>如果你还希望某个函数能同时接受任意数量的位置参数和关键字参数，可以同时使用*和**。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">anyargs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="c1"># A tuple</span>
    <span class="k">print</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># A dict</span>
</pre></div>
</div>
<p>使用这个函数时，所有位置参数会被放到args元组中，所有关键字参数会被放到字典kwargs中。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>一个*参数只能出现在函数定义中最后一个位置参数后面，而 <a href="#id5"><span class="problematic" id="id6">**</span></a>参数只能出现在最后一个参数。
有一点要注意的是，在*参数后面仍然可以定义其他参数。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>这种参数就是我们所说的强制关键字参数，在后面7.2小节还会详细讲解到。</p>
</div>
</div>
<span id="document-c07/p02_functions_that_only_accept_keyword_arguments"></span><div class="section" id="id1">
<h3>7.2 只接受关键字参数的函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你希望函数的某些参数强制使用关键字参数传递</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>将强制关键字参数放到某个*参数或者单个*后面就能达到这种效果。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recv</span><span class="p">(</span><span class="n">maxsize</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
    <span class="s1">&#39;Receives a message&#39;</span>
    <span class="k">pass</span>

<span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="c1"># TypeError</span>
<span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># Ok</span>
</pre></div>
</div>
<p>利用这种技术，我们还能在接受任意多个位置参数的函数中指定关键字参数。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mininum</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">clip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">clip</span> <span class="k">if</span> <span class="n">clip</span> <span class="o">&gt;</span> <span class="n">m</span> <span class="k">else</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">m</span>

<span class="n">minimum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># Returns -5</span>
<span class="n">minimum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Returns 0</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>很多情况下，使用强制关键字参数会比使用位置参数表意更加清晰，程序也更加具有可读性。
例如，考虑下如下一个函数调用：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">msg</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>如果调用者对recv函数并不是很熟悉，那他肯定不明白那个False参数到底来干嘛用的。
但是，如果代码变成下面这样子的话就清楚多了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">msg</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>另外，使用强制关键字参数也会比使用**kwargs参数更好，因为在使用函数help的时候输出也会更容易理解：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">recv</span><span class="p">)</span>
<span class="go">Help on function recv in module __main__:</span>
<span class="go">recv(maxsize, *, block)</span>
<span class="go">    Receives a message</span>
</pre></div>
</div>
<p>强制关键字参数在一些更高级场合同样也很有用。
例如，它们可以被用来在使用*args和**kwargs参数作为输入的函数中插入参数，9.11小节有一个这样的例子。</p>
</div>
</div>
<span id="document-c07/p03_attach_informatinal_matadata_to_function_arguments"></span><div class="section" id="id1">
<h3>7.3 给函数参数增加元信息<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你写好了一个函数，然后想为这个函数的参数增加一些额外的信息，这样的话其他使用者就能清楚的知道这个函数应该怎么使用。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用函数参数注解是一个很好的办法，它能提示程序员应该怎样正确使用这个函数。
例如，下面有一个被注解了的函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>python解释器不会对这些注解添加任何的语义。它们不会被类型检查，运行时跟没有加注解之前的效果也没有任何差距。
然而，对于那些阅读源码的人来讲就很有帮助啦。第三方工具和框架可能会对这些注解添加语义。同时它们也会出现在文档中。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="go">Help on function add in module __main__:</span>
<span class="go">add(x: int, y: int) -&gt; int</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>尽管你可以使用任意类型的对象给函数添加注解(例如数字，字符串，对象实例等等)，不过通常来讲使用类或者字符串会比较好点。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>函数注解只存储在函数的 <code class="docutils literal"><span class="pre">__annotations__</span></code> 属性中。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">__annotations__</span>
<span class="go">{&#39;y&#39;: &lt;class &#39;int&#39;&gt;, &#39;return&#39;: &lt;class &#39;int&#39;&gt;, &#39;x&#39;: &lt;class &#39;int&#39;&gt;}</span>
</pre></div>
</div>
<p>尽管注解的使用方法可能有很多种，但是它们的主要用途还是文档。
因为python并没有类型声明，通常来讲仅仅通过阅读源码很难知道应该传递什么样的参数给这个函数。
这时候使用注解就能给程序员更多的提示，让他们可以正确的使用函数。</p>
<p>参考9.20小节的一个更加高级的例子，演示了如何利用注解来实现多分派(比如重载函数)。</p>
</div>
</div>
<span id="document-c07/p04_return_multiple_values_from_function"></span><div class="section" id="id1">
<h3>7.4 返回多个值的函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你希望构造一个可以返回多个值的函数</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了能返回多个值，函数直接return一个元组就行了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myfun</span><span class="p">():</span>
<span class="gp">... </span><span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">myfun</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>尽管myfun()看上去返回了多个值，实际上是先创建了一个元组然后返回的。
这个语法看上去比较奇怪，实际上我们使用的是逗号来生成一个元组，而不是用括号。比如下面的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># With parentheses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="c1"># Without parentheses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">(1, 2)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当我们调用返回一个元组的函数的时候 ，通常我们会将结果赋值给多个变量，就像上面的那样。
其实这就是1.1小节中我们所说的元组解包。返回结果也可以赋值给单个变量，
这时候这个变量值就是函数返回的那个元组本身了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">myfun</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">(1, 2, 3)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c07/p05_define_functions_with_default_arguments"></span><div class="section" id="id1">
<h3>7.5 定义有默认参数的函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想定义一个函数或者方法，它的一个或多个参数是可选的并且有一个默认值。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>定义一个有可选参数的函数是非常简单的，直接在函数定义中给参数指定一个默认值，并放到参数列表最后就行了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Ok. a=1, b=42</span>
<span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Ok. a=1, b=2</span>
</pre></div>
</div>
<p>如果默认参数是一个可修改的容器比如一个列表、集合或者字典，可以使用None作为默认值，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Using a list as a default value</span>
<span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果你并不想提供一个默认值，而是想仅仅测试下某个默认参数是不是有传递进来，可以像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">_no_value</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">_no_value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">_no_value</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;No b value supplied&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>我们测试下这个函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">No b value supplied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># b = 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="c1"># b = None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>仔细观察可以发现到传递一个None值和不传值两种情况是有差别的。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>定义带默认值参数的函数是很简单的，但绝不仅仅只是这个，还有一些东西在这里也深入讨论下。</p>
<p>首先，默认参数的值仅仅在函数定义的时候赋值一次。试着运行下面这个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1 42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">23</span> <span class="c1"># Has no effect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1 42</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意到当我们改变x的值的时候对默认参数值并没有影响，这是因为在函数定义的时候就已经确定了它的默认值了。</p>
<p>其次，默认参数的值应该是不可变的对象，比如None、True、False、数字或字符串。
特别的，千万不要像下面这样写代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">[]):</span> <span class="c1"># NO!</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果你这么做了，当默认值在其他地方被修改后你将会遇到各种麻烦。这些修改会影响到下次调用这个函数时的默认值。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">[]):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Yow!&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">[99, &#39;Yow!&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Modified list gets returned!</span>
<span class="go">[99, &#39;Yow!&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种结果应该不是你想要的。为了避免这种情况的发生，最好是将默认值设为None，
然后在函数里面检查它，前面的例子就是这样做的。</p>
<p>在测试None值时使用 <code class="docutils literal"><span class="pre">is</span></code> 操作符是很重要的，也是这种方案的关键点。
有时候大家会犯下下面这样的错误：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span> <span class="c1"># NO! Use &#39;b is None&#39; instead</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这么写的问题在于尽管None值确实是被当成False，
但是还有其他的对象(比如长度为0的字符串、列表、元组、字典等)都会被当做False。
因此，上面的代码会误将一些其他输入也当成是没有输入。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># OK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># Silent error. x value overwritten by default</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Silent error. 0 ignored</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="c1"># Silent error. &#39;&#39; ignored</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。
这时候需要小心的是你不能用某个默认值比如None、
0或者False值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。
因此，你需要其他的解决方案了。</p>
<p>为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的_no_value变量那样。
在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。
这里的思路是用户不可能去传递这个_no_value实例作为输入。
因此，这里通过检查这个值就能确定某个参数是否被传递进来了。</p>
<p>这里对 <code class="docutils literal"><span class="pre">object()</span></code> 的使用看上去有点不太常见。<code class="docutils literal"><span class="pre">object</span></code> 是python中所有类的基类。
你可以创建 <code class="docutils literal"><span class="pre">object</span></code> 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法，
也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。
你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。</p>
</div>
</div>
<span id="document-c07/p06_define_anonymous_or_inline_functions"></span><div class="section" id="id1">
<h3>7.6 定义匿名或内联函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想为 <code class="docutils literal"><span class="pre">sort()</span></code> 操作创建一个很短的回调函数，但又不想用 <code class="docutils literal"><span class="pre">def</span></code> 去写一个单行函数，
而是希望通过某个快捷方式以内联方式来创建这个函数。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>当一些函数很简单，仅仅只是计算一个表达式的值的时候，就可以使用lambda表达式来代替了。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">)</span>
<span class="go">&#39;helloworld&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这里使用的lambda表达式跟下面的效果是一样的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>lambda表达式典型的使用场景是排序或数据reduce等：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;David Beazley&#39;</span><span class="p">,</span> <span class="s1">&#39;Brian Jones&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;Raymond Hettinger&#39;</span><span class="p">,</span> <span class="s1">&#39;Ned Batchelder&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
<span class="go">[&#39;Ned Batchelder&#39;, &#39;David Beazley&#39;, &#39;Raymond Hettinger&#39;, &#39;Brian Jones&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>尽管lambda表达式允许你定义简单函数，但是它的使用是有限制的。
你只能指定单个表达式，它的值就是最后的返回值。也就是说不能包含其他的语言特性了，
包括多个语句、条件表达式、迭代以及异常处理等等。</p>
<p>你可以不使用lambda表达式就能编写大部分python代码。
但是，当有人编写大量计算表达式值的短小函数或者需要用户提供回调函数的程序的时候，
你就会看到lambda表达式的身影了。</p>
</div>
</div>
<span id="document-c07/p07_capturing_variables_in_anonymous_functions"></span><div class="section" id="id1">
<h3>7.7 匿名函数捕获变量值<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你用lambda定义了一个匿名函数，并想在定义时捕获到某些变量的值。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>先看下下面代码的效果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>现在我问你，a(10)和b(10)返回的结果是什么？如果你认为结果是20和30，那么你就错了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">30</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这其中的奥妙在于lambda表达式中的x是一个自由变量，
在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。
因此，在调用这个lambda表达式的时候，x的值是执行时的值。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想让某个匿名函数在定义时就捕获到值，可以将那个参数值定义成默认参数即可，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">30</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在这里列出来的问题是新手很容易犯的错误，有些新手可能会不恰当的使用lambda表达式。
比如，通过在一个循环或列表推导中创建一个lambda表达式列表，并期望函数能在定义时就记住每次的迭代值。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">4</span>
<span class="go">4</span>
<span class="go">4</span>
<span class="go">4</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但是实际效果是运行是n的值为迭代的最后一个值。现在我们用另一种方式修改一下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>通过使用函数默认值参数形式，lambda函数在定义时就能绑定到值。</p>
</div>
</div>
<span id="document-c07/p08_make_callable_with_fewer_arguments"></span><div class="section" id="id1">
<h3>7.8 减少可调用对象的参数个数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个被其他python代码使用的callable对象，可能是一个回调函数或者是一个处理器，
但是它的参数太多了，导致调用时出错。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果需要减少某个函数的参数个数，你可以使用 <code class="docutils literal"><span class="pre">functools.partial()</span></code> 。
<code class="docutils literal"><span class="pre">partial()</span></code> 函数允许你给一个或多个参数设置固定的值，减少接下来被调用时的参数个数。
为了演示清楚，假设你有下面这样的函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>现在我们使用 <code class="docutils literal"><span class="pre">partial()</span></code> 函数来固定某些参数值：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">spam</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># a = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">1 4 5 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">spam</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span> <span class="c1"># d = 42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">1 2 3 42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">4 5 5 42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">spam</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span> <span class="c1"># a = 1, b = 2, d = 42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1 2 3 42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">1 2 4 42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">1 2 5 42</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以看出 <code class="docutils literal"><span class="pre">partial()</span></code> 固定某些参数并返回一个新的callable对象。这个新的callable接受未赋值的参数，
然后跟之前已经赋值过的参数合并起来，最后将所有参数传递给原始函数。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本节要解决的问题是让原本不兼容的代码可以一起工作。下面我会列举一系列的例子。</p>
<p>第一个例子是，假设你有一个点的列表来表示(x,y)坐标元组。
你可以使用下面的函数来计算两点之间的距离：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">points</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="p">]</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">p1</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">p2</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</pre></div>
</div>
<p>现在假设你想以某个点为基点，根据点和基点之间的距离来排序所有的这些点。
列表的 <code class="docutils literal"><span class="pre">sort()</span></code> 方法接受一个关键字参数来自定义排序逻辑，
但是它只能接受一个单个参数的函数(distance()很明显是不符合条件的)。
现在我们可以通过使用 <code class="docutils literal"><span class="pre">partial()</span></code> 来解决这个问题：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span><span class="n">pt</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span>
<span class="go">[(3, 4), (1, 2), (5, 6), (7, 8)]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>更进一步，<code class="docutils literal"><span class="pre">partial()</span></code> 通常被用来微调其他库函数所使用的回调函数的参数。
例如，下面是一段代码，使用 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 来异步计算一个结果值，
然后这个值被传递给一个接受一个result值和一个可选logging参数的回调函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">output_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">log</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Got: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="c1"># A sample function</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">logging</span>
    <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">output_result</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>当给 <code class="docutils literal"><span class="pre">apply_async()</span></code> 提供回调函数时，通过使用 <code class="docutils literal"><span class="pre">partial()</span></code> 传递额外的 <code class="docutils literal"><span class="pre">logging</span></code> 参数。
而 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 对这些一无所知——它仅仅只是使用单个值来调用回调函数。</p>
<p>作为一个类似的例子，考虑下编写网络服务器的问题，<code class="docutils literal"><span class="pre">socketserver</span></code> 模块让它变得很容易。
下面是个简单的echo服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socketserver</span> <span class="kn">import</span> <span class="n">StreamRequestHandler</span><span class="p">,</span> <span class="n">TCPServer</span>

<span class="k">class</span> <span class="nc">EchoHandler</span><span class="p">(</span><span class="n">StreamRequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;GOT:&#39;</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span>

<span class="n">serv</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span> <span class="n">EchoHandler</span><span class="p">)</span>
<span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>不过，假设你想给EchoHandler增加一个可以接受其他配置选项的 <code class="docutils literal"><span class="pre">__init__</span></code> 方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EchoHandler</span><span class="p">(</span><span class="n">StreamRequestHandler</span><span class="p">):</span>
    <span class="c1"># ack is added keyword-only argument. *args, **kwargs are</span>
    <span class="c1"># any normal parameters supplied (which are passed on)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ack</span> <span class="o">=</span> <span class="n">ack</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ack</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p>这么修改后，我们就不需要显式地在TCPServer类中添加前缀了。
但是你再次运行程序后会报类似下面的错误：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ne">Exception</span> <span class="n">happened</span> <span class="n">during</span> <span class="n">processing</span> <span class="n">of</span> <span class="n">request</span> <span class="kn">from</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">59834</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="o">...</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="fm">__init__</span><span class="p">()</span> <span class="n">missing</span> <span class="mi">1</span> <span class="n">required</span> <span class="n">keyword</span><span class="o">-</span><span class="n">only</span> <span class="n">argument</span><span class="p">:</span> <span class="s1">&#39;ack&#39;</span>
</pre></div>
</div>
<p>初看起来好像很难修正这个错误，除了修改 <code class="docutils literal"><span class="pre">socketserver</span></code> 模块源代码或者使用某些奇怪的方法之外。
但是，如果使用 <code class="docutils literal"><span class="pre">partial()</span></code> 就能很轻松的解决——给它传递 <code class="docutils literal"><span class="pre">ack</span></code> 参数的值来初始化即可，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="n">serv</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span> <span class="n">partial</span><span class="p">(</span><span class="n">EchoHandler</span><span class="p">,</span> <span class="n">ack</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;RECEIVED:&#39;</span><span class="p">))</span>
<span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>在这个例子中，<code class="docutils literal"><span class="pre">__init__()</span></code> 方法中的ack参数声明方式看上去很有趣，其实就是声明ack为一个强制关键字参数。
关于强制关键字参数问题我们在7.2小节我们已经讨论过了，读者可以再去回顾一下。</p>
<p>很多时候 <code class="docutils literal"><span class="pre">partial()</span></code> 能实现的效果，lambda表达式也能实现。比如，之前的几个例子可以使用下面这样的表达式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">points</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">distance</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
<span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">result</span><span class="p">:</span> <span class="n">output_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">log</span><span class="p">))</span>
<span class="n">serv</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">EchoHandler</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ack</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;RECEIVED:&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
</pre></div>
</div>
<p>这样写也能实现同样的效果，不过相比而已会显得比较臃肿，对于阅读代码的人来讲也更加难懂。
这时候使用 <code class="docutils literal"><span class="pre">partial()</span></code> 可以更加直观的表达你的意图(给某些参数预先赋值)。</p>
</div>
</div>
<span id="document-c07/p09_replace_single_method_classes_with_functions"></span><div class="section" id="id1">
<h3>7.9 将单方法的类转换为函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个除 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法外只定义了一个方法的类。为了简化代码，你想将它转换成一个函数。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>大多数情况下，可以使用闭包来将单个方法的类转换成函数。
举个例子，下面示例中的类允许使用者根据某个模板方案来获取到URL链接地址。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>

<span class="k">class</span> <span class="nc">UrlTemplate</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="n">template</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">urlopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

<span class="c1"># Example use. Download stock data from yahoo</span>
<span class="n">yahoo</span> <span class="o">=</span> <span class="n">UrlTemplate</span><span class="p">(</span><span class="s1">&#39;http://finance.yahoo.com/d/quotes.csv?s={names}&amp;f={fields}&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">yahoo</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="s1">&#39;IBM,AAPL,FB&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="s1">&#39;sl1c1v&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>这个类可以被一个更简单的函数来代替：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">urltemplate</span><span class="p">(</span><span class="n">template</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">opener</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">urlopen</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">opener</span>

<span class="c1"># Example use</span>
<span class="n">yahoo</span> <span class="o">=</span> <span class="n">urltemplate</span><span class="p">(</span><span class="s1">&#39;http://finance.yahoo.com/d/quotes.csv?s={names}&amp;f={fields}&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">yahoo</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="s1">&#39;IBM,AAPL,FB&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="s1">&#39;sl1c1v&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>大部分情况下，你拥有一个单方法类的原因是需要存储某些额外的状态来给方法使用。
比如，定义UrlTemplate类的唯一目的就是先在某个地方存储模板值，以便将来可以在open()方法中使用。</p>
<p>使用一个内部函数或者闭包的方案通常会更优雅一些。简单来讲，一个闭包就是一个函数，
只不过在函数内部带上了一个额外的变量环境。闭包关键特点就是它会记住自己被定义时的环境。
因此，在我们的解决方案中，<code class="docutils literal"><span class="pre">opener()</span></code> 函数记住了 <code class="docutils literal"><span class="pre">template</span></code> 参数的值，并在接下来的调用中使用它。</p>
<p>任何时候只要你碰到需要给某个函数增加额外的状态信息的问题，都可以考虑使用闭包。
相比将你的函数转换成一个类而言，闭包通常是一种更加简洁和优雅的方案。</p>
</div>
</div>
<span id="document-c07/p10_carry_extra_state_with_callback_functions"></span><div class="section" id="id1">
<h3>7.10 带额外状态信息的回调函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的代码中需要依赖到回调函数的使用(比如事件处理器、等待后台任务完成后的回调等)，
并且你还需要让回调函数拥有额外的状态值，以便在它的内部使用到。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这一小节主要讨论的是那些出现在很多函数库和框架中的回调函数的使用——特别是跟异步处理有关的。
为了演示与测试，我们先定义如下一个需要调用回调函数的函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apply_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="c1"># Compute the result</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># Invoke the callback with the result</span>
    <span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>实际上，这段代码可以做任何更高级的处理，包括线程、进程和定时器，但是这些都不是我们要关心的。
我们仅仅只需要关注回调函数的调用。下面是一个演示怎样使用上述代码的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_result</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got:&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">print_result</span><span class="p">)</span>
<span class="go">Got: 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">print_result</span><span class="p">)</span>
<span class="go">Got: helloworld</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意到 <code class="docutils literal"><span class="pre">print_result()</span></code> 函数仅仅只接受一个参数 <code class="docutils literal"><span class="pre">result</span></code> 。不能再传入其他信息。
而当你想让回调函数访问其他变量或者特定环境的变量值的时候就会遇到麻烦。</p>
<p>为了让回调函数访问外部信息，一种方法是使用一个绑定方法来代替一个简单函数。
比如，下面这个类会保存一个内部序列号，每次接收到一个 <code class="docutils literal"><span class="pre">result</span></code> 的时候序列号加1：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ResultHandler</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;[{}] Got: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
<p>使用这个类的时候，你先创建一个类的实例，然后用它的 <code class="docutils literal"><span class="pre">handler()</span></code> 绑定方法来做为回调函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">ResultHandler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>
<span class="go">[1] Got: 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>
<span class="go">[2] Got: helloworld</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>第二种方式，作为类的替代，可以使用一个闭包捕获状态值，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_handler</span><span class="p">():</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
        <span class="n">nonlocal</span> <span class="n">sequence</span>
        <span class="n">sequence</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;[{}] Got: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">handler</span>
</pre></div>
</div>
<p>下面是使用闭包方式的一个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">handler</span> <span class="o">=</span> <span class="n">make_handler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
<span class="go">[1] Got: 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
<span class="go">[2] Got: helloworld</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>还有另外一个更高级的方法，可以使用协程来完成同样的事情：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_handler</span><span class="p">():</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span>
        <span class="n">sequence</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;[{}] Got: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
<p>对于协程，你需要使用它的 <code class="docutils literal"><span class="pre">send()</span></code> 方法作为回调函数，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">handler</span> <span class="o">=</span> <span class="n">make_handler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="c1"># Advance to the yield</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">handler</span><span class="o">.</span><span class="n">send</span><span class="p">)</span>
<span class="go">[1] Got: 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">handler</span><span class="o">.</span><span class="n">send</span><span class="p">)</span>
<span class="go">[2] Got: helloworld</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>基于回调函数的软件通常都有可能变得非常复杂。一部分原因是回调函数通常会跟请求执行代码断开。
因此，请求执行和处理结果之间的执行环境实际上已经丢失了。如果你想让回调函数连续执行多步操作，
那你就必须去解决如何保存和恢复相关的状态信息了。</p>
<p>至少有两种主要方式来捕获和保存状态信息，你可以在一个对象实例(通过一个绑定方法)或者在一个闭包中保存它。
两种方式相比，闭包或许是更加轻量级和自然一点，因为它们可以很简单的通过函数来构造。
它们还能自动捕获所有被使用到的变量。因此，你无需去担心如何去存储额外的状态信息(代码中自动判定)。</p>
<p>如果使用闭包，你需要注意对那些可修改变量的操作。在上面的方案中，
<code class="docutils literal"><span class="pre">nonlocal</span></code> 声明语句用来指示接下来的变量会在回调函数中被修改。如果没有这个声明，代码会报错。</p>
<p>而使用一个协程来作为一个回调函数就更有趣了，它跟闭包方法密切相关。
某种意义上来讲，它显得更加简洁，因为总共就一个函数而已。
并且，你可以很自由的修改变量而无需去使用 <code class="docutils literal"><span class="pre">nonlocal</span></code> 声明。
这种方式唯一缺点就是相对于其他Python技术而言或许比较难以理解。
另外还有一些比较难懂的部分，比如使用之前需要调用 <code class="docutils literal"><span class="pre">next()</span></code> ，实际使用时这个步骤很容易被忘记。
尽管如此，协程还有其他用处，比如作为一个内联回调函数的定义(下一节会讲到)。</p>
<p>如果你仅仅只需要给回调函数传递额外的值的话，还有一种使用 <code class="docutils literal"><span class="pre">partial()</span></code> 的方式也很有用。
在没有使用 <code class="docutils literal"><span class="pre">partial()</span></code> 的时候，你可能经常看到下面这种使用lambda表达式的复杂代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">apply_async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
<span class="go">[1] Got: 5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以参考7.8小节的几个示例，教你如何使用 <code class="docutils literal"><span class="pre">partial()</span></code> 来更改参数签名来简化上述代码。</p>
</div>
</div>
<span id="document-c07/p11_inline_callback_functions"></span><div class="section" id="id1">
<h3>7.11 内联回调函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>当你编写使用回调函数的代码的时候，担心很多小函数的扩张可能会弄乱程序控制流。
你希望找到某个方法来让代码看上去更像是一个普通的执行序列。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>通过使用生成器和协程可以使得回调函数内联在某个函数中。
为了演示说明，假设你有如下所示的一个执行某种计算任务然后调用一个回调函数的函数(参考7.10小节)：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apply_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="c1"># Compute the result</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># Invoke the callback with the result</span>
    <span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>接下来让我们看一下下面的代码，它包含了一个 <code class="docutils literal"><span class="pre">Async</span></code> 类和一个 <code class="docutils literal"><span class="pre">inlined_async</span></code> 装饰器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">class</span> <span class="nc">Async</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

<span class="k">def</span> <span class="nf">inlined_async</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">result_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
        <span class="n">result_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">apply_async</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">result_queue</span><span class="o">.</span><span class="n">put</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>这两个代码片段允许你使用 <code class="docutils literal"><span class="pre">yield</span></code> 语句内联回调步骤。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nd">@inlined_async</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">Async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">Async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">Async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Goodbye&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你调用 <code class="docutils literal"><span class="pre">test()</span></code> ，你会得到类似如下的输出：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mi">5</span>
<span class="n">helloworld</span>
<span class="mi">0</span>
<span class="mi">2</span>
<span class="mi">4</span>
<span class="mi">6</span>
<span class="mi">8</span>
<span class="mi">10</span>
<span class="mi">12</span>
<span class="mi">14</span>
<span class="mi">16</span>
<span class="mi">18</span>
<span class="n">Goodbye</span>
</pre></div>
</div>
<p>你会发现，除了那个特别的装饰器和 <code class="docutils literal"><span class="pre">yield</span></code> 语句外，其他地方并没有出现任何的回调函数(其实是在后台定义的)。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本小节会实实在在的测试你关于回调函数、生成器和控制流的知识。</p>
<p>首先，在需要使用到回调的代码中，关键点在于当前计算工作会挂起并在将来的某个时候重启(比如异步执行)。
当计算重启时，回调函数被调用来继续处理结果。<code class="docutils literal"><span class="pre">apply_async()</span></code> 函数演示了执行回调的实际逻辑，
尽管实际情况中它可能会更加复杂(包括线程、进程、事件处理器等等)。</p>
<p>计算的暂停与重启思路跟生成器函数的执行模型不谋而合。
具体来讲，<code class="docutils literal"><span class="pre">yield</span></code> 操作会使一个生成器函数产生一个值并暂停。
接下来调用生成器的 <code class="docutils literal"><span class="pre">__next__()</span></code> 或 <code class="docutils literal"><span class="pre">send()</span></code> 方法又会让它从暂停处继续执行。</p>
<p>根据这个思路，这一小节的核心就在 <code class="docutils literal"><span class="pre">inline_async()</span></code> 装饰器函数中了。
关键点就是，装饰器会逐步遍历生成器函数的所有 <code class="docutils literal"><span class="pre">yield</span></code> 语句，每一次一个。
为了这样做，刚开始的时候创建了一个 <code class="docutils literal"><span class="pre">result</span></code> 队列并向里面放入一个 <code class="docutils literal"><span class="pre">None</span></code> 值。
然后开始一个循环操作，从队列中取出结果值并发送给生成器，它会持续到下一个 <code class="docutils literal"><span class="pre">yield</span></code> 语句，
在这里一个 <code class="docutils literal"><span class="pre">Async</span></code> 的实例被接受到。然后循环开始检查函数和参数，并开始进行异步计算 <code class="docutils literal"><span class="pre">apply_async()</span></code> 。
然而，这个计算有个最诡异部分是它并没有使用一个普通的回调函数，而是用队列的 <code class="docutils literal"><span class="pre">put()</span></code> 方法来回调。</p>
<p>这时候，是时候详细解释下到底发生了什么了。主循环立即返回顶部并在队列上执行 <code class="docutils literal"><span class="pre">get()</span></code> 操作。
如果数据存在，它一定是 <code class="docutils literal"><span class="pre">put()</span></code> 回调存放的结果。如果没有数据，那么先暂停操作并等待结果的到来。
这个具体怎样实现是由 <code class="docutils literal"><span class="pre">apply_async()</span></code> 函数来决定的。
如果你不相信会有这么神奇的事情，你可以使用 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 库来试一下，
在单独的进程中执行异步计算操作，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
    <span class="n">apply_async</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span>

    <span class="c1"># Run the test function</span>
    <span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>实际上你会发现这个真的就是这样的，但是要解释清楚具体的控制流得需要点时间了。</p>
<p>将复杂的控制流隐藏到生成器函数背后的例子在标准库和第三方包中都能看到。
比如，在 <code class="docutils literal"><span class="pre">contextlib</span></code> 中的 <code class="docutils literal"><span class="pre">&#64;contextmanager</span></code> 装饰器使用了一个令人费解的技巧，
通过一个 <code class="docutils literal"><span class="pre">yield</span></code> 语句将进入和离开上下文管理器粘合在一起。
另外非常流行的 <code class="docutils literal"><span class="pre">Twisted</span></code> 包中也包含了非常类似的内联回调。</p>
</div>
</div>
<span id="document-c07/p12_access_variables_defined_inside_closure"></span><div class="section" id="id1">
<h3>7.12 访问闭包中定义的变量<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想要扩展函数中的某个闭包，允许它能访问和修改函数的内部变量。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>通常来讲，闭包的内部变量对于外界来讲是完全隐藏的。
但是，你可以通过编写访问函数并将其作为函数属性绑定到闭包上来实现这个目的。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sample</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Closure function</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;n=&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="c1"># Accessor methods for n</span>
    <span class="k">def</span> <span class="nf">get_n</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">set_n</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">nonlocal</span> <span class="n">n</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Attach as function attributes</span>
    <span class="n">func</span><span class="o">.</span><span class="n">get_n</span> <span class="o">=</span> <span class="n">get_n</span>
    <span class="n">func</span><span class="o">.</span><span class="n">set_n</span> <span class="o">=</span> <span class="n">set_n</span>
    <span class="k">return</span> <span class="n">func</span>
</pre></div>
</div>
<p>下面是使用的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="go">n= 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">set_n</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="go">n= 10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">get_n</span><span class="p">()</span>
<span class="go">10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>为了说明清楚它如何工作的，有两点需要解释一下。首先，<code class="docutils literal"><span class="pre">nonlocal</span></code> 声明可以让我们编写函数来修改内部变量的值。
其次，函数属性允许我们用一种很简单的方式将访问方法绑定到闭包函数上，这个跟实例方法很像(尽管并没有定义任何类)。</p>
<p>还可以进一步的扩展，让闭包模拟类的实例。你要做的仅仅是复制上面的内部函数到一个字典实例中并返回它即可。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">class</span> <span class="nc">ClosureInstance</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">locals</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="nb">locals</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f_locals</span>

        <span class="c1"># Update instance dictionary with callables</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">locals</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">)</span>
    <span class="c1"># Redirect special methods</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;__len__&#39;</span><span class="p">]()</span>

<span class="c1"># Example use</span>
<span class="k">def</span> <span class="nf">Stack</span><span class="p">():</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">():</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ClosureInstance</span><span class="p">()</span>
</pre></div>
</div>
<p>下面是一个交互式会话来演示它是如何工作的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;__main__.ClosureInstance object at 0x10069ed10&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有趣的是，这个代码运行起来会比一个普通的类定义要快很多。你可能会像下面这样测试它跟一个类的性能对比：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Stack2</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
</pre></div>
</div>
<p>如果这样做，你会得到类似如下的结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">timeit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test involving closures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;s.push(1);s.pop()&#39;</span><span class="p">,</span> <span class="s1">&#39;from __main__ import s&#39;</span><span class="p">)</span>
<span class="go">0.9874754269840196</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test involving a class</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stack2</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;s.push(1);s.pop()&#39;</span><span class="p">,</span> <span class="s1">&#39;from __main__ import s&#39;</span><span class="p">)</span>
<span class="go">1.0707052160287276</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>结果显示，闭包的方案运行起来要快大概8%，大部分原因是因为对实例变量的简化访问，
闭包更快是因为不会涉及到额外的self变量。</p>
<p>Raymond Hettinger对于这个问题设计出了更加难以理解的改进方案。不过，你得考虑下是否真的需要在你代码中这样做，
而且它只是真实类的一个奇怪的替换而已，例如，类的主要特性如继承、属性、描述器或类方法都是不能用的。
并且你要做一些其他的工作才能让一些特殊方法生效(比如上面 <code class="docutils literal"><span class="pre">ClosureInstance</span></code> 中重写过的 <code class="docutils literal"><span class="pre">__len__()</span></code> 实现。)</p>
<p>最后，你可能还会让其他阅读你代码的人感到疑惑，为什么它看起来不像一个普通的类定义呢？
(当然，他们也想知道为什么它运行起来会更快)。尽管如此，这对于怎样访问闭包的内部变量也不失为一个有趣的例子。</p>
<p>总体上讲，在配置的时候给闭包添加方法会有更多的实用功能，
比如你需要重置内部状态、刷新缓冲区、清除缓存或其他的反馈机制的时候。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p08_classes_and_objects"></span><div class="section" id="id1">
<h2>第八章：类与对象<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>本章主要关注点的是和类定义有关的常见编程模型。包括让对象支持常见的Python特性、特殊方法的使用、
类封装技术、继承、内存管理以及有用的设计模式。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c08/p01_change_string_representation_of_instances"></span><div class="section" id="id1">
<h3>8.1 改变对象的字符串显示<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想改变对象实例的打印或显示输出，让它们更具可读性。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>要改变一个实例的字符串表示，可重新定义它的 <code class="docutils literal"><span class="pre">__str__()</span></code> 和 <code class="docutils literal"><span class="pre">__repr__()</span></code> 方法。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Pair</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Pair({0.x!r}, {0.y!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;({0.x!s}, {0.y!s})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__repr__()</span></code> 方法返回一个实例的代码表示形式，通常用来重新构造这个实例。
内置的 <code class="docutils literal"><span class="pre">repr()</span></code> 函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。
<code class="docutils literal"><span class="pre">__str__()</span></code> 方法将实例转换为一个字符串，使用 <code class="docutils literal"><span class="pre">str()</span></code> 或 <code class="docutils literal"><span class="pre">print()</span></code> 函数会输出这个字符串。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">Pair(3, 4) # __repr__() output</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">(3, 4) # __str__() output</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>我们在这里还演示了在格式化的时候怎样使用不同的字符串表现形式。
特别来讲，<code class="docutils literal"><span class="pre">!r</span></code> 格式化代码指明输出使用 <code class="docutils literal"><span class="pre">__repr__()</span></code> 来代替默认的 <code class="docutils literal"><span class="pre">__str__()</span></code> 。
你可以用前面的类来试着测试下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;p is {0!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="go">p is Pair(3, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;p is {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="go">p is (3, 4)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>自定义 <code class="docutils literal"><span class="pre">__repr__()</span></code> 和 <code class="docutils literal"><span class="pre">__str__()</span></code> 通常是很好的习惯，因为它能简化调试和实例输出。
例如，如果仅仅只是打印输出或日志输出某个实例，那么程序员会看到实例更加详细与有用的信息。</p>
<p><code class="docutils literal"><span class="pre">__repr__()</span></code> 生成的文本字符串标准做法是需要让 <code class="docutils literal"><span class="pre">eval(repr(x))</span> <span class="pre">==</span> <span class="pre">x</span></code> 为真。
如果实在不能这样子做，应该创建一个有用的文本表示，并使用 &lt; 和 &gt; 括起来。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;file.dat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;_io.TextIOWrapper name=&#39;file.dat&#39; mode=&#39;r&#39; encoding=&#39;UTF-8&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">__str__()</span></code> 没有被定义，那么就会使用 <code class="docutils literal"><span class="pre">__repr__()</span></code> 来代替输出。</p>
<p>上面的 <code class="docutils literal"><span class="pre">format()</span></code> 方法的使用看上去很有趣，格式化代码 <code class="docutils literal"><span class="pre">{0.x}</span></code> 对应的是第1个参数的x属性。
因此，在下面的函数中，0实际上指的就是 <code class="docutils literal"><span class="pre">self</span></code> 本身：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;Pair({0.x!r}, {0.y!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>作为这种实现的一个替代，你也可以使用 <code class="docutils literal"><span class="pre">%</span></code> 操作符，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;Pair(</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c08/p02_customizing_string_formatting"></span><div class="section" id="id1">
<h3>8.2 自定义字符串的格式化<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想通过 <code class="docutils literal"><span class="pre">format()</span></code> 函数和字符串方法使得一个对象能支持自定义的格式化。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了自定义字符串的格式化，我们需要在类上面定义 <code class="docutils literal"><span class="pre">__format__()</span></code> 方法。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">_formats</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;ymd&#39;</span> <span class="p">:</span> <span class="s1">&#39;{d.year}-{d.month}-{d.day}&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mdy&#39;</span> <span class="p">:</span> <span class="s1">&#39;{d.month}/{d.day}/{d.year}&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dmy&#39;</span> <span class="p">:</span> <span class="s1">&#39;{d.day}/{d.month}/{d.year}&#39;</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Date</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span> <span class="n">day</span>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;ymd&#39;</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">_formats</span><span class="p">[</span><span class="n">code</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>现在 <code class="docutils literal"><span class="pre">Date</span></code> 类的实例可以支持格式化操作了，如同下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Date</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;2012-12-21&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;mdy&#39;</span><span class="p">)</span>
<span class="go">&#39;12/21/2012&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;The date is {:ymd}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;The date is 2012-12-21&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;The date is {:mdy}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;The date is 12/21/2012&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">__format__()</span></code> 方法给Python的字符串格式化功能提供了一个钩子。
这里需要着重强调的是格式化代码的解析工作完全由类自己决定。因此，格式化代码可以是任何值。
例如，参考下面来自 <code class="docutils literal"><span class="pre">datetime</span></code> 模块中的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;2012-12-21&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="s1">&#39;%A, %B </span><span class="si">%d</span><span class="s1">, %Y&#39;</span><span class="p">)</span>
<span class="go">&#39;Friday, December 21, 2012&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;The end is {:</span><span class="si">%d</span><span class="s1"> %b %Y}. Goodbye&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;The end is 21 Dec 2012. Goodbye&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于内置类型的格式化有一些标准的约定。
可以参考 <a class="reference external" href="https://docs.python.org/3/library/string.html">string模块文档</a> 说明。</p>
</div>
</div>
<span id="document-c08/p03_make_objects_support_context_management_protocol"></span><div class="section" id="id1">
<h3>8.3 让对象支持上下文管理协议<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想让你的对象支持上下文管理协议(with语句)。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了让一个对象兼容 <code class="docutils literal"><span class="pre">with</span></code> 语句，你需要实现 <code class="docutils literal"><span class="pre">__enter__()</span></code> 和 <code class="docutils literal"><span class="pre">__exit__()</span></code> 方法。
例如，考虑如下的一个类，它能为我们创建一个网络连接：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="k">class</span> <span class="nc">LazyConnection</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already connected&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_ty</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>
</div>
<p>这个类的关键特点在于它表示了一个网络连接，但是初始化的时候并不会做任何事情(比如它并没有建立一个连接)。
连接的建立和关闭是使用 <code class="docutils literal"><span class="pre">with</span></code> 语句自动完成的，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">LazyConnection</span><span class="p">((</span><span class="s1">&#39;www.python.org&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="c1"># Connection closed</span>
<span class="k">with</span> <span class="n">conn</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
    <span class="c1"># conn.__enter__() executes: connection open</span>
    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;GET /index.html HTTP/1.0</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Host: www.python.org</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">,</span> <span class="mi">8192</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="c1"># conn.__exit__() executes: connection closed</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>编写上下文管理器的主要原理是你的代码会放到 <code class="docutils literal"><span class="pre">with</span></code> 语句块中执行。
当出现 <code class="docutils literal"><span class="pre">with</span></code> 语句的时候，对象的 <code class="docutils literal"><span class="pre">__enter__()</span></code> 方法被触发，
它返回的值(如果有的话)会被赋值给 <code class="docutils literal"><span class="pre">as</span></code> 声明的变量。然后，<code class="docutils literal"><span class="pre">with</span></code> 语句块里面的代码开始执行。
最后，<code class="docutils literal"><span class="pre">__exit__()</span></code> 方法被触发进行清理工作。</p>
<p>不管 <code class="docutils literal"><span class="pre">with</span></code> 代码块中发生什么，上面的控制流都会执行完，就算代码块中发生了异常也是一样的。
事实上，<code class="docutils literal"><span class="pre">__exit__()</span></code> 方法的第三个参数包含了异常类型、异常值和追溯信息(如果有的话)。
<code class="docutils literal"><span class="pre">__exit__()</span></code> 方法能自己决定怎样利用这个异常信息，或者忽略它并返回一个None值。
如果 <code class="docutils literal"><span class="pre">__exit__()</span></code> 返回 <code class="docutils literal"><span class="pre">True</span></code> ，那么异常会被清空，就好像什么都没发生一样，
<code class="docutils literal"><span class="pre">with</span></code> 语句后面的程序继续在正常执行。</p>
<p>还有一个细节问题就是 <code class="docutils literal"><span class="pre">LazyConnection</span></code> 类是否允许多个 <code class="docutils literal"><span class="pre">with</span></code> 语句来嵌套使用连接。
很显然，上面的定义中一次只能允许一个socket连接，如果正在使用一个socket的时候又重复使用 <code class="docutils literal"><span class="pre">with</span></code> 语句，
就会产生一个异常了。不过你可以像下面这样修改下上面的实现来解决这个问题：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="k">class</span> <span class="nc">LazyConnection</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sock</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_ty</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># Example use</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">LazyConnection</span><span class="p">((</span><span class="s1">&#39;www.python.org&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="k">with</span> <span class="n">conn</span> <span class="k">as</span> <span class="n">s1</span><span class="p">:</span>
    <span class="k">pass</span>
    <span class="k">with</span> <span class="n">conn</span> <span class="k">as</span> <span class="n">s2</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1"># s1 and s2 are independent sockets</span>
</pre></div>
</div>
<p>在第二个版本中，<code class="docutils literal"><span class="pre">LazyConnection</span></code> 类可以被看做是某个连接工厂。在内部，一个列表被用来构造一个栈。
每次 <code class="docutils literal"><span class="pre">__enter__()</span></code> 方法执行的时候，它复制创建一个新的连接并将其加入到栈里面。
<code class="docutils literal"><span class="pre">__exit__()</span></code> 方法简单的从栈中弹出最后一个连接并关闭它。
这里稍微有点难理解，不过它能允许嵌套使用 <code class="docutils literal"><span class="pre">with</span></code> 语句创建多个连接，就如上面演示的那样。</p>
<p>在需要管理一些资源比如文件、网络连接和锁的编程环境中，使用上下文管理器是很普遍的。
这些资源的一个主要特征是它们必须被手动的关闭或释放来确保程序的正确运行。
例如，如果你请求了一个锁，那么你必须确保之后释放了它，否则就可能产生死锁。
通过实现 <code class="docutils literal"><span class="pre">__enter__()</span></code> 和 <code class="docutils literal"><span class="pre">__exit__()</span></code> 方法并使用 <code class="docutils literal"><span class="pre">with</span></code> 语句可以很容易的避免这些问题，
因为 <code class="docutils literal"><span class="pre">__exit__()</span></code> 方法可以让你无需担心这些了。</p>
<p>在 <code class="docutils literal"><span class="pre">contextmanager</span></code> 模块中有一个标准的上下文管理方案模板，可参考9.22小节。
同时在12.6小节中还有一个对本节示例程序的线程安全的修改版。</p>
</div>
</div>
<span id="document-c08/p04_save_memory_when_create_large_number_instances"></span><div class="section" id="id1">
<h3>8.4 创建大量对象时节省内存方法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序要创建大量(可能上百万)的对象，导致占用很大的内存。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于主要是用来当成简单的数据结构的类而言，你可以通过给类添加 <code class="docutils literal"><span class="pre">__slots__</span></code> 属性来极大的减少实例所占的内存。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Date</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span> <span class="n">day</span>
</pre></div>
</div>
<p>当你定义 <code class="docutils literal"><span class="pre">__slots__</span></code> 后，Python就会为实例使用一种更加紧凑的内部表示。
实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似。
在 <code class="docutils literal"><span class="pre">__slots__</span></code> 中列出的属性名在内部被映射到这个数组的指定小标上。
使用slots一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在 <code class="docutils literal"><span class="pre">__slots__</span></code> 中定义的那些属性名。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>使用slots后节省的内存会跟存储属性的数量和类型有关。
不过，一般来讲，使用到的内存总量和将数据存储在一个元组中差不多。
为了给你一个直观认识，假设你不使用slots直接存储一个Date实例，
在64位的Python上面要占用428字节，而如果使用了slots，内存占用下降到156字节。
如果程序中需要同时创建大量的日期实例，那么这个就能极大的减小内存使用量了。</p>
<p>尽管slots看上去是一个很有用的特性，很多时候你还是得减少对它的使用冲动。
Python的很多特性都依赖于普通的基于字典的实现。
另外，定义了slots后的类不再支持一些普通类特性了，比如多继承。
大多数情况下，你应该只在那些经常被使用到的用作数据结构的类上定义slots
(比如在程序中需要创建某个类的几百万个实例对象)。</p>
<p>关于 <code class="docutils literal"><span class="pre">__slots__</span></code> 的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。
尽管使用slots可以达到这样的目的，但是这个并不是它的初衷。
<code class="docutils literal"><span class="pre">__slots__</span></code> 更多的是用来作为一个内存优化工具。</p>
</div>
</div>
<span id="document-c08/p05_encapsulating_names_in_class"></span><div class="section" id="id1">
<h3>8.5 在类中封装属性名<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想封装类的实例上面的“私有”数据，但是Python语言并没有访问控制。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python程序员不去依赖语言特性去封装数据，而是通过遵循一定的属性和方法命名规约来达到这个效果。
第一个约定是任何以单下划线_开头的名字都应该是内部实现。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># An internal attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">public</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># A public attribute</span>

    <span class="k">def</span> <span class="nf">public_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A public method</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_internal_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Python并不会真的阻止别人访问内部名称。但是如果你这么做肯定是不好的，可能会导致脆弱的代码。
同时还要注意到，使用下划线开头的约定同样适用于模块名和模块级别函数。
例如，如果你看到某个模块名以单下划线开头(比如_socket)，那它就是内部实现。
类似的，模块级别函数比如 <code class="docutils literal"><span class="pre">sys._getframe()</span></code> 在使用的时候就得加倍小心了。</p>
<p>你还可能会遇到在类定义中使用两个下划线(__)开头的命名。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__private</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__private_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">public_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__private_method</span><span class="p">()</span>
</pre></div>
</div>
<p>使用双下划线开始会导致访问名称变成其他形式。
比如，在前面的类B中，私有属性会被分别重命名为 <code class="docutils literal"><span class="pre">_B__private</span></code> 和 <code class="docutils literal"><span class="pre">_B__private_method</span></code> 。
这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__private</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Does not override B.__private</span>

    <span class="c1"># Does not override B.__private_method()</span>
    <span class="k">def</span> <span class="nf">__private_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>这里，私有名称 <code class="docutils literal"><span class="pre">__private</span></code> 和 <code class="docutils literal"><span class="pre">__private_method</span></code>
被重命名为 <code class="docutils literal"><span class="pre">_C__private</span></code> 和 <code class="docutils literal"><span class="pre">_C__private_method</span></code> ，这个跟父类B中的名称是完全不同的。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>上面提到有两种不同的编码约定(单下划线和双下划线)来命名私有属性，那么问题就来了：到底哪种方式好呢？
大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类，
并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p>
<p>还有一点要注意的是，有时候你定义的一个变量和某个保留关键字冲突，这时候可以使用单下划线作为后缀，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">lambda_</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="c1"># Trailing _ to avoid clash with lambda keyword</span>
</pre></div>
</div>
<p>这里我们并不使用单下划线前缀的原因是它避免误解它的使用初衷
(如使用单下划线前缀的目的是为了防止命名冲突而不是指明这个属性是私有的)。
通过使用单下划线后缀可以解决这个问题。</p>
</div>
</div>
<span id="document-c08/p06_create_managed_attributes"></span><div class="section" id="id1">
<h3>8.6 创建可管理的属性<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想给某个实例attribute增加除访问与修改之外的其他处理逻辑，比如类型检查或合法性验证。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>自定义某个属性的一种简单方法是将它定义为一个property。
例如，下面的代码定义了一个property，增加对一个属性简单的类型检查：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="n">first_name</span>

    <span class="c1"># Getter function</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span>

    <span class="c1"># Setter function</span>
    <span class="nd">@first_name.setter</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Deleter function (optional)</span>
    <span class="nd">@first_name.deleter</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t delete attribute&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>上述代码中有三个相关联的方法，这三个方法的名字都必须一样。
第一个方法是一个 <code class="docutils literal"><span class="pre">getter</span></code> 函数，它使得 <code class="docutils literal"><span class="pre">first_name</span></code> 成为一个属性。
其他两个方法给 <code class="docutils literal"><span class="pre">first_name</span></code> 属性添加了 <code class="docutils literal"><span class="pre">setter</span></code> 和 <code class="docutils literal"><span class="pre">deleter</span></code> 函数。
需要强调的是只有在 <code class="docutils literal"><span class="pre">first_name</span></code> 属性被创建后，
后面的两个装饰器 <code class="docutils literal"><span class="pre">&#64;first_name.setter</span></code> 和 <code class="docutils literal"><span class="pre">&#64;first_name.deleter</span></code> 才能被定义。</p>
<p>property的一个关键特征是它看上去跟普通的attribute没什么两样，
但是访问它的时候会自动触发 <code class="docutils literal"><span class="pre">getter</span></code> 、<code class="docutils literal"><span class="pre">setter</span></code> 和 <code class="docutils literal"><span class="pre">deleter</span></code> 方法。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">first_name</span> <span class="c1"># Calls the getter</span>
<span class="go">&#39;Guido&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="mi">42</span> <span class="c1"># Calls the setter</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;prop.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">14</span><span class="p">,</span> <span class="ow">in</span> <span class="n">first_name</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
<span class="gr">TypeError</span>: <span class="n">Expected a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="o">.</span><span class="n">first_name</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">can`t delete attribute</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在实现一个property的时候，底层数据(如果有的话)仍然需要存储在某个地方。
因此，在get和set方法中，你会看到对 <code class="docutils literal"><span class="pre">_first_name</span></code> 属性的操作，这也是实际数据保存的地方。
另外，你可能还会问为什么 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法中设置了 <code class="docutils literal"><span class="pre">self.first_name</span></code> 而不是 <code class="docutils literal"><span class="pre">self._first_name</span></code> 。
在这个例子中，我们创建一个property的目的就是在设置attribute的时候进行检查。
因此，你可能想在初始化的时候也进行这种类型检查。通过设置 <code class="docutils literal"><span class="pre">self.first_name</span></code> ，自动调用 <code class="docutils literal"><span class="pre">setter</span></code> 方法，
这个方法里面会进行参数的检查，否则就是直接访问 <code class="docutils literal"><span class="pre">self._first_name</span></code> 了。</p>
<p>还能在已存在的get和set方法基础上定义property。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_first_name</span><span class="p">(</span><span class="n">first_name</span><span class="p">)</span>

    <span class="c1"># Getter function</span>
    <span class="k">def</span> <span class="nf">get_first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span>

    <span class="c1"># Setter function</span>
    <span class="k">def</span> <span class="nf">set_first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Deleter function (optional)</span>
    <span class="k">def</span> <span class="nf">del_first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t delete attribute&quot;</span><span class="p">)</span>

    <span class="c1"># Make a property from existing get/set methods</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_first_name</span><span class="p">,</span> <span class="n">set_first_name</span><span class="p">,</span> <span class="n">del_first_name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>一个property属性其实就是一系列相关绑定方法的集合。如果你去查看拥有property的类，
就会发现property本身的fget、fset和fdel属性就是类里面的普通方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Person</span><span class="o">.</span><span class="n">first_name</span><span class="o">.</span><span class="n">fget</span>
<span class="go">&lt;function Person.first_name at 0x1006a60e0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Person</span><span class="o">.</span><span class="n">first_name</span><span class="o">.</span><span class="n">fset</span>
<span class="go">&lt;function Person.first_name at 0x1006a6170&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Person</span><span class="o">.</span><span class="n">first_name</span><span class="o">.</span><span class="n">fdel</span>
<span class="go">&lt;function Person.first_name at 0x1006a62e0&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>通常来讲，你不会直接取调用fget或者fset，它们会在访问property的时候自动被触发。</p>
<p>只有当你确实需要对attribute执行其他额外的操作的时候才应该使用到property。
有时候一些从其他编程语言(比如Java)过来的程序员总认为所有访问都应该通过getter和setter，
所以他们认为代码应该像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="n">first_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span>

    <span class="nd">@first_name.setter</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>不要写这种没有做任何其他额外操作的property。
首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。
其次，它还会让你的程序运行起来变慢很多。
最后，这样的设计并没有带来任何的好处。
特别是当你以后想给普通attribute访问添加额外的处理逻辑的时候，
你可以将它变成一个property而无需改变原来的代码。
因为访问attribute的代码还是保持原样。</p>
<p>Properties还是一种定义动态计算attribute的方法。
这种类型的attributes并不会被实际的存储，而是在需要的时候计算出来。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
</pre></div>
</div>
<p>在这里，我们通过使用properties，将所有的访问接口形式统一起来，
对半径、直径、周长和面积的访问都是通过属性访问，就跟访问简单的attribute是一样的。
如果不这样做的话，那么就要在代码中混合使用简单属性访问和方法调用。
下面是使用的实例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">radius</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>  <span class="c1"># Notice lack of ()</span>
<span class="go">50.26548245743669</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">perimeter</span>  <span class="c1"># Notice lack of ()</span>
<span class="go">25.132741228718345</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>尽管properties可以实现优雅的编程接口，但有些时候你还是会想直接使用getter和setter函数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">get_first_name</span><span class="p">()</span>
<span class="go">&#39;Guido&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">set_first_name</span><span class="p">(</span><span class="s1">&#39;Larry&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种情况的出现通常是因为Python代码被集成到一个大型基础平台架构或程序中。
例如，有可能是一个Python类准备加入到一个基于远程过程调用的大型分布式系统中。
这种情况下，直接使用get/set方法(普通方法调用)而不是property或许会更容易兼容。</p>
<p>最后一点，不要像下面这样写有大量重复代码的property定义：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="n">first_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="n">last_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span>

    <span class="nd">@first_name.setter</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Repeated property code, but for a different name (bad!)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_name</span>

    <span class="nd">@last_name.setter</span>
    <span class="k">def</span> <span class="nf">last_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_name</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>重复代码会导致臃肿、易出错和丑陋的程序。好消息是，通过使用装饰器或闭包，有很多种更好的方法来完成同样的事情。
可以参考8.9和9.21小节的内容。</p>
</div>
</div>
<span id="document-c08/p07_calling_method_on_parent_class"></span><div class="section" id="id1">
<h3>8.7 调用父类方法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在子类中调用父类的某个已经被覆盖的方法。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了调用父类(超类)的一个方法，可以使用 <code class="docutils literal"><span class="pre">super()</span></code> 函数，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.spam&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.spam&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">spam</span><span class="p">()</span>  <span class="c1"># Call parent spam()</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">super()</span></code> 函数的一个常见用法是在 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法中确保父类被正确的初始化了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">super()</span></code> 的另外一个常见用法出现在覆盖Python特殊方法的代码中，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Proxy</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="c1"># Delegate attribute lookup to internal obj</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Delegate attribute assignment</span>
    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="c1"># Call original __setattr__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>在上面代码中，<code class="docutils literal"><span class="pre">__setattr__()</span></code> 的实现包含一个名字检查。
如果某个属性名以下划线(_)开头，就通过 <code class="docutils literal"><span class="pre">super()</span></code> 调用原始的 <code class="docutils literal"><span class="pre">__setattr__()</span></code> ，
否则的话就委派给内部的代理对象 <code class="docutils literal"><span class="pre">self._obj</span></code> 去处理。
这看上去有点意思，因为就算没有显式的指明某个类的父类， <code class="docutils literal"><span class="pre">super()</span></code> 仍然可以有效的工作。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>实际上，大家对于在Python中如何正确使用 <code class="docutils literal"><span class="pre">super()</span></code> 函数普遍知之甚少。
你有时候会看到像下面这样直接调用父类的一个方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Base.__init__&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Base</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.__init__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。
比如，考虑如下的情况：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Base.__init__&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Base</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.__init__&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Base</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.__init__&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">A</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;C.__init__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你运行这段代码就会发现 <code class="docutils literal"><span class="pre">Base.__init__()</span></code> 被调用两次，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="go">Base.__init__</span>
<span class="go">A.__init__</span>
<span class="go">Base.__init__</span>
<span class="go">B.__init__</span>
<span class="go">C.__init__</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可能两次调用 <code class="docutils literal"><span class="pre">Base.__init__()</span></code> 没什么坏处，但有时候却不是。
另一方面，假设你在代码中换成使用 <code class="docutils literal"><span class="pre">super()</span></code> ，结果就很完美了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Base.__init__&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.__init__&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.__init__&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># Only one call to super() here</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;C.__init__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>运行这个新版本后，你会发现每个 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法只会被调用一次了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="go">Base.__init__</span>
<span class="go">B.__init__</span>
<span class="go">A.__init__</span>
<span class="go">C.__init__</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了弄清它的原理，我们需要花点时间解释下Python是如何实现继承的。
对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表。
这个MRO列表就是一个简单的所有基类的线性顺序表。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__mro__</span>
<span class="go">(&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.Base&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<p>而这个MRO列表的构造是通过一个C3线性化算法来实现的。
我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则：</p>
<ul class="simple">
<li>子类会先于父类被检查</li>
<li>多个父类会根据它们在列表中的顺序被检查</li>
<li>如果对下一个类存在两个合法的选择，选择第一个父类</li>
</ul>
<p>老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义。</p>
<p>当你使用 <code class="docutils literal"><span class="pre">super()</span></code> 函数时，Python会在MRO列表上继续搜索下一个类。
只要每个重定义的方法统一使用 <code class="docutils literal"><span class="pre">super()</span></code> 并只调用它一次，
那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次。
这也是为什么在第二个例子中你不会调用两次 <code class="docutils literal"><span class="pre">Base.__init__()</span></code> 的原因。</p>
<p><code class="docutils literal"><span class="pre">super()</span></code> 有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类，
你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.spam&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">spam</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你试着直接使用这个类就会出错：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">spam</span><span class="p">()</span>
<span class="go">A.spam</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">spam</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;super&#39; object has no attribute &#39;spam&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但是，如果你使用多继承的话看看会发生什么：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.spam&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">spam</span><span class="p">()</span>
<span class="go">A.spam</span>
<span class="go">B.spam</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你可以看到在类A中使用 <code class="docutils literal"><span class="pre">super().spam()</span></code> 实际上调用的是跟类A毫无关系的类B中的 <code class="docutils literal"><span class="pre">spam()</span></code> 方法。
这个用类C的MRO列表就可以完全解释清楚了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__mro__</span>
<span class="go">(&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;,</span>
<span class="go">&lt;class &#39;object&#39;&gt;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在定义混入类的时候这样使用 <code class="docutils literal"><span class="pre">super()</span></code> 是很普遍的。可以参考8.13和8.18小节。</p>
<p>然而，由于 <code class="docutils literal"><span class="pre">super()</span></code> 可能会调用不是你想要的方法，你应该遵循一些通用原则。
首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。
这样可以确保 <code class="docutils literal"><span class="pre">super()</span></code> 调用一个非直接父类方法时不会出错。
其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。</p>
<p>在Python社区中对于 <code class="docutils literal"><span class="pre">super()</span></code> 的使用有时候会引来一些争议。
尽管如此，如果一切顺利的话，你应该在你最新代码中使用它。
Raymond Hettinger为此写了一篇非常好的文章
<a class="reference external" href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super">“Python’s super() Considered Super!”</a> ，
通过大量的例子向我们解释了为什么 <code class="docutils literal"><span class="pre">super()</span></code> 是极好的。</p>
</div>
</div>
<span id="document-c08/p08_extending_property_in_subclass"></span><div class="section" id="property">
<h3>8.8 子类中扩展property<a class="headerlink" href="#property" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>在子类中，你想要扩展定义在父类中的property的功能。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>考虑如下的代码，它定义了一个property：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="c1"># Getter function</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="c1"># Setter function</span>
    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Deleter function</span>
    <span class="nd">@name.deleter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t delete attribute&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是一个示例类，它继承自Person并扩展了 <code class="docutils literal"><span class="pre">name</span></code> 属性的功能：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SubPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Getting name&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Setting name to&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SubPerson</span><span class="p">,</span> <span class="n">SubPerson</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@name.deleter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Deleting name&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SubPerson</span><span class="p">,</span> <span class="n">SubPerson</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>接下来使用这个新类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SubPerson</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="go">Setting name to Guido</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="go">Getting name</span>
<span class="go">&#39;Guido&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Larry&#39;</span>
<span class="go">Setting name to Larry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">16</span><span class="p">,</span> <span class="ow">in</span> <span class="n">name</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
<span class="gr">TypeError</span>: <span class="n">Expected a string</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你仅仅只想扩展property的某一个方法，那么可以像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SubPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="nd">@Person.name.getter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Getting name&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>或者，你只想修改setter方法，就这么写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SubPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="nd">@Person.name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Setting name to&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SubPerson</span><span class="p">,</span> <span class="n">SubPerson</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在子类中扩展一个property可能会引起很多不易察觉的问题，
因为一个property其实是 <code class="docutils literal"><span class="pre">getter</span></code>、<code class="docutils literal"><span class="pre">setter</span></code> 和 <code class="docutils literal"><span class="pre">deleter</span></code> 方法的集合，而不是单个方法。
因此，当你扩展一个property的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中某一个。</p>
<p>在第一个例子中，所有的property方法都被重新定义。
在每一个方法中，使用了 <code class="docutils literal"><span class="pre">super()</span></code> 来调用父类的实现。
在 <code class="docutils literal"><span class="pre">setter</span></code> 函数中使用 <code class="docutils literal"><span class="pre">super(SubPerson,</span> <span class="pre">SubPerson).name.__set__(self,</span> <span class="pre">value)</span></code> 的语句是没有错的。
为了委托给之前定义的setter方法，需要将控制权传递给之前定义的name属性的 <code class="docutils literal"><span class="pre">__set__()</span></code> 方法。
不过，获取这个方法的唯一途径是使用类变量而不是实例变量来访问它。
这也是为什么我们要使用 <code class="docutils literal"><span class="pre">super(SubPerson,</span> <span class="pre">SubPerson)</span></code> 的原因。</p>
<p>如果你只想重定义其中一个方法，那只使用 &#64;property 本身是不够的。比如，下面的代码就无法工作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SubPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="nd">@property</span>  <span class="c1"># Doesn&#39;t work</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Getting name&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>如果你试着运行会发现setter函数整个消失了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SubPerson</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__init__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<span class="gr">AttributeError</span>: <span class="n">can&#39;t set attribute</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你应该像之前说过的那样修改代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SubPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="nd">@Person.name.getter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Getting name&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>这么写后，property之前已经定义过的方法会被复制过来，而getter函数被替换。然后它就能按照期望的工作了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SubPerson</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="go">Getting name</span>
<span class="go">&#39;Guido&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Larry&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="go">Getting name</span>
<span class="go">&#39;Larry&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">16</span><span class="p">,</span> <span class="ow">in</span> <span class="n">name</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
<span class="gr">TypeError</span>: <span class="n">Expected a string</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这个特别的解决方案中，我们没办法使用更加通用的方式去替换硬编码的 <code class="docutils literal"><span class="pre">Person</span></code> 类名。
如果你不知道到底是哪个基类定义了property，
那你只能通过重新定义所有property并使用 <code class="docutils literal"><span class="pre">super()</span></code> 来将控制权传递给前面的实现。</p>
<p>值的注意的是上面演示的第一种技术还可以被用来扩展一个描述器(在8.9小节我们有专门的介绍)。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># A descriptor</span>
<span class="k">class</span> <span class="nc">String</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="c1"># A class with a descriptor</span>
<span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="c1"># Extending a descriptor with a property</span>
<span class="k">class</span> <span class="nc">SubPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Getting name&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Setting name to&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SubPerson</span><span class="p">,</span> <span class="n">SubPerson</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@name.deleter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Deleting name&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SubPerson</span><span class="p">,</span> <span class="n">SubPerson</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>最后值的注意的是，读到这里时，你应该会发现子类化 <code class="docutils literal"><span class="pre">setter</span></code> 和 <code class="docutils literal"><span class="pre">deleter</span></code> 方法其实是很简单的。
这里演示的解决方案同样适用，但是在 <a class="reference external" href="http://bugs.python.org/issue14965">Python的issue页面</a>
报告的一个bug，或许会使得将来的Python版本中出现一个更加简洁的方法。</p>
</div>
</div>
<span id="document-c08/p09_create_new_kind_of_class_or_instance_attribute"></span><div class="section" id="id1">
<h3>8.9 创建新的类或实例属性<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想创建一个新的拥有一些额外功能的实例属性类型，比如类型检查。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想创建一个全新的实例属性，可以通过一个描述器类的形式来定义它的功能。下面是一个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Descriptor attribute for an integer type-checked attribute</span>
<span class="k">class</span> <span class="nc">Integer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected an int&#39;</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>一个描述器就是一个实现了三个核心的属性访问操作(get, set, delete)的类，
分别为 <code class="docutils literal"><span class="pre">__get__()</span></code> 、<code class="docutils literal"><span class="pre">__set__()</span></code> 和 <code class="docutils literal"><span class="pre">__delete__()</span></code> 这三个特殊的方法。
这些方法接受一个实例作为输入，之后相应的操作实例底层的字典。</p>
<p>为了使用一个描述器，需将这个描述器的实例作为类属性放到一个类的定义中。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
</pre></div>
</div>
<p>当你这样做后，所有对描述器属性(比如x或y)的访问会被
<code class="docutils literal"><span class="pre">__get__()</span></code> 、<code class="docutils literal"><span class="pre">__set__()</span></code> 和 <code class="docutils literal"><span class="pre">__delete__()</span></code> 方法捕获到。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="c1"># Calls Point.x.__get__(p,Point)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># Calls Point.y.__set__(p, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">2.3</span> <span class="c1"># Calls Point.x.__set__(p, 2.3)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;descrip.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">12</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__set__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected an int&#39;</span><span class="p">)</span>
<span class="gr">TypeError</span>: <span class="n">Expected an int</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>作为输入，描述器的每一个方法会接受一个操作实例。
为了实现请求操作，会相应的操作实例底层的字典(__dict__属性)。
描述器的 <code class="docutils literal"><span class="pre">self.name</span></code> 属性存储了在实例字典中被实际使用到的key。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>描述器可实现大部分Python类特性中的底层魔法，
包括 <code class="docutils literal"><span class="pre">&#64;classmethod</span></code> 、<code class="docutils literal"><span class="pre">&#64;staticmethod</span></code> 、<code class="docutils literal"><span class="pre">&#64;property</span></code> ，甚至是 <code class="docutils literal"><span class="pre">__slots__</span></code> 特性。</p>
<p>通过定义一个描述器，你可以在底层捕获核心的实例操作(get, set, delete)，并且可完全自定义它们的行为。
这是一个强大的工具，有了它你可以实现很多高级功能，并且它也是很多高级库和框架中的重要工具之一。</p>
<p>描述器的一个比较困惑的地方是它只能在类级别被定义，而不能为每个实例单独定义。因此，下面的代码是无法工作的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Does NOT work</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="c1"># No! Must be a class variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
</pre></div>
</div>
<p>同时，<code class="docutils literal"><span class="pre">__get__()</span></code> 方法实现起来比看上去要复杂得多：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Descriptor attribute for an integer type-checked attribute</span>
<span class="k">class</span> <span class="nc">Integer</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__get__()</span></code> 看上去有点复杂的原因归结于实例变量和类变量的不同。
如果一个描述器被当做一个类变量来访问，那么 <code class="docutils literal"><span class="pre">instance</span></code> 参数被设置成 <code class="docutils literal"><span class="pre">None</span></code> 。
这种情况下，标准做法就是简单的返回这个描述器本身即可(尽管你还可以添加其他的自定义操作)。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="c1"># Calls Point.x.__get__(p, Point)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point</span><span class="o">.</span><span class="n">x</span> <span class="c1"># Calls Point.x.__get__(None, Point)</span>
<span class="go">&lt;__main__.Integer object at 0x100671890&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>描述器通常是那些使用到装饰器或元类的大型框架中的一个组件。同时它们的使用也被隐藏在后面。
举个例子，下面是一些更高级的基于描述器的代码，并涉及到一个类装饰器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Descriptor for a type-checked attribute</span>
<span class="k">class</span> <span class="nc">Typed</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expected_type</span> <span class="o">=</span> <span class="n">expected_type</span>
    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_type</span><span class="p">))</span>
        <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

<span class="c1"># Class decorator that applies it to selected attributes</span>
<span class="k">def</span> <span class="nf">typeassert</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">expected_type</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Attach a Typed descriptor to the class</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">Typed</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span>
    <span class="k">return</span> <span class="n">decorate</span>

<span class="c1"># Example use</span>
<span class="nd">@typeassert</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">shares</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
</pre></div>
</div>
<p>最后要指出的一点是，如果你只是想简单的自定义某个类的单个属性访问的话就不用去写描述器了。
这种情况下使用8.6小节介绍的property技术会更加容易。
当程序中有很多重复代码的时候描述器就很有用了
(比如你想在你代码的很多地方使用描述器提供的功能或者将它作为一个函数库特性)。</p>
</div>
</div>
<span id="document-c08/p10_using_lazily_computed_properties"></span><div class="section" id="id1">
<h3>8.10 使用延迟计算属性<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想将一个只读属性定义成一个property，并且只在访问的时候才会计算结果。
但是一旦被访问后，你希望结果值被缓存起来，不用每次都去计算。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>定义一个延迟属性的一种高效方法是通过使用一个描述器类，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">lazyproperty</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<p>你需要像下面这样在一个类中使用它：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Computing area&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Computing perimeter&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
</pre></div>
</div>
<p>下面在一个交互环境中演示它的使用：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">radius</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">Computing area</span>
<span class="go">50.26548245743669</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">50.26548245743669</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">perimeter</span>
<span class="go">Computing perimeter</span>
<span class="go">25.132741228718345</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">perimeter</span>
<span class="go">25.132741228718345</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>仔细观察你会发现消息 <code class="docutils literal"><span class="pre">Computing</span> <span class="pre">area</span></code> 和 <code class="docutils literal"><span class="pre">Computing</span> <span class="pre">perimeter</span></code> 仅仅出现一次。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>很多时候，构造一个延迟计算属性的主要目的是为了提升性能。
例如，你可以避免计算这些属性值，除非你真的需要它们。
这里演示的方案就是用来实现这样的效果的，
只不过它是通过以非常高效的方式使用描述器的一个精妙特性来达到这种效果的。</p>
<p>正如在其他小节(如8.9小节)所讲的那样，当一个描述器被放入一个类的定义时，
每次访问属性时它的 <code class="docutils literal"><span class="pre">__get__()</span></code> 、<code class="docutils literal"><span class="pre">__set__()</span></code> 和 <code class="docutils literal"><span class="pre">__delete__()</span></code> 方法就会被触发。
不过，如果一个描述器仅仅只定义了一个 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法的话，它比通常的具有更弱的绑定。
特别地，只有当被访问属性不在实例底层的字典中时 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法才会被触发。</p>
<p><code class="docutils literal"><span class="pre">lazyproperty</span></code> 类利用这一点，使用 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法在实例中存储计算出来的值，
这个实例使用相同的名字作为它的property。
这样一来，结果值被存储在实例字典中并且以后就不需要再去计算这个property了。
你可以尝试更深入的例子来观察结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get instance variables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">{&#39;radius&#39;: 4.0}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute area and observe variables afterward</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">Computing area</span>
<span class="go">50.26548245743669</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">{&#39;area&#39;: 50.26548245743669, &#39;radius&#39;: 4.0}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Notice access doesn&#39;t invoke property anymore</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">50.26548245743669</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Delete the variable and see property trigger again</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">{&#39;radius&#39;: 4.0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">Computing area</span>
<span class="go">50.26548245743669</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种方案有一个小缺陷就是计算出的值被创建后是可以被修改的。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">Computing area</span>
<span class="go">50.26548245743669</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">25</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你担心这个问题，那么可以使用一种稍微没那么高效的实现，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lazyproperty</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;_lazy_&#39;</span> <span class="o">+</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lazy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">lazy</span>
</pre></div>
</div>
<p>如果你使用这个版本，就会发现现在修改操作已经不被允许了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">Computing area</span>
<span class="go">50.26548245743669</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span>
<span class="go">50.26548245743669</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="mi">25</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">can&#39;t set attribute</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然而，这种方案有一个缺点就是所有get操作都必须被定向到属性的 <code class="docutils literal"><span class="pre">getter</span></code> 函数上去。
这个跟之前简单的在实例字典中查找值的方案相比效率要低一点。
如果想获取更多关于property和可管理属性的信息，可以参考8.6小节。而描述器的相关内容可以在8.9小节找到。</p>
</div>
</div>
<span id="document-c08/p11_simplify_initialization_of_data_structure"></span><div class="section" id="id1">
<h3>8.11 简化数据结构的初始化<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你写了很多仅仅用作数据结构的类，不想写太多烦人的 <code class="docutils literal"><span class="pre">__init__()</span></code> 函数</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>可以在一个基类中写一个公用的 <code class="docutils literal"><span class="pre">__init__()</span></code> 函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Structure1</span><span class="p">:</span>
    <span class="c1"># Class variable that specifies expected fields</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected {} arguments&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)))</span>
        <span class="c1"># Set the arguments</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>然后使你的类继承自这个基类:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Example class definitions</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure1</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure1</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">(</span><span class="n">Structure1</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
<p>使用这些类的示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;structure.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__init__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected {} arguments&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)))</span>
<span class="gr">TypeError</span>: <span class="n">Expected 3 arguments</span>
</pre></div>
</div>
<p>如果还想支持关键字参数，可以将关键字参数设置为实例属性：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Structure2</span><span class="p">:</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected {} arguments&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)))</span>

        <span class="c1"># Set all of the positional arguments</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Set the remaining keyword arguments</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):]:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="c1"># Check for any remaining unknown arguments</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid argument(s): {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)))</span>
<span class="c1"># Example use</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure2</span><span class="p">):</span>
        <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">]</span>

    <span class="n">s1</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mf">91.1</span><span class="p">)</span>
    <span class="n">s3</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="n">shares</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mf">91.1</span><span class="p">)</span>
    <span class="c1"># s3 = Stock(&#39;ACME&#39;, shares=50, price=91.1, aa=1)</span>
</pre></div>
</div>
<p>你还能将不在 <code class="docutils literal"><span class="pre">_fields</span></code> 中的名称加入到属性中去：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Structure3</span><span class="p">:</span>
    <span class="c1"># Class variable that specifies expected fields</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected {} arguments&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)))</span>

        <span class="c1"># Set the arguments</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Set the additional arguments (if any)</span>
        <span class="n">extra_args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">extra_args</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Duplicate values for {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)))</span>

<span class="c1"># Example use</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure3</span><span class="p">):</span>
        <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">]</span>

    <span class="n">s1</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="s1">&#39;8/2/2012&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>当你需要使用大量很小的数据结构类的时候，
相比手工一个个定义 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法而已，使用这种方式可以大大简化代码。</p>
<p>在上面的实现中我们使用了 <code class="docutils literal"><span class="pre">setattr()</span></code> 函数类设置属性值，
你可能不想用这种方式，而是想直接更新实例字典，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Structure</span><span class="p">:</span>
    <span class="c1"># Class variable that specifies expected fields</span>
    <span class="n">_fields</span><span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected {} arguments&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)))</span>

        <span class="c1"># Set the arguments (alternate)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">,</span><span class="n">args</span><span class="p">))</span>
</pre></div>
</div>
<p>尽管这也可以正常工作，但是当定义子类的时候问题就来了。
当一个子类定义了 <code class="docutils literal"><span class="pre">__slots__</span></code> 或者通过property(或描述器)来包装某个属性，
那么直接访问实例字典就不起作用了。我们上面使用 <code class="docutils literal"><span class="pre">setattr()</span></code> 会显得更通用些，因为它也适用于子类情况。</p>
<p>这种方法唯一不好的地方就是对某些IDE而言，在显示帮助函数时可能不太友好。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">Stock</span><span class="p">)</span>
<span class="go">Help on class Stock in module __main__:</span>
<span class="go">class Stock(Structure)</span>
<span class="gp">...</span>
<span class="go">| Methods inherited from Structure:</span>
<span class="go">|</span>
<span class="go">| __init__(self, *args, **kwargs)</span>
<span class="go">|</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以参考9.16小节来强制在 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法中指定参数的类型签名。</p>
</div>
</div>
<span id="document-c08/p12_define_interface_or_abstract_base_class"></span><div class="section" id="id1">
<h3>8.12 定义接口或者抽象基类<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想定义一个接口或抽象类，并且通过执行类型检查来确保子类实现了某些特定的方法</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">abc</span></code> 模块可以很轻松的定义抽象基类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="k">class</span> <span class="nc">IStream</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxbytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>抽象类的一个特点是它不能直接被实例化，比如你想像下面这样做是不行的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">IStream</span><span class="p">()</span> <span class="c1"># TypeError: Can&#39;t instantiate abstract class</span>
                <span class="c1"># IStream with abstract methods read, write</span>
</pre></div>
</div>
<p>抽象类的目的就是让别的类继承它并实现特定的抽象方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SocketStream</span><span class="p">(</span><span class="n">IStream</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxbytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">IStream</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected an IStream&#39;</span><span class="p">)</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>除了继承这种方式外，还可以通过注册方式来让某个类实现抽象基类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">io</span>

<span class="c1"># Register the built-in I/O classes as supporting our interface</span>
<span class="n">IStream</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="p">)</span>

<span class="c1"># Open a normal file and type check</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">)</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">IStream</span><span class="p">)</span> <span class="c1"># Returns True</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&#64;abstractmethod</span></code> 还能注解静态方法、类方法和 <code class="docutils literal"><span class="pre">properties</span></code> 。
你只需保证这个注解紧靠在函数定义前即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@name.setter</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">method1</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">method2</span><span class="p">():</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>标准库中有很多用到抽象基类的地方。<code class="docutils literal"><span class="pre">collections</span></code> 模块定义了很多跟容器和迭代器(序列、映射、集合等)有关的抽象基类。
<code class="docutils literal"><span class="pre">numbers</span></code> 库定义了跟数字对象(整数、浮点数、有理数等)有关的基类。<code class="docutils literal"><span class="pre">io</span></code> 库定义了很多跟I/O操作相关的基类。</p>
<p>你可以使用预定义的抽象类来执行更通用的类型检查，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>

<span class="c1"># Check if x is a sequence</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
<span class="o">...</span>

<span class="c1"># Check if x is iterable</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
<span class="o">...</span>

<span class="c1"># Check if x has a size</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sized</span><span class="p">):</span>
<span class="o">...</span>

<span class="c1"># Check if x is a mapping</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
</pre></div>
</div>
<p>尽管ABCs可以让我们很方便的做类型检查，但是我们在代码中最好不要过多的使用它。
因为Python的本质是一门动态编程语言，其目的就是给你更多灵活性，
强制类型检查或让你代码变得更复杂，这样做无异于舍本求末。</p>
</div>
</div>
<span id="document-c08/p13_implementing_data_model_or_type_system"></span><div class="section" id="id1">
<h3>8.13 实现数据模型的类型约束<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想定义某些在属性赋值上面有限制的数据结构。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在这个问题中，你需要在对某些实例属性赋值时进行检查。
所以你要自定义属性赋值函数，这种情况下最好使用描述器。</p>
<p>下面的代码使用描述器实现了一个系统类型和赋值验证框架：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Base class. Uses a descriptor to set a value</span>
<span class="k">class</span> <span class="nc">Descriptor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<span class="c1"># Descriptor for enforcing types</span>
<span class="k">class</span> <span class="nc">Typed</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="n">expected_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;expected &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_type</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="c1"># Descriptor for enforcing values</span>
<span class="k">class</span> <span class="nc">Unsigned</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected &gt;= 0&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MaxSized</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;size&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;missing size option&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;size must be &lt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>这些类就是你要创建的数据模型或类型系统的基础构建模块。
下面就是我们实际定义的各种不同的数据类型：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Integer</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">expected_type</span> <span class="o">=</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">UnsignedInteger</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Unsigned</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Float</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">expected_type</span> <span class="o">=</span> <span class="nb">float</span>

<span class="k">class</span> <span class="nc">UnsignedFloat</span><span class="p">(</span><span class="n">Float</span><span class="p">,</span> <span class="n">Unsigned</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">String</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">expected_type</span> <span class="o">=</span> <span class="nb">str</span>

<span class="k">class</span> <span class="nc">SizedString</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">MaxSized</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>然后使用这些自定义数据类型，我们定义一个类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Stock</span><span class="p">:</span>
    <span class="c1"># Specify constraints</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">SizedString</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">UnsignedInteger</span><span class="p">(</span><span class="s1">&#39;shares&#39;</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">UnsignedFloat</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
</pre></div>
</div>
<p>然后测试这个类的属性赋值约束，可发现对某些属性的赋值违法了约束是不合法的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;ACME&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="mi">75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">17</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__set__</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">23</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__set__</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected &gt;= 0&#39;</span><span class="p">)</span>
<span class="gr">ValueError</span>: <span class="n">Expected &gt;= 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="s1">&#39;a lot&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">16</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__set__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;expected &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_type</span><span class="p">))</span>
<span class="gr">TypeError</span>: <span class="n">expected &lt;class &#39;float&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;ABRACADABRA&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">17</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__set__</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">35</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__set__</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;size must be &lt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
<span class="gr">ValueError</span>: <span class="n">size must be &lt; 8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>还有一些技术可以简化上面的代码，其中一种是使用类装饰器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Class decorator to apply constraints</span>
<span class="k">def</span> <span class="nf">check_attributes</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Descriptor</span><span class="p">):</span>
                <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">key</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">return</span> <span class="n">decorate</span>

<span class="c1"># Example</span>
<span class="nd">@check_attributes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">SizedString</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">8</span><span class="p">),</span>
                  <span class="n">shares</span><span class="o">=</span><span class="n">UnsignedInteger</span><span class="p">,</span>
                  <span class="n">price</span><span class="o">=</span><span class="n">UnsignedFloat</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
</pre></div>
</div>
<p>另外一种方式是使用元类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># A metaclass that applies checking</span>
<span class="k">class</span> <span class="nc">checkedmeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">methods</span><span class="p">):</span>
        <span class="c1"># Attach attribute names to the descriptors</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">methods</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Descriptor</span><span class="p">):</span>
                <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">methods</span><span class="p">)</span>

<span class="c1"># Example</span>
<span class="k">class</span> <span class="nc">Stock2</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">checkedmeta</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">SizedString</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">UnsignedInteger</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">UnsignedFloat</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本节使用了很多高级技术，包括描述器、混入类、<code class="docutils literal"><span class="pre">super()</span></code> 的使用、类装饰器和元类。
不可能在这里一一详细展开来讲，但是可以在8.9、8.18、9.19小节找到更多例子。
但是，我在这里还是要提一下几个需要注意的点。</p>
<p>首先，在 <code class="docutils literal"><span class="pre">Descriptor</span></code> 基类中你会看到有个 <code class="docutils literal"><span class="pre">__set__()</span></code> 方法，却没有相应的 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法。
如果一个描述仅仅是从底层实例字典中获取某个属性值的话，那么没必要去定义 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法。</p>
<p>所有描述器类都是基于混入类来实现的。比如 <code class="docutils literal"><span class="pre">Unsigned</span></code> 和 <code class="docutils literal"><span class="pre">MaxSized</span></code> 要跟其他继承自 <code class="docutils literal"><span class="pre">Typed</span></code> 类混入。
这里利用多继承来实现相应的功能。</p>
<p>混入类的一个比较难理解的地方是，调用 <code class="docutils literal"><span class="pre">super()</span></code> 函数时，你并不知道究竟要调用哪个具体类。
你需要跟其他类结合后才能正确的使用，也就是必须合作才能产生效果。</p>
<p>使用类装饰器和元类通常可以简化代码。上面两个例子中你会发现你只需要输入一次属性名即可了。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Normal</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

<span class="c1"># Metaclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">checkedmeta</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>
</pre></div>
</div>
<p>所有方法中，类装饰器方案应该是最灵活和最高明的。
首先，它并不依赖任何其他新的技术，比如元类。其次，装饰器可以很容易的添加或删除。</p>
<p>最后，装饰器还能作为混入类的替代技术来实现同样的效果;</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Decorator for applying type checking</span>
<span class="k">def</span> <span class="nf">Typed</span><span class="p">(</span><span class="n">expected_type</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="bp">cls</span><span class="p">:</span> <span class="n">Typed</span><span class="p">(</span><span class="n">expected_type</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">super_set</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__set__</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;expected &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expected_type</span><span class="p">))</span>
        <span class="n">super_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__set__</span> <span class="o">=</span> <span class="fm">__set__</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="c1"># Decorator for unsigned values</span>
<span class="k">def</span> <span class="nf">Unsigned</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="n">super_set</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__set__</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected &gt;= 0&#39;</span><span class="p">)</span>
        <span class="n">super_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__set__</span> <span class="o">=</span> <span class="fm">__set__</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="c1"># Decorator for allowing sized values</span>
<span class="k">def</span> <span class="nf">MaxSized</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="n">super_init</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;size&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;missing size option&#39;</span><span class="p">)</span>
        <span class="n">super_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="fm">__init__</span>

    <span class="n">super_set</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__set__</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;size must be &lt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">super_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__set__</span> <span class="o">=</span> <span class="fm">__set__</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="c1"># Specialized descriptors</span>
<span class="nd">@Typed</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Integer</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="nd">@Unsigned</span>
<span class="k">class</span> <span class="nc">UnsignedInteger</span><span class="p">(</span><span class="n">Integer</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="nd">@Typed</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Float</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="nd">@Unsigned</span>
<span class="k">class</span> <span class="nc">UnsignedFloat</span><span class="p">(</span><span class="n">Float</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="nd">@Typed</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">String</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="nd">@MaxSized</span>
<span class="k">class</span> <span class="nc">SizedString</span><span class="p">(</span><span class="n">String</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>这种方式定义的类跟之前的效果一样，而且执行速度会更快。
设置一个简单的类型属性的值，装饰器方式要比之前的混入类的方式几乎快100%。
现在你应该庆幸自己读完了本节全部内容了吧？^_^</p>
</div>
</div>
<span id="document-c08/p14_implementing_custom_containers"></span><div class="section" id="id1">
<h3>8.14 实现自定义容器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想实现一个自定义的类来模拟内置的容器类功能，比如列表和字典。但是你不确定到底要实现哪些方法。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">collections</span></code> 定义了很多抽象基类，当你想自定义容器类的时候它们会非常有用。
比如你想让你的类支持迭代，那就让你的类继承 <code class="docutils literal"><span class="pre">collections.Iterable</span></code> 即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>不过你需要实现 <code class="docutils literal"><span class="pre">collections.Iterable</span></code> 所有的抽象方法，否则会报错:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">Can&#39;t instantiate abstract class A with abstract methods __iter__</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你只要实现 <code class="docutils literal"><span class="pre">__iter__()</span></code> 方法就不会报错了(参考4.2和4.7小节)。</p>
<p>你可以先试着去实例化一个对象，在错误提示中可以找到需要实现哪些方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">collections</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">Can&#39;t instantiate abstract class Sequence with abstract methods \</span>
<span class="go">__getitem__, __len__</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>下面是一个简单的示例，继承自上面Sequence抽象类，并且实现元素按照顺序存储：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SortedItems</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span> <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="c1"># Required sequence methods</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">)</span>

    <span class="c1"># Method for adding an item in the right location</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">bisect</span><span class="o">.</span><span class="n">insort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>


<span class="n">items</span> <span class="o">=</span> <span class="n">SortedItems</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">items</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
</pre></div>
</div>
<p>可以看到，SortedItems跟普通的序列没什么两样，支持所有常用操作，包括索引、迭代、包含判断，甚至是切片操作。</p>
<p>这里面使用到了 <code class="docutils literal"><span class="pre">bisect</span></code> 模块，它是一个在排序列表中插入元素的高效方式。可以保证元素插入后还保持顺序。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">collections</span></code> 中的抽象基类可以确保你自定义的容器实现了所有必要的方法。并且还能简化类型检查。
你的自定义容器会满足大部分类型检查需要，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="n">SortedItems</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">collections</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sized</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">collections</span></code> 中很多抽象类会为一些常见容器操作提供默认的实现，
这样一来你只需要实现那些你最感兴趣的方法即可。假设你的类继承自 <code class="docutils literal"><span class="pre">collections.MutableSequence</span></code> ，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Items</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span> <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="c1"># Required sequence methods</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Getting:&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Setting:&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Deleting:&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Inserting:&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Len&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你创建 <code class="docutils literal"><span class="pre">Items</span></code> 的实例，你会发现它支持几乎所有的核心列表方法(如append()、remove()、count()等)。
下面是使用演示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Items</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Len</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Len</span>
<span class="go">Inserting: 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Len</span>
<span class="go">Inserting: 4 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Getting: 0</span>
<span class="go">Getting: 1</span>
<span class="go">Getting: 2</span>
<span class="go">Getting: 3</span>
<span class="go">Getting: 4</span>
<span class="go">Getting: 5</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Getting: 0</span>
<span class="go">Getting: 1</span>
<span class="go">Getting: 2</span>
<span class="go">Deleting: 2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>本小节只是对Python抽象类功能的抛砖引玉。<code class="docutils literal"><span class="pre">numbers</span></code> 模块提供了一个类似的跟整数类型相关的抽象类型集合。
可以参考8.12小节来构造更多自定义抽象基类。</p>
</div>
</div>
<span id="document-c08/p15_delegating_attribute_access"></span><div class="section" id="id1">
<h3>8.15 属性的代理访问<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想将某个实例的属性访问代理到内部另一个实例中去，目的可能是作为继承的一个替代方法或者实现代理模式。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>简单来说，代理是一种编程模式，它将某个操作转移给另外一个对象来实现。
最简单的形式可能是像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">B1</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;简单的代理&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># Delegate to the internal self._a instance</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">spam</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Delegate to the internal self._a instance</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>如果仅仅就两个方法需要代理，那么像这样写就足够了。但是，如果有大量的方法需要代理，
那么使用 <code class="docutils literal"><span class="pre">__getattr__()</span></code> 方法或许或更好些：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">B2</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;使用__getattr__的代理，代理方法比较多时候&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># Expose all of the methods defined on class A</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;这个方法在访问的attribute不存在的时候被调用</span>
<span class="sd">        the __getattr__() method is actually a fallback method</span>
<span class="sd">        that only gets called when an attribute is not found&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__getattr__</span></code> 方法是在访问attribute不存在的时候被调用，使用演示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span> <span class="c1"># Calls B.bar() (exists on B)</span>
<span class="n">b</span><span class="o">.</span><span class="n">spam</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c1"># Calls B.__getattr__(&#39;spam&#39;) and delegates to A.spam</span>
</pre></div>
</div>
<p>另外一个代理例子是实现代理模式，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># A proxy class that wraps around another object, but</span>
<span class="c1"># exposes its public attributes</span>
<span class="k">class</span> <span class="nc">Proxy</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="c1"># Delegate attribute lookup to internal obj</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;getattr:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Delegate attribute assignment</span>
    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;setattr:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># Delegate attribute deletion</span>
    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;delattr:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>使用这个代理类时，你只需要用它来包装下其他类即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Spam.bar:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Create an instance</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Create a proxy around it</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Proxy</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1"># Access the proxy</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Outputs 2</span>
<span class="n">p</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Outputs &quot;Spam.bar: 2 3&quot;</span>
<span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">37</span>  <span class="c1"># Changes s.x to 37</span>
</pre></div>
</div>
<p>通过自定义属性访问方法，你可以用不同方式自定义代理类行为(比如加入日志功能、只读访问等)。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>代理类有时候可以作为继承的替代方案。例如，一个简单的继承如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.spam&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.foo&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.spam&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">spam</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.bar&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用代理的话，就是下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.spam&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.foo&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.spam&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">spam</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.bar&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>当实现代理模式时，还有些细节需要注意。
首先，<code class="docutils literal"><span class="pre">__getattr__()</span></code> 实际是一个后备方法，只有在属性不存在时才会调用。
因此，如果代理类实例本身有这个属性的话，那么不会触发这个方法的。
另外，<code class="docutils literal"><span class="pre">__setattr__()</span></code> 和 <code class="docutils literal"><span class="pre">__delattr__()</span></code> 需要额外的魔法来区分代理实例和被代理实例 <code class="docutils literal"><span class="pre">_obj</span></code> 的属性。
一个通常的约定是只代理那些不以下划线 <code class="docutils literal"><span class="pre">_</span></code> 开头的属性(代理类只暴露被代理类的公共属性)。</p>
<p>还有一点需要注意的是，<code class="docutils literal"><span class="pre">__getattr__()</span></code> 对于大部分以双下划线(__)开始和结尾的属性并不适用。
比如，考虑如下的类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListLike</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;__getattr__对于双下划线开始和结尾的方法是不能用的，需要一个个去重定义&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>如果是创建一个ListLike对象，会发现它支持普通的列表方法，如append()和insert()，
但是却不支持len()、元素查找等。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ListLike</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;ListLike&#39; has no len()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;ListLike&#39; object does not support indexing</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了让它支持这些方法，你必须手动的实现这些方法代理：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListLike</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;__getattr__对于双下划线开始和结尾的方法是不能用的，需要一个个去重定义&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Added special methods to support certain list operations</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>11.8小节还有一个在远程方法调用环境中使用代理的例子。</p>
</div>
</div>
<span id="document-c08/p16_define_more_than_one_constructor_in_class"></span><div class="section" id="id1">
<h3>8.16 在类中定义多个构造器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想实现一个类，除了使用 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法外，还有其他方式可以初始化它。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了实现多个构造器，你需要使用到类方法。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Date</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;方法一：使用类方法&quot;&quot;&quot;</span>
    <span class="c1"># Primary constructor</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span> <span class="n">day</span>

    <span class="c1"># Alternate constructor</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">today</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">tm_year</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_mon</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_mday</span><span class="p">)</span>
</pre></div>
</div>
<p>直接调用类方法即可，下面是使用示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Date</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span> <span class="c1"># Primary</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span> <span class="c1"># Alternate</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>类方法的一个主要用途就是定义多个构造器。它接受一个 <code class="docutils literal"><span class="pre">class</span></code> 作为第一个参数(cls)。
你应该注意到了这个类被用来创建并返回最终的实例。在继承时也能工作的很好：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewDate</span><span class="p">(</span><span class="n">Date</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span> <span class="c1"># Creates an instance of Date (cls=Date)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">NewDate</span><span class="o">.</span><span class="n">today</span><span class="p">()</span> <span class="c1"># Creates an instance of NewDate (cls=NewDate)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c08/p17_create_instance_without_invoking_init_method"></span><div class="section" id="init">
<h3>8.17 创建不调用init方法的实例<a class="headerlink" href="#init" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想创建一个实例，但是希望绕过执行 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>可以通过 <code class="docutils literal"><span class="pre">__new__()</span></code> 方法创建一个未初始化的实例。例如考虑如下这个类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Date</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span> <span class="n">day</span>
</pre></div>
</div>
<p>下面演示如何不调用 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法来创建这个Date实例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Date</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Date</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">&lt;__main__.Date object at 0x1006716d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">year</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;Date&#39; object has no attribute &#39;year&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>结果可以看到，这个Date实例的属性year还不存在，所以你需要手动初始化：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;year&#39;</span><span class="p">:</span><span class="mi">2012</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">:</span><span class="mi">29</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">setattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">year</span>
<span class="go">2012</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">month</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>当我们在反序列对象或者实现某个类方法构造函数时需要绕过 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法来创建对象。
例如，对于上面的Date来讲，有时候你可能会像下面这样定义一个新的构造函数 <code class="docutils literal"><span class="pre">today()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">localtime</span>

<span class="k">class</span> <span class="nc">Date</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span> <span class="n">day</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">today</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_year</span>
        <span class="n">d</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_mon</span>
        <span class="n">d</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_mday</span>
        <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>同样，在你反序列化JSON数据时产生一个如下的字典对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;year&#39;</span><span class="p">:</span> <span class="mi">2012</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">:</span> <span class="mi">29</span> <span class="p">}</span>
</pre></div>
</div>
<p>如果你想将它转换成一个Date类型实例，可以使用上面的技术。</p>
<p>当你通过这种非常规方式来创建实例的时候，最好不要直接去访问底层实例字典，除非你真的清楚所有细节。
否则的话，如果这个类使用了 <code class="docutils literal"><span class="pre">__slots__</span></code> 、properties 、descriptors 或其他高级技术的时候代码就会失效。
而这时候使用 <code class="docutils literal"><span class="pre">setattr()</span></code> 方法会让你的代码变得更加通用。</p>
</div>
</div>
<span id="document-c08/p18_extending_classes_with_mixins"></span><div class="section" id="mixins">
<h3>8.18 利用Mixins扩展类功能<a class="headerlink" href="#mixins" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你有很多有用的方法，想使用它们来扩展其他类的功能。但是这些类并没有任何继承的关系。
因此你不能简单的将这些方法放入一个基类，然后被其他类继承。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>通常当你想自定义类的时候会碰上这些问题。可能是某个库提供了一些基础类，
你可以利用它们来构造你自己的类。</p>
<p>假设你想扩展映射对象，给它们添加日志、唯一性设置、类型检查等等功能。下面是一些混入类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LoggedMappingMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add logging to get/set/delete operations for debugging.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># 混入类都没有实例变量，因为直接实例化混入类没有任何意义</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Getting &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Setting {} = {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Deleting &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SetOnceMappingMixin</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Only allow a key to be set once.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; already set&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">StringKeysMappingMixin</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Restrict keys to strings only</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;keys must be strings&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>这些类单独使用起来没有任何意义，事实上如果你去实例化任何一个类，除了产生异常外没任何作用。
它们是用来通过多继承来和其他映射对象混入使用的。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LoggedDict</span><span class="p">(</span><span class="n">LoggedMappingMixin</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">LoggedDict</span><span class="p">()</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">23</span>
<span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span> <span class="nc">SetOnceDefaultDict</span><span class="p">(</span><span class="n">SetOnceMappingMixin</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">d</span> <span class="o">=</span> <span class="n">SetOnceDefaultDict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># d[&#39;x&#39;] = 23  # KeyError: &#39;x already set&#39;</span>
</pre></div>
</div>
<p>这个例子中，可以看到混入类跟其他已存在的类(比如dict、defaultdict和OrderedDict)结合起来使用，一个接一个。
结合后就能发挥正常功效了。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>混入类在标准库中很多地方都出现过，通常都是用来像上面那样扩展某些类的功能。
它们也是多继承的一个主要用途。比如，当你编写网络代码时候，
你会经常使用 <code class="docutils literal"><span class="pre">socketserver</span></code> 模块中的 <code class="docutils literal"><span class="pre">ThreadingMixIn</span></code> 来给其他网络相关类增加多线程支持。
例如，下面是一个多线程的XML-RPC服务：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>
<span class="kn">from</span> <span class="nn">socketserver</span> <span class="kn">import</span> <span class="n">ThreadingMixIn</span>
<span class="k">class</span> <span class="nc">ThreadedXMLRPCServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">SimpleXMLRPCServer</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>同时在一些大型库和框架中也会发现混入类的使用，用途同样是增强已存在的类的功能和一些可选特征。</p>
<p>对于混入类，有几点需要记住。首先是，混入类不能直接被实例化使用。
其次，混入类没有自己的状态信息，也就是说它们并没有定义 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法，并且没有实例属性。
这也是为什么我们在上面明确定义了 <code class="docutils literal"><span class="pre">__slots__</span> <span class="pre">=</span> <span class="pre">()</span></code> 。</p>
<p>还有一种实现混入类的方式就是使用类装饰器，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">LoggedMapping</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;第二种方式：使用类装饰器&quot;&quot;&quot;</span>
    <span class="n">cls_getitem</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__getitem__</span>
    <span class="n">cls_setitem</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__setitem__</span>
    <span class="n">cls_delitem</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__delitem__</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Getting &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cls_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Setting {} = {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cls_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Deleting &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cls_delitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="fm">__getitem__</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="fm">__setitem__</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__delitem__</span> <span class="o">=</span> <span class="fm">__delitem__</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="nd">@LoggedMapping</span>
<span class="k">class</span> <span class="nc">LoggedDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>这个效果跟之前的是一样的，而且不再需要使用多继承了。参考9.12小节获取更多类装饰器的信息，
参考8.13小节查看更多混入类和类装饰器的例子。</p>
</div>
</div>
<span id="document-c08/p19_implements_stateful_objects_or_state_machines"></span><div class="section" id="id1">
<h3>8.19 实现状态对象或者状态机<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想实现一个状态机或者是在不同状态下执行操作的对象，但是又不想在代码中出现太多的条件判断语句。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在很多程序中，有些对象会根据状态的不同来执行不同的操作。比如考虑如下的一个连接对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;普通方案，好多个判断语句，效率低下~~&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;CLOSED&#39;</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s1">&#39;OPEN&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not open&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;reading&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s1">&#39;OPEN&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not open&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;writing&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;OPEN&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already open&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;OPEN&#39;</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;CLOSED&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already closed&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;CLOSED&#39;</span>
</pre></div>
</div>
<p>这样写有很多缺点，首先是代码太复杂了，好多的条件判断。其次是执行效率变低，
因为一些常见的操作比如read()、write()每次执行前都需要执行检查。</p>
<p>一个更好的办法是为每个状态定义一个对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Connection1</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;新方案——对每个状态定义一个类&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_state</span><span class="p">(</span><span class="n">ClosedConnectionState</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newstate</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">newstate</span>
        <span class="c1"># Delegate to the state class</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="c1"># Connection state base class</span>
<span class="k">class</span> <span class="nc">ConnectionState</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="c1"># Implementation of different states</span>
<span class="k">class</span> <span class="nc">ClosedConnectionState</span><span class="p">(</span><span class="n">ConnectionState</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not open&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not open&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">new_state</span><span class="p">(</span><span class="n">OpenConnectionState</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already closed&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OpenConnectionState</span><span class="p">(</span><span class="n">ConnectionState</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;reading&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;writing&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already open&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">new_state</span><span class="p">(</span><span class="n">ClosedConnectionState</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是使用演示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">_state</span>
<span class="go">&lt;class &#39;__main__.ClosedConnectionState&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">10</span><span class="p">,</span> <span class="ow">in</span> <span class="n">read</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">43</span><span class="p">,</span> <span class="ow">in</span> <span class="n">read</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not open&#39;</span><span class="p">)</span>
<span class="gr">RuntimeError</span>: <span class="n">Not open</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">_state</span>
<span class="go">&lt;class &#39;__main__.OpenConnectionState&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">reading</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">writing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">_state</span>
<span class="go">&lt;class &#39;__main__.ClosedConnectionState&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>如果代码中出现太多的条件判断语句的话，代码就会变得难以维护和阅读。
这里的解决方案是将每个状态抽取出来定义成一个类。</p>
<p>这里看上去有点奇怪，每个状态对象都只有静态方法，并没有存储任何的实例属性数据。
实际上，所有状态信息都只存储在 <code class="docutils literal"><span class="pre">Connection</span></code> 实例中。
在基类中定义的 <code class="docutils literal"><span class="pre">NotImplementedError</span></code> 是为了确保子类实现了相应的方法。
这里你或许还想使用8.12小节讲解的抽象基类方式。</p>
<p>设计模式中有一种模式叫状态模式，这一小节算是一个初步入门！</p>
</div>
</div>
<span id="document-c08/p20_call_method_on_object_by_string_name"></span><div class="section" id="id1">
<h3>8.20 通过字符串调用对象方法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个字符串形式的方法名称，想通过它调用某个对象的对应方法。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>最简单的情况，可以使用 <code class="docutils literal"><span class="pre">getattr()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Point({!r:},{!r:})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>


<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Calls p.distance(0, 0)</span>
</pre></div>
</div>
<p>另外一种方法是使用 <code class="docutils literal"><span class="pre">operator.methodcaller()</span></code> ，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">operator</span>
<span class="n">operator</span><span class="o">.</span><span class="n">methodcaller</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>当你需要通过相同的参数多次调用某个方法时，使用 <code class="docutils literal"><span class="pre">operator.methodcaller</span></code> 就很方便了。
比如你需要排序一系列的点，就可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">),</span>
    <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">),</span>
    <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
    <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">]</span>
<span class="c1"># Sort by distance from origin (0, 0)</span>
<span class="n">points</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">methodcaller</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>调用一个方法实际上是两部独立操作，第一步是查找属性，第二步是函数调用。
因此，为了调用某个方法，你可以首先通过 <code class="docutils literal"><span class="pre">getattr()</span></code> 来查找到这个属性，然后再去以函数方式调用它即可。</p>
<p><code class="docutils literal"><span class="pre">operator.methodcaller()</span></code> 创建一个可调用对象，并同时提供所有必要参数，
然后调用的时候只需要将实例对象传递给它即可，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">methodcaller</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">5.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>通过方法名称字符串来调用方法通常出现在需要模拟 <code class="docutils literal"><span class="pre">case</span></code> 语句或实现访问者模式的时候。
参考下一小节获取更多高级例子。</p>
</div>
</div>
<span id="document-c08/p21_implementing_visitor_pattern"></span><div class="section" id="id1">
<h3>8.21 实现访问者模式<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你要处理由大量不同类型的对象组成的复杂数据结构，每一个对象都需要需要进行不同的处理。
比如，遍历一个树形结构，然后根据每个节点的相应状态执行不同的操作。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这里遇到的问题在编程领域中是很普遍的，有时候会构建一个由大量不同对象组成的数据结构。
假设你要写一个表示数学表达式的程序，那么你可能需要定义如下的类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">UnaryOperator</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operand</span> <span class="o">=</span> <span class="n">operand</span>

<span class="k">class</span> <span class="nc">BinaryOperator</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Add</span><span class="p">(</span><span class="n">BinaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">BinaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Mul</span><span class="p">(</span><span class="n">BinaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Div</span><span class="p">(</span><span class="n">BinaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Negate</span><span class="p">(</span><span class="n">UnaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Number</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>然后利用这些类构建嵌套数据结构，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Representation of 1 + 2 * (3 - 4) / 5</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Sub</span><span class="p">(</span><span class="n">Number</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="n">Number</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">t1</span><span class="p">)</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">Div</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">Number</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="n">t4</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">t3</span><span class="p">)</span>
</pre></div>
</div>
<p>这样做的问题是对于每个表达式，每次都要重新定义一遍，有没有一种更通用的方式让它支持所有的数字和操作符呢。
这里我们使用访问者模式可以达到这样的目的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NodeVisitor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">methname</span> <span class="o">=</span> <span class="s1">&#39;visit_&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span>
        <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No {} method&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;visit_&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
</pre></div>
</div>
<p>为了使用这个类，可以定义一个类继承它并且实现各种 <code class="docutils literal"><span class="pre">visit_Name()</span></code> 方法，其中Name是node类型。
例如，如果你想求表达式的值，可以这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Evaluator</span><span class="p">(</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">visit_Number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">visit_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Negate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span>
</pre></div>
</div>
<p>使用示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Evaluator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">t4</span><span class="p">)</span>
<span class="go">0.6</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>作为一个不同的例子，下面定义一个类在一个栈上面将一个表达式转换成多个操作序列：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StackCode</span><span class="p">(</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">generate_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span>

    <span class="k">def</span> <span class="nf">visit_Number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;PUSH&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">instruction</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">instruction</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">visit_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;ADD&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;SUB&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;MUL&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;DIV&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unaryop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">instruction</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">instruction</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">visit_Negate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unaryop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;NEG&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">StackCode</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">generate_code</span><span class="p">(</span><span class="n">t4</span><span class="p">)</span>
<span class="go">[(&#39;PUSH&#39;, 1), (&#39;PUSH&#39;, 2), (&#39;PUSH&#39;, 3), (&#39;PUSH&#39;, 4), (&#39;SUB&#39;,),</span>
<span class="go">(&#39;MUL&#39;,), (&#39;PUSH&#39;, 5), (&#39;DIV&#39;,), (&#39;ADD&#39;,)]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>刚开始的时候你可能会写大量的if/else语句来实现，
这里访问者模式的好处就是通过 <code class="docutils literal"><span class="pre">getattr()</span></code> 来获取相应的方法，并利用递归来遍历所有的节点：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">instruction</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">instruction</span><span class="p">,))</span>
</pre></div>
</div>
<p>还有一点需要指出的是，这种技术也是实现其他语言中switch或case语句的方式。
比如，如果你正在写一个HTTP框架，你可能会写这样一个请求分发的控制器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HTTPHandler</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="n">methname</span> <span class="o">=</span> <span class="s1">&#39;do_&#39;</span> <span class="o">+</span> <span class="n">request</span><span class="o">.</span><span class="n">request_method</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">)(</span><span class="n">request</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">do_GET</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">do_POST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">do_HEAD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>访问者模式一个缺点就是它严重依赖递归，如果数据结构嵌套层次太深可能会有问题，
有时候会超过Python的递归深度限制(参考 <code class="docutils literal"><span class="pre">sys.getrecursionlimit()</span></code> )。</p>
<p>可以参照8.22小节，利用生成器或迭代器来实现非递归遍历算法。</p>
<p>在跟解析和编译相关的编程中使用访问者模式是非常常见的。
Python本身的 <code class="docutils literal"><span class="pre">ast</span></code> 模块值的关注下，可以去看看源码。
9.24小节演示了一个利用 <code class="docutils literal"><span class="pre">ast</span></code> 模块来处理Python源代码的例子。</p>
</div>
</div>
<span id="document-c08/p22_implementing_visitor_pattern_without_recursion"></span><div class="section" id="id1">
<h3>8.22 不用递归实现访问者模式<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你使用访问者模式遍历一个很深的嵌套树形数据结构，并且因为超过嵌套层级限制而失败。
你想消除递归，并同时保持访问者编程模式。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>通过巧妙的使用生成器可以在树遍历或搜索算法中消除递归。
在8.21小节中，我们给出了一个访问者类。
下面我们利用一个栈和生成器重新实现这个类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">NodeVisitor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="n">last_result</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">last_result</span><span class="p">))</span>
                    <span class="n">last_result</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_visit</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">last_result</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">last_result</span>

    <span class="k">def</span> <span class="nf">_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">methname</span> <span class="o">=</span> <span class="s1">&#39;visit_&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span>
        <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No {} method&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;visit_&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
</pre></div>
</div>
<p>如果你使用这个类，也能达到相同的效果。事实上你完全可以将它作为上一节中的访问者模式的替代实现。
考虑如下代码，遍历一个表达式的树：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UnaryOperator</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operand</span> <span class="o">=</span> <span class="n">operand</span>

<span class="k">class</span> <span class="nc">BinaryOperator</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Add</span><span class="p">(</span><span class="n">BinaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">BinaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Mul</span><span class="p">(</span><span class="n">BinaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Div</span><span class="p">(</span><span class="n">BinaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Negate</span><span class="p">(</span><span class="n">UnaryOperator</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Number</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="c1"># A sample visitor class that evaluates expressions</span>
<span class="k">class</span> <span class="nc">Evaluator</span><span class="p">(</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">visit_Number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">visit_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Negate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># 1 + 2*(3-4) / 5</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Sub</span><span class="p">(</span><span class="n">Number</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="n">Number</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">t1</span><span class="p">)</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="n">Div</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">Number</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
    <span class="n">t4</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">t3</span><span class="p">)</span>
    <span class="c1"># Evaluate it</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">Evaluator</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">t4</span><span class="p">))</span>  <span class="c1"># Outputs 0.6</span>
</pre></div>
</div>
<p>如果嵌套层次太深那么上述的Evaluator就会失效：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; a = Number(0)
&gt;&gt;&gt; for n in range(1, 100000):
... a = Add(a, Number(n))
...
&gt;&gt;&gt; e = Evaluator()
&gt;&gt;&gt; e.visit(a)
Traceback (most recent call last):
...
    File &quot;visitor.py&quot;, line 29, in _visit
return meth(node)
    File &quot;visitor.py&quot;, line 67, in visit_Add
return self.visit(node.left) + self.visit(node.right)
RuntimeError: maximum recursion depth exceeded
&gt;&gt;&gt;
</pre></div>
</div>
<p>现在我们稍微修改下上面的Evaluator：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Evaluator</span><span class="p">(</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">visit_Number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">visit_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">yield</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">yield</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">yield</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">yield</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Negate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">yield</span> <span class="o">-</span> <span class="p">(</span><span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
</pre></div>
</div>
<p>再次运行，就不会报错了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Number</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Number</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Evaluator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4999950000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你还想添加其他自定义逻辑也没问题：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Evaluator</span><span class="p">(</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">visit_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Add:&#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;left=&#39;</span><span class="p">,</span> <span class="n">lhs</span><span class="p">)</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;right=&#39;</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>下面是简单的测试：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Evaluator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">t4</span><span class="p">)</span>
<span class="go">Add: &lt;__main__.Add object at 0x1006a8d90&gt;</span>
<span class="go">left= 1</span>
<span class="go">right= -0.4</span>
<span class="go">0.6</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一小节我们演示了生成器和协程在程序控制流方面的强大功能。
避免递归的一个通常方法是使用一个栈或队列的数据结构。
例如，深度优先的遍历算法，第一次碰到一个节点时将其压入栈中，处理完后弹出栈。<code class="docutils literal"><span class="pre">visit()</span></code> 方法的核心思路就是这样。</p>
<p>另外一个需要理解的就是生成器中yield语句。当碰到yield语句时，生成器会返回一个数据并暂时挂起。
上面的例子使用这个技术来代替了递归。例如，之前我们是这样写递归：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
</pre></div>
</div>
<p>现在换成yield语句：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
</pre></div>
</div>
<p>它会将 <code class="docutils literal"><span class="pre">node.left</span></code> 返回给 <code class="docutils literal"><span class="pre">visit()</span></code> 方法，然后 <code class="docutils literal"><span class="pre">visit()</span></code> 方法调用那个节点相应的 <code class="docutils literal"><span class="pre">visit_Name()</span></code> 方法。
yield暂时将程序控制器让出给调用者，当执行完后，结果会赋值给value，</p>
<p>看完这一小节，你也许想去寻找其它没有yield语句的方案。但是这么做没有必要，你必须处理很多棘手的问题。
例如，为了消除递归，你必须要维护一个栈结构，如果不使用生成器，代码会变得很臃肿，到处都是栈操作语句、回调函数等。
实际上，使用yield语句可以让你写出非常漂亮的代码，它消除了递归但是看上去又很像递归实现，代码很简洁。</p>
</div>
</div>
<span id="document-c08/p23_managing_memory_in_cyclic_data_structures"></span><div class="section" id="id1">
<h3>8.23 循环引用数据结构的内存管理<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序创建了很多循环引用数据结构(比如树、图、观察者模式等)，你碰到了内存管理难题。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>一个简单的循环引用数据结构例子就是一个树形结构，双亲节点有指针指向孩子节点，孩子节点又返回来指向双亲节点。
这种情况下，可以考虑使用 <code class="docutils literal"><span class="pre">weakref</span></code> 库中的弱引用。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">weakref</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Node({!r:})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># property that manages the parent as a weak-reference</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">()</span>

    <span class="nd">@parent.setter</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
</pre></div>
</div>
<p>这种是想方式允许parent静默终止。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s1">&#39;child&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="go">Node(&#39;parent&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>循环引用的数据结构在Python中是一个很棘手的问题，因为正常的垃圾回收机制不能适用于这种情形。
例如考虑如下代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Class just to illustrate when deletion occurs</span>
<span class="k">class</span> <span class="nc">Data</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Data.__del__&#39;</span><span class="p">)</span>

<span class="c1"># Node class involving a cycle</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
</pre></div>
</div>
<p>下面我们使用这个代码来做一些垃圾回收试验：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span> <span class="c1"># Immediately deleted</span>
<span class="go">Data.__del__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span> <span class="c1"># Immediately deleted</span>
<span class="go">Data.__del__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">Node</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span> <span class="c1"># Not deleted (no message)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以看到，最后一个的删除时打印语句没有出现。原因是Python的垃圾回收机制是基于简单的引用计数。
当一个对象的引用数变成0的时候才会立即删除掉。而对于循环引用这个条件永远不会成立。
因此，在上面例子中最后部分，父节点和孩子节点互相拥有对方的引用，导致每个对象的引用计数都不可能变成0。</p>
<p>Python有另外的垃圾回收器来专门针对循环引用的，但是你永远不知道它什么时候会触发。
另外你还可以手动的触发它，但是代码看上去很挫：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span> <span class="c1"># Force collection</span>
<span class="go">Data.__del__</span>
<span class="go">Data.__del__</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果循环引用的对象自己还定义了自己的 <code class="docutils literal"><span class="pre">__del__()</span></code> 方法，那么会让情况变得更糟糕。
假设你像下面这样给Node定义自己的 <code class="docutils literal"><span class="pre">__del__()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Node class involving a cycle</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="c1"># NEVER DEFINE LIKE THIS.</span>
    <span class="c1"># Only here to illustrate pathological behavior</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">del</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">del</span><span class="o">.</span><span class="n">children</span>
</pre></div>
</div>
<p>这种情况下，垃圾回收永远都不会去回收这个对象的，还会导致内存泄露。
如果你试着去运行它会发现，<code class="docutils literal"><span class="pre">Data.__del__</span></code> 消息永远不会出现了,甚至在你强制内存回收时：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">Node</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span> <span class="c1"># No message (not collected)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span> <span class="c1"># No message (not collected)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>弱引用消除了引用循环的这个问题，本质来讲，弱引用就是一个对象指针，它不会增加它的引用计数。
你可以通过 <code class="docutils literal"><span class="pre">weakref</span></code> 来创建弱引用。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weakref</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_ref</span>
<span class="go">&lt;weakref at 0x100581f70; to &#39;Node&#39; at 0x1005c5410&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了访问弱引用所引用的对象，你可以像函数一样去调用它即可。如果那个对象还存在就会返回它，否则就返回一个None。
由于原始对象的引用计数没有增加，那么就可以去删除它了。例如;</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a_ref</span><span class="p">())</span>
<span class="go">&lt;__main__.Node object at 0x1005c5410&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span>
<span class="go">Data.__del__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a_ref</span><span class="p">())</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>通过这里演示的弱引用技术，你会发现不再有循环引用问题了，一旦某个节点不被使用了，垃圾回收器立即回收它。
你还能参考8.25小节关于弱引用的另外一个例子。</p>
</div>
</div>
<span id="document-c08/p24_making_classes_support_comparison_operations"></span><div class="section" id="id1">
<h3>8.24 让类支持比较操作<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想让某个类的实例支持标准的比较运算(比如&gt;=,!=,&lt;=,&lt;等)，但是又不想去实现那一大丢的特殊方法。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python类对每个比较操作都需要实现一个特殊方法来支持。
例如为了支持&gt;=操作符，你需要定义一个 <code class="docutils literal"><span class="pre">__ge__()</span></code> 方法。
尽管定义一个方法没什么问题，但如果要你实现所有可能的比较方法那就有点烦人了。</p>
<p>装饰器 <code class="docutils literal"><span class="pre">functools.total_ordering</span></code> 就是用来简化这个处理的。
使用它来装饰一个来，你只需定义一个 <code class="docutils literal"><span class="pre">__eq__()</span></code> 方法，
外加其他方法(__lt__, __le__, __gt__, or __ge__)中的一个即可。
然后装饰器会自动为你填充其它比较方法。</p>
<p>作为例子，我们构建一些房子，然后给它们增加一些房间，最后通过房子大小来比较它们：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">total_ordering</span>

<span class="k">class</span> <span class="nc">Room</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">square_feet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>

<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">House</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">style</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">style</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rooms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">living_space_footage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">square_feet</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rooms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_room</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;{}: {} square foot {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">living_space_footage</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">style</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">living_space_footage</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">living_space_footage</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">living_space_footage</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">living_space_footage</span>
</pre></div>
</div>
<p>这里我们只是给House类定义了两个方法：<code class="docutils literal"><span class="pre">__eq__()</span></code> 和 <code class="docutils literal"><span class="pre">__lt__()</span></code> ，它就能支持所有的比较操作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Build a few houses, and add rooms to them</span>
<span class="n">h1</span> <span class="o">=</span> <span class="n">House</span><span class="p">(</span><span class="s1">&#39;h1&#39;</span><span class="p">,</span> <span class="s1">&#39;Cape&#39;</span><span class="p">)</span>
<span class="n">h1</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Master Bedroom&#39;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
<span class="n">h1</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Living Room&#39;</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">h1</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Kitchen&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
<span class="n">h1</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Office&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">h2</span> <span class="o">=</span> <span class="n">House</span><span class="p">(</span><span class="s1">&#39;h2&#39;</span><span class="p">,</span> <span class="s1">&#39;Ranch&#39;</span><span class="p">)</span>
<span class="n">h2</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Master Bedroom&#39;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
<span class="n">h2</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Living Room&#39;</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">h2</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Kitchen&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
<span class="n">h3</span> <span class="o">=</span> <span class="n">House</span><span class="p">(</span><span class="s1">&#39;h3&#39;</span><span class="p">,</span> <span class="s1">&#39;Split&#39;</span><span class="p">)</span>
<span class="n">h3</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Master Bedroom&#39;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
<span class="n">h3</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Living Room&#39;</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">h3</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Office&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
<span class="n">h3</span><span class="o">.</span><span class="n">add_room</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="s1">&#39;Kitchen&#39;</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span>
<span class="n">houses</span> <span class="o">=</span> <span class="p">[</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">h3</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Is h1 bigger than h2?&#39;</span><span class="p">,</span> <span class="n">h1</span> <span class="o">&gt;</span> <span class="n">h2</span><span class="p">)</span> <span class="c1"># prints True</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Is h2 smaller than h3?&#39;</span><span class="p">,</span> <span class="n">h2</span> <span class="o">&lt;</span> <span class="n">h3</span><span class="p">)</span> <span class="c1"># prints True</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Is h2 greater than or equal to h1?&#39;</span><span class="p">,</span> <span class="n">h2</span> <span class="o">&gt;=</span> <span class="n">h1</span><span class="p">)</span> <span class="c1"># Prints False</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Which one is biggest?&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">houses</span><span class="p">))</span> <span class="c1"># Prints &#39;h3: 1101-square-foot Split&#39;</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Which is smallest?&#39;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">houses</span><span class="p">))</span> <span class="c1"># Prints &#39;h2: 846-square-foot Ranch&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>其实 <code class="docutils literal"><span class="pre">total_ordering</span></code> 装饰器也没那么神秘。
它就是定义了一个从每个比较支持方法到所有需要定义的其他方法的一个映射而已。
比如你定义了 <code class="docutils literal"><span class="pre">__le__()</span></code> 方法，那么它就被用来构建所有其他的需要定义的那些特殊方法。
实际上就是在类里面像下面这样定义了一些特殊方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">House</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="c1"># Methods created by @total_ordering</span>
    <span class="fm">__le__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
    <span class="fm">__gt__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>
    <span class="fm">__ge__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">)</span>
    <span class="fm">__ne__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
</pre></div>
</div>
<p>当然，你自己去写也很容易，但是使用 <code class="docutils literal"><span class="pre">&#64;total_ordering</span></code> 可以简化代码，何乐而不为呢。</p>
</div>
</div>
<span id="document-c08/p25_creating_cached_instances"></span><div class="section" id="id1">
<h3>8.25 创建缓存实例<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>在创建一个类的对象时，如果之前使用同样参数创建过这个对象， 你想返回它的缓存引用。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这种通常是因为你希望相同参数创建的对象时单例的。
在很多库中都有实际的例子，比如 <code class="docutils literal"><span class="pre">logging</span></code> 模块，使用相同的名称创建的 <code class="docutils literal"><span class="pre">logger</span></code> 实例永远只有一个。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">logging</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">c</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为了达到这样的效果，你需要使用一个和类本身分开的工厂函数，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># The class in question</span>
<span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="c1"># Caching support</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="n">_spam_cache</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">get_spam</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_spam_cache</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">_spam_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">_spam_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>然后做一个测试，你会发现跟之前那个日志对象的创建行为是一致的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">get_spam</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">get_spam</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">get_spam</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">c</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>编写一个工厂函数来修改普通的实例创建行为通常是一个比较简单的方法。
但是我们还能否找到更优雅的解决方案呢？</p>
<p>例如，你可能会考虑重新定义类的 <code class="docutils literal"><span class="pre">__new__()</span></code> 方法，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Note: This code doesn&#39;t quite work</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="n">_spam_cache</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_spam_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_spam_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_spam_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Initializing Spam&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>初看起来好像可以达到预期效果，但是问题是 <code class="docutils literal"><span class="pre">__init__()</span></code> 每次都会被调用，不管这个实例是否被缓存了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;Dave&#39;</span><span class="p">)</span>
<span class="go">Initializing Spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;Dave&#39;</span><span class="p">)</span>
<span class="go">Initializing Spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="ow">is</span> <span class="n">t</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这个或许不是你想要的效果，因此这种方法并不可取。</p>
<p>上面我们使用到了弱引用计数，对于垃圾回收来讲是很有帮助的，关于这个我们在8.23小节已经讲过了。
当我们保持实例缓存时，你可能只想在程序中使用到它们时才保存。
一个 <code class="docutils literal"><span class="pre">WeakValueDictionary</span></code> 实例只会保存那些在其它地方还在被使用的实例。
否则的话，只要实例不再被使用了，它就从字典中被移除了。观察下下面的测试结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">get_spam</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">get_spam</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">get_spam</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">_spam_cache</span><span class="p">)</span>
<span class="go">[&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">_spam_cache</span><span class="p">)</span>
<span class="go">[&#39;bar&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">_spam_cache</span><span class="p">)</span>
<span class="go">[]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于大部分程序而已，这里代码已经够用了。不过还是有一些更高级的实现值得了解下。</p>
<p>首先是这里使用到了一个全局变量，并且工厂函数跟类放在一块。我们可以通过将缓存代码放到一个单独的缓存管理器中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">weakref</span>

<span class="k">class</span> <span class="nc">CachedSpamManager</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">CachedSpamManager</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">get_spam</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Spam</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">get_spam</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>这样的话代码更清晰，并且也更灵活，我们可以增加更多的缓存管理机制，只需要替代manager即可。</p>
<p>还有一点就是，我们暴露了类的实例化给用户，用户很容易去直接实例化这个类，而不是使用工厂方法，如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有几种方式可以防止用户这样做，第一个是将类的名字修改为以下划线(_)开头，提示用户别直接调用它。
第二种就是让这个类的 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法抛出一个异常，让它不能被初始化：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t instantiate directly&quot;</span><span class="p">)</span>

    <span class="c1"># Alternate constructor</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>然后修改缓存管理器代码，使用 <code class="docutils literal"><span class="pre">Spam._new()</span></code> 来创建实例，而不是直接调用 <code class="docutils literal"><span class="pre">Spam()</span></code> 构造函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># ------------------------最后的修正方案------------------------</span>
<span class="k">class</span> <span class="nc">CachedSpamManager2</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">Spam3</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># Modified creation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">temp</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Spam3</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t instantiate directly&quot;</span><span class="p">)</span>

    <span class="c1"># Alternate constructor</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>最后这样的方案就已经足够好了。
缓存和其他构造模式还可以使用9.13小节中的元类实现的更优雅一点(使用了更高级的技术)。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p09_meta_programming"></span><div class="section" id="id1">
<h2>第九章：元编程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>软件开发领域中最经典的口头禅就是“don’t repeat yourself”。
也就是说，任何时候当你的程序中存在高度重复(或者是通过剪切复制)的代码时，都应该想想是否有更好的解决方案。
在Python当中，通常都可以通过元编程来解决这类问题。
简而言之，元编程就是关于创建操作源代码(比如修改、生成或包装原来的代码)的函数和类。
主要技术是使用装饰器、类装饰器和元类。不过还有一些其他技术，
包括签名对象、使用 <code class="docutils literal"><span class="pre">exec()</span></code> 执行代码以及对内部函数和类的反射技术等。
本章的主要目的是向大家介绍这些元编程技术，并且给出实例来演示它们是怎样定制化你的源代码行为的。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c09/p01_put_wrapper_around_function"></span><div class="section" id="id1">
<h3>9.1 在函数上添加包装器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在函数上添加一个包装器，增加额外的操作处理(比如日志、计时等)。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想使用额外的代码包装一个函数，可以定义一个装饰器函数，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">timethis</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Decorator that reports the execution time.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>下面是使用装饰器的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@timethis</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="sd">    Counts down</span>
<span class="gp">... </span><span class="sd">    &#39;&#39;&#39;</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="go">countdown 0.008917808532714844</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="p">(</span><span class="mi">10000000</span><span class="p">)</span>
<span class="go">countdown 0.87188299392912</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>一个装饰器就是一个函数，它接受一个函数作为参数并返回一个新的函数。
当你像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@timethis</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>跟像下面这样写其实效果是一样的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">countdown</span> <span class="o">=</span> <span class="n">timethis</span><span class="p">(</span><span class="n">countdown</span><span class="p">)</span>
</pre></div>
</div>
<p>顺便说一下，内置的装饰器比如 <code class="docutils literal"><span class="pre">&#64;staticmethod,</span> <span class="pre">&#64;classmethod,&#64;property</span></code> 原理也是一样的。
例如，下面这两个代码片段是等价的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="c1"># Equivalent definition of a class method</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="n">method</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
<p>在上面的 <code class="docutils literal"><span class="pre">wrapper()</span></code> 函数中，
装饰器内部定义了一个使用 <code class="docutils literal"><span class="pre">*args</span></code> 和  <code class="docutils literal"><span class="pre">**kwargs</span></code> 来接受任意参数的函数。
在这个函数里面调用了原始函数并将其结果返回，不过你还可以添加其他额外的代码(比如计时)。
然后这个新的函数包装器被作为结果返回来代替原始函数。</p>
<p>需要强调的是装饰器并不会修改原始函数的参数签名以及返回值。
使用 <code class="docutils literal"><span class="pre">*args</span></code> 和  <code class="docutils literal"><span class="pre">**kwargs</span></code> 目的就是确保任何参数都能适用。
而返回结果值基本都是调用原始函数 <code class="docutils literal"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code> 的返回结果，其中func就是原始函数。</p>
<p>刚开始学习装饰器的时候，会使用一些简单的例子来说明，比如上面演示的这个。
不过实际场景使用时，还是有一些细节问题要注意的。
比如上面使用 <code class="docutils literal"><span class="pre">&#64;wraps(func)</span></code> 注解是很重要的，
它能保留原始函数的元数据(下一小节会讲到)，新手经常会忽略这个细节。
接下来的几个小节我们会更加深入的讲解装饰器函数的细节问题，如果你想构造你自己的装饰器函数，需要认真看一下。</p>
</div>
</div>
<span id="document-c09/p02_preserve_function_metadata_when_write_decorators"></span><div class="section" id="id1">
<h3>9.2 创建装饰器时保留函数元信息<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你写了一个装饰器作用在某个函数上，但是这个函数的重要的元信息比如名字、文档字符串、注解和参数签名都丢失了。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>任何时候你定义装饰器的时候，都应该使用 <code class="docutils literal"><span class="pre">functools</span></code> 库中的 <code class="docutils literal"><span class="pre">&#64;wraps</span></code> 装饰器来注解底层包装函数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="k">def</span> <span class="nf">timethis</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Decorator that reports the execution time.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>下面我们使用这个被包装后的函数并检查它的元信息：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@timethis</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="sd">    Counts down</span>
<span class="gp">... </span><span class="sd">    &#39;&#39;&#39;</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="go">countdown 0.008917808532714844</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;countdown&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;\n\tCounts down\n\t&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="n">__annotations__</span>
<span class="go">{&#39;n&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在编写装饰器的时候复制元信息是一个非常重要的部分。如果你忘记了使用 <code class="docutils literal"><span class="pre">&#64;wraps</span></code> ，
那么你会发现被装饰函数丢失了所有有用的信息。比如如果忽略 <code class="docutils literal"><span class="pre">&#64;wraps</span></code> 后的效果是下面这样的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;wrapper&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="n">__annotations__</span>
<span class="go">{}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&#64;wraps</span></code> 有一个重要特征是它能让你通过属性 <code class="docutils literal"><span class="pre">__wrapped__</span></code> 直接访问被包装函数。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__wrapped__</span></code> 属性还能让被装饰函数正确暴露底层的参数签名信息。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">countdown</span><span class="p">))</span>
<span class="go">(n:int)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一个很普遍的问题是怎样让装饰器去直接复制原始函数的参数签名信息，
如果想自己手动实现的话需要做大量的工作，最好就简单的使用 <code class="docutils literal"><span class="pre">&#64;wraps</span></code> 装饰器。
通过底层的 <code class="docutils literal"><span class="pre">__wrapped__</span></code> 属性访问到函数签名信息。更多关于签名的内容可以参考9.16小节。</p>
</div>
</div>
<span id="document-c09/p03_unwrapping_decorator"></span><div class="section" id="id1">
<h3>9.3 解除一个装饰器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>一个装饰器已经作用在一个函数上，你想撤销它，直接访问原始的未包装的那个函数。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>假设装饰器是通过 <code class="docutils literal"><span class="pre">&#64;wraps</span></code> (参考9.2小节)来实现的，那么你可以通过访问 <code class="docutils literal"><span class="pre">__wrapped__</span></code> 属性来访问原始函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@somedecorator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orig_add</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">__wrapped__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orig_add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>直接访问未包装的原始函数在调试、内省和其他函数操作时是很有用的。
但是我们这里的方案仅仅适用于在包装器中正确使用了 <code class="docutils literal"><span class="pre">&#64;wraps</span></code> 或者直接设置了 <code class="docutils literal"><span class="pre">__wrapped__</span></code> 属性的情况。</p>
<p>如果有多个包装器，那么访问 <code class="docutils literal"><span class="pre">__wrapped__</span></code> 属性的行为是不可预知的，应该避免这样做。
在Python3.3中，它会略过所有的包装层，比如，假如你有如下的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">decorator1</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Decorator 1&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">decorator2</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Decorator 2&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@decorator1</span>
<span class="nd">@decorator2</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>下面我们在Python3.3下测试：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Decorator 1</span>
<span class="go">Decorator 2</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>下面我们在Python3.4下测试：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Decorator 1</span>
<span class="go">Decorator 2</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Decorator 2</span>
<span class="go">5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后要说的是，并不是所有的装饰器都使用了 <code class="docutils literal"><span class="pre">&#64;wraps</span></code> ，因此这里的方案并不全部适用。
特别的，内置的装饰器 <code class="docutils literal"><span class="pre">&#64;staticmethod</span></code> 和 <code class="docutils literal"><span class="pre">&#64;classmethod</span></code> 就没有遵循这个约定
(它们把原始函数存储在属性 <code class="docutils literal"><span class="pre">__func__</span></code> 中)。</p>
</div>
</div>
<span id="document-c09/p04_define_decorator_that_takes_arguments"></span><div class="section" id="id1">
<h3>9.4 定义一个带参数的装饰器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想定义一个可以接受参数的装饰器</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>我们用一个例子详细阐述下接受参数的处理过程。
假设你想写一个装饰器，给函数添加日志功能，同时允许用户指定日志的级别和其他的选项。
下面是这个装饰器的定义和使用示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">def</span> <span class="nf">logged</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add logging to a function. level is the logging</span>
<span class="sd">    level, name is the logger name, and message is the</span>
<span class="sd">    log message. If name and message aren&#39;t specified,</span>
<span class="sd">    they default to the function&#39;s module and name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">logname</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">logname</span><span class="p">)</span>
        <span class="n">logmsg</span> <span class="o">=</span> <span class="n">message</span> <span class="k">if</span> <span class="n">message</span> <span class="k">else</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">logmsg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorate</span>

<span class="c1"># Example use</span>
<span class="nd">@logged</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nd">@logged</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span> <span class="s1">&#39;example&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spam</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Spam!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>初看起来，这种实现看上去很复杂，但是核心思想很简单。
最外层的函数 <code class="docutils literal"><span class="pre">logged()</span></code> 接受参数并将它们作用在内部的装饰器函数上面。
内层的函数 <code class="docutils literal"><span class="pre">decorate()</span></code> 接受一个函数作为参数，然后在函数上面放置一个包装器。
这里的关键点是包装器是可以使用传递给 <code class="docutils literal"><span class="pre">logged()</span></code> 的参数的。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>定义一个接受参数的包装器看上去比较复杂主要是因为底层的调用序列。特别的，如果你有下面这个代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@decorator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>装饰器处理过程跟下面的调用是等效的;</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)(</span><span class="n">func</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">decorator(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> 的返回结果必须是一个可调用对象，它接受一个函数作为参数并包装它，
可以参考9.7小节中另外一个可接受参数的包装器例子。</p>
</div>
</div>
<span id="document-c09/p05_define_decorator_with_user_adjustable_attributes"></span><div class="section" id="id1">
<h3>9.5 可自定义属性的装饰器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想写一个装饰器来包装一个函数，并且允许用户提供参数在运行时控制装饰器行为。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>引入一个访问函数，使用 <code class="docutils literal"><span class="pre">nonlocal</span></code> 来修改内部变量。
然后这个访问函数被作为一个属性赋值给包装函数。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="c1"># Utility decorator to attach a function as an attribute of obj</span>
<span class="k">def</span> <span class="nf">attach_wrapper</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">attach_wrapper</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="k">def</span> <span class="nf">logged</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Add logging to a function. level is the logging</span>
<span class="sd">    level, name is the logger name, and message is the</span>
<span class="sd">    log message. If name and message aren&#39;t specified,</span>
<span class="sd">    they default to the function&#39;s module and name.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">logname</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">logname</span><span class="p">)</span>
        <span class="n">logmsg</span> <span class="o">=</span> <span class="n">message</span> <span class="k">if</span> <span class="n">message</span> <span class="k">else</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">logmsg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Attach setter functions</span>
        <span class="nd">@attach_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">set_level</span><span class="p">(</span><span class="n">newlevel</span><span class="p">):</span>
            <span class="n">nonlocal</span> <span class="n">level</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">newlevel</span>

        <span class="nd">@attach_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">set_message</span><span class="p">(</span><span class="n">newmsg</span><span class="p">):</span>
            <span class="n">nonlocal</span> <span class="n">logmsg</span>
            <span class="n">logmsg</span> <span class="o">=</span> <span class="n">newmsg</span>

        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">decorate</span>

<span class="c1"># Example use</span>
<span class="nd">@logged</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nd">@logged</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span> <span class="s1">&#39;example&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spam</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Spam!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是交互环境下的使用例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">logging</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">DEBUG:__main__:add</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Change the log message</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">set_message</span><span class="p">(</span><span class="s1">&#39;Add called&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">DEBUG:__main__:Add called</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Change the log level</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">set_level</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">WARNING:__main__:Add called</span>
<span class="go">5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一小节的关键点在于访问函数(如 <code class="docutils literal"><span class="pre">set_message()</span></code> 和 <code class="docutils literal"><span class="pre">set_level()</span></code> )，它们被作为属性赋给包装器。
每个访问函数允许使用 <code class="docutils literal"><span class="pre">nonlocal</span></code> 来修改函数内部的变量。</p>
<p>还有一个令人吃惊的地方是访问函数会在多层装饰器间传播(如果你的装饰器都使用了 <code class="docutils literal"><span class="pre">&#64;functools.wraps</span></code> 注解)。
例如，假设你引入另外一个装饰器，比如9.2小节中的 <code class="docutils literal"><span class="pre">&#64;timethis</span></code> ，像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@timethis</span>
<span class="nd">@logged</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>你会发现访问函数依旧有效：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="p">(</span><span class="mi">10000000</span><span class="p">)</span>
<span class="go">DEBUG:__main__:countdown</span>
<span class="go">countdown 0.8198461532592773</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="n">set_level</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="n">set_message</span><span class="p">(</span><span class="s2">&quot;Counting down to zero&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="p">(</span><span class="mi">10000000</span><span class="p">)</span>
<span class="go">WARNING:__main__:Counting down to zero</span>
<span class="go">countdown 0.8225970268249512</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你还会发现即使装饰器像下面这样以相反的方向排放，效果也是一样的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@logged</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="nd">@timethis</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>还能通过使用lambda表达式代码来让访问函数的返回不同的设定值：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@attach_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_level</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">level</span>

<span class="c1"># Alternative</span>
<span class="n">wrapper</span><span class="o">.</span><span class="n">get_level</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">level</span>
</pre></div>
</div>
<p>一个比较难理解的地方就是对于访问函数的首次使用。例如，你可能会考虑另外一个方法直接访问函数的属性，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">wrapper</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">logmsg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c1"># Attach adjustable attributes</span>
<span class="n">wrapper</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>
<span class="n">wrapper</span><span class="o">.</span><span class="n">logmsg</span> <span class="o">=</span> <span class="n">logmsg</span>
<span class="n">wrapper</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>
</pre></div>
</div>
<p>这个方法也可能正常工作，但前提是它必须是最外层的装饰器才行。
如果它的上面还有另外的装饰器(比如上面提到的 <code class="docutils literal"><span class="pre">&#64;timethis</span></code> 例子)，那么它会隐藏底层属性，使得修改它们没有任何作用。
而通过使用访问函数就能避免这样的局限性。</p>
<p>最后提一点，这一小节的方案也可以作为9.9小节中装饰器类的另一种实现方法。</p>
</div>
</div>
<span id="document-c09/p06_define_decorator_that_takes_optional_argument"></span><div class="section" id="id1">
<h3>9.6 带可选参数的装饰器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想写一个装饰器，既可以不传参数给它，比如 <code class="docutils literal"><span class="pre">&#64;decorator</span></code> ，
也可以传递可选参数给它，比如 <code class="docutils literal"><span class="pre">&#64;decorator(x,y,z)</span></code> 。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>下面是9.5小节中日志装饰器的一个修改版本：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">def</span> <span class="nf">logged</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">logged</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">)</span>

    <span class="n">logname</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">logname</span><span class="p">)</span>
    <span class="n">logmsg</span> <span class="o">=</span> <span class="n">message</span> <span class="k">if</span> <span class="n">message</span> <span class="k">else</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">logmsg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>

<span class="c1"># Example use</span>
<span class="nd">@logged</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nd">@logged</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;example&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spam</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Spam!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>可以看到，<code class="docutils literal"><span class="pre">&#64;logged</span></code> 装饰器可以同时不带参数或带参数。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这里提到的这个问题就是通常所说的编程一致性问题。
当我们使用装饰器的时候，大部分程序员习惯了要么不给它们传递任何参数，要么给它们传递确切参数。
其实从技术上来讲，我们可以定义一个所有参数都是可选的装饰器，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@logged</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</pre></div>
</div>
<p>但是，这种写法并不符合我们的习惯，有时候程序员忘记加上后面的括号会导致错误。
这里我们向你展示了如何以一致的编程风格来同时满足没有括号和有括号两种情况。</p>
<p>为了理解代码是如何工作的，你需要非常熟悉装饰器是如何作用到函数上以及它们的调用规则。
对于一个像下面这样的简单装饰器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Example use</span>
<span class="nd">@logged</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>这个调用序列跟下面等价：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">add</span> <span class="o">=</span> <span class="n">logged</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
</pre></div>
</div>
<p>这时候，被装饰函数会被当做第一个参数直接传递给 <code class="docutils literal"><span class="pre">logged</span></code> 装饰器。
因此，<code class="docutils literal"><span class="pre">logged()</span></code> 中的第一个参数就是被包装函数本身。所有其他参数都必须有默认值。</p>
<p>而对于一个下面这样有参数的装饰器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@logged</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;example&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spam</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Spam!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>调用序列跟下面等价：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">spam</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Spam!&#39;</span><span class="p">)</span>
<span class="n">spam</span> <span class="o">=</span> <span class="n">logged</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;example&#39;</span><span class="p">)(</span><span class="n">spam</span><span class="p">)</span>
</pre></div>
</div>
<p>初始调用 <code class="docutils literal"><span class="pre">logged()</span></code> 函数时，被包装函数并没有传递进来。
因此在装饰器内，它必须是可选的。这个反过来会迫使其他参数必须使用关键字来指定。
并且，但这些参数被传递进来后，装饰器要返回一个接受一个函数参数并包装它的函数(参考9.5小节)。
为了这样做，我们使用了一个技巧，就是利用 <code class="docutils literal"><span class="pre">functools.partial</span></code> 。
它会返回一个未完全初始化的自身，除了被包装函数外其他参数都已经确定下来了。
可以参考7.8小节获取更多 <code class="docutils literal"><span class="pre">partial()</span></code> 方法的知识。</p>
</div>
</div>
<span id="document-c09/p07_enforcing_type_check_on_function_using_decorator"></span><div class="section" id="id1">
<h3>9.7 利用装饰器强制函数上的类型检查<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>作为某种编程规约，你想在对函数参数进行强制类型检查。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在演示实际代码前，先说明我们的目标：能对函数参数类型进行断言，类似下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@typeassert</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;contract.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">33</span><span class="p">,</span> <span class="ow">in</span> <span class="n">wrapper</span>
<span class="gr">TypeError</span>: <span class="n">Argument y must be &lt;class &#39;int&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>下面是使用装饰器技术来实现 <code class="docutils literal"><span class="pre">&#64;typeassert</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">typeassert</span><span class="p">(</span><span class="o">*</span><span class="n">ty_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ty_kwargs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="c1"># If in optimized mode, disable type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span>

        <span class="c1"># Map function argument names to supplied types</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">bound_types</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="o">*</span><span class="n">ty_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ty_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">arguments</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">bound_values</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Enforce type assertions across supplied arguments</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bound_values</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">bound_types</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">bound_types</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s1">&#39;Argument {} must be {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bound_types</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                            <span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorate</span>
</pre></div>
</div>
<p>可以看出这个装饰器非常灵活，既可以指定所有参数类型，也可以只指定部分。
并且可以通过位置或关键字来指定参数类型。下面是使用示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; @typeassert(int, z=int)
... def spam(x, y, z=42):
...     print(x, y, z)
...
&gt;&gt;&gt; spam(1, 2, 3)
1 2 3
&gt;&gt;&gt; spam(1, &#39;hello&#39;, 3)
1 hello 3
&gt;&gt;&gt; spam(1, &#39;hello&#39;, &#39;world&#39;)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;contract.py&quot;, line 33, in wrapper
TypeError: Argument z must be &lt;class &#39;int&#39;&gt;
&gt;&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这节是高级装饰器示例，引入了很多重要的概念。</p>
<p>首先，装饰器只会在函数定义时被调用一次。
有时候你去掉装饰器的功能，那么你只需要简单的返回被装饰函数即可。
下面的代码中，如果全局变量　<code class="docutils literal"><span class="pre">__debug__</span></code> 被设置成了False(当你使用-O或-OO参数的优化模式执行程序时)，
那么就直接返回未修改过的函数本身：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="c1"># If in optimized mode, disable type checking</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">__debug__</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span>
</pre></div>
</div>
<p>其次，这里还对被包装函数的参数签名进行了检查，我们使用了 <code class="docutils literal"><span class="pre">inspect.signature()</span></code> 函数。
简单来讲，它运行你提取一个可调用对象的参数签名信息。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">spam</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
<span class="go">(x, y, z=42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span>
<span class="go">mappingproxy(OrderedDict([(&#39;x&#39;, &lt;Parameter at 0x10077a050 &#39;x&#39;&gt;),</span>
<span class="go">(&#39;y&#39;, &lt;Parameter at 0x10077a158 &#39;y&#39;&gt;), (&#39;z&#39;, &lt;Parameter at 0x10077a1b0 &#39;z&#39;&gt;)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;z&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span>
<span class="go">&lt;_ParameterKind: &#39;POSITIONAL_OR_KEYWORD&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>装饰器的开始部分，我们使用了 <code class="docutils literal"><span class="pre">bind_partial()</span></code> 方法来执行从指定类型到名称的部分绑定。
下面是例子演示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bound_types</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bound_types</span>
<span class="go">&lt;inspect.BoundArguments object at 0x10069bb50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bound_types</span><span class="o">.</span><span class="n">arguments</span>
<span class="go">OrderedDict([(&#39;x&#39;, &lt;class &#39;int&#39;&gt;), (&#39;z&#39;, &lt;class &#39;int&#39;&gt;)])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这个部分绑定中，你可以注意到缺失的参数被忽略了(比如并没有对y进行绑定)。
不过最重要的是创建了一个有序字典 <code class="docutils literal"><span class="pre">bound_types.arguments</span></code> 。
这个字典会将参数名以函数签名中相同顺序映射到指定的类型值上面去。
在我们的装饰器例子中，这个映射包含了我们要强制指定的类型断言。</p>
<p>在装饰器创建的实际包装函数中使用到了 <code class="docutils literal"><span class="pre">sig.bind()</span></code> 方法。
<code class="docutils literal"><span class="pre">bind()</span></code> 跟 <code class="docutils literal"><span class="pre">bind_partial()</span></code> 类似，但是它不允许忽略任何参数。因此有了下面的结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bound_values</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bound_values</span><span class="o">.</span><span class="n">arguments</span>
<span class="go">OrderedDict([(&#39;x&#39;, 1), (&#39;y&#39;, 2), (&#39;z&#39;, 3)])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用这个映射我们可以很轻松的实现我们的强制类型检查：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bound_values</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">bound_types</span><span class="o">.</span><span class="n">arguments</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">bound_types</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>不过这个方案还有点小瑕疵，它对于有默认值的参数并不适用。
比如下面的代码可以正常工作，尽管items的类型是错误的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@typeassert</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">items</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>    <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">items</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;contract.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">33</span><span class="p">,</span> <span class="ow">in</span> <span class="n">wrapper</span>
<span class="gr">TypeError</span>: <span class="n">Argument items must be &lt;class &#39;list&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后一点是关于适用装饰器参数和函数注解之间的争论。
例如，为什么不像下面这样写一个装饰器来查找函数中的注解呢？</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@typeassert</span>
<span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>一个可能的原因是如果使用了函数参数注解，那么就被限制了。
如果注解被用来做类型检查就不能做其他事情了。而且 <code class="docutils literal"><span class="pre">&#64;typeassert</span></code> 不能再用于使用注解做其他事情的函数了。
而使用上面的装饰器参数灵活性大多了，也更加通用。</p>
<p>可以在PEP 362以及 <code class="docutils literal"><span class="pre">inspect</span></code> 模块中找到更多关于函数参数对象的信息。在9.16小节还有另外一个例子。</p>
</div>
</div>
<span id="document-c09/p08_define_decorators_as_part_of_class"></span><div class="section" id="id1">
<h3>9.8 将装饰器定义为类的一部分<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在类中定义装饰器，并将其作用在其他函数或方法上。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在类里面定义装饰器很简单，但是你首先要确认它的使用方式。比如到底是作为一个实例方法还是类方法。
下面我们用例子来阐述它们的不同：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="c1"># Decorator as an instance method</span>
    <span class="k">def</span> <span class="nf">decorator1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Decorator 1&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="c1"># Decorator as a class method</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">decorator2</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Decorator 2&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>下面是一使用例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># As an instance method</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="nd">@a.decorator1</span>
<span class="k">def</span> <span class="nf">spam</span><span class="p">():</span>
    <span class="k">pass</span>
<span class="c1"># As a class method</span>
<span class="nd">@A.decorator2</span>
<span class="k">def</span> <span class="nf">grok</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>仔细观察可以发现一个是实例调用，一个是类调用。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在类中定义装饰器初看上去好像很奇怪，但是在标准库中有很多这样的例子。
特别的，<code class="docutils literal"><span class="pre">&#64;property</span></code> 装饰器实际上是一个类，它里面定义了三个方法 <code class="docutils literal"><span class="pre">getter(),</span> <span class="pre">setter(),</span> <span class="pre">deleter()</span></code> ,
每一个方法都是一个装饰器。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="c1"># Create a property instance</span>
    <span class="n">first_name</span> <span class="o">=</span> <span class="nb">property</span><span class="p">()</span>

    <span class="c1"># Apply decorator methods</span>
    <span class="nd">@first_name.getter</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span>

    <span class="nd">@first_name.setter</span>
    <span class="k">def</span> <span class="nf">first_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_name</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>它为什么要这么定义的主要原因是各种不同的装饰器方法会在关联的 <code class="docutils literal"><span class="pre">property</span></code> 实例上操作它的状态。
因此，任何时候只要你碰到需要在装饰器中记录或绑定信息，那么这不失为一种可行方法。</p>
<p>在类中定义装饰器有个难理解的地方就是对于额外参数 <code class="docutils literal"><span class="pre">self</span></code> 或 <code class="docutils literal"><span class="pre">cls</span></code> 的正确使用。
尽管最外层的装饰器函数比如 <code class="docutils literal"><span class="pre">decorator1()</span></code> 或 <code class="docutils literal"><span class="pre">decorator2()</span></code> 需要提供一个 <code class="docutils literal"><span class="pre">self</span></code> 或 <code class="docutils literal"><span class="pre">cls</span></code> 参数，
但是在两个装饰器内部被创建的 <code class="docutils literal"><span class="pre">wrapper()</span></code> 函数并不需要包含这个 <code class="docutils literal"><span class="pre">self</span></code> 参数。
你唯一需要这个参数是在你确实要访问包装器中这个实例的某些部分的时候。其他情况下都不用去管它。</p>
<p>对于类里面定义的包装器还有一点比较难理解，就是在涉及到继承的时候。
例如，假设你想让在A中定义的装饰器作用在子类B中。你需要像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="nd">@A.decorator2</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>也就是说，装饰器要被定义成类方法并且你必须显式的使用父类名去调用它。
你不能使用 <code class="docutils literal"><span class="pre">&#64;B.decorator2</span></code> ，因为在方法定义时，这个类B还没有被创建。</p>
</div>
</div>
<span id="document-c09/p09_define_decorators_as_classes"></span><div class="section" id="id1">
<h3>9.9 将装饰器定义为类<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想使用一个装饰器去包装函数，但是希望返回一个可调用的实例。
你需要让你的装饰器可以同时工作在类定义的内部和外部。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了将装饰器定义成一个实例，你需要确保它实现了 <code class="docutils literal"><span class="pre">__call__()</span></code> 和 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法。
例如，下面的代码定义了一个类，它在其他函数上放置一个简单的记录层：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">class</span> <span class="nc">Profiled</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
</pre></div>
</div>
<p>你可以将它当做一个普通的装饰器来使用，在类里面或外面都可以：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@Profiled</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="nd">@Profiled</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>在交互环境中的使用示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">ncalls</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;__main__.Spam object at 0x10069e9d0&gt; 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&lt;__main__.Spam object at 0x10069e9d0&gt; 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&lt;__main__.Spam object at 0x10069e9d0&gt; 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Spam</span><span class="o">.</span><span class="n">bar</span><span class="o">.</span><span class="n">ncalls</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>将装饰器定义成类通常是很简单的。但是这里还是有一些细节需要解释下，特别是当你想将它作用在实例方法上的时候。</p>
<p>首先，使用 <code class="docutils literal"><span class="pre">functools.wraps()</span></code> 函数的作用跟之前还是一样，将被包装函数的元信息复制到可调用实例中去。</p>
<p>其次，通常很容易会忽视上面的 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法。如果你忽略它，保持其他代码不变再次运行，
你会发现当你去调用被装饰实例方法时出现很奇怪的问题。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">bar() missing 1 required positional argument: &#39;x&#39;</span>
</pre></div>
</div>
<p>出错原因是当方法函数在一个类中被查找时，它们的 <code class="docutils literal"><span class="pre">__get__()</span></code> 方法依据描述器协议被调用，
在8.9小节已经讲述过描述器协议了。在这里，<code class="docutils literal"><span class="pre">__get__()</span></code> 的目的是创建一个绑定方法对象
(最终会给这个方法传递self参数)。下面是一个例子来演示底层原理：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">grok</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grok</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Spam</span><span class="p">)</span>
<span class="go">&lt;bound method Spam.grok of &lt;__main__.Spam object at 0x100671e90&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__get__()</span></code> 方法是为了确保绑定方法对象能被正确的创建。
<code class="docutils literal"><span class="pre">type.MethodType()</span></code> 手动创建一个绑定方法来使用。只有当实例被使用的时候绑定方法才会被创建。
如果这个方法是在类上面来访问，
那么 <code class="docutils literal"><span class="pre">__get__()</span></code> 中的instance参数会被设置成None并直接返回 <code class="docutils literal"><span class="pre">Profiled</span></code> 实例本身。
这样的话我们就可以提取它的 <code class="docutils literal"><span class="pre">ncalls</span></code> 属性了。</p>
<p>如果你想避免一些混乱，也可以考虑另外一个使用闭包和 <code class="docutils literal"><span class="pre">nonlocal</span></code> 变量实现的装饰器，这个在9.5小节有讲到。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">profiled</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">ncalls</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nonlocal</span> <span class="n">ncalls</span>
        <span class="n">ncalls</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">ncalls</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="c1"># Example</span>
<span class="nd">@profiled</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>这个方式跟之前的效果几乎一样，除了对于 <code class="docutils literal"><span class="pre">ncalls</span></code> 的访问现在是通过一个被绑定为属性的函数来实现，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">ncalls</span><span class="p">()</span>
<span class="go">2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c09/p10_apply_decorators_to_class_and_static_methods"></span><div class="section" id="id1">
<h3>9.10 为类和静态方法提供装饰器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想给类或静态方法提供装饰器。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>给类或静态方法提供装饰器是很简单的，不过要确保装饰器在 <code class="docutils literal"><span class="pre">&#64;classmethod</span></code> 或 <code class="docutils literal"><span class="pre">&#64;staticmethod</span></code> 之前。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="c1"># A simple decorator</span>
<span class="k">def</span> <span class="nf">timethis</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="c1"># Class illustrating application of the decorator to different kinds of methods</span>
<span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="nd">@timethis</span>
    <span class="k">def</span> <span class="nf">instance_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@timethis</span>
    <span class="k">def</span> <span class="nf">class_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@timethis</span>
    <span class="k">def</span> <span class="nf">static_method</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>装饰后的类和静态方法可正常工作，只不过增加了额外的计时功能：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">instance_method</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="go">&lt;__main__.Spam object at 0x1006a6050&gt; 1000000</span>
<span class="go">0.11817407608032227</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Spam</span><span class="o">.</span><span class="n">class_method</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.Spam&#39;&gt; 1000000</span>
<span class="go">0.11334395408630371</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Spam</span><span class="o">.</span><span class="n">static_method</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="go">1000000</span>
<span class="go">0.11740279197692871</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>如果你把装饰器的顺序写错了就会出错。例如，假设你像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="nd">@timethis</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static_method</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>那么你调用这个静态方法时就会报错：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; Spam.static_method(1000000)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;timethis.py&quot;, line 6, in wrapper
start = time.time()
TypeError: &#39;staticmethod&#39; object is not callable
&gt;&gt;&gt;
</pre></div>
</div>
<p>问题在于 <code class="docutils literal"><span class="pre">&#64;classmethod</span></code> 和 <code class="docutils literal"><span class="pre">&#64;staticmethod</span></code> 实际上并不会创建可直接调用的对象，
而是创建特殊的描述器对象(参考8.9小节)。因此当你试着在其他装饰器中将它们当做函数来使用时就会出错。
确保这种装饰器出现在装饰器链中的第一个位置可以修复这个问题。</p>
<p>当我们在抽象基类中定义类方法和静态方法(参考8.12小节)时，这里讲到的知识就很有用了。
例如，如果你想定义一个抽象类方法，可以使用类似下面的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>在这段代码中，<code class="docutils literal"><span class="pre">&#64;classmethod</span></code> 跟 <code class="docutils literal"><span class="pre">&#64;abstractmethod</span></code> 两者的顺序是有讲究的，如果你调换它们的顺序就会出错。</p>
</div>
</div>
<span id="document-c09/p11_write_decorators_that_add_arguments_to_functions"></span><div class="section" id="id1">
<h3>9.11 装饰器为被包装函数增加参数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在装饰器中给被包装函数增加额外的参数，但是不能影响这个函数现有的调用规则。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>可以使用关键字参数来给被包装函数增加额外参数。考虑下面的装饰器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">optional_debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Calling&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@optional_debug</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1 2 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Calling spam</span>
<span class="go">1 2 3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>通过装饰器来给被包装函数增加参数的做法并不常见。
尽管如此，有时候它可以避免一些重复代码。例如，如果你有下面这样的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Calling a&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Calling b&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Calling c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>那么你可以将其重构成这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="k">def</span> <span class="nf">optional_debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;debug&#39;</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;debug argument already defined&#39;</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Calling&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@optional_debug</span>
<span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@optional_debug</span>
<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@optional_debug</span>
<span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>这种实现方案之所以行得通，在于强制关键字参数很容易被添加到接受 <code class="docutils literal"><span class="pre">*args</span></code> 和 <code class="docutils literal"><span class="pre">**kwargs</span></code> 参数的函数中。
通过使用强制关键字参数，它被作为一个特殊情况被挑选出来，
并且接下来仅仅使用剩余的位置和关键字参数去调用这个函数时，这个特殊参数会被排除在外。
也就是说，它并不会被纳入到 <code class="docutils literal"><span class="pre">**kwargs</span></code> 中去。</p>
<p>还有一个难点就是如何去处理被添加的参数与被包装函数参数直接的名字冲突。
例如，如果装饰器 <code class="docutils literal"><span class="pre">&#64;optional_debug</span></code> 作用在一个已经拥有一个 <code class="docutils literal"><span class="pre">debug</span></code> 参数的函数上时会有问题。
这里我们增加了一步名字检查。</p>
<p>上面的方案还可以更完美一点，因为精明的程序员应该发现了被包装函数的函数签名其实是错误的。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@optional_debug</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">add</span><span class="p">))</span>
<span class="go">(x, y)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>通过如下的修改，可以解决这个问题：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="k">def</span> <span class="nf">optional_debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;debug&#39;</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;debug argument already defined&#39;</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Calling&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">parms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">parms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span>
                <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">parms</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>通过这样的修改，包装后的函数签名就能正确的显示 <code class="docutils literal"><span class="pre">debug</span></code> 参数的存在了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@optional_debug</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">add</span><span class="p">))</span>
<span class="go">(x, y, *, debug=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>参考9.16小节获取更多关于函数签名的信息。</p>
</div>
</div>
<span id="document-c09/p12_using_decorators_to_patch_class_definitions"></span><div class="section" id="id1">
<h3>9.12 使用装饰器扩充类的功能<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想通过反省或者重写类定义的某部分来修改它的行为，但是你又不希望使用继承或元类的方式。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这种情况可能是类装饰器最好的使用场景了。例如，下面是一个重写了特殊方法 <code class="docutils literal"><span class="pre">__getattribute__</span></code> 的类装饰器，
可以打印日志：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">log_getattribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="c1"># Get the original implementation</span>
    <span class="n">orig_getattribute</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__getattribute__</span>

    <span class="c1"># Make a new definition</span>
    <span class="k">def</span> <span class="nf">new_getattribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;getting:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orig_getattribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Attach to the class and return</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__getattribute__</span> <span class="o">=</span> <span class="n">new_getattribute</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="c1"># Example use</span>
<span class="nd">@log_getattribute</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>下面是使用效果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">getting: x</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">spam</span><span class="p">()</span>
<span class="go">getting: spam</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>类装饰器通常可以作为其他高级技术比如混入或元类的一种非常简洁的替代方案。
比如，上面示例中的另外一种实现使用到继承：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LoggedGetattribute</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;getting:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="c1"># Example:</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">LoggedGetattribute</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>这种方案也行得通，但是为了去理解它，你就必须知道方法调用顺序、<code class="docutils literal"><span class="pre">super()</span></code> 以及其它8.7小节介绍的继承知识。
某种程度上来讲，类装饰器方案就显得更加直观，并且它不会引入新的继承体系。它的运行速度也更快一些，
因为他并不依赖 <code class="docutils literal"><span class="pre">super()</span></code> 函数。</p>
<p>如果你系想在一个类上面使用多个类装饰器，那么就需要注意下顺序问题。
例如，一个装饰器A会将其装饰的方法完整替换成另一种实现，
而另一个装饰器B只是简单的在其装饰的方法中添加点额外逻辑。
那么这时候装饰器A就需要放在装饰器B的前面。</p>
<p>你还可以回顾一下8.13小节另外一个关于类装饰器的有用的例子。</p>
</div>
</div>
<span id="document-c09/p13_using_mataclass_to_control_instance_creation"></span><div class="section" id="id1">
<h3>9.13 使用元类控制实例的创建<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想通过改变实例创建方式来实现单例、缓存或其他类似的特性。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python程序员都知道，如果你定义了一个类，就能像函数一样的调用它来创建实例，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;Diana&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你想自定义这个步骤，你可以定义一个元类并自己实现 <code class="docutils literal"><span class="pre">__call__()</span></code> 方法。</p>
<p>为了演示，假设你不想任何人创建这个类的实例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NoInstances</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t instantiate directly&quot;</span><span class="p">)</span>

<span class="c1"># Example</span>
<span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">NoInstances</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">grok</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Spam.grok&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这样的话，用户只能调用这个类的静态方法，而不能使用通常的方法来创建它的实例。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Spam</span><span class="o">.</span><span class="n">grok</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">Spam.grok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;example1.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">7</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__call__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t instantiate directly&quot;</span><span class="p">)</span>
<span class="gr">TypeError</span>: <span class="n">Can&#39;t instantiate directly</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>现在，假如你想实现单例模式（只能创建唯一实例的类），实现起来也很简单：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Singleton</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__instance</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__instance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__instance</span>

<span class="c1"># Example</span>
<span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Singleton</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Creating Spam&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>那么Spam类就只能创建唯一的实例了，演示如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="go">Creating Spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">c</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后，假设你想创建8.25小节中那样的缓存实例。下面我们可以通过元类来实现：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">weakref</span>

<span class="k">class</span> <span class="nc">Cached</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="n">args</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">return</span> <span class="n">obj</span>

<span class="c1"># Example</span>
<span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Cached</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Creating Spam({!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>然后我也来测试一下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="go">Creating Spam(&#39;Guido&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;Diana&#39;</span><span class="p">)</span>
<span class="go">Creating Spam(&#39;Diana&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span> <span class="c1"># Cached</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">c</span> <span class="c1"># Cached value returned</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>利用元类实现多种实例创建模式通常要比不使用元类的方式优雅得多。</p>
<p>假设你不使用元类，你可能需要将类隐藏在某些工厂函数后面。
比如为了实现一个单例，你你可能会像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_Spam</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Creating Spam&#39;</span><span class="p">)</span>

<span class="n">_spam_instance</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">Spam</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">_spam_instance</span>

    <span class="k">if</span> <span class="n">_spam_instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_spam_instance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_spam_instance</span> <span class="o">=</span> <span class="n">_Spam</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">_spam_instance</span>
</pre></div>
</div>
<p>尽管使用元类可能会涉及到比较高级点的技术，但是它的代码看起来会更加简洁舒服，而且也更加直观。</p>
<p>更多关于创建缓存实例、弱引用等内容，请参考8.25小节。</p>
</div>
</div>
<span id="document-c09/p14_capture_class_attribute_definition_order"></span><div class="section" id="id1">
<h3>9.14 捕获类的属性定义顺序<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想自动记录一个类中属性和方法定义的顺序，
然后可以利用它来做很多操作（比如序列化、映射到数据库等等）。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>利用元类可以很容易的捕获类的定义信息。下面是一个例子，使用了一个OrderedDict来记录描述器的定义顺序：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="c1"># A set of descriptors for various types</span>
<span class="k">class</span> <span class="nc">Typed</span><span class="p">:</span>
    <span class="n">_expected_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expected_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expected_type</span><span class="p">))</span>
        <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">Integer</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">_expected_type</span> <span class="o">=</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Float</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">_expected_type</span> <span class="o">=</span> <span class="nb">float</span>

<span class="k">class</span> <span class="nc">String</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">_expected_type</span> <span class="o">=</span> <span class="nb">str</span>

<span class="c1"># Metaclass that uses an OrderedDict for class body</span>
<span class="k">class</span> <span class="nc">OrderedMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">clsdict</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">clsdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Typed</span><span class="p">):</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">()</span>
</pre></div>
</div>
<p>在这个元类中，执行类主体时描述器的定义顺序会被一个 <code class="docutils literal"><span class="pre">OrderedDict``捕获到，</span>
<span class="pre">生成的有序名称从字典中提取出来并放入类属性</span> <span class="pre">``_order</span></code> 中。这样的话类中的方法可以通过多种方式来使用它。
例如，下面是一个简单的类，使用这个排序字典来实现将一个类实例的数据序列化为一行CSV数据：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Structure</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">OrderedMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">as_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">)</span>

<span class="c1"># Example use</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="p">()</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">Float</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
</pre></div>
</div>
<p>我们在交互式环境中测试一下这个Stock类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;GOOG&#39;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mf">490.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;GOOG&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">as_csv</span><span class="p">()</span>
<span class="go">&#39;GOOG,100,490.1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;AAPL&#39;</span><span class="p">,</span><span class="s1">&#39;a lot&#39;</span><span class="p">,</span> <span class="mf">610.23</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;dupmethod.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">34</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__init__</span>
<span class="gr">TypeError</span>: <span class="n">shares expects &lt;class &#39;int&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本节一个关键点就是OrderedMeta元类中定义的 `` __prepare__()`` 方法。
这个方法会在开始定义类和它的父类的时候被执行。它必须返回一个映射对象以便在类定义体中被使用到。
我们这里通过返回了一个OrderedDict而不是一个普通的字典，可以很容易的捕获定义的顺序。</p>
<p>如果你想构造自己的类字典对象，可以很容易的扩展这个功能。比如，下面的这个修改方案可以防止重复的定义：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="k">class</span> <span class="nc">NoDupOrderedDict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clsname</span> <span class="o">=</span> <span class="n">clsname</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;{} already defined in {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clsname</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OrderedMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">clsdict</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">clsdict</span> <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NoDupOrderedDict</span><span class="p">(</span><span class="n">clsname</span><span class="p">)</span>
</pre></div>
</div>
<p>下面我们测试重复的定义会出现什么情况：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">OrderedMeta</span><span class="p">):</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span><span class="k">pass</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span><span class="k">pass</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">A</span>
    <span class="n">File</span> <span class="s2">&quot;dupmethod2.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">25</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__setitem__</span>
        <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clsname</span><span class="p">))</span>
<span class="gr">TypeError</span>: <span class="n">spam already defined in A</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后还有一点很重要，就是在 <code class="docutils literal"><span class="pre">__new__()</span></code> 方法中对于元类中被修改字典的处理。
尽管类使用了另外一个字典来定义，在构造最终的 <code class="docutils literal"><span class="pre">class</span></code> 对象的时候，
我们仍然需要将这个字典转换为一个正确的 <code class="docutils literal"><span class="pre">dict</span></code> 实例。
通过语句 <code class="docutils literal"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">dict(clsdict)</span></code> 来完成这个效果。</p>
<p>对于很多应用程序而已，能够捕获类定义的顺序是一个看似不起眼却又非常重要的特性。
例如，在对象关系映射中，我们通常会看到下面这种方式定义的类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="p">()</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">Float</span><span class="p">()</span>
</pre></div>
</div>
<p>在框架底层，我们必须捕获定义的顺序来将对象映射到元组或数据库表中的行（就类似于上面例子中的 <code class="docutils literal"><span class="pre">as_csv()</span></code> 的功能）。
这节演示的技术非常简单，并且通常会比其他类似方法（通常都要在描述器类中维护一个隐藏的计数器）要简单的多。</p>
</div>
</div>
<span id="document-c09/p15_define_metaclass_that_takes_optional_arguments"></span><div class="section" id="id1">
<h3>9.15 定义有可选参数的元类<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想定义一个元类，允许类定义时提供可选参数，这样可以控制或配置类型的创建过程。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在定义类的时候，Python允许我们使用 <a href="#id4"><span class="problematic" id="id5">``</span></a>metaclass``关键字参数来指定特定的元类。
例如使用抽象基类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="k">class</span> <span class="nc">IStream</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>然而，在自定义元类中我们还可以提供其他的关键字参数，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MyMeta</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">synchronize</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>为了使元类支持这些关键字参数，你必须确保在 <code class="docutils literal"><span class="pre">__prepare__()</span></code> , <code class="docutils literal"><span class="pre">__new__()</span></code> 和 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法中
都使用强制关键字参数。就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="c1"># Optional</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">synchronize</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c1"># Custom processing</span>
        <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__prepare__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span>

    <span class="c1"># Required</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">synchronize</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c1"># Custom processing</span>
        <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>

    <span class="c1"># Required</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">synchronize</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c1"># Custom processing</span>
        <span class="k">pass</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>讨论<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>给一个元类添加可选关键字参数需要你完全弄懂类创建的所有步骤，
因为这些参数会被传递给每一个相关的方法。
<code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法在所有类定义开始执行前首先被调用，用来创建类命名空间。
通常来讲，这个方法只是简单的返回一个字典或其他映射对象。
<code class="docutils literal"><span class="pre">__new__()</span></code> 方法被用来实例化最终的类对象。它在类的主体被执行完后开始执行。
<code class="docutils literal"><span class="pre">__init__()</span></code> 方法最后被调用，用来执行其他的一些初始化工作。</p>
<p>当我们构造元类的时候，通常只需要定义一个 <code class="docutils literal"><span class="pre">__new__()</span></code> 或 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法，但不是两个都定义。
但是，如果需要接受其他的关键字参数的话，这两个方法就要同时提供，并且都要提供对应的参数签名。
默认的 <code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法接受任意的关键字参数，但是会忽略它们，
所以只有当这些额外的参数可能会影响到类命名空间的创建时你才需要去定义 <code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法。</p>
<p>通过使用强制关键字参数，在类的创建过程中我们必须通过关键字来指定这些参数。</p>
<p>使用关键字参数配置一个元类还可以视作对类变量的一种替代方式。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MyMeta</span><span class="p">):</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">synchronize</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>将这些属性定义为参数的好处在于它们不会污染类的名称空间，
这些属性仅仅只从属于类的创建阶段，而不是类中的语句执行阶段。
另外，它们在 <code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法中是可以被访问的，因为这个方法会在所有类主体执行前被执行。
但是类变量只能在元类的 <code class="docutils literal"><span class="pre">__new__()</span></code> 和 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法中可见。</p>
</div>
</div>
<span id="document-c09/p16_enforce_argument_signature_on_args_kwargs"></span><div class="section" id="args-kwargs">
<h3>9.16 <a href="#id1"><span class="problematic" id="id2">*</span></a>args和**kwargs的强制参数签名<a class="headerlink" href="#args-kwargs" title="永久链接至标题">¶</a></h3>
<div class="section" id="id3">
<h4>问题<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>你有一个函数或方法，它使用*args和**kwargs作为参数，这样使得它比较通用，
但有时候你想检查传递进来的参数是不是某个你想要的类型。</p>
</div>
<div class="section" id="id4">
<h4>解决方案<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>对任何涉及到操作函数调用签名的问题，你都应该使用 <code class="docutils literal"><span class="pre">inspect</span></code> 模块中的签名特性。
我们最主要关注两个类：<code class="docutils literal"><span class="pre">Signature</span></code> 和 <code class="docutils literal"><span class="pre">Parameter</span></code> 。下面是一个创建函数前面的交互例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Make a signature for a func(x, y=42, *, z=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parms</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parms</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
<span class="go">(x, y=42, *, z=None)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一旦你有了一个签名对象，你就可以使用它的 <code class="docutils literal"><span class="pre">bind()</span></code> 方法很容易的将它绑定到 <code class="docutils literal"><span class="pre">*args</span></code> 和 <code class="docutils literal"><span class="pre">**kwargs</span></code> 上去。
下面是一个简单的演示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">bound_values</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bound_values</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Try various examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x 1</span>
<span class="go">y 2</span>
<span class="go">z 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x 1</span>
<span class="go">z 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x 1</span>
<span class="go">y 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/inspect.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1972</span><span class="p">,</span> <span class="ow">in</span> <span class="n">_bind</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;too many positional arguments&#39;</span><span class="p">)</span>
<span class="gr">TypeError</span>: <span class="n">too many positional arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/inspect.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1961</span><span class="p">,</span> <span class="ow">in</span> <span class="n">_bind</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
<span class="gr">TypeError</span>: <span class="n">&#39;x&#39; parameter lacking default value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
    <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/inspect.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1985</span><span class="p">,</span> <span class="ow">in</span> <span class="n">_bind</span>
        <span class="s1">&#39;{arg!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<span class="gr">TypeError</span>: <span class="n">multiple values for argument &#39;x&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以看出来，通过将签名和传递的参数绑定起来，可以强制函数调用遵循特定的规则，比如必填、默认、重复等等。</p>
<p>下面是一个强制函数签名更具体的例子。在代码中，我们在基类中先定义了一个非常通用的 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法，
然后我们强制所有的子类必须提供一个特定的参数签名。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Parameter</span>

<span class="k">def</span> <span class="nf">make_sig</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">):</span>
    <span class="n">parms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parms</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Structure</span><span class="p">:</span>
    <span class="n">__signature__</span> <span class="o">=</span> <span class="n">make_sig</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bound_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bound_values</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c1"># Example use</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">__signature__</span> <span class="o">=</span> <span class="n">make_sig</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">__signature__</span> <span class="o">=</span> <span class="n">make_sig</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是使用这个 <code class="docutils literal"><span class="pre">Stock</span></code> 类的示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">Stock</span><span class="p">))</span>
<span class="go">(name, shares, price)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">490.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;price&#39; parameter lacking default value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">490.1</span><span class="p">,</span> <span class="n">shares</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">multiple values for argument &#39;shares&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>讨论<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>在我们需要构建通用函数库、编写装饰器或实现代理的时候，对于 <code class="docutils literal"><span class="pre">*args</span></code> 和 <code class="docutils literal"><span class="pre">**kwargs</span></code> 的使用是很普遍的。
但是，这样的函数有一个缺点就是当你想要实现自己的参数检验时，代码就会笨拙混乱。在8.11小节里面有这样一个例子。
这时候我们可以通过一个签名对象来简化它。</p>
<p>在最后的一个方案实例中，我们还可以通过使用自定义元类来创建签名对象。下面演示怎样来实现：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Parameter</span>

<span class="k">def</span> <span class="nf">make_sig</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">):</span>
    <span class="n">parms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parms</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StructureMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">clsdict</span><span class="p">[</span><span class="s1">&#39;__signature__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_sig</span><span class="p">(</span><span class="o">*</span><span class="n">clsdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_fields&#39;</span><span class="p">,[]))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Structure</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">StructureMeta</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bound_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bound_values</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c1"># Example</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>当我们自定义签名的时候，将签名存储在特定的属性 <code class="docutils literal"><span class="pre">__signature__</span></code> 中通常是很有用的。
这样的话，在使用 <code class="docutils literal"><span class="pre">inspect</span></code> 模块执行内省的代码就能发现签名并将它作为调用约定。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">Stock</span><span class="p">))</span>
<span class="go">(name, shares, price)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">Point</span><span class="p">))</span>
<span class="go">(x, y)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c09/p17_enforce_coding_conventions_in_classes"></span><div class="section" id="id1">
<h3>9.17 在类上强制使用编程规约<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序包含一个很大的类继承体系，你希望强制执行某些编程规约（或者代码诊断）来帮助程序员保持清醒。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想监控类的定义，通常可以通过定义一个元类。一个基本元类通常是继承自 <code class="docutils literal"><span class="pre">type</span></code> 并重定义它的 <code class="docutils literal"><span class="pre">__new__()</span></code> 方法
或者是 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="c1"># clsname is name of class being defined</span>
        <span class="c1"># bases is tuple of base classes</span>
        <span class="c1"># clsdict is class dictionary</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>
</pre></div>
</div>
<p>另一种是，定义 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>
        <span class="c1"># clsname is name of class being defined</span>
        <span class="c1"># bases is tuple of base classes</span>
        <span class="c1"># clsdict is class dictionary</span>
</pre></div>
</div>
<p>为了使用这个元类，你通常要将它放到到一个顶级父类定义中，然后其他的类继承这个顶级父类。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Root</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MyMeta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Root</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Root</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>元类的一个关键特点是它允许你在定义的时候检查类的内容。在重新定义 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法中，
你可以很轻松的检查类字典、父类等等。并且，一旦某个元类被指定给了某个类，那么就会被继承到所有子类中去。
因此，一个框架的构建者就能在大型的继承体系中通过给一个顶级父类指定一个元类去捕获所有下面子类的定义。</p>
<p>作为一个具体的应用例子，下面定义了一个元类，它会拒绝任何有混合大小写名字作为方法的类定义（可能是想气死Java程序员^_^）：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NoMixedCaseMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">clsdict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Bad attribute name: &#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Root</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">NoMixedCaseMeta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Root</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">foo_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># Ok</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Root</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fooBar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># TypeError</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>作为更高级和实用的例子，下面有一个元类，它用来检测重载方法，确保它的调用参数跟父类中原始方法有着相同的参数签名。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">class</span> <span class="nc">MatchSignaturesMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>
        <span class="n">sup</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">clsdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># Get the previous definition (if any) and compare the signatures</span>
            <span class="n">prev_dfn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sup</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prev_dfn</span><span class="p">:</span>
                <span class="n">prev_sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">prev_dfn</span><span class="p">)</span>
                <span class="n">val_sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prev_sig</span> <span class="o">!=</span> <span class="n">val_sig</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Signature mismatch in </span><span class="si">%s</span><span class="s1">. </span><span class="si">%s</span><span class="s1"> != </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                                    <span class="n">value</span><span class="o">.</span><span class="n">__qualname__</span><span class="p">,</span> <span class="n">prev_sig</span><span class="p">,</span> <span class="n">val_sig</span><span class="p">)</span>

<span class="c1"># Example</span>
<span class="k">class</span> <span class="nc">Root</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MatchSignaturesMeta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Root</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="c1"># Class with redefined methods, but slightly different signatures</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>如果你运行这段代码，就会得到下面这样的输出结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">WARNING</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Signature</span> <span class="n">mismatch</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">spam</span><span class="o">.</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">WARNING</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Signature</span> <span class="n">mismatch</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">foo</span><span class="o">.</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>这种警告信息对于捕获一些微妙的程序bug是很有用的。例如，如果某个代码依赖于传递给方法的关键字参数，
那么当子类改变参数名字的时候就会调用出错。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在大型面向对象的程序中，通常将类的定义放在元类中控制是很有用的。
元类可以监控类的定义，警告编程人员某些没有注意到的可能出现的问题。</p>
<p>有人可能会说，像这样的错误可以通过程序分析工具或IDE去做会更好些。诚然，这些工具是很有用。
但是，如果你在构建一个框架或函数库供其他人使用，那么你没办法去控制使用者要使用什么工具。
因此，对于这种类型的程序，如果可以在元类中做检测或许可以带来更好的用户体验。</p>
<p>在元类中选择重新定义 <code class="docutils literal"><span class="pre">__new__()</span></code> 方法还是 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法取决于你想怎样使用结果类。
<code class="docutils literal"><span class="pre">__new__()</span></code> 方法在类创建之前被调用，通常用于通过某种方式（比如通过改变类字典的内容）修改类的定义。
而 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法是在类被创建之后被调用，当你需要完整构建类对象的时候会很有用。
在最后一个例子中，这是必要的，因为它使用了 <code class="docutils literal"><span class="pre">super()</span></code> 函数来搜索之前的定义。
它只能在类的实例被创建之后，并且相应的方法解析顺序也已经被设置好了。</p>
<p>最后一个例子还演示了Python的函数签名对象的使用。
实际上，元类将每个可调用定义放在一个类中，搜索前一个定义（如果有的话），
然后通过使用 <code class="docutils literal"><span class="pre">inspect.signature()</span></code> 来简单的比较它们的调用签名。</p>
<p>最后一点，代码中有一行使用了 <code class="docutils literal"><span class="pre">super(self,</span> <span class="pre">self)</span></code> 并不是排版错误。
当使用元类的时候，我们要时刻记住一点就是 <code class="docutils literal"><span class="pre">self</span></code> 实际上是一个类对象。
因此，这条语句其实就是用来寻找位于继承体系中构建 <code class="docutils literal"><span class="pre">self</span></code> 父类的定义。</p>
</div>
</div>
<span id="document-c09/p18_define_classes_programmatically"></span><div class="section" id="id1">
<h3>9.18 以编程方式定义类<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你在写一段代码，最终需要创建一个新的类对象。你考虑将类的定义源代码以字符串的形式发布出去。
并且使用函数比如 <code class="docutils literal"><span class="pre">exec()</span></code> 来执行它，但是你想寻找一个更加优雅的解决方案。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>你可以使用函数 <code class="docutils literal"><span class="pre">types.new_class()</span></code> 来初始化新的类对象。
你需要做的只是提供类的名字、父类元组、关键字参数，以及一个用成员变量填充类字典的回调函数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># stock.py</span>
<span class="c1"># Example of making a class manually from parts</span>

<span class="c1"># Methods</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
<span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">price</span>

<span class="n">cls_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;__init__&#39;</span> <span class="p">:</span> <span class="fm">__init__</span><span class="p">,</span>
    <span class="s1">&#39;cost&#39;</span> <span class="p">:</span> <span class="n">cost</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># Make a class</span>
<span class="kn">import</span> <span class="nn">types</span>

<span class="n">Stock</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">new_class</span><span class="p">(</span><span class="s1">&#39;Stock&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{},</span> <span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cls_dict</span><span class="p">))</span>
<span class="n">Stock</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__name__</span>
</pre></div>
</div>
<p>这种方式会构建一个普通的类对象，并且按照你的期望工作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;stock.Stock object at 0x1006a9b10&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cost</span><span class="p">()</span>
<span class="go">4555.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种方法中，一个比较难理解的地方是在调用完 <code class="docutils literal"><span class="pre">types.new_class()</span></code> 对 <code class="docutils literal"><span class="pre">Stock.__module__</span></code> 的赋值。
每次当一个类被定义后，它的 <code class="docutils literal"><span class="pre">__module__</span></code> 属性包含定义它的模块名。
这个名字用于生成 <code class="docutils literal"><span class="pre">__repr__()</span></code> 方法的输出。它同样也被用于很多库，比如 <code class="docutils literal"><span class="pre">pickle</span></code> 。
因此，为了让你创建的类是“正确”的，你需要确保这个属性也设置正确了。</p>
<p>如果你想创建的类需要一个不同的元类，可以通过 <code class="docutils literal"><span class="pre">types.new_class()</span></code> 第三个参数传递给它。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">abc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Stock</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">new_class</span><span class="p">(</span><span class="s1">&#39;Stock&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s1">&#39;metaclass&#39;</span><span class="p">:</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">},</span>
<span class="gp">... </span>                        <span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cls_dict</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Stock</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__name__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Stock</span>
<span class="go">&lt;class &#39;__main__.Stock&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Stock</span><span class="p">)</span>
<span class="go">&lt;class &#39;abc.ABCMeta&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>第三个参数还可以包含其他的关键字参数。比如，一个类的定义如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">Base</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">typecheck</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>那么可以将其翻译成如下的 <code class="docutils literal"><span class="pre">new_class()</span></code> 调用形式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Spam</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">new_class</span><span class="p">(</span><span class="s1">&#39;Spam&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">Base</span><span class="p">,),</span>
                        <span class="p">{</span><span class="s1">&#39;debug&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s1">&#39;typecheck&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span>
                        <span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cls_dict</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">new_class()</span></code> 第四个参数最神秘，它是一个用来接受类命名空间的映射对象的函数。
通常这是一个普通的字典，但是它实际上是 <code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法返回的任意对象，这个在9.14小节已经介绍过了。
这个函数需要使用上面演示的 <code class="docutils literal"><span class="pre">update()</span></code> 方法给命名空间增加内容。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>很多时候如果能构造新的类对象是很有用的。
有个很熟悉的例子是调用 <code class="docutils literal"><span class="pre">collections.namedtuple()</span></code> 函数，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Stock</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Stock&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Stock</span>
<span class="go">&lt;class &#39;__main__.Stock&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">namedtuple()</span></code> 使用 <code class="docutils literal"><span class="pre">exec()</span></code> 而不是上面介绍的技术。但是，下面通过一个简单的变化，
我们直接创建一个类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">named_tuple</span><span class="p">(</span><span class="n">classname</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">):</span>
    <span class="c1"># Populate a dictionary of field property accessors</span>
    <span class="n">cls_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="nb">property</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fieldnames</span><span class="p">)</span> <span class="p">}</span>

    <span class="c1"># Make a __new__ function and add to the class dict</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fieldnames</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected {} arguments&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fieldnames</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="n">cls_dict</span><span class="p">[</span><span class="s1">&#39;__new__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="fm">__new__</span>

    <span class="c1"># Make the class</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">new_class</span><span class="p">(</span><span class="n">classname</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,),</span> <span class="p">{},</span>
                        <span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cls_dict</span><span class="p">))</span>

    <span class="c1"># Set the module to that of the caller</span>
    <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f_globals</span><span class="p">[</span><span class="s1">&#39;__name__&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">cls</span>
</pre></div>
</div>
<p>这段代码的最后部分使用了一个所谓的&#8221;框架魔法&#8221;，通过调用 <code class="docutils literal"><span class="pre">sys._getframe()</span></code> 来获取调用者的模块名。
另外一个框架魔法例子在2.15小节中有介绍过。</p>
<p>下面的例子演示了前面的代码是如何工作的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Point</span> <span class="o">=</span> <span class="n">named_tuple</span><span class="p">(</span><span class="s1">&#39;Point&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point</span>
<span class="go">&lt;class &#39;__main__.Point&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">x</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">y</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">can&#39;t set attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">p</span><span class="p">)</span>
<span class="go">4 5</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这项技术一个很重要的方面是它对于元类的正确使用。
你可能像通过直接实例化一个元类来直接创建一个类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Stock</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;Stock&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="n">cls_dict</span><span class="p">)</span>
</pre></div>
</div>
<p>这种方法的问题在于它忽略了一些关键步骤，比如对于元类中 <code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法的调用。
通过使用 <code class="docutils literal"><span class="pre">types.new_class()</span></code> ，你可以保证所有的必要初始化步骤都能得到执行。
比如，<code class="docutils literal"><span class="pre">types.new_class()</span></code> 第四个参数的回调函数接受 <code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法返回的映射对象。</p>
<p>如果你仅仅只是想执行准备步骤，可以使用 <code class="docutils literal"><span class="pre">types.prepare_class()</span></code> 。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>
<span class="n">metaclass</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">prepare_class</span><span class="p">(</span><span class="s1">&#39;Stock&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s1">&#39;metaclass&#39;</span><span class="p">:</span> <span class="nb">type</span><span class="p">})</span>
</pre></div>
</div>
<p>它会查找合适的元类并调用它的 <code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法。
然后这个元类保存它的关键字参数，准备命名空间后被返回。</p>
<p>更多信息, 请参考 <a class="reference external" href="https://www.python.org/dev/peps/pep-3115/">PEP 3115</a> ,
以及 <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#metaclasses">Python documentation</a> .</p>
</div>
</div>
<span id="document-c09/p19_initializing_class_members_at_definition_time"></span><div class="section" id="id1">
<h3>9.19 在定义的时候初始化类的成员<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在类被定义的时候就初始化一部分类的成员，而不是要等到实例被创建后。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在类定义时就执行初始化或设置操作是元类的一个典型应用场景。本质上讲，一个元类会在定义时被触发，
这时候你可以执行一些额外的操作。</p>
<p>下面是一个例子，利用这个思路来创建类似于 <code class="docutils literal"><span class="pre">collections</span></code> 模块中的命名元组的类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">operator</span>

<span class="k">class</span> <span class="nc">StructTupleMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_fields</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

<span class="k">class</span> <span class="nc">StructTuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">StructTupleMeta</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_fields</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;{} arguments required&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_fields</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>这段代码可以用来定义简单的基于元组的数据结构，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">StructTuple</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shares&#39;</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">StructTuple</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>下面演示它如何工作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">(&#39;ACME&#39;, 50, 91.1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;ACME&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;ACME&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">shares</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">price</span>
<span class="go">4555.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="mi">23</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">can&#39;t set attribute</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这一小节中，类 <code class="docutils literal"><span class="pre">StructTupleMeta</span></code> 获取到类属性 <code class="docutils literal"><span class="pre">_fields</span></code> 中的属性名字列表，
然后将它们转换成相应的可访问特定元组槽的方法。函数 <code class="docutils literal"><span class="pre">operator.itemgetter()</span></code> 创建一个访问器函数，
然后 <code class="docutils literal"><span class="pre">property()</span></code> 函数将其转换成一个属性。</p>
<p>本节最难懂的部分是知道不同的初始化步骤是什么时候发生的。
<code class="docutils literal"><span class="pre">StructTupleMeta</span></code> 中的 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法只在每个类被定义时被调用一次。
<code class="docutils literal"><span class="pre">cls</span></code> 参数就是那个被定义的类。实际上，上述代码使用了 <code class="docutils literal"><span class="pre">_fields</span></code> 类变量来保存新的被定义的类，
然后给它再添加一点新的东西。</p>
<p><code class="docutils literal"><span class="pre">StructTuple</span></code> 类作为一个普通的基类，供其他使用者来继承。
这个类中的 <code class="docutils literal"><span class="pre">__new__()</span></code> 方法用来构造新的实例。
这里使用 <code class="docutils literal"><span class="pre">__new__()</span></code> 并不是很常见，主要是因为我们要修改元组的调用签名，
使得我们可以像普通的实例调用那样创建实例。就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span> <span class="c1"># OK</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">((</span><span class="s1">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">))</span> <span class="c1"># Error</span>
</pre></div>
</div>
<p>跟 <code class="docutils literal"><span class="pre">__init__()</span></code> 不同的是，<code class="docutils literal"><span class="pre">__new__()</span></code> 方法在实例被创建之前被触发。
由于元组是不可修改的，所以一旦它们被创建了就不可能对它做任何改变。而 <code class="docutils literal"><span class="pre">__init__()</span></code> 会在实例创建的最后被触发，
这样的话我们就可以做我们想做的了。这也是为什么 <code class="docutils literal"><span class="pre">__new__()</span></code> 方法已经被定义了。</p>
<p>尽管本节很短，还是需要你能仔细研读，深入思考Python类是如何被定义的，实例是如何被创建的，
还有就是元类和类的各个不同的方法究竟在什么时候被调用。</p>
<p><a class="reference external" href="http://www.python.org/dev/peps/pep-0422">PEP 422</a>
提供了一个解决本节问题的另外一种方法。
但是，截止到我写这本书的时候，它还没被采纳和接受。
尽管如此，如果你使用的是Python 3.3或更高的版本，那么还是值得去看一下的。</p>
</div>
</div>
<span id="document-c09/p20_implement_multiple_dispatch_with_function_annotations"></span><div class="section" id="id1">
<h3>9.20 利用函数注解实现方法重载<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你已经学过怎样使用函数参数注解，那么你可能会想利用它来实现基于类型的方法重载。
但是你不确定应该怎样去实现（或者到底行得通不）。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>本小节的技术是基于一个简单的技术，那就是Python允许参数注解，代码可以像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Bar 1:&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Bar 2:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Prints Bar 1: 2 3</span>
<span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span> <span class="c1"># Prints Bar 2: hello 0</span>
</pre></div>
</div>
<p>下面是我们第一步的尝试，使用到了一个元类和描述器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># multiple.py</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">types</span>

<span class="k">class</span> <span class="nc">MultiMethod</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Represents a single multimethod.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Register a new method as a multimethod</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>

        <span class="c1"># Build a type signature from the method&#39;s annotations</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">parm</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;self&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">parm</span><span class="o">.</span><span class="n">annotation</span> <span class="ow">is</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;Argument {} must be annotated with a type&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parm</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;Argument {} annotation must be a type&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">parm</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">types</span><span class="p">)]</span> <span class="o">=</span> <span class="n">meth</span>
            <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parm</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">types</span><span class="p">)]</span> <span class="o">=</span> <span class="n">meth</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Call a method based on type signature of the arguments</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;No matching method for types {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">types</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Descriptor method needed to make calls work in a class</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">MultiDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Special dictionary to build multimethods in a metaclass</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># If key already exists, it must be a multimethod or callable</span>
            <span class="n">current_value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_value</span><span class="p">,</span> <span class="n">MultiMethod</span><span class="p">):</span>
                <span class="n">current_value</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mvalue</span> <span class="o">=</span> <span class="n">MultiMethod</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">mvalue</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">current_value</span><span class="p">)</span>
                <span class="n">mvalue</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mvalue</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MultipleMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Metaclass that allows multiple dispatch of methods</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">clsdict</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MultiDict</span><span class="p">()</span>
</pre></div>
</div>
<p>为了使用这个类，你可以像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MultipleMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Bar 1:&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Bar 2:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="c1"># Example: overloaded __init__</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Date</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MultipleMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">month</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">day</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span> <span class="n">day</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">tm_year</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_mon</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_mday</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是一个交互示例来验证它能正确的工作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Bar 1: 2 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">Bar 2: hello 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Bar 2: hello 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;multiple.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">42</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__call__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;No matching method for types {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">types</span><span class="p">))</span>
<span class="gr">TypeError</span>: <span class="n">No matching method for types (&lt;class &#39;int&#39;&gt;, &lt;class &#39;str&#39;&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Overloaded __init__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Date</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get today&#39;s date</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Date</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">year</span>
<span class="go">2012</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">month</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">day</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>坦白来讲，相对于通常的代码而已本节使用到了很多的魔法代码。
但是，它却能让我们深入理解元类和描述器的底层工作原理，
并能加深对这些概念的印象。因此，就算你并不会立即去应用本节的技术，
它的一些底层思想却会影响到其它涉及到元类、描述器和函数注解的编程技术。</p>
<p>本节的实现中的主要思路其实是很简单的。<code class="docutils literal"><span class="pre">MutipleMeta</span></code> 元类使用它的 <code class="docutils literal"><span class="pre">__prepare__()</span></code> 方法
来提供一个作为 <code class="docutils literal"><span class="pre">MultiDict</span></code> 实例的自定义字典。这个跟普通字典不一样的是，
<code class="docutils literal"><span class="pre">MultiDict</span></code> 会在元素被设置的时候检查是否已经存在，如果存在的话，重复的元素会在 <code class="docutils literal"><span class="pre">MultiMethod</span></code>
实例中合并。</p>
<p><code class="docutils literal"><span class="pre">MultiMethod</span></code> 实例通过构建从类型签名到函数的映射来收集方法。
在这个构建过程中，函数注解被用来收集这些签名然后构建这个映射。
这个过程在 <code class="docutils literal"><span class="pre">MultiMethod.register()</span></code> 方法中实现。
这种映射的一个关键特点是对于多个方法，所有参数类型都必须要指定，否则就会报错。</p>
<p>为了让 <code class="docutils literal"><span class="pre">MultiMethod</span></code> 实例模拟一个调用，它的 <code class="docutils literal"><span class="pre">__call__()</span></code> 方法被实现了。
这个方法从所有排除 <code class="docutils literal"><span class="pre">slef</span></code> 的参数中构建一个类型元组，在内部map中查找这个方法，
然后调用相应的方法。为了能让 <code class="docutils literal"><span class="pre">MultiMethod</span></code> 实例在类定义时正确操作，<code class="docutils literal"><span class="pre">__get__()</span></code> 是必须得实现的。
它被用来构建正确的绑定方法。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">bar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&lt;bound method Spam.bar of &lt;__main__.Spam object at 0x1006a46d0&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="vm">__self__</span>
<span class="go">&lt;__main__.Spam object at 0x1006a46d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="vm">__func__</span>
<span class="go">&lt;__main__.MultiMethod object at 0x1006a4d50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Bar 1: 2 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">Bar 2: hello 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>不过本节的实现还有一些限制，其中一个是它不能使用关键字参数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">__call__() got an unexpected keyword argument &#39;y&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">TypeError</span>: <span class="n">__call__() got an unexpected keyword argument &#39;s&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>也许有其他的方法能添加这种支持，但是它需要一个完全不同的方法映射方式。
问题在于关键字参数的出现是没有顺序的。当它跟位置参数混合使用时，
那你的参数就会变得比较混乱了，这时候你不得不在 <code class="docutils literal"><span class="pre">__call__()</span></code> 方法中先去做个排序。</p>
<p>同样对于继承也是有限制的，例如，类似下面这种代码就不能正常工作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MultipleMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">A</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Foo 1:&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">C</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Foo 2:&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>原因是因为 <code class="docutils literal"><span class="pre">x:A</span></code> 注解不能成功匹配子类实例（比如B的实例），如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Foo 1: &lt;__main__.A object at 0x1006a5310&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">Foo 2: &lt;__main__.C object at 0x1007a1910&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;multiple.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">44</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__call__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;No matching method for types {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">types</span><span class="p">))</span>
<span class="gr">TypeError</span>: <span class="n">No matching method for types (&lt;class &#39;__main__.B&#39;&gt;,)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>作为使用元类和注解的一种替代方案，可以通过描述器来实现类似的效果。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>

<span class="k">class</span> <span class="nc">multimethod</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">types</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">ndefaults</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">)</span> <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndefaults</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="p">[</span><span class="n">types</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="n">func</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">register</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>为了使用描述器版本，你需要像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="nd">@multimethod</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># Default method called if no match</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;No matching method for bar&#39;</span><span class="p">)</span>

    <span class="nd">@bar.match</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Bar 1:&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="nd">@bar.match</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Bar 2:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>描述器方案同样也有前面提到的限制（不支持关键字参数和继承）。</p>
<p>所有事物都是平等的，有好有坏，也许最好的办法就是在普通代码中避免使用方法重载。
不过有些特殊情况下还是有意义的，比如基于模式匹配的方法重载程序中。
举个例子，8.21小节中的访问者模式可以修改为一个使用方法重载的类。
但是，除了这个以外，通常不应该使用方法重载（就简单的使用不同名称的方法就行了）。</p>
<p>在Python社区对于实现方法重载的讨论已经由来已久。
对于引发这个争论的原因，可以参考下Guido van Rossum的这篇博客：
<a class="reference external" href="http://www.artima.com/weblogs/viewpost.jsp?thread=101605">Five-Minute Multimethods in Python</a></p>
</div>
</div>
<span id="document-c09/p21_avoid_repetitive_property_methods"></span><div class="section" id="id1">
<h3>9.21 避免重复的属性方法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你在类中需要重复的定义一些执行相同逻辑的属性方法，比如进行类型检查，怎样去简化这些重复代码呢？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>考虑下一个简单的类，它的属性由属性方法包装：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="p">,</span><span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;name must be a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age</span>

    <span class="nd">@age.setter</span>
    <span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;age must be an int&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_age</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>可以看到，为了实现属性值的类型检查我们写了很多的重复代码。
只要你以后看到类似这样的代码，你都应该想办法去简化它。
一个可行的方法是创建一个函数用来定义属性并返回它。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">typed_property</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">):</span>
    <span class="n">storage_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage_name</span><span class="p">)</span>

    <span class="nd">@prop.setter</span>
    <span class="k">def</span> <span class="nf">prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;{} must be a {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">))</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">prop</span>

<span class="c1"># Example use</span>
<span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">typed_property</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">typed_property</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本节我们演示内部函数或者闭包的一个重要特性，它们很像一个宏。例子中的函数 <code class="docutils literal"><span class="pre">typed_property()</span></code>
看上去有点难理解，其实它所做的仅仅就是为你生成属性并返回这个属性对象。
因此，当在一个类中使用它的时候，效果跟将它里面的代码放到类定义中去是一样的。
尽管属性的 <code class="docutils literal"><span class="pre">getter</span></code> 和 <code class="docutils literal"><span class="pre">setter</span></code> 方法访问了本地变量如 <code class="docutils literal"><span class="pre">name</span></code> , <code class="docutils literal"><span class="pre">expected_type</span></code>
以及 <code class="docutils literal"><span class="pre">storate_name</span></code> ，这个很正常，这些变量的值会保存在闭包当中。</p>
<p>我们还可以使用 <code class="docutils literal"><span class="pre">functools.partial()</span></code> 来稍稍改变下这个例子，很有趣。例如，你可以像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="n">String</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">typed_property</span><span class="p">,</span> <span class="n">expected_type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="n">Integer</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">typed_property</span><span class="p">,</span> <span class="n">expected_type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="c1"># Example:</span>
<span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
</pre></div>
</div>
<p>其实你可以发现，这里的代码跟8.13小节中的类型系统描述器代码有些相似。</p>
</div>
</div>
<span id="document-c09/p22_define_context_managers_the_easy_way"></span><div class="section" id="id1">
<h3>9.22 定义上下文管理器的简单方法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想自己去实现一个新的上下文管理器，以便使用with语句。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>实现一个新的上下文管理器的最简单的方法就是使用 <code class="docutils literal"><span class="pre">contexlib</span></code> 模块中的 <code class="docutils literal"><span class="pre">&#64;contextmanager</span></code> 装饰器。
下面是一个实现了代码块计时功能的上下文管理器例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">timethis</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{}: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>

<span class="c1"># Example use</span>
<span class="k">with</span> <span class="n">timethis</span><span class="p">(</span><span class="s1">&#39;counting&#39;</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">10000000</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>在函数 <code class="docutils literal"><span class="pre">timethis()</span></code> 中，<code class="docutils literal"><span class="pre">yield</span></code> 之前的代码会在上下文管理器中作为 <code class="docutils literal"><span class="pre">__enter__()</span></code> 方法执行，
所有在 <code class="docutils literal"><span class="pre">yield</span></code> 之后的代码会作为 <code class="docutils literal"><span class="pre">__exit__()</span></code> 方法执行。
如果出现了异常，异常会在yield语句那里抛出。</p>
<p>下面是一个更加高级一点的上下文管理器，实现了列表对象上的某种事务：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">list_transaction</span><span class="p">(</span><span class="n">orig_list</span><span class="p">):</span>
    <span class="n">working</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">orig_list</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">working</span>
    <span class="n">orig_list</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">working</span>
</pre></div>
</div>
<p>这段代码的作用是任何对列表的修改只有当所有代码运行完成并且不出现异常的情况下才会生效。
下面我们来演示一下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">list_transaction</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">as</span> <span class="n">working</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span>
<span class="go">[1, 2, 3, 4, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">list_transaction</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">as</span> <span class="n">working</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;oops&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">oops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span>
<span class="go">[1, 2, 3, 4, 5]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>通常情况下，如果要写一个上下文管理器，你需要定义一个类，里面包含一个 <code class="docutils literal"><span class="pre">__enter__()</span></code> 和一个
<code class="docutils literal"><span class="pre">__exit__()</span></code> 方法，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">timethis</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_ty</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{}: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
<p>尽管这个也不难写，但是相比较写一个简单的使用 <code class="docutils literal"><span class="pre">&#64;contextmanager</span></code> 注解的函数而言还是稍显乏味。</p>
<p><code class="docutils literal"><span class="pre">&#64;contextmanager</span></code> 应该仅仅用来写自包含的上下文管理函数。
如果你有一些对象(比如一个文件、网络连接或锁)，需要支持 <code class="docutils literal"><span class="pre">with</span></code> 语句，那么你就需要单独实现
<code class="docutils literal"><span class="pre">__enter__()</span></code> 方法和 <code class="docutils literal"><span class="pre">__exit__()</span></code> 方法。</p>
</div>
</div>
<span id="document-c09/p23_executing_code_with_local_side_effects"></span><div class="section" id="id1">
<h3>9.23 在局部变量域中执行代码<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在使用范围内执行某个代码片段，并且希望在执行后所有的结果都不可见。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了理解这个问题，先试试一个简单场景。首先，在全局命名空间内执行一个代码片段：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">exec</span><span class="p">(</span><span class="s1">&#39;b = a + 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">14</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然后，再在一个函数中执行同样的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
<span class="gp">... </span>    <span class="k">exec</span><span class="p">(</span><span class="s1">&#39;b = a + 1&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test</span>
<span class="gr">NameError</span>: <span class="n">global name &#39;b&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以看出，最后抛出了一个NameError异常，就跟在 <code class="docutils literal"><span class="pre">exec()</span></code> 语句从没执行过一样。
要是你想在后面的计算中使用到 <code class="docutils literal"><span class="pre">exec()</span></code> 执行结果的话就会有问题了。</p>
<p>为了修正这样的错误，你需要在调用 <code class="docutils literal"><span class="pre">exec()</span></code> 之前使用 <code class="docutils literal"><span class="pre">locals()</span></code> 函数来得到一个局部变量字典。
之后你就能从局部字典中获取修改过后的变量值了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
<span class="gp">... </span>    <span class="n">loc</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">exec</span><span class="p">(</span><span class="s1">&#39;b = a + 1&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
<span class="go">14</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>实际上对于 <code class="docutils literal"><span class="pre">exec()</span></code> 的正确使用是比较难的。大多数情况下当你要考虑使用 <code class="docutils literal"><span class="pre">exec()</span></code> 的时候，
还有另外更好的解决方案（比如装饰器、闭包、元类等等）。</p>
<p>然而，如果你仍然要使用 <code class="docutils literal"><span class="pre">exec()</span></code> ，本节列出了一些如何正确使用它的方法。
默认情况下，<code class="docutils literal"><span class="pre">exec()</span></code> 会在调用者局部和全局范围内执行代码。然而，在函数里面，
传递给 <code class="docutils literal"><span class="pre">exec()</span></code> 的局部范围是拷贝实际局部变量组成的一个字典。
因此，如果 <code class="docutils literal"><span class="pre">exec()</span></code> 如果执行了修改操作，这种修改后的结果对实际局部变量值是没有影响的。
下面是另外一个演示它的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">test1</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">exec</span><span class="p">(</span><span class="s1">&#39;x += 1&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test1</span><span class="p">()</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>上面代码里，当你调用 <code class="docutils literal"><span class="pre">locals()</span></code> 获取局部变量时，你获得的是传递给 <code class="docutils literal"><span class="pre">exec()</span></code> 的局部变量的一个拷贝。
通过在代码执行后审查这个字典的值，那就能获取修改后的值了。下面是一个演示例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">test2</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">loc</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;before:&#39;</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">exec</span><span class="p">(</span><span class="s1">&#39;x += 1&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;after:&#39;</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;x =&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test2</span><span class="p">()</span>
<span class="go">before: {&#39;x&#39;: 0}</span>
<span class="go">after: {&#39;loc&#39;: {...}, &#39;x&#39;: 1}</span>
<span class="go">x = 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>仔细观察最后一步的输出，除非你将 <code class="docutils literal"><span class="pre">loc</span></code> 中被修改后的值手动赋值给x，否则x变量值是不会变的。</p>
<p>在使用 <code class="docutils literal"><span class="pre">locals()</span></code> 的时候，你需要注意操作顺序。每次它被调用的时候，
<code class="docutils literal"><span class="pre">locals()</span></code> 会获取局部变量值中的值并覆盖字典中相应的变量。
请注意观察下下面这个试验的输出结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">test3</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">loc</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">exec</span><span class="p">(</span><span class="s1">&#39;x += 1&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">locals</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test3</span><span class="p">()</span>
<span class="go">{&#39;x&#39;: 0}</span>
<span class="go">{&#39;loc&#39;: {...}, &#39;x&#39;: 1}</span>
<span class="go">{&#39;loc&#39;: {...}, &#39;x&#39;: 0}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意最后一次调用 <code class="docutils literal"><span class="pre">locals()</span></code> 的时候x的值是如何被覆盖掉的。</p>
<p>作为 <code class="docutils literal"><span class="pre">locals()</span></code> 的一个替代方案，你可以使用你自己的字典，并将它传递给 <code class="docutils literal"><span class="pre">exec()</span></code> 。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">test4</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
<span class="gp">... </span>    <span class="n">loc</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;a&#39;</span> <span class="p">:</span> <span class="n">a</span> <span class="p">}</span>
<span class="gp">... </span>    <span class="n">glb</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
<span class="gp">... </span>    <span class="k">exec</span><span class="p">(</span><span class="s1">&#39;b = a + 1&#39;</span><span class="p">,</span> <span class="n">glb</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test4</span><span class="p">()</span>
<span class="go">14</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>大部分情况下，这种方式是使用 <code class="docutils literal"><span class="pre">exec()</span></code> 的最佳实践。
你只需要保证全局和局部字典在后面代码访问时已经被初始化。</p>
<p>还有一点，在使用 <code class="docutils literal"><span class="pre">exec()</span></code> 之前，你可能需要问下自己是否有其他更好的替代方案。
大多数情况下当你要考虑使用 <code class="docutils literal"><span class="pre">exec()</span></code> 的时候，
还有另外更好的解决方案，比如装饰器、闭包、元类，或其他一些元编程特性。</p>
</div>
</div>
<span id="document-c09/p24_parse_and_analyzing_python_source"></span><div class="section" id="python">
<h3>9.24 解析与分析Python源码<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想写解析并分析Python源代码的程序。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>大部分程序员知道Python能够计算或执行字符串形式的源代码。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;2 + 3*4 + x&#39;</span><span class="p">)</span>
<span class="go">56</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">exec</span><span class="p">(</span><span class="s1">&#39;for i in range(10): print(i)&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
<span class="go">7</span>
<span class="go">8</span>
<span class="go">9</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>尽管如此，<code class="docutils literal"><span class="pre">ast</span></code> 模块能被用来将Python源码编译成一个可被分析的抽象语法树（AST）。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ast</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ex</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2 + 3*4 + x&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;eval&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ex</span>
<span class="go">&lt;_ast.Expression object at 0x1007473d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="go">&quot;Expression(body=BinOp(left=BinOp(left=Num(n=2), op=Add(),</span>
<span class="go">right=BinOp(left=Num(n=3), op=Mult(), right=Num(n=4))), op=Add(),</span>
<span class="go">right=Name(id=&#39;x&#39;, ctx=Load())))&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">top</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;for i in range(10): print(i)&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;exec&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top</span>
<span class="go">&lt;_ast.Module object at 0x100747390&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
<span class="go">&quot;Module(body=[For(target=Name(id=&#39;i&#39;, ctx=Store()),</span>
<span class="go">iter=Call(func=Name(id=&#39;range&#39;, ctx=Load()), args=[Num(n=10)],</span>
<span class="go">keywords=[], starargs=None, kwargs=None),</span>
<span class="go">body=[Expr(value=Call(func=Name(id=&#39;print&#39;, ctx=Load()),</span>
<span class="go">args=[Name(id=&#39;i&#39;, ctx=Load())], keywords=[], starargs=None,</span>
<span class="go">kwargs=None))], orelse=[])])&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>分析源码树需要你自己更多的学习，它是由一系列AST节点组成的。
分析这些节点最简单的方法就是定义一个访问者类，实现很多 <code class="docutils literal"><span class="pre">visit_NodeName()</span></code> 方法，
<code class="docutils literal"><span class="pre">NodeName()</span></code> 匹配那些你感兴趣的节点。下面是这样一个类，记录了哪些名字被加载、存储和删除的信息。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ast</span>

<span class="k">class</span> <span class="nc">CodeAnalyzer</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Load</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Del</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleted</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

<span class="c1"># Sample usage</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># Some Python code</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    for i in range(10):</span>
<span class="s1">        print(i)</span>
<span class="s1">    del i</span>
<span class="s1">    &#39;&#39;&#39;</span>

    <span class="c1"># Parse into an AST</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;exec&#39;</span><span class="p">)</span>

    <span class="c1"># Feed the AST to analyze name usage</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">CodeAnalyzer</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Loaded:&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">loaded</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Stored:&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">stored</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Deleted:&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">deleted</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你运行这个程序，你会得到下面这样的输出：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Loaded</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="s1">&#39;print&#39;</span><span class="p">}</span>
<span class="n">Stored</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">}</span>
<span class="n">Deleted</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>最后，AST可以通过 <code class="docutils literal"><span class="pre">compile()</span></code> 函数来编译并执行。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">exec</span><span class="p">(</span><span class="nb">compile</span><span class="p">(</span><span class="n">top</span><span class="p">,</span><span class="s1">&#39;&lt;stdin&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">))</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
<span class="go">7</span>
<span class="go">8</span>
<span class="go">9</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>当你能够分析源代码并从中获取信息的时候，你就能写很多代码分析、优化或验证工具了。
例如，相比盲目的传递一些代码片段到类似 <code class="docutils literal"><span class="pre">exec()</span></code> 函数中，你可以先将它转换成一个AST，
然后观察它的细节看它到底是怎样做的。
你还可以写一些工具来查看某个模块的全部源码，并且在此基础上执行某些静态分析。</p>
<p>需要注意的是，如果你知道自己在干啥，你还能够重写AST来表示新的代码。
下面是一个装饰器例子，可以通过重新解析函数体源码、
重写AST并重新创建函数代码对象来将全局访问变量降为函数体作用范围，</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># namelower.py</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="c1"># Node visitor that lowers globally accessed names into</span>
<span class="c1"># the function body as local variables.</span>
<span class="k">class</span> <span class="nc">NameLower</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowered_names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowered_names</span> <span class="o">=</span> <span class="n">lowered_names</span>

    <span class="k">def</span> <span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># Compile some assignments to lower the constants</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;__globals = globals()</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;{0} = __globals[&#39;{0}&#39;]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowered_names</span><span class="p">)</span>
        <span class="n">code_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;exec&#39;</span><span class="p">)</span>

        <span class="c1"># Inject new statements into the function body</span>
        <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">code_ast</span><span class="o">.</span><span class="n">body</span>

        <span class="c1"># Save the function object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">node</span>

<span class="c1"># Decorator that turns global names into locals</span>
<span class="k">def</span> <span class="nf">lower_names</span><span class="p">(</span><span class="o">*</span><span class="n">namelist</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">srclines</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="c1"># Skip source lines prior to the @lower_names decorator</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">srclines</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;@lower_names&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">src</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">srclines</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1"># Hack to deal with indented code</span>
        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)):</span>
            <span class="n">src</span> <span class="o">=</span> <span class="s1">&#39;if 1:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">src</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;exec&#39;</span><span class="p">)</span>

        <span class="c1"># Transform the AST</span>
        <span class="n">cl</span> <span class="o">=</span> <span class="n">NameLower</span><span class="p">(</span><span class="n">namelist</span><span class="p">)</span>
        <span class="n">cl</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>

        <span class="c1"># Execute the modified AST</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">exec</span><span class="p">(</span><span class="nb">compile</span><span class="p">(</span><span class="n">top</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;exec&#39;</span><span class="p">),</span> <span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

        <span class="c1"># Pull out the modified code object</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__code__</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__code__</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">lower</span>
</pre></div>
</div>
<p>为了使用这个代码，你可以像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">INCR</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nd">@lower_names</span><span class="p">(</span><span class="s1">&#39;INCR&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="n">INCR</span>
</pre></div>
</div>
<p>装饰器会将 <code class="docutils literal"><span class="pre">countdown()</span></code> 函数重写为类似下面这样子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">__globals</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
    <span class="n">INCR</span> <span class="o">=</span> <span class="n">__globals</span><span class="p">[</span><span class="s1">&#39;INCR&#39;</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="n">INCR</span>
</pre></div>
</div>
<p>在性能测试中，它会让函数运行快20%</p>
<p>现在，你是不是想为你所有的函数都加上这个装饰器呢？或许不会。
但是，这却是对于一些高级技术比如AST操作、源码操作等等的一个很好的演示说明</p>
<p>本节受另外一个在 <code class="docutils literal"><span class="pre">ActiveState</span></code> 中处理Python字节码的章节的启示。
使用AST是一个更加高级点的技术，并且也更简单些。参考下面一节获得字节码的更多信息。</p>
</div>
</div>
<span id="document-c09/p25_disassembling_python_byte_code"></span><div class="section" id="python">
<h3>9.25 拆解Python字节码<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想通过将你的代码反编译成低级的字节码来查看它底层的工作机制。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">dis</span></code> 模块可以被用来输出任何Python函数的反编译结果。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span><span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;T-minus&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Blastoff!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">countdown</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>当你想要知道你的程序底层的运行机制的时候，<code class="docutils literal"><span class="pre">dis</span></code> 模块是很有用的。比如如果你想试着理解性能特征。
被 <code class="docutils literal"><span class="pre">dis()</span></code> 函数解析的原始字节码如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_code</span>
<span class="go">b&quot;x&#39;\x00|\x00\x00d\x01\x00k\x04\x00r)\x00t\x00\x00d\x02\x00|\x00\x00\x83</span>
<span class="go">\x02\x00\x01|\x00\x00d\x03\x008}\x00\x00q\x03\x00Wt\x00\x00d\x04\x00\x83</span>
<span class="go">\x01\x00\x01d\x00\x00S&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想自己解释这段代码，你需要使用一些在 <code class="docutils literal"><span class="pre">opcode</span></code> 模块中定义的常量。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">countdown</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_code</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">opcode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opcode</span><span class="o">.</span><span class="n">opname</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opcode</span><span class="o">.</span><span class="n">opname</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="go">&#39;SETUP_LOOP&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opcode</span><span class="o">.</span><span class="n">opname</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
<span class="go">&#39;LOAD_FAST&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>奇怪的是，在 <code class="docutils literal"><span class="pre">dis</span></code> 模块中并没有函数让你以编程方式很容易的来处理字节码。
不过，下面的生成器函数可以将原始字节码序列转换成 <code class="docutils literal"><span class="pre">opcodes</span></code> 和参数。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">opcode</span>

<span class="k">def</span> <span class="nf">generate_opcodes</span><span class="p">(</span><span class="n">codebytes</span><span class="p">):</span>
    <span class="n">extended_arg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">codebytes</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">codebytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">&gt;=</span> <span class="n">opcode</span><span class="o">.</span><span class="n">HAVE_ARGUMENT</span><span class="p">:</span>
            <span class="n">oparg</span> <span class="o">=</span> <span class="n">codebytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">codebytes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">256</span> <span class="o">+</span> <span class="n">extended_arg</span>
            <span class="n">extended_arg</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">opcode</span><span class="o">.</span><span class="n">EXTENDED_ARG</span><span class="p">:</span>
                <span class="n">extended_arg</span> <span class="o">=</span> <span class="n">oparg</span> <span class="o">*</span> <span class="mi">65536</span>
                <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">oparg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">oparg</span><span class="p">)</span>
</pre></div>
</div>
<p>使用方法如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">oparg</span> <span class="ow">in</span> <span class="n">generate_opcodes</span><span class="p">(</span><span class="n">countdown</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_code</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">opcode</span><span class="o">.</span><span class="n">opname</span><span class="p">[</span><span class="n">op</span><span class="p">],</span> <span class="n">oparg</span><span class="p">)</span>
</pre></div>
</div>
<p>这种方式很少有人知道，你可以利用它替换任何你想要替换的函数的原始字节码。
下面我们用一个示例来演示整个过程：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="vm">__code__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">&lt;code object add at 0x1007beed0, file &quot;&lt;stdin&gt;&quot;, line 1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">co_code</span>
<span class="go">b&#39;|\x00\x00|\x01\x00\x17S&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Make a completely new code object with bogus byte code</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newbytecode</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;xxxxxxx&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nc</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">CodeType</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">co_argcount</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">co_kwonlyargcount</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">c</span><span class="o">.</span><span class="n">co_nlocals</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">co_stacksize</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">co_flags</span><span class="p">,</span> <span class="n">newbytecode</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">co_consts</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">c</span><span class="o">.</span><span class="n">co_names</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">co_name</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">c</span><span class="o">.</span><span class="n">co_firstlineno</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">co_lnotab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nc</span>
<span class="go">&lt;code object add at 0x10069fe40, file &quot;&lt;stdin&gt;&quot;, line 1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="vm">__code__</span> <span class="o">=</span> <span class="n">nc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Segmentation fault</span>
</pre></div>
</div>
<p>你可以像这样耍大招让解释器奔溃。但是，对于编写更高级优化和元编程工具的程序员来讲，
他们可能真的需要重写字节码。本节最后的部分演示了这个是怎样做到的。你还可以参考另外一个类似的例子：
<a class="reference external" href="http://code.activestate.com/recipes/277940-decorator-for-bindingconstants-at-compile-time/">this code on ActiveState</a></p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p10_modules_and_packages"></span><div class="section" id="id1">
<h2>第十章：模块与包<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>模块与包是任何大型程序的核心，就连Python安装程序本身也是一个包。本章重点涉及有关模块和包的常用编程技术，例如如何组织包、把大型模块分割成多个文件、创建命名空间包。同时，也给出了让你自定义导入语句的秘籍。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c10/p01_make_hierarchical_package_of_modules"></span><div class="section" id="id1">
<h3>10.1 构建一个模块的层级包<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想将你的代码组织成由很多分层模块构成的包。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>封装成包是很简单的。在文件系统上组织你的代码，并确保每个目录都定义了一个__init__.py文件。
例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">graphics</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">primitive</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">line</span><span class="o">.</span><span class="n">py</span>
        <span class="n">fill</span><span class="o">.</span><span class="n">py</span>
        <span class="n">text</span><span class="o">.</span><span class="n">py</span>
    <span class="n">formats</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">png</span><span class="o">.</span><span class="n">py</span>
        <span class="n">jpg</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>一旦你做到了这一点，你应该能够执行各种import语句，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">graphics.primitive.line</span>
<span class="kn">from</span> <span class="nn">graphics.primitive</span> <span class="kn">import</span> <span class="n">line</span>
<span class="kn">import</span> <span class="nn">graphics.formats.jpg</span> <span class="kn">as</span> <span class="nn">jpg</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>定义模块的层次结构就像在文件系统上建立目录结构一样容易。
文件__init__.py的目的是要包含不同运行级别的包的可选的初始化代码。
举个例子，如果你执行了语句import graphics， 文件graphics/__init__.py将被导入,建立graphics命名空间的内容。像import graphics.format.jpg这样导入，文件graphics/__init__.py和文件graphics/formats/__init__.py将在文件graphics/formats/jpg.py导入之前导入。</p>
<p>绝大部分时候让__init__.py空着就好。但是有些情况下可能包含代码。
举个例子，__init__.py能够用来自动加载子模块:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># graphics/formats/__init__.py</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">jpg</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">png</span>
</pre></div>
</div>
<p>像这样一个文件,用户可以仅仅通过import grahpics.formats来代替import graphics.formats.jpg以及import graphics.formats.png。</p>
<p>__init__.py的其他常用用法包括将多个文件合并到一个逻辑命名空间，这将在10.4小节讨论。</p>
<p>敏锐的程序员会发现，即使没有__init__.py文件存在，python仍然会导入包。如果你没有定义__init__.py时，实际上创建了一个所谓的“命名空间包”，这将在10.5小节讨论。万物平等，如果你着手创建一个新的包的话，包含一个__init__.py文件吧。</p>
</div>
</div>
<span id="document-c10/p02_control_the_import_of_everything"></span><div class="section" id="id1">
<h3>10.2 控制模块被全部导入的内容<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>当使用&#8217;from module import <a href="#id3"><span class="problematic" id="id4">*</span></a>&#8216; 语句时，希望对从模块或包导出的符号进行精确控制。</p>
</div>
<div class="section" id="id5">
<h4>解决方案<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>在你的模块中定义一个变量 __all__ 来明确地列出需要导出的内容。</p>
<p>举个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># somemodule.py</span>
<span class="k">def</span> <span class="nf">spam</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">grok</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">blah</span> <span class="o">=</span> <span class="mi">42</span>
<span class="c1"># Only export &#39;spam&#39; and &#39;grok&#39;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;grok&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>讨论<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>尽管强烈反对使用 &#8216;from module import <a href="#id7"><span class="problematic" id="id8">*</span></a>&#8216;, 但是在定义了大量变量名的模块中频繁使用。
如果你不做任何事, 这样的导入将会导入所有不以下划线开头的。
另一方面,如果定义了 __all__ , 那么只有被列举出的东西会被导出。</p>
<p>如果你将 __all__ 定义成一个空列表, 没有东西将被导入。
如果 __all__ 包含未定义的名字, 在导入时引起AttributeError。</p>
</div>
</div>
<span id="document-c10/p03_import_submodules_by_relative_names"></span><div class="section" id="id1">
<h3>10.3 使用相对路径名导入包中子模块<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>将代码组织成包,想用import语句从另一个包名没有硬编码过的包的中导入子模块。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用包的相对导入，使一个模块导入同一个包的另一个模块
举个例子，假设在你的文件系统上有mypackage包，组织如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mypackage</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">A</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">spam</span><span class="o">.</span><span class="n">py</span>
        <span class="n">grok</span><span class="o">.</span><span class="n">py</span>
    <span class="n">B</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">bar</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>如果模块mypackage.A.spam要导入同目录下的模块grok，它应该包括的import语句如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># mypackage/A/spam.py</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">grok</span>
</pre></div>
</div>
<p>如果模块mypackage.A.spam要导入不同目录下的模块B.bar，它应该使用的import语句如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># mypackage/A/spam.py</span>
<span class="kn">from</span> <span class="nn">..B</span> <span class="kn">import</span> <span class="n">bar</span>
</pre></div>
</div>
<p>两个import语句都没包含顶层包名，而是使用了spam.py的相对路径。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在包内，既可以使用相对路径也可以使用绝对路径来导入。
举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># mypackage/A/spam.py</span>
<span class="kn">from</span> <span class="nn">mypackage.A</span> <span class="kn">import</span> <span class="n">grok</span> <span class="c1"># OK</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">grok</span> <span class="c1"># OK</span>
<span class="kn">import</span> <span class="nn">grok</span> <span class="c1"># Error (not found)</span>
</pre></div>
</div>
<p>像mypackage.A这样使用绝对路径名的不利之处是这将顶层包名硬编码到你的源码中。如果你想重新组织它，你的代码将更脆，很难工作。 举个例子，如果你改变了包名，你就必须检查所有文件来修正源码。 同样，硬编码的名称会使移动代码变得困难。举个例子，也许有人想安装两个不同版本的软件包，只通过名称区分它们。 如果使用相对导入，那一切都ok，然而使用绝对路径名很可能会出问题。</p>
<p>import语句的 <code class="docutils literal"><span class="pre">.</span></code> 和 <code class="docutils literal"><span class="pre">..</span></code> 看起来很滑稽, 但它指定目录名.为当前目录，..B为目录../B。这种语法只适用于import。
举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">grok</span> <span class="c1"># OK</span>
<span class="kn">import</span> <span class="o">.</span><span class="n">grok</span> <span class="c1"># ERROR</span>
</pre></div>
</div>
<p>尽管使用相对导入看起来像是浏览文件系统，但是不能到定义包的目录之外。也就是说，使用点的这种模式从不是包的目录中导入将会引发错误。</p>
<p>最后，相对导入只适用于在合适的包中的模块。尤其是在顶层的脚本的简单模块中，它们将不起作用。如果包的部分被作为脚本直接执行，那它们将不起作用
例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">python3</span> <span class="n">mypackage</span><span class="o">/</span><span class="n">A</span><span class="o">/</span><span class="n">spam</span><span class="o">.</span><span class="n">py</span> <span class="c1"># Relative imports fail</span>
</pre></div>
</div>
<p>另一方面，如果你使用Python的-m选项来执行先前的脚本，相对导入将会正确运行。
例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">python3</span> <span class="o">-</span><span class="n">m</span> <span class="n">mypackage</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">spam</span> <span class="c1"># Relative imports work</span>
</pre></div>
</div>
<p>更多的包的相对导入的背景知识,请看 <a class="reference external" href="http://www.python.org/dev/peps/pep-0328">PEP 328</a> .</p>
</div>
</div>
<span id="document-c10/p04_split_module_into_multiple_files"></span><div class="section" id="id1">
<h3>10.4 将模块分割成多个文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想将一个模块分割成多个文件。但是你不想将分离的文件统一成一个逻辑模块时使已有的代码遭到破坏。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>程序模块可以通过变成包来分割成多个独立的文件。考虑下下面简单的模块：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># mymodule.py</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.spam&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.bar&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>假设你想mymodule.py分为两个文件，每个定义的一个类。要做到这一点，首先用mymodule目录来替换文件mymodule.py。
这这个目录下，创建以下文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mymodule</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">a</span><span class="o">.</span><span class="n">py</span>
    <span class="n">b</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>在a.py文件中插入以下代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># a.py</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;A.spam&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在b.py文件中插入以下代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># b.py</span>
<span class="kn">from</span> <span class="nn">.a</span> <span class="kn">import</span> <span class="n">A</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;B.bar&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，在 __init__.py 中，将2个文件粘合在一起：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># __init__.py</span>
<span class="kn">from</span> <span class="nn">.a</span> <span class="kn">import</span> <span class="n">A</span>
<span class="kn">from</span> <span class="nn">.b</span> <span class="kn">import</span> <span class="n">B</span>
</pre></div>
</div>
<p>如果按照这些步骤，所产生的包MyModule将作为一个单一的逻辑模块：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mymodule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">spam</span><span class="p">()</span>
<span class="go">A.spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
<span class="go">B.bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在这个章节中的主要问题是一个设计问题，不管你是否希望用户使用很多小模块或只是一个模块。举个例子，在一个大型的代码库中，你可以将这一切都分割成独立的文件，让用户使用大量的import语句，就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mymodule.a</span> <span class="kn">import</span> <span class="n">A</span>
<span class="kn">from</span> <span class="nn">mymodule.b</span> <span class="kn">import</span> <span class="n">B</span>
<span class="o">...</span>
</pre></div>
</div>
<p>这样能工作，但这让用户承受更多的负担，用户要知道不同的部分位于何处。通常情况下，将这些统一起来，使用一条import将更加容易，就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mymodule</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
</pre></div>
</div>
<p>对后者而言，让mymodule成为一个大的源文件是最常见的。但是，这一章节展示了如何合并多个文件合并成一个单一的逻辑命名空间。
这样做的关键是创建一个包目录，使用 __init__.py 文件来将每部分粘合在一起。</p>
<p>当一个模块被分割，你需要特别注意交叉引用的文件名。举个例子，在这一章节中，B类需要访问A类作为基类。用包的相对导入 from .a import A 来获取。</p>
<p>整个章节都使用包的相对导入来避免将顶层模块名硬编码到源代码中。这使得重命名模块或者将它移动到别的位置更容易。（见10.3小节）</p>
<p>作为这一章节的延伸，将介绍延迟导入。如图所示，__init__.py文件一次导入所有必需的组件的。但是对于一个很大的模块，可能你只想组件在需要时被加载。
要做到这一点，__init__.py有细微的变化：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># __init__.py</span>
<span class="k">def</span> <span class="nf">A</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">.a</span> <span class="kn">import</span> <span class="n">A</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">B</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">.b</span> <span class="kn">import</span> <span class="n">B</span>
    <span class="k">return</span> <span class="n">B</span><span class="p">()</span>
</pre></div>
</div>
<p>在这个版本中，类A和类B被替换为在第一次访问时加载所需的类的函数。对于用户，这看起来不会有太大的不同。
例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mymodule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">spam</span><span class="p">()</span>
<span class="go">A.spam</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>延迟加载的主要缺点是继承和类型检查可能会中断。你可能会稍微改变你的代码，例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">A</span><span class="p">):</span> <span class="c1"># Error</span>
<span class="o">...</span>

<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">A</span><span class="p">):</span> <span class="c1"># Ok</span>
<span class="o">...</span>
</pre></div>
</div>
<p>延迟加载的真实例子, 见标准库 multiprocessing/__init__.py 的源码.</p>
</div>
</div>
<span id="document-c10/p05_separate_directories_import_by_namespace"></span><div class="section" id="id1">
<h3>10.5 利用命名空间导入目录分散的代码<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你可能有大量的代码，由不同的人来分散地维护。每个部分被组织为文件目录，如一个包。然而，你希望能用共同的包前缀将所有组件连接起来，不是将每一个部分作为独立的包来安装。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>从本质上讲，你要定义一个顶级Python包，作为一个大集合分开维护子包的命名空间。这个问题经常出现在大的应用框架中，框架开发者希望鼓励用户发布插件或附加包。</p>
<p>在统一不同的目录里统一相同的命名空间，但是要删去用来将组件联合起来的__init__.py文件。假设你有Python代码的两个不同的目录如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">-</span><span class="n">package</span><span class="o">/</span>
    <span class="n">spam</span><span class="o">/</span>
        <span class="n">blah</span><span class="o">.</span><span class="n">py</span>

<span class="n">bar</span><span class="o">-</span><span class="n">package</span><span class="o">/</span>
    <span class="n">spam</span><span class="o">/</span>
        <span class="n">grok</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有__init__.py文件。</p>
<p>让我们看看，如果将foo-package和bar-package都加到python模块路径并尝试导入会发生什么</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;foo-package&#39;</span><span class="p">,</span> <span class="s1">&#39;bar-package&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.blah</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.grok</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>两个不同的包目录被合并到一起，你可以导入spam.blah和spam.grok，并且它们能够工作。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在这里工作的机制被称为“包命名空间”的一个特征。从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p>
<p>包命名空间的关键是确保顶级目录中没有__init__.py文件来作为共同的命名空间。缺失__init__.py文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其__path__变量中。
举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">__path__</span>
<span class="go">_NamespacePath([&#39;foo-package/spam&#39;, &#39;bar-package/spam&#39;])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在定位包的子组件时，目录__path__将被用到(例如, 当导入spam.grok或者spam.blah的时候).</p>
<p>包命名空间的一个重要特点是任何人都可以用自己的代码来扩展命名空间。举个例子，假设你自己的代码目录像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">my</span><span class="o">-</span><span class="n">package</span><span class="o">/</span>
    <span class="n">spam</span><span class="o">/</span>
        <span class="n">custom</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>如果你将你的代码目录和其他包一起添加到sys.path，这将无缝地合并到别的spam包目录中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.custom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.grok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam.blah</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一个包是否被作为一个包命名空间的主要方法是检查其__file__属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的“namespace”这个词体现出来。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="vm">__file__</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;module&#39; object has no attribute &#39;__file__&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span>
<span class="go">&lt;module &#39;spam&#39; (namespace)&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>更多的包命名空间信息可以查看
<a class="reference external" href="https://www.python.org/dev/peps/pep-0420/">PEP 420</a>.</p>
</div>
</div>
<span id="document-c10/p06_reloading_modules"></span><div class="section" id="id1">
<h3>10.6 重新加载模块<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想重新加载已经加载的模块，因为你对其源码进行了修改。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用imp.reload()来重新加载先前加载的模块。举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">imp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">spam</span><span class="p">)</span>
<span class="go">&lt;module &#39;spam&#39; from &#39;./spam.py&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>重新加载模块在开发和调试过程中常常很有用。但在生产环境中的代码使用会不安全，因为它并不总是像您期望的那样工作。</p>
<p>reload()擦除了模块底层字典的内容，并通过重新执行模块的源代码来刷新它。模块对象本身的身份保持不变。因此，该操作在程序中所有已经被导入了的地方更新了模块。</p>
<p>尽管如此，reload()没有更新像&#8221;from module import name&#8221;这样使用import语句导入的定义。举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># spam.py</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">grok</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;grok&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>现在启动交互式会话：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">spam</span> <span class="kn">import</span> <span class="n">grok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
<span class="go">bar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grok</span><span class="p">()</span>
<span class="go">grok</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>不退出Python修改spam.py的源码，将grok()函数改成这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">grok</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;New grok&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>现在回到交互式会话，重新加载模块，尝试下这个实验：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">imp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">spam</span><span class="p">)</span>
<span class="go">&lt;module &#39;spam&#39; from &#39;./spam.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
<span class="go">bar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grok</span><span class="p">()</span> <span class="c1"># Notice old output</span>
<span class="go">grok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">grok</span><span class="p">()</span> <span class="c1"># Notice new output</span>
<span class="go">New grok</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这个例子中，你看到有2个版本的grok()函数被加载。通常来说，这不是你想要的，而是令人头疼的事。</p>
<p>因此，在生产环境中可能需要避免重新加载模块。在交互环境下调试，解释程序并试图弄懂它。</p>
</div>
</div>
<span id="document-c10/p07_make_directory_or_zip_runnable_as_main_script"></span><div class="section" id="id1">
<h3>10.7 运行目录或压缩文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>您有一个已成长为包含多个文件的应用，它已远不再是一个简单的脚本，你想向用户提供一些简单的方法运行这个程序。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你的应用程序已经有多个文件，你可以把你的应用程序放进它自己的目录并添加一个__main__.py文件。 举个例子，你可以像这样创建目录：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">myapplication</span><span class="o">/</span>
    <span class="n">spam</span><span class="o">.</span><span class="n">py</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">py</span>
    <span class="n">grok</span><span class="o">.</span><span class="n">py</span>
    <span class="n">__main__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>如果__main__.py存在，你可以简单地在顶级目录运行Python解释器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">myapplication</span>
</pre></div>
</div>
<p>解释器将执行__main__.py文件作为主程序。</p>
<p>如果你将你的代码打包成zip文件，这种技术同样也适用，举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">ls</span>
<span class="n">spam</span><span class="o">.</span><span class="n">py</span> <span class="n">bar</span><span class="o">.</span><span class="n">py</span> <span class="n">grok</span><span class="o">.</span><span class="n">py</span> <span class="n">__main__</span><span class="o">.</span><span class="n">py</span>
<span class="n">bash</span> <span class="o">%</span> <span class="nb">zip</span> <span class="o">-</span><span class="n">r</span> <span class="n">myapp</span><span class="o">.</span><span class="n">zip</span> <span class="o">*.</span><span class="n">py</span>
<span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">myapp</span><span class="o">.</span><span class="n">zip</span>
<span class="o">...</span> <span class="n">output</span> <span class="kn">from</span> <span class="nn">__main__.py</span> <span class="nn">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>创建一个目录或zip文件并添加__main__.py文件来将一个更大的Python应用打包是可行的。这和作为标准库被安装到Python库的代码包是有一点区别的。相反，这只是让别人执行的代码包。</p>
<p>由于目录和zip文件与正常文件有一点不同，你可能还需要增加一个shell脚本，使执行更加容易。例如，如果代码文件名为myapp.zip，你可以创建这样一个顶级脚本：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3 /usr/local/bin/myapp.zip</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c10/p08_read_datafile_within_package"></span><div class="section" id="id1">
<h3>10.8 读取位于包中的数据文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的包中包含代码需要去读取的数据文件。你需要尽可能地用最便捷的方式来做这件事。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>假设你的包中的文件组织成如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mypackage</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">somedata</span><span class="o">.</span><span class="n">dat</span>
    <span class="n">spam</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>现在假设spam.py文件需要读取somedata.dat文件中的内容。你可以用以下代码来完成：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># spam.py</span>
<span class="kn">import</span> <span class="nn">pkgutil</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pkgutil</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">__package__</span><span class="p">,</span> <span class="s1">&#39;somedata.dat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>由此产生的变量是包含该文件的原始内容的字节字符串。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>要读取数据文件，你可能会倾向于编写使用内置的I/ O功能的代码，如open()。但是这种方法也有一些问题。</p>
<p>首先，一个包对解释器的当前工作目录几乎没有控制权。因此，编程时任何I/O操作都必须使用绝对文件名。由于每个模块包含有完整路径的__file__变量，这弄清楚它的路径不是不可能，但它很凌乱。</p>
<p>第二，包通常安装作为.zip或.egg文件，这些文件并不像在文件系统上的一个普通目录里那样被保存。因此，你试图用open()对一个包含数据文件的归档文件进行操作，它根本不会工作。</p>
<p>pkgutil.get_data()函数是一个读取数据文件的高级工具，不用管包是如何安装以及安装在哪。它只是工作并将文件内容以字节字符串返回给你</p>
<p>get_data()的第一个参数是包含包名的字符串。你可以直接使用包名，也可以使用特殊的变量，比如__package__。第二个参数是包内文件的相对名称。如果有必要，可以使用标准的Unix命名规范到不同的目录，只有最后的目录仍然位于包中。</p>
</div>
</div>
<span id="document-c10/p09_add_directories_to_sys_path"></span><div class="section" id="sys-path">
<h3>10.9 将文件夹加入到sys.path<a class="headerlink" href="#sys-path" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你无法导入你的Python代码因为它所在的目录不在sys.path里。你想将添加新目录到Python路径，但是不想硬链接到你的代码。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>有两种常用的方式将新目录添加到sys.path。第一种，你可以使用PYTHONPATH环境变量来添加。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">env</span> <span class="n">PYTHONPATH</span><span class="o">=/</span><span class="n">some</span><span class="o">/</span><span class="nb">dir</span><span class="p">:</span><span class="o">/</span><span class="n">other</span><span class="o">/</span><span class="nb">dir</span> <span class="n">python3</span>
<span class="n">Python</span> <span class="mf">3.3</span><span class="o">.</span><span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">Oct</span> <span class="mi">4</span> <span class="mi">2012</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">33</span><span class="p">)</span>
<span class="p">[</span><span class="n">GCC</span> <span class="mf">4.2</span><span class="o">.</span><span class="mi">1</span> <span class="p">(</span><span class="n">Apple</span> <span class="n">Inc</span><span class="o">.</span> <span class="n">build</span> <span class="mi">5666</span><span class="p">)</span> <span class="p">(</span><span class="n">dot</span> <span class="mi">3</span><span class="p">)]</span> <span class="n">on</span> <span class="n">darwin</span>
<span class="n">Type</span> <span class="s2">&quot;help&quot;</span><span class="p">,</span> <span class="s2">&quot;copyright&quot;</span><span class="p">,</span> <span class="s2">&quot;credits&quot;</span> <span class="ow">or</span> <span class="s2">&quot;license&quot;</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span>
<span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;/some/dir&#39;</span><span class="p">,</span> <span class="s1">&#39;/other/dir&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在自定义应用程序中，这样的环境变量可在程序启动时设置或通过shell脚本。</p>
<p>第二种方法是创建一个.pth文件，将目录列举出来，像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># myapplication.pth</span>
<span class="o">/</span><span class="n">some</span><span class="o">/</span><span class="nb">dir</span>
<span class="o">/</span><span class="n">other</span><span class="o">/</span><span class="nb">dir</span>
</pre></div>
</div>
<p>这个.pth文件需要放在某个Python的site-packages目录，通常位于/usr/local/lib/python3.3/site-packages 或者 ~/.local/lib/python3.3/sitepackages。当解释器启动时，.pth文件里列举出来的存在于文件系统的目录将被添加到sys.path。安装一个.pth文件可能需要管理员权限，如果它被添加到系统级的Python解释器。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>比起费力地找文件，你可能会倾向于写一个代码手动调节sys.path的值。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;/some/dir&#39;</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;/other/dir&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>虽然这能“工作”，它是在实践中极为脆弱，应尽量避免使用。这种方法的问题是，它将目录名硬编码到了你的源代码。如果你的代码被移到一个新的位置，这会导致维护问题。更好的做法是在不修改源代码的情况下，将path配置到其他地方。如果您使用模块级的变量来精心构造一个适当的绝对路径，有时你可以解决硬编码目录的问题，比如__file__。举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">abspath</span><span class="p">,</span> <span class="n">join</span><span class="p">,</span> <span class="n">dirname</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">join</span><span class="p">(</span><span class="n">abspath</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)),</span> <span class="s1">&#39;src&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>这将src目录添加到path里，和执行插入步骤的代码在同一个目录里。</p>
<p>site-packages目录是第三方包和模块安装的目录。如果你手动安装你的代码，它将被安装到site-packages目录。虽然用于配置path的.pth文件必须放置在site-packages里，但它配置的路径可以是系统上任何你希望的目录。因此，你可以把你的代码放在一系列不同的目录，只要那些目录包含在.pth文件里。</p>
</div>
</div>
<span id="document-c10/p10_import_modules_using_name_given_in_string"></span><div class="section" id="id1">
<h3>10.10 通过字符串名导入模块<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想导入一个模块，但是模块的名字在字符串里。你想对字符串调用导入命令。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用importlib.import_module()函数来手动导入名字为字符串给出的一个模块或者包的一部分。举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;math&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.9092974268256817</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;urllib.request&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>import_module只是简单地执行和import相同的步骤，但是返回生成的模块对象。你只需要将其存储在一个变量，然后像正常的模块一样使用。</p>
<p>如果你正在使用的包，import_module()也可用于相对导入。但是，你需要给它一个额外的参数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="c1"># Same as &#39;from . import b&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;.b&#39;</span><span class="p">,</span> <span class="n">__package__</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>使用import_module()手动导入模块的问题通常出现在以某种方式编写修改或覆盖模块的代码时候。例如，也许你正在执行某种自定义导入机制，需要通过名称来加载一个模块，通过补丁加载代码。</p>
<p>在旧的代码，有时你会看到用于导入的内建函数__import__()。尽管它能工作，但是importlib.import_module() 通常更容易使用。</p>
<p>自定义导入过程的高级实例见10.11小节</p>
</div>
</div>
<span id="document-c10/p11_load_modules_from_remote_machine_by_hooks"></span><div class="section" id="id1">
<h3>10.11 通过钩子远程加载模块<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想自定义Python的import语句，使得它能从远程机器上面透明的加载模块。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>首先要提出来的是安全问题。本节讨论的思想如果没有一些额外的安全和认知机制的话会很糟糕。
也就是说，我们的主要目的是深入分析Python的import语句机制。
如果你理解了本节内部原理，你就能够为其他任何目的而自定义import。
有了这些，让我们继续向前走。</p>
<p>本节核心是设计导入语句的扩展功能。有很多种方法可以做这个，
不过为了演示的方便，我们开始先构造下面这个Python代码结构：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">testcode</span><span class="o">/</span>
    <span class="n">spam</span><span class="o">.</span><span class="n">py</span>
    <span class="n">fib</span><span class="o">.</span><span class="n">py</span>
    <span class="n">grok</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">blah</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>这些文件的内容并不重要，不过我们在每个文件中放入了少量的简单语句和函数，
这样你可以测试它们并查看当它们被导入时的输出。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># spam.py</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;I&#39;m spam&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hello </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="c1"># fib.py</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;I&#39;m fib&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># grok/__init__.py</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;I&#39;m grok.__init__&quot;</span><span class="p">)</span>

<span class="c1"># grok/blah.py</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;I&#39;m grok.blah&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>这里的目的是允许这些文件作为模块被远程访问。
也许最简单的方式就是将它们发布到一个web服务器上面。在testcode目录中像下面这样运行Python：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">cd</span> <span class="n">testcode</span>
<span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="o">-</span><span class="n">m</span> <span class="n">http</span><span class="o">.</span><span class="n">server</span> <span class="mi">15000</span>
<span class="n">Serving</span> <span class="n">HTTP</span> <span class="n">on</span> <span class="mf">0.0</span><span class="o">.</span><span class="mf">0.0</span> <span class="n">port</span> <span class="mi">15000</span> <span class="o">...</span>
</pre></div>
</div>
<p>服务器运行起来后再启动一个单独的Python解释器。
确保你可以使用 <code class="docutils literal"><span class="pre">urllib</span></code> 访问到远程文件。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://localhost:15000/fib.py&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go"># fib.py</span>
<span class="go">print(&quot;I&#39;m fib&quot;)</span>

<span class="go">def fib(n):</span>
<span class="go">    if n &lt; 2:</span>
<span class="go">        return 1</span>
<span class="go">    else:</span>
<span class="go">        return fib(n-1) + fib(n-2)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>从这个服务器加载源代码是接下来本节的基础。
为了替代手动的通过 <code class="docutils literal"><span class="pre">urlopen()</span></code> 来收集源文件，
我们通过自定义import语句来在后台自动帮我们做到。</p>
<p>加载远程模块的第一种方法是创建一个显示的加载函数来完成它。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">imp</span>
<span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">imp</span><span class="o">.</span><span class="n">new_module</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>
    <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">)</span>
    <span class="n">mod</span><span class="o">.</span><span class="vm">__file__</span> <span class="o">=</span> <span class="n">url</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">exec</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mod</span>
</pre></div>
</div>
<p>这个函数会下载源代码，并使用 <code class="docutils literal"><span class="pre">compile()</span></code> 将其编译到一个代码对象中，
然后在一个新创建的模块对象的字典中来执行它。下面是使用这个函数的方式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">load_module</span><span class="p">(</span><span class="s1">&#39;http://localhost:15000/fib.py&#39;</span><span class="p">)</span>
<span class="go">I&#39;m fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="o">.</span><span class="n">fib</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">89</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span> <span class="o">=</span> <span class="n">load_module</span><span class="p">(</span><span class="s1">&#39;http://localhost:15000/spam.py&#39;</span><span class="p">)</span>
<span class="go">I&#39;m spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="go">Hello Guido</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span>
<span class="go">&lt;module &#39;http://localhost:15000/fib.py&#39; from &#39;http://localhost:15000/fib.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span>
<span class="go">&lt;module &#39;http://localhost:15000/spam.py&#39; from &#39;http://localhost:15000/spam.py&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正如你所见，对于简单的模块这个是行得通的。
不过它并没有嵌入到通常的import语句中，如果要支持更高级的结构比如包就需要更多的工作了。</p>
<p>一个更酷的做法是创建一个自定义导入器。第一种方法是创建一个元路径导入器。如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># urlimport.py</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">importlib.abc</span>
<span class="kn">import</span> <span class="nn">imp</span>
<span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>
<span class="kn">from</span> <span class="nn">urllib.error</span> <span class="kn">import</span> <span class="n">HTTPError</span><span class="p">,</span> <span class="n">URLError</span>
<span class="kn">from</span> <span class="nn">html.parser</span> <span class="kn">import</span> <span class="n">HTMLParser</span>

<span class="c1"># Debugging</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># Get links from a given URL</span>
<span class="k">def</span> <span class="nf">_get_links</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">LinkParser</span><span class="p">(</span><span class="n">HTMLParser</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">handle_starttag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
                <span class="n">links</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;href&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span>
    <span class="n">links</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Getting links from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">url</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">LinkParser</span><span class="p">()</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Could not get links. </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;links: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">links</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">links</span>

<span class="k">class</span> <span class="nc">UrlMetaFinder</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MetaPathFinder</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loaders</span> <span class="o">=</span> <span class="p">{</span> <span class="n">baseurl</span> <span class="p">:</span> <span class="n">UrlModuleLoader</span><span class="p">(</span><span class="n">baseurl</span><span class="p">)</span> <span class="p">}</span>

    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_module: fullname=</span><span class="si">%r</span><span class="s1">, path=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">baseurl</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">fullname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">basename</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_module: baseurl=</span><span class="si">%r</span><span class="s1">, basename=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">,</span> <span class="n">basename</span><span class="p">)</span>

        <span class="c1"># Check link cache</span>
        <span class="k">if</span> <span class="n">basename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="p">[</span><span class="n">baseurl</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_links</span><span class="p">(</span><span class="n">baseurl</span><span class="p">)</span>

        <span class="c1"># Check if it&#39;s a package</span>
        <span class="k">if</span> <span class="n">basename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="p">[</span><span class="n">baseurl</span><span class="p">]:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_module: trying package </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
            <span class="n">fullurl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">basename</span>
            <span class="c1"># Attempt to load the package (which accesses __init__.py)</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">UrlPackageLoader</span><span class="p">(</span><span class="n">fullurl</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="p">[</span><span class="n">fullurl</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_links</span><span class="p">(</span><span class="n">fullurl</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_loaders</span><span class="p">[</span><span class="n">fullurl</span><span class="p">]</span> <span class="o">=</span> <span class="n">UrlModuleLoader</span><span class="p">(</span><span class="n">fullurl</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_module: package </span><span class="si">%r</span><span class="s1"> loaded&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_module: package failed. </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="n">loader</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">loader</span>
        <span class="c1"># A normal module</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">basename</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="p">[</span><span class="n">baseurl</span><span class="p">]:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_module: module </span><span class="si">%r</span><span class="s1"> found&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaders</span><span class="p">[</span><span class="n">baseurl</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_module: module </span><span class="si">%r</span><span class="s1"> not found&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">invalidate_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;invalidating link cache&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<span class="c1"># Module Loader for a URL</span>
<span class="k">class</span> <span class="nc">UrlModuleLoader</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">SourceLoader</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;urlmodule </span><span class="si">%r</span><span class="s1"> from </span><span class="si">%r</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">module</span><span class="o">.</span><span class="vm">__file__</span><span class="p">)</span>

    <span class="c1"># Required method</span>
    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_code</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">imp</span><span class="o">.</span><span class="n">new_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="n">mod</span><span class="o">.</span><span class="vm">__file__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">fullname</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mod</span>

    <span class="c1"># Optional extensions</span>
    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_source</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">compile</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">),</span> <span class="s1">&#39;exec&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">fullname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span>

    <span class="k">def</span> <span class="nf">get_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;loader: reading </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_cache</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;loader: cached </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;loader: </span><span class="si">%r</span><span class="s1"> loaded&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_source_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span>
            <span class="k">return</span> <span class="n">source</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">HTTPError</span><span class="p">,</span> <span class="n">URLError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;loader: </span><span class="si">%r</span><span class="s1"> failed. </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t load </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_package</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="c1"># Package loader for a URL</span>
<span class="k">class</span> <span class="nc">UrlPackageLoader</span><span class="p">(</span><span class="n">UrlModuleLoader</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">__path__</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="p">]</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">fullname</span>

    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="s1">&#39;__init__.py&#39;</span>

    <span class="k">def</span> <span class="nf">is_package</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

<span class="c1"># Utility functions for installing/uninstalling the loader</span>
<span class="n">_installed_meta_cache</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">def</span> <span class="nf">install_meta</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_installed_meta_cache</span><span class="p">:</span>
        <span class="n">finder</span> <span class="o">=</span> <span class="n">UrlMetaFinder</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="n">_installed_meta_cache</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">finder</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">finder</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> installed on sys.meta_path&#39;</span><span class="p">,</span> <span class="n">finder</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">remove_meta</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">_installed_meta_cache</span><span class="p">:</span>
        <span class="n">finder</span> <span class="o">=</span> <span class="n">_installed_meta_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">finder</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> removed from sys.meta_path&#39;</span><span class="p">,</span> <span class="n">finder</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是一个交互会话，演示了如何使用前面的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; # importing currently fails
&gt;&gt;&gt; import fib
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named &#39;fib&#39;
&gt;&gt;&gt; # Load the importer and retry (it works)
&gt;&gt;&gt; import urlimport
&gt;&gt;&gt; urlimport.install_meta(&#39;http://localhost:15000&#39;)
&gt;&gt;&gt; import fib
I&#39;m fib
&gt;&gt;&gt; import spam
I&#39;m spam
&gt;&gt;&gt; import grok.blah
I&#39;m grok.__init__
I&#39;m grok.blah
&gt;&gt;&gt; grok.blah.__file__
&#39;http://localhost:15000/grok/blah.py&#39;
&gt;&gt;&gt;
</pre></div>
</div>
<p>这个特殊的方案会安装一个特别的查找器 <code class="docutils literal"><span class="pre">UrlMetaFinder</span></code> 实例，
作为 <code class="docutils literal"><span class="pre">sys.meta_path</span></code> 中最后的实体。
当模块被导入时，会依据 <code class="docutils literal"><span class="pre">sys.meta_path</span></code> 中的查找器定位模块。
在这个例子中，<code class="docutils literal"><span class="pre">UrlMetaFinder</span></code> 实例是最后一个查找器方案，
当模块在任何一个普通地方都找不到的时候就触发它。</p>
<p>作为常见的实现方案，<code class="docutils literal"><span class="pre">UrlMetaFinder</span></code> 类包装在一个用户指定的URL上。
在内部，查找器通过抓取指定URL的内容构建合法的链接集合。
导入的时候，模块名会跟已有的链接作对比。如果找到了一个匹配的，
一个单独的 <code class="docutils literal"><span class="pre">UrlModuleLoader</span></code> 类被用来从远程机器上加载源代码并创建最终的模块对象。
这里缓存链接的一个原因是避免不必要的HTTP请求重复导入。</p>
<p>自定义导入的第二种方法是编写一个钩子直接嵌入到 <code class="docutils literal"><span class="pre">sys.path</span></code> 变量中去，
识别某些目录命名模式。
在 <code class="docutils literal"><span class="pre">urlimport.py</span></code> 中添加如下的类和支持函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># urlimport.py</span>
<span class="c1"># ... include previous code above ...</span>
<span class="c1"># Path finder class for a URL</span>
<span class="k">class</span> <span class="nc">UrlPathFinder</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">PathEntryFinder</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseurl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loader</span> <span class="o">=</span> <span class="n">UrlModuleLoader</span><span class="p">(</span><span class="n">baseurl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">=</span> <span class="n">baseurl</span>

    <span class="k">def</span> <span class="nf">find_loader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_loader: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">fullname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">basename</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Check link cache</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># See discussion</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="n">_get_links</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span><span class="p">)</span>

        <span class="c1"># Check if it&#39;s a package</span>
        <span class="k">if</span> <span class="n">basename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_loader: trying package </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
            <span class="n">fullurl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">basename</span>
            <span class="c1"># Attempt to load the package (which accesses __init__.py)</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">UrlPackageLoader</span><span class="p">(</span><span class="n">fullurl</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_loader: package </span><span class="si">%r</span><span class="s1"> loaded&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_loader: </span><span class="si">%r</span><span class="s1"> is a namespace package&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
                <span class="n">loader</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="p">[</span><span class="n">fullurl</span><span class="p">])</span>

        <span class="c1"># A normal module</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">basename</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_loader: module </span><span class="si">%r</span><span class="s1"> found&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_loader</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;find_loader: module </span><span class="si">%r</span><span class="s1"> not found&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">def</span> <span class="nf">invalidate_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;invalidating link cache&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># Check path to see if it looks like a URL</span>
<span class="n">_url_path_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">handle_url</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;http://&#39;</span><span class="p">,</span> <span class="s1">&#39;https://&#39;</span><span class="p">)):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Handle path? </span><span class="si">%s</span><span class="s1">. [Yes]&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">_url_path_cache</span><span class="p">:</span>
            <span class="n">finder</span> <span class="o">=</span> <span class="n">_url_path_cache</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">finder</span> <span class="o">=</span> <span class="n">UrlPathFinder</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">_url_path_cache</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">finder</span>
        <span class="k">return</span> <span class="n">finder</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Handle path? </span><span class="si">%s</span><span class="s1">. [No]&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">install_path_hook</span><span class="p">():</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">handle_url</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Installing handle_url&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">remove_path_hook</span><span class="p">():</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">handle_url</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Removing handle_url&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>要使用这个路径查找器，你只需要在 <code class="docutils literal"><span class="pre">sys.path</span></code> 中加入URL链接。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initial import fails</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fib</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ImportError</span>: <span class="n">No module named &#39;fib&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Install the path hook</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urlimport</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlimport</span><span class="o">.</span><span class="n">install_path_hook</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Imports still fail (not on path)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fib</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ImportError</span>: <span class="n">No module named &#39;fib&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Add an entry to sys.path and watch it work</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;http://localhost:15000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fib</span>
<span class="go">I&#39;m fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">grok.blah</span>
<span class="go">I&#39;m grok.__init__</span>
<span class="go">I&#39;m grok.blah</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grok</span><span class="o">.</span><span class="n">blah</span><span class="o">.</span><span class="vm">__file__</span>
<span class="go">&#39;http://localhost:15000/grok/blah.py&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>关键点就是 <code class="docutils literal"><span class="pre">handle_url()</span></code> 函数，它被添加到了 <code class="docutils literal"><span class="pre">sys.path_hooks</span></code> 变量中。
当 <code class="docutils literal"><span class="pre">sys.path</span></code> 的实体被处理时，会调用 <code class="docutils literal"><span class="pre">sys.path_hooks</span></code> 中的函数。
如果任何一个函数返回了一个查找器对象，那么这个对象就被用来为 <code class="docutils literal"><span class="pre">sys.path</span></code> 实体加载模块。</p>
<p>远程模块加载跟其他的加载使用方法几乎是一样的。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span>
<span class="go">&lt;urlmodule &#39;fib&#39; from &#39;http://localhost:15000/fib.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;fib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="o">.</span><span class="vm">__file__</span>
<span class="go">&#39;http://localhost:15000/fib.py&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">fib</span><span class="p">))</span>
<span class="go"># fib.py</span>
<span class="go">print(&quot;I&#39;m fib&quot;)</span>

<span class="go">def fib(n):</span>
<span class="go">    if n &lt; 2:</span>
<span class="go">        return 1</span>
<span class="go">    else:</span>
<span class="go">        return fib(n-1) + fib(n-2)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在详细讨论之前，有点要强调的是，Python的模块、包和导入机制是整个语言中最复杂的部分，
即使经验丰富的Python程序员也很少能精通它们。
我在这里推荐一些值的去读的文档和书籍，包括
<a class="reference external" href="https://docs.python.org/3/library/importlib.html">importlib module</a>
和 <a class="reference external" href="http://www.python.org/dev/peps/pep-0302">PEP 302</a>.
文档内容在这里不会被重复提到，不过我在这里会讨论一些最重要的部分。</p>
<p>首先，如果你想创建一个新的模块对象，使用 <code class="docutils literal"><span class="pre">imp.new_module()</span></code> 函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">imp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">new_module</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;spam&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;spam&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>模块对象通常有一些期望属性，包括 <code class="docutils literal"><span class="pre">__file__</span></code> （运行模块加载语句的文件名）
和 <code class="docutils literal"><span class="pre">__package__</span></code> (包名)。</p>
<p>其次，模块会被解释器缓存起来。模块缓存可以在字典 <code class="docutils literal"><span class="pre">sys.modules</span></code> 中被找到。
因为有了这个缓存机制，通常可以将缓存和模块的创建通过一个步骤完成：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">imp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="n">imp</span><span class="o">.</span><span class="n">new_module</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;spam&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果给定模块已经存在那么就会直接获得已经被创建过的模块，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;math&#39;</span><span class="p">,</span> <span class="n">imp</span><span class="o">.</span><span class="n">new_module</span><span class="p">(</span><span class="s1">&#39;math&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;math&#39; from &#39;/usr/local/lib/python3.3/lib-dynload/math.so&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.9092974268256817</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-0.4161468365471424</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>由于创建模块很简单，很容易编写简单函数比如第一部分的 <code class="docutils literal"><span class="pre">load_module()</span></code> 函数。
这个方案的一个缺点是很难处理复杂情况比如包的导入。
为了处理一个包，你要重新实现普通import语句的底层逻辑（比如检查目录，查找__init__.py文件，
执行那些文件，设置路径等）。这个复杂性就是为什么最好直接扩展import语句而不是自定义函数的一个原因。</p>
<p>扩展import语句很简单，但是会有很多移动操作。
最高层上，导入操作被一个位于sys.meta_path列表中的“元路径”查找器处理。
如果你输出它的值，会看到下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">)</span>
<span class="go">[&lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;,</span>
<span class="go">&lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;,</span>
<span class="go">&lt;class &#39;_frozen_importlib.PathFinder&#39;&gt;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当执行一个语句比如 <code class="docutils literal"><span class="pre">import</span> <span class="pre">fib</span></code> 时，解释器会遍历sys.mata_path中的查找器对象，
调用它们的 <code class="docutils literal"><span class="pre">find_module()</span></code> 方法定位正确的模块加载器。
可以通过实验来看看：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Finder</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Looking for&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">None</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Finder</span><span class="p">())</span> <span class="c1"># Insert as first entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="go">Looking for math None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">types</span>
<span class="go">Looking for types None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">threading</span>
<span class="go">Looking for threading None</span>
<span class="go">Looking for time None</span>
<span class="go">Looking for traceback None</span>
<span class="go">Looking for linecache None</span>
<span class="go">Looking for tokenize None</span>
<span class="go">Looking for token None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意看 <code class="docutils literal"><span class="pre">find_module()</span></code> 方法是怎样在每一个导入就被触发的。
这个方法中的path参数的作用是处理包。
多个包被导入，就是一个可在包的 <code class="docutils literal"><span class="pre">__path__</span></code> 属性中找到的路径列表。
要找到包的子组件就要检查这些路径。
比如注意对于 <code class="docutils literal"><span class="pre">xml.etree</span></code> 和 <code class="docutils literal"><span class="pre">xml.etree.ElementTree</span></code> 的路径配置：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span>
<span class="go">Looking for xml None</span>
<span class="go">Looking for xml.etree [&#39;/usr/local/lib/python3.3/xml&#39;]</span>
<span class="go">Looking for xml.etree.ElementTree [&#39;/usr/local/lib/python3.3/xml/etree&#39;]</span>
<span class="go">Looking for warnings None</span>
<span class="go">Looking for contextlib None</span>
<span class="go">Looking for xml.etree.ElementPath [&#39;/usr/local/lib/python3.3/xml/etree&#39;]</span>
<span class="go">Looking for _elementtree None</span>
<span class="go">Looking for copy None</span>
<span class="go">Looking for org None</span>
<span class="go">Looking for pyexpat None</span>
<span class="go">Looking for ElementC14N None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">sys.meta_path</span></code> 上查找器的位置很重要，将它从队头移到队尾，然后再试试导入看：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Finder</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
</pre></div>
</div>
<p>现在你看不到任何输出了，因为导入被sys.meta_path中的其他实体处理。
这时候，你只有在导入不存在模块的时候才能看到它被触发：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fib</span>
<span class="go">Looking for fib None</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ImportError</span>: <span class="n">No module named &#39;fib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">xml.superfast</span>
<span class="go">Looking for xml.superfast [&#39;/usr/local/lib/python3.3/xml&#39;]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ImportError</span>: <span class="n">No module named &#39;xml.superfast&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你之前安装过一个捕获未知模块的查找器，这个是 <code class="docutils literal"><span class="pre">UrlMetaFinder</span></code> 类的关键。
一个 <code class="docutils literal"><span class="pre">UrlMetaFinder</span></code> 实例被添加到 <code class="docutils literal"><span class="pre">sys.meta_path</span></code> 的末尾，作为最后一个查找器方案。
如果被请求的模块名不能定位，就会被这个查找器处理掉。
处理包的时候需要注意，在path参数中指定的值需要被检查，看它是否以查找器中注册的URL开头。
如果不是，该子模块必须归属于其他查找器并被忽略掉。</p>
<p>对于包的其他处理可在 <code class="docutils literal"><span class="pre">UrlPackageLoader</span></code> 类中被找到。
这个类不会导入包名，而是去加载对应的 <code class="docutils literal"><span class="pre">__init__.py</span></code> 文件。
它也会设置模块的 <code class="docutils literal"><span class="pre">__path__</span></code> 属性，这一步很重要，
因为在加载包的子模块时这个值会被传给后面的 <code class="docutils literal"><span class="pre">find_module()</span></code> 调用。
基于路径的导入钩子是这些思想的一个扩展，但是采用了另外的方法。
我们都知道，<code class="docutils literal"><span class="pre">sys.path</span></code> 是一个Python查找模块的目录列表，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
<span class="go">[&#39;&#39;,</span>
<span class="go">&#39;/usr/local/lib/python33.zip&#39;,</span>
<span class="go">&#39;/usr/local/lib/python3.3&#39;,</span>
<span class="go">&#39;/usr/local/lib/python3.3/plat-darwin&#39;,</span>
<span class="go">&#39;/usr/local/lib/python3.3/lib-dynload&#39;,</span>
<span class="go">&#39;/usr/local/lib/...3.3/site-packages&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">sys.path</span></code> 中的每一个实体都会被额外的绑定到一个查找器对象上。
你可以通过查看 <code class="docutils literal"><span class="pre">sys.path_importer_cache</span></code> 去看下这些查找器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="p">)</span>
<span class="go">{&#39;.&#39;: FileFinder(&#39;.&#39;),</span>
<span class="go">&#39;/usr/local/lib/python3.3&#39;: FileFinder(&#39;/usr/local/lib/python3.3&#39;),</span>
<span class="go">&#39;/usr/local/lib/python3.3/&#39;: FileFinder(&#39;/usr/local/lib/python3.3/&#39;),</span>
<span class="go">&#39;/usr/local/lib/python3.3/collections&#39;: FileFinder(&#39;...python3.3/collections&#39;),</span>
<span class="go">&#39;/usr/local/lib/python3.3/encodings&#39;: FileFinder(&#39;...python3.3/encodings&#39;),</span>
<span class="go">&#39;/usr/local/lib/python3.3/lib-dynload&#39;: FileFinder(&#39;...python3.3/lib-dynload&#39;),</span>
<span class="go">&#39;/usr/local/lib/python3.3/plat-darwin&#39;: FileFinder(&#39;...python3.3/plat-darwin&#39;),</span>
<span class="go">&#39;/usr/local/lib/python3.3/site-packages&#39;: FileFinder(&#39;...python3.3/site-packages&#39;),</span>
<span class="go">&#39;/usr/local/lib/python33.zip&#39;: None}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sys.path_importer_cache</span></code> 比 <code class="docutils literal"><span class="pre">sys.path</span></code> 会更大点，
因为它会为所有被加载代码的目录记录它们的查找器。
这包括包的子目录，这些通常在 <code class="docutils literal"><span class="pre">sys.path</span></code> 中是不存在的。</p>
<p>要执行 <code class="docutils literal"><span class="pre">import</span> <span class="pre">fib</span></code> ，会顺序检查 <code class="docutils literal"><span class="pre">sys.path</span></code> 中的目录。
对于每个目录，名称“fib”会被传给相应的 <code class="docutils literal"><span class="pre">sys.path_importer_cache</span></code> 中的查找器。
这个可以让你创建自己的查找器并在缓存中放入一个实体。试试这个：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Finder</span><span class="p">:</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">find_loader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Looking for&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Add a &quot;debug&quot; entry to the importer cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Finder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Add a &quot;debug&quot; directory to sys.path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;debug&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">threading</span>
<span class="go">Looking for threading</span>
<span class="go">Looking for time</span>
<span class="go">Looking for traceback</span>
<span class="go">Looking for linecache</span>
<span class="go">Looking for tokenize</span>
<span class="go">Looking for token</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这里，你可以为名字“debug”创建一个新的缓存实体并将它设置成 <code class="docutils literal"><span class="pre">sys.path</span></code> 上的第一个。
在所有接下来的导入中，你会看到你的查找器被触发了。
不过，由于它返回 (None, [])，那么处理进程会继续处理下一个实体。</p>
<p><code class="docutils literal"><span class="pre">sys.path_importer_cache</span></code> 的使用被一个存储在 <code class="docutils literal"><span class="pre">sys.path_hooks</span></code> 中的函数列表控制。
试试下面的例子，它会清除缓存并给 <code class="docutils literal"><span class="pre">sys.path_hooks</span></code> 添加一个新的路径检查函数</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">check_path</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Checking&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">check_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fib</span>
<span class="go">Checked debug</span>
<span class="go">Checking .</span>
<span class="go">Checking /usr/local/lib/python33.zip</span>
<span class="go">Checking /usr/local/lib/python3.3</span>
<span class="go">Checking /usr/local/lib/python3.3/plat-darwin</span>
<span class="go">Checking /usr/local/lib/python3.3/lib-dynload</span>
<span class="go">Checking /Users/beazley/.local/lib/python3.3/site-packages</span>
<span class="go">Checking /usr/local/lib/python3.3/site-packages</span>
<span class="go">Looking for fib</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ImportError</span>: <span class="n">No module named &#39;fib&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正如你所见，<code class="docutils literal"><span class="pre">check_path()</span></code> 函数被每个 <code class="docutils literal"><span class="pre">sys.path</span></code> 中的实体调用。
不顾，由于抛出了 <code class="docutils literal"><span class="pre">ImportError</span></code> 异常，
啥都不会发生了（仅仅将检查转移到sys.path_hooks的下一个函数）。</p>
<p>知道了怎样sys.path是怎样被处理的，你就能构建一个自定义路径检查函数来查找文件名，不然URL。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">check_url</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http://&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">Finder</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;http://localhost:15000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_url</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fib</span>
<span class="go">Looking for fib # Finder output!</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="gr">ImportError</span>: <span class="n">No module named &#39;fib&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Notice installation of Finder in sys.path_importer_cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="p">[</span><span class="s1">&#39;http://localhost:15000&#39;</span><span class="p">]</span>
<span class="go">&lt;__main__.Finder object at 0x10064c850&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这就是本节最后部分的关键点。事实上，一个用来在sys.path中查找URL的自定义路径检查函数已经构建完毕。
当它们被碰到的时候，一个新的 <code class="docutils literal"><span class="pre">UrlPathFinder</span></code> 实例被创建并被放入 <code class="docutils literal"><span class="pre">sys.path_importer_cache</span></code>.
之后，所有需要检查 <code class="docutils literal"><span class="pre">sys.path</span></code> 的导入语句都会使用你的自定义查找器。</p>
<p>基于路径导入的包处理稍微有点复杂，并且跟 <code class="docutils literal"><span class="pre">find_loader()</span></code> 方法返回值有关。
对于简单模块，<code class="docutils literal"><span class="pre">find_loader()</span></code> 返回一个元组(loader, None)，
其中的loader是一个用于导入模块的加载器实例。</p>
<p>对于一个普通的包，<code class="docutils literal"><span class="pre">find_loader()</span></code> 返回一个元组(loader, path)，
其中的loader是一个用于导入包（并执行__init__.py）的加载器实例，
path是一个会初始化包的 <code class="docutils literal"><span class="pre">__path__</span></code> 属性的目录列表。
例如，如果基础URL是 <a class="reference external" href="http://localhost:15000">http://localhost:15000</a> 并且一个用户执行 <code class="docutils literal"><span class="pre">import</span> <span class="pre">grok</span></code> ,
那么 <code class="docutils literal"><span class="pre">find_loader()</span></code> 返回的path就会是 [ &#8216;<a class="reference external" href="http://localhost:15000/grok">http://localhost:15000/grok</a>&#8216; ]</p>
<p><code class="docutils literal"><span class="pre">find_loader()</span></code> 还要能处理一个命名空间包。
一个命名空间包中有一个合法的包目录名，但是不存在__init__.py文件。
这样的话，<code class="docutils literal"><span class="pre">find_loader()</span></code> 必须返回一个元组(None, path)，
path是一个目录列表，由它来构建包的定义有__init__.py文件的__path__属性。
对于这种情况，导入机制会继续前行去检查sys.path中的目录。
如果找到了命名空间包，所有的结果路径被加到一起来构建最终的命名空间包。
关于命名空间包的更多信息请参考10.5小节。</p>
<p>所有的包都包含了一个内部路径设置，可以在__path__属性中看到，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xml</span><span class="o">.</span><span class="n">__path__</span>
<span class="go">[&#39;/usr/local/lib/python3.3/xml&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xml</span><span class="o">.</span><span class="n">etree</span><span class="o">.</span><span class="n">__path__</span>
<span class="go">[&#39;/usr/local/lib/python3.3/xml/etree&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>之前提到，__path__的设置是通过 <code class="docutils literal"><span class="pre">find_loader()</span></code> 方法返回值控制的。
不过，__path__接下来也被sys.path_hooks中的函数处理。
因此，但包的子组件被加载后，位于__path__中的实体会被 <code class="docutils literal"><span class="pre">handle_url()</span></code> 函数检查。
这会导致新的 <code class="docutils literal"><span class="pre">UrlPathFinder</span></code> 实例被创建并且被加入到 <code class="docutils literal"><span class="pre">sys.path_importer_cache</span></code> 中。</p>
<p>还有个难点就是 <code class="docutils literal"><span class="pre">handle_url()</span></code> 函数以及它跟内部使用的 <code class="docutils literal"><span class="pre">_get_links()</span></code> 函数之间的交互。
如果你的查找器实现需要使用到其他模块（比如urllib.request），
有可能这些模块会在查找器操作期间进行更多的导入。
它可以导致 <code class="docutils literal"><span class="pre">handle_url()</span></code> 和其他查找器部分陷入一种递归循环状态。
为了解释这种可能性，实现中有一个被创建的查找器缓存（每一个URL一个）。
它可以避免创建重复查找器的问题。
另外，下面的代码片段可以确保查找器不会在初始化链接集合的时候响应任何导入请求：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Check link cache</span>
<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># See discussion</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="n">_get_links</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseurl</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，查找器的 <code class="docutils literal"><span class="pre">invalidate_caches()</span></code> 方法是一个工具方法，用来清理内部缓存。
这个方法再用户调用 <code class="docutils literal"><span class="pre">importlib.invalidate_caches()</span></code> 的时候被触发。
如果你想让URL导入者重新读取链接列表的话可以使用它。</p>
<p>对比下两种方案（修改sys.meta_path或使用一个路径钩子）。
使用sys.meta_path的导入者可以按照自己的需要自由处理模块。
例如，它们可以从数据库中导入或以不同于一般模块/包处理方式导入。
这种自由同样意味着导入者需要自己进行内部的一些管理。
另外，基于路径的钩子只是适用于对sys.path的处理。
通过这种扩展加载的模块跟普通方式加载的特性是一样的。</p>
<p>如果到现在为止你还是不是很明白，那么可以通过增加一些日志打印来测试下本节。像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig(level=logging.DEBUG)
&gt;&gt;&gt; import urlimport
&gt;&gt;&gt; urlimport.install_path_hook()
DEBUG:urlimport:Installing handle_url
&gt;&gt;&gt; import fib
DEBUG:urlimport:Handle path? /usr/local/lib/python33.zip. [No]
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named &#39;fib&#39;
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append(&#39;http://localhost:15000&#39;)
&gt;&gt;&gt; import fib
DEBUG:urlimport:Handle path? http://localhost:15000. [Yes]
DEBUG:urlimport:Getting links from http://localhost:15000
DEBUG:urlimport:links: {&#39;spam.py&#39;, &#39;fib.py&#39;, &#39;grok&#39;}
DEBUG:urlimport:find_loader: &#39;fib&#39;
DEBUG:urlimport:find_loader: module &#39;fib&#39; found
DEBUG:urlimport:loader: reading &#39;http://localhost:15000/fib.py&#39;
DEBUG:urlimport:loader: &#39;http://localhost:15000/fib.py&#39; loaded
I&#39;m fib
&gt;&gt;&gt;
</pre></div>
</div>
<p>最后，建议你花点时间看看 <a class="reference external" href="http://www.python.org/dev/peps/pep-0302">PEP 302</a>
以及importlib的文档。</p>
</div>
</div>
<span id="document-c10/p12_patching_modules_on_import"></span><div class="section" id="id1">
<h3>10.12 导入模块的同时修改模块<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想给某个已存在模块中的函数添加装饰器。
不过，前提是这个模块已经被导入并且被使用过。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这里问题的本质就是你想在模块被加载时执行某个动作。
可能是你想在一个模块被加载时触发某个回调函数来通知你。</p>
<p>这个问题可以使用10.11小节中同样的导入钩子机制来实现。下面是一个可能的方案：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># postimport.py</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">_post_import_hooks</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">PostImportFinder</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fullname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PostImportLoader</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">PostImportLoader</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">finder</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finder</span> <span class="o">=</span> <span class="n">finder</span>

    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">fullname</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">_post_import_hooks</span><span class="p">[</span><span class="n">fullname</span><span class="p">]:</span>
            <span class="n">func</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finder</span><span class="o">.</span><span class="n">_skip</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">module</span>

<span class="k">def</span> <span class="nf">when_imported</span><span class="p">(</span><span class="n">fullname</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fullname</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="n">func</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">fullname</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_post_import_hooks</span><span class="p">[</span><span class="n">fullname</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">decorate</span>

<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PostImportFinder</span><span class="p">())</span>
</pre></div>
</div>
<p>这样，你就可以使用 <code class="docutils literal"><span class="pre">when_imported()</span></code> 装饰器了，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">postimport</span> <span class="kn">import</span> <span class="n">when_imported</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@when_imported</span><span class="p">(</span><span class="s1">&#39;threading&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">warn_threads</span><span class="p">(</span><span class="n">mod</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Threads? Are you crazy?&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">threading</span>
<span class="go">Threads? Are you crazy?</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>作为一个更实际的例子，你可能想在已存在的定义上面添加装饰器，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">postimport</span> <span class="kn">import</span> <span class="n">when_imported</span>

<span class="k">def</span> <span class="nf">logged</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Calling&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="c1"># Example</span>
<span class="nd">@when_imported</span><span class="p">(</span><span class="s1">&#39;math&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_logging</span><span class="p">(</span><span class="n">mod</span><span class="p">):</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">cos</span> <span class="o">=</span> <span class="n">logged</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">cos</span><span class="p">)</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">sin</span> <span class="o">=</span> <span class="n">logged</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">sin</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本节技术依赖于10.11小节中讲述过的导入钩子，并稍作修改。</p>
<p><code class="docutils literal"><span class="pre">&#64;when_imported</span></code> 装饰器的作用是注册在导入时被激活的处理器函数。
该装饰器检查sys.modules来查看模块是否真的已经被加载了。
如果是的话，该处理器被立即调用。不然，处理器被添加到 <code class="docutils literal"><span class="pre">_post_import_hooks</span></code> 字典中的一个列表中去。
<code class="docutils literal"><span class="pre">_post_import_hooks</span></code> 的作用就是收集所有的为每个模块注册的处理器对象。
一个模块可以注册多个处理器。</p>
<p>要让模块导入后触发添加的动作，<code class="docutils literal"><span class="pre">PostImportFinder</span></code> 类被设置为sys.meta_path第一个元素。
它会捕获所有模块导入操作。</p>
<p>本节中的 <code class="docutils literal"><span class="pre">PostImportFinder</span></code> 的作用并不是加载模块，而是自带导入完成后触发相应的动作。
实际的导入被委派给位于sys.meta_path中的其他查找器。
<code class="docutils literal"><span class="pre">PostImportLoader</span></code> 类中的 <code class="docutils literal"><span class="pre">imp.import_module()</span></code> 函数被递归的调用。
为了避免陷入无线循环，<code class="docutils literal"><span class="pre">PostImportFinder</span></code> 保持了一个所有被加载过的模块集合。
如果一个模块名存在就会直接被忽略掉。</p>
<p>当一个模块被 <code class="docutils literal"><span class="pre">imp.import_module()</span></code> 加载后，
所有在_post_import_hooks被注册的处理器被调用，使用新加载模块作为一个参数。</p>
<p>有一点需要注意的是本机不适用于那些通过 <code class="docutils literal"><span class="pre">imp.reload()</span></code> 被显式加载的模块。
也就是说，如果你加载一个之前已被加载过的模块，那么导入处理器将不会再被触发。
另外，要是你从sys.modules中删除模块然后再重新导入，处理器又会再一次触发。</p>
<p>更多关于导入后钩子信息请参考 <a class="reference external" href="https://www.python.org/dev/peps/pep-0369">PEP 369</a>.</p>
</div>
</div>
<span id="document-c10/p13_installing_packages_just_for_yourself"></span><div class="section" id="id1">
<h3>10.13 安装私有的包<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想要安装一个第三方包，但是没有权限将它安装到系统Python库中去。
或者，你可能想要安装一个供自己使用的包，而不是系统上面所有用户。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python有一个用户安装目录，通常类似&#8221;~/.local/lib/python3.3/site-packages&#8221;。
要强制在这个目录中安装包，可使用安装选项“&#8211;user”。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">python3</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span>
</pre></div>
</div>
<p>或者</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span> <span class="n">packagename</span>
</pre></div>
</div>
<p>在sys.path中用户的“site-packages”目录位于系统的“site-packages”目录之前。
因此，你安装在里面的包就比系统已安装的包优先级高
（尽管并不总是这样，要取决于第三方包管理器，比如distribute或pip）。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>通常包会被安装到系统的site-packages目录中去，路径类似“/usr/local/lib/python3.3/site-packages”。
不过，这样做需要有管理员权限并且使用sudo命令。
就算你有这样的权限去执行命令，使用sudo去安装一个新的，可能没有被验证过的包有时候也不安全。</p>
<p>安装包到用户目录中通常是一个有效的方案，它允许你创建一个自定义安装。</p>
<p>另外，你还可以创建一个虚拟环境，这个我们在下一节会讲到。</p>
</div>
</div>
<span id="document-c10/p14_creating_new_python_environment"></span><div class="section" id="python">
<h3>10.14 创建新的Python环境<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想创建一个新的Python环境，用来安装模块和包。
不过，你不想安装一个新的Python克隆，也不想对系统Python环境产生影响。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你可以使用 <code class="docutils literal"><span class="pre">pyvenv</span></code> 命令创建一个新的“虚拟”环境。
这个命令被安装在Python解释器同一目录，或Windows上面的Scripts目录中。下面是一个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">pyvenv</span> <span class="n">Spam</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
<p>传给 <code class="docutils literal"><span class="pre">pyvenv</span></code> 命令的名字是将要被创建的目录名。当被创建后，Span目录像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">cd</span> <span class="n">Spam</span>
<span class="n">bash</span> <span class="o">%</span> <span class="n">ls</span>
<span class="nb">bin</span> <span class="n">include</span> <span class="n">lib</span> <span class="n">pyvenv</span><span class="o">.</span><span class="n">cfg</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
<p>在bin目录中，你会找到一个可以使用的Python解释器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">Spam</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">python3</span>
<span class="n">Python</span> <span class="mf">3.3</span><span class="o">.</span><span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">Oct</span> <span class="mi">6</span> <span class="mi">2012</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>
<span class="p">[</span><span class="n">GCC</span> <span class="mf">4.2</span><span class="o">.</span><span class="mi">1</span> <span class="p">(</span><span class="n">Apple</span> <span class="n">Inc</span><span class="o">.</span> <span class="n">build</span> <span class="mi">5666</span><span class="p">)</span> <span class="p">(</span><span class="n">dot</span> <span class="mi">3</span><span class="p">)]</span> <span class="n">on</span> <span class="n">darwin</span>
<span class="n">Type</span> <span class="s2">&quot;help&quot;</span><span class="p">,</span> <span class="s2">&quot;copyright&quot;</span><span class="p">,</span> <span class="s2">&quot;credits&quot;</span> <span class="ow">or</span> <span class="s2">&quot;license&quot;</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
<span class="s1">&#39;/usr/local/lib/python33.zip&#39;</span><span class="p">,</span>
<span class="s1">&#39;/usr/local/lib/python3.3&#39;</span><span class="p">,</span>
<span class="s1">&#39;/usr/local/lib/python3.3/plat-darwin&#39;</span><span class="p">,</span>
<span class="s1">&#39;/usr/local/lib/python3.3/lib-dynload&#39;</span><span class="p">,</span>
<span class="s1">&#39;/Users/beazley/Spam/lib/python3.3/site-packages&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这个解释器的特点就是他的site-packages目录被设置为新创建的环境。
如果你要安装第三方包，它们会被安装在那里，而不是通常系统的site-packages目录。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>创建虚拟环境通常是为了安装和管理第三方包。
正如你在例子中看到的那样，<code class="docutils literal"><span class="pre">sys.path</span></code> 变量包含来自于系统Python的目录，
而 site-packages目录已经被重定位到一个新的目录。</p>
<p>有了一个新的虚拟环境，下一步就是安装一个包管理器，比如distribute或pip。
但安装这样的工具和包的时候，你需要确保你使用的是虚拟环境的解释器。
它会将包安装到新创建的site-packages目录中去。</p>
<p>尽管一个虚拟环境看上去是Python安装的一个复制，
不过它实际上只包含了少量几个文件和一些符号链接。
所有标准库函文件和可执行解释器都来自原来的Python安装。
因此，创建这样的环境是很容易的，并且几乎不会消耗机器资源。</p>
<p>默认情况下，虚拟环境是空的，不包含任何额外的第三方库。如果你想将一个已经安装的包作为虚拟环境的一部分，
可以使用“&#8211;system-site-packages”选项来创建虚拟环境，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">pyvenv</span> <span class="o">--</span><span class="n">system</span><span class="o">-</span><span class="n">site</span><span class="o">-</span><span class="n">packages</span> <span class="n">Spam</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
<p>跟多关于 <code class="docutils literal"><span class="pre">pyvenv</span></code> 和虚拟环境的信息可以参考
<a class="reference external" href="https://www.python.org/dev/peps/pep-0405/">PEP 405</a>.</p>
</div>
</div>
<span id="document-c10/p15_distributing_packages"></span><div class="section" id="id1">
<h3>10.15 分发包<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你已经编写了一个有用的库，想将它分享给其他人。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你想分发你的代码，第一件事就是给它一个唯一的名字，并且清理它的目录结构。
例如，一个典型的函数库包会类似下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">projectname</span><span class="o">/</span>
    <span class="n">README</span><span class="o">.</span><span class="n">txt</span>
    <span class="n">Doc</span><span class="o">/</span>
        <span class="n">documentation</span><span class="o">.</span><span class="n">txt</span>
    <span class="n">projectname</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">py</span>
        <span class="n">bar</span><span class="o">.</span><span class="n">py</span>
        <span class="n">utils</span><span class="o">/</span>
            <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
            <span class="n">spam</span><span class="o">.</span><span class="n">py</span>
            <span class="n">grok</span><span class="o">.</span><span class="n">py</span>
    <span class="n">examples</span><span class="o">/</span>
        <span class="n">helloworld</span><span class="o">.</span><span class="n">py</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>要让你的包可以发布出去，首先你要编写一个 <code class="docutils literal"><span class="pre">setup.py</span></code> ，类似下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># setup.py</span>
<span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;projectname&#39;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s1">&#39;1.0&#39;</span><span class="p">,</span>
    <span class="n">author</span><span class="o">=</span><span class="s1">&#39;Your Name&#39;</span><span class="p">,</span>
    <span class="n">author_email</span><span class="o">=</span><span class="s1">&#39;you@youraddress.com&#39;</span><span class="p">,</span>
    <span class="n">url</span><span class="o">=</span><span class="s1">&#39;http://www.you.com/projectname&#39;</span><span class="p">,</span>
    <span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;projectname&#39;</span><span class="p">,</span> <span class="s1">&#39;projectname.utils&#39;</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>下一步，就是创建一个 <code class="docutils literal"><span class="pre">MANIFEST.in</span></code> 文件，列出所有在你的包中需要包含进来的非源码文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># MANIFEST.in</span>
<span class="n">include</span> <span class="o">*.</span><span class="n">txt</span>
<span class="n">recursive</span><span class="o">-</span><span class="n">include</span> <span class="n">examples</span> <span class="o">*</span>
<span class="n">recursive</span><span class="o">-</span><span class="n">include</span> <span class="n">Doc</span> <span class="o">*</span>
</pre></div>
</div>
<p>确保 <code class="docutils literal"><span class="pre">setup.py</span></code> 和 <code class="docutils literal"><span class="pre">MANIFEST.in</span></code> 文件放在你的包的最顶级目录中。
一旦你已经做了这些，你就可以像下面这样执行命令来创建一个源码分发包了：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">bash</span> <span class="n">python3</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">sdist</span>
</pre></div>
</div>
<p>它会创建一个文件比如&#8221;projectname-1.0.zip&#8221; 或 “projectname-1.0.tar.gz”,
具体依赖于你的系统平台。如果一切正常，
这个文件就可以发送给别人使用或者上传至 <a class="reference external" href="http://pypi.python.org/">Python Package Index</a>.</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>对于纯Python代码，编写一个普通的 <code class="docutils literal"><span class="pre">setup.py</span></code> 文件通常很简单。
一个可能的问题是你必须手动列出所有构成包源码的子目录。
一个常见错误就是仅仅只列出一个包的最顶级目录，忘记了包含包的子组件。
这也是为什么在 <code class="docutils literal"><span class="pre">setup.py</span></code> 中对于包的说明包含了列表
<code class="docutils literal"><span class="pre">packages=['projectname',</span> <span class="pre">'projectname.utils']</span></code></p>
<p>大部分Python程序员都知道，有很多第三方包管理器供选择，包括setuptools、distribute等等。
有些是为了替代标准库中的distutils。注意如果你依赖这些包，
用户可能不能安装你的软件，除非他们已经事先安装过所需要的包管理器。
正因如此，你更应该时刻记住越简单越好的道理。
最好让你的代码使用标准的Python 3安装。
如果其他包也需要的话，可以通过一个可选项来支持。</p>
<p>对于涉及到C扩展的代码打包与分发就更复杂点了。
第15章对关于C扩展的这方面知识有一些详细讲解，特别是在15.2小节中。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p11_network_and_web_program"></span><div class="section" id="web">
<h2>第十一章：网络与Web编程<a class="headerlink" href="#web" title="永久链接至标题">¶</a></h2>
<p>本章是关于在网络应用和分布式应用中使用的各种主题。主题划分为使用Python编写客户端程序来访问已有的服务，以及使用Python实现网络服务端程序。也给出了一些常见的技术，用于编写涉及协同或通信的的代码。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c11/p01_interact_with_http_services_as_client"></span><div class="section" id="http">
<h3>11.1 作为客户端与HTTP服务交互<a class="headerlink" href="#http" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你需要通过HTTP协议以客户端的方式访问多种服务。例如，下载数据或者与基于REST的API进行交互。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>对于简单的事情来说，通常使用 <code class="docutils literal"><span class="pre">urllib.request</span></code> 模块就够了。例如，发送一个简单的HTTP GET请求到远程的服务上，可以这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">request</span><span class="p">,</span> <span class="n">parse</span>

<span class="c1"># Base URL being accessed</span>
<span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://httpbin.org/get&#39;</span>

<span class="c1"># Dictionary of query parameters (if any)</span>
<span class="n">parms</span> <span class="o">=</span> <span class="p">{</span>
   <span class="s1">&#39;name1&#39;</span> <span class="p">:</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span>
   <span class="s1">&#39;name2&#39;</span> <span class="p">:</span> <span class="s1">&#39;value2&#39;</span>
<span class="p">}</span>

<span class="c1"># Encode the query string</span>
<span class="n">querystring</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">(</span><span class="n">parms</span><span class="p">)</span>

<span class="c1"># Make a GET request and read the response</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="o">+</span><span class="s1">&#39;?&#39;</span> <span class="o">+</span> <span class="n">querystring</span><span class="p">)</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你需要使用POST方法在请求主体中发送查询参数，可以将参数编码后作为可选参数提供给 <code class="docutils literal"><span class="pre">urlopen()</span></code> 函数，就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">request</span><span class="p">,</span> <span class="n">parse</span>

<span class="c1"># Base URL being accessed</span>
<span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://httpbin.org/post&#39;</span>

<span class="c1"># Dictionary of query parameters (if any)</span>
<span class="n">parms</span> <span class="o">=</span> <span class="p">{</span>
   <span class="s1">&#39;name1&#39;</span> <span class="p">:</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span>
   <span class="s1">&#39;name2&#39;</span> <span class="p">:</span> <span class="s1">&#39;value2&#39;</span>
<span class="p">}</span>

<span class="c1"># Encode the query string</span>
<span class="n">querystring</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">(</span><span class="n">parms</span><span class="p">)</span>

<span class="c1"># Make a POST request and read the response</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">querystring</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你需要在发出的请求中提供一些自定义的HTTP头，例如修改 <code class="docutils literal"><span class="pre">user-agent</span></code> 字段,可以创建一个包含字段值的字典，并创建一个Request实例然后将其传给 <code class="docutils literal"><span class="pre">urlopen()</span></code> ，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">request</span><span class="p">,</span> <span class="n">parse</span>
<span class="o">...</span>

<span class="c1"># Extra headers</span>
<span class="n">headers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;User-agent&#39;</span> <span class="p">:</span> <span class="s1">&#39;none/ofyourbusiness&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Spam&#39;</span> <span class="p">:</span> <span class="s1">&#39;Eggs&#39;</span>
<span class="p">}</span>

<span class="n">req</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">querystring</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span> <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>

<span class="c1"># Make a request and read the response</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>如果需要交互的服务比上面的例子都要复杂，也许应该去看看 requests 库（<a class="reference external" href="https://pypi.python.org/pypi/requests">https://pypi.python.org/pypi/requests</a>）。例如，下面这个示例采用requests库重新实现了上面的操作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">requests</span>

<span class="c1"># Base URL being accessed</span>
<span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://httpbin.org/post&#39;</span>

<span class="c1"># Dictionary of query parameters (if any)</span>
<span class="n">parms</span> <span class="o">=</span> <span class="p">{</span>
   <span class="s1">&#39;name1&#39;</span> <span class="p">:</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span>
   <span class="s1">&#39;name2&#39;</span> <span class="p">:</span> <span class="s1">&#39;value2&#39;</span>
<span class="p">}</span>

<span class="c1"># Extra headers</span>
<span class="n">headers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;User-agent&#39;</span> <span class="p">:</span> <span class="s1">&#39;none/ofyourbusiness&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Spam&#39;</span> <span class="p">:</span> <span class="s1">&#39;Eggs&#39;</span>
<span class="p">}</span>

<span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">parms</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>

<span class="c1"># Decoded text returned by the request</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">text</span>
</pre></div>
</div>
<p>关于requests库，一个值得一提的特性就是它能以多种方式从请求中返回响应结果的内容。从上面的代码来看， <code class="docutils literal"><span class="pre">resp.text</span></code> 带给我们的是以Unicode解码的响应文本。但是，如果去访问 <code class="docutils literal"><span class="pre">resp.content</span></code> ，就会得到原始的二进制数据。另一方面，如果访问 <code class="docutils literal"><span class="pre">resp.json</span></code> ，那么就会得到JSON格式的响应内容。</p>
<p>下面这个示例利用 <code class="docutils literal"><span class="pre">requests</span></code> 库发起一个HEAD请求，并从响应中提取出一些HTTP头数据的字段：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">requests</span>

<span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/index.html&#39;</span><span class="p">)</span>

<span class="n">status</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span>
<span class="n">last_modified</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">&#39;last-modified&#39;</span><span class="p">]</span>
<span class="n">content_type</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">&#39;content-type&#39;</span><span class="p">]</span>
<span class="n">content_length</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">&#39;content-length&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>下面是一个利用requests通过基本认证登录Pypi的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">requests</span>

<span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;http://pypi.python.org/pypi?:action=login&#39;</span><span class="p">,</span>
                    <span class="n">auth</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span><span class="s1">&#39;password&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>下面是一个利用requests将HTTP cookies从一个请求传递到另一个的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">requests</span>

<span class="c1"># First request</span>
<span class="n">resp1</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="o">...</span>

<span class="c1"># Second requests with cookies received on first requests</span>
<span class="n">resp2</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">cookies</span><span class="o">=</span><span class="n">resp1</span><span class="o">.</span><span class="n">cookies</span><span class="p">)</span>
</pre></div>
</div>
<p>最后但并非最不重要的一个例子是用requests上传内容：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">requests</span>
<span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://httpbin.org/post&#39;</span>
<span class="n">files</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;data.csv&#39;</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span> <span class="p">}</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于真的很简单HTTP客户端代码，用内置的 <code class="docutils literal"><span class="pre">urllib</span></code> 模块通常就足够了。但是，如果你要做的不仅仅只是简单的GET或POST请求，那就真的不能再依赖它的功能了。这时候就是第三方模块比如 <code class="docutils literal"><span class="pre">requests</span></code> 大显身手的时候了。</p>
<p>例如，如果你决定坚持使用标准的程序库而不考虑像 <code class="docutils literal"><span class="pre">requests</span></code> 这样的第三方库，那么也许就不得不使用底层的 <code class="docutils literal"><span class="pre">http.client</span></code> 模块来实现自己的代码。比方说，下面的代码展示了如何执行一个HEAD请求：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">http.client</span> <span class="kn">import</span> <span class="n">HTTPConnection</span>
<span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">parse</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">HTTPConnection</span><span class="p">(</span><span class="s1">&#39;www.python.org&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s1">&#39;HEAD&#39;</span><span class="p">,</span> <span class="s1">&#39;/index.html&#39;</span><span class="p">)</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getresponse</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Status&#39;</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">resp</span><span class="o">.</span><span class="n">getheaders</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>同样地，如果必须编写涉及代理、认证、cookies以及其他一些细节方面的代码，那么使用 <code class="docutils literal"><span class="pre">urllib</span></code> 就显得特别别扭和啰嗦。比方说，下面这个示例实现在Python包索引上的认证：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>

<span class="n">auth</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s1">&#39;pypi&#39;</span><span class="p">,</span><span class="s1">&#39;http://pypi.python.org&#39;</span><span class="p">,</span><span class="s1">&#39;username&#39;</span><span class="p">,</span><span class="s1">&#39;password&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth</span><span class="p">)</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">&#39;http://pypi.python.org/pypi?:action=login&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># From here. You can access more pages using opener</span>
<span class="o">...</span>
</pre></div>
</div>
<p>坦白说，所有的这些操作在 <code class="docutils literal"><span class="pre">requests</span></code> 库中都变得简单的多。</p>
<p>在开发过程中测试HTTP客户端代码常常是很令人沮丧的，因为所有棘手的细节问题都需要考虑（例如cookies、认证、HTTP头、编码方式等）。要完成这些任务，考虑使用httpbin服务（<a class="reference external" href="http://httpbin.org">http://httpbin.org</a>）。这个站点会接收发出的请求，然后以JSON的形式将相应信息回传回来。下面是一个交互式的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">requests</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;http://httpbin.org/get?name=Dave&amp;n=37&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headers</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;User-agent&#39;</span><span class="p">:</span> <span class="s1">&#39;goaway/1.0&#39;</span> <span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resp</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resp</span><span class="p">[</span><span class="s1">&#39;headers&#39;</span><span class="p">]</span>
<span class="go">{&#39;User-Agent&#39;: &#39;goaway/1.0&#39;, &#39;Content-Length&#39;: &#39;&#39;, &#39;Content-Type&#39;: &#39;&#39;,</span>
<span class="go">&#39;Accept-Encoding&#39;: &#39;gzip, deflate, compress&#39;, &#39;Connection&#39;:</span>
<span class="go">&#39;keep-alive&#39;, &#39;Host&#39;: &#39;httpbin.org&#39;, &#39;Accept&#39;: &#39;*/*&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resp</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>
<span class="go">{&#39;name&#39;: &#39;Dave&#39;, &#39;n&#39;: &#39;37&#39;}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在要同一个真正的站点进行交互前，先在 httpbin.org 这样的网站上做实验常常是可取的办法。尤其是当我们面对3次登录失败就会关闭账户这样的风险时尤为有用（不要尝试自己编写HTTP认证客户端来登录你的银行账户）。</p>
<p>尽管本节没有涉及， <code class="docutils literal"><span class="pre">request</span></code> 库还对许多高级的HTTP客户端协议提供了支持，比如OAuth。 <code class="docutils literal"><span class="pre">requests</span></code> 模块的文档（<a class="reference external" href="http://docs.python-requests.org">http://docs.python-requests.org</a>)质量很高（坦白说比在这短短的一节的篇幅中所提供的任何信息都好），可以参考文档以获得更多地信息。</p>
</div>
</div>
<span id="document-c11/p02_creating_tcp_server"></span><div class="section" id="tcp">
<h3>11.2 创建TCP服务器<a class="headerlink" href="#tcp" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想实现一个服务器，通过TCP协议和客户端通信。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>创建一个TCP服务器的一个简单方法是使用 <code class="docutils literal"><span class="pre">socketserver</span></code> 库。例如，下面是一个简单的应答服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socketserver</span> <span class="kn">import</span> <span class="n">BaseRequestHandler</span><span class="p">,</span> <span class="n">TCPServer</span>

<span class="k">class</span> <span class="nc">EchoHandler</span><span class="p">(</span><span class="n">BaseRequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">),</span> <span class="n">EchoHandler</span><span class="p">)</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>在这段代码中，你定义了一个特殊的处理类，实现了一个 <code class="docutils literal"><span class="pre">handle()</span></code> 方法，用来为客户端连接服务。
<code class="docutils literal"><span class="pre">request</span></code> 属性是客户端socket，<code class="docutils literal"><span class="pre">client_address</span></code> 有客户端地址。
为了测试这个服务器，运行它并打开另外一个Python进程连接这个服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>很多时候，可以很容易的定义一个不同的处理器。下面是一个使用 <code class="docutils literal"><span class="pre">StreamRequestHandler</span></code>
基类将一个类文件接口放置在底层socket上的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socketserver</span> <span class="kn">import</span> <span class="n">StreamRequestHandler</span><span class="p">,</span> <span class="n">TCPServer</span>

<span class="k">class</span> <span class="nc">EchoHandler</span><span class="p">(</span><span class="n">StreamRequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>
        <span class="c1"># self.rfile is a file-like object for reading</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span><span class="p">:</span>
            <span class="c1"># self.wfile is a file-like object for writing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">),</span> <span class="n">EchoHandler</span><span class="p">)</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">socketserver</span></code> 可以让我们很容易的创建简单的TCP服务器。
但是，你需要注意的是，默认情况下这种服务器是单线程的，一次只能为一个客户端连接服务。
如果你想处理多个客户端，可以初始化一个 <code class="docutils literal"><span class="pre">ForkingTCPServer</span></code> 或者是 <code class="docutils literal"><span class="pre">ThreadingTCPServer</span></code> 对象。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socketserver</span> <span class="kn">import</span> <span class="n">ThreadingTCPServer</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">ThreadingTCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">),</span> <span class="n">EchoHandler</span><span class="p">)</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>使用fork或线程服务器有个潜在问题就是它们会为每个客户端连接创建一个新的进程或线程。
由于客户端连接数是没有限制的，因此一个恶意的黑客可以同时发送大量的连接让你的服务器奔溃。</p>
<p>如果你担心这个问题，你可以创建一个预先分配大小的工作线程池或进程池。
你先创建一个普通的非线程服务器，然后在一个线程池中使用 <code class="docutils literal"><span class="pre">serve_forever()</span></code> 方法来启动它们。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
    <span class="n">NWORKERS</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">),</span> <span class="n">EchoHandler</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NWORKERS</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>一般来讲，一个 <code class="docutils literal"><span class="pre">TCPServer</span></code> 在实例化的时候会绑定并激活相应的 <code class="docutils literal"><span class="pre">socket</span></code> 。
不过，有时候你想通过设置某些选项去调整底下的 <cite>socket`</cite> ，可以设置参数 <code class="docutils literal"><span class="pre">bind_and_activate=False</span></code> 。如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">),</span> <span class="n">EchoHandler</span><span class="p">,</span> <span class="n">bind_and_activate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="c1"># Set up various socket options</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="c1"># Bind and activate</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">server_bind</span><span class="p">()</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">server_activate</span><span class="p">()</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>上面的 <code class="docutils literal"><span class="pre">socket</span></code> 选项是一个非常普遍的配置项，它允许服务器重新绑定一个之前使用过的端口号。
由于要被经常使用到，它被放置到类变量中，可以直接在 <code class="docutils literal"><span class="pre">TCPServer</span></code> 上面设置。
在实例化服务器的时候去设置它的值，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">TCPServer</span><span class="o">.</span><span class="n">allow_reuse_address</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">),</span> <span class="n">EchoHandler</span><span class="p">)</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>在上面示例中，我们演示了两种不同的处理器基类（ <code class="docutils literal"><span class="pre">BaseRequestHandler</span></code> 和 <code class="docutils literal"><span class="pre">StreamRequestHandler</span></code> ）。
<code class="docutils literal"><span class="pre">StreamRequestHandler</span></code> 更加灵活点，能通过设置其他的类变量来支持一些新的特性。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>

<span class="k">class</span> <span class="nc">EchoHandler</span><span class="p">(</span><span class="n">StreamRequestHandler</span><span class="p">):</span>
    <span class="c1"># Optional settings (defaults shown)</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5</span>                      <span class="c1"># Timeout on all socket operations</span>
    <span class="n">rbufsize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>                    <span class="c1"># Read buffer size</span>
    <span class="n">wbufsize</span> <span class="o">=</span> <span class="mi">0</span>                     <span class="c1"># Write buffer size</span>
    <span class="n">disable_nagle_algorithm</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># Sets TCP_NODELAY socket option</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span><span class="p">:</span>
                <span class="c1"># self.wfile is a file-like object for writing</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">timeout</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Timed out!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，还需要注意的是巨大部分Python的高层网络模块（比如HTTP、XML-RPC等）都是建立在 <code class="docutils literal"><span class="pre">socketserver</span></code> 功能之上。
也就是说，直接使用 <code class="docutils literal"><span class="pre">socket</span></code> 库来实现服务器也并不是很难。
下面是一个使用 <code class="docutils literal"><span class="pre">socket</span></code> 直接编程实现的一个服务器简单例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="k">def</span> <span class="nf">echo_handler</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">client_sock</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">address</span><span class="p">))</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">client_sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">client_sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">client_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">backlog</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">backlog</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">echo_handler</span><span class="p">(</span><span class="n">client_addr</span><span class="p">,</span> <span class="n">client_sock</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">echo_server</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c11/p03_creating_udp_server"></span><div class="section" id="udp">
<h3>11.3 创建UDP服务器<a class="headerlink" href="#udp" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想实现一个基于UDP协议的服务器来与客户端通信。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>跟TCP一样，UDP服务器也可以通过使用 <code class="docutils literal"><span class="pre">socketserver</span></code> 库很容易的被创建。
例如，下面是一个简单的时间服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socketserver</span> <span class="kn">import</span> <span class="n">BaseRequestHandler</span><span class="p">,</span> <span class="n">UDPServer</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">TimeHandler</span><span class="p">(</span><span class="n">BaseRequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>
        <span class="c1"># Get message and client socket</span>
        <span class="n">msg</span><span class="p">,</span> <span class="n">sock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">UDPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">),</span> <span class="n">TimeHandler</span><span class="p">)</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>跟之前一样，你先定义一个实现 <code class="docutils literal"><span class="pre">handle()</span></code> 特殊方法的类，为客户端连接服务。
这个类的 <code class="docutils literal"><span class="pre">request</span></code> 属性是一个包含了数据报和底层socket对象的元组。<code class="docutils literal"><span class="pre">client_address</span></code> 包含了客户端地址。</p>
<p>我们来测试下这个服务器，首先运行它，然后打开另外一个Python进程向服务器发送消息：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
<span class="go">(b&#39;Wed Aug 15 20:35:08 2012&#39;, (&#39;127.0.0.1&#39;, 20000))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>一个典型的UDP服务器接收到达的数据报(消息)和客户端地址。如果服务器需要做应答，
它要给客户端回发一个数据报。对于数据报的传送，
你应该使用socket的 <code class="docutils literal"><span class="pre">sendto()</span></code> 和 <code class="docutils literal"><span class="pre">recvfrom()</span></code> 方法。
尽管传统的 <code class="docutils literal"><span class="pre">send()</span></code> 和 <code class="docutils literal"><span class="pre">recv()</span></code> 也可以达到同样的效果，
但是前面的两个方法对于UDP连接而言更普遍。</p>
<p>由于没有底层的连接，UPD服务器相对于TCP服务器来讲实现起来更加简单。
不过，UDP天生是不可靠的（因为通信没有建立连接，消息可能丢失）。
因此需要由你自己来决定该怎样处理丢失消息的情况。这个已经不在本书讨论范围内了，
不过通常来说，如果可靠性对于你程序很重要，你需要借助于序列号、重试、超时以及一些其他方法来保证。
UDP通常被用在那些对于可靠传输要求不是很高的场合。例如，在实时应用如多媒体流以及游戏领域，
无需返回恢复丢失的数据包（程序只需简单的忽略它并继续向前运行）。</p>
<p><code class="docutils literal"><span class="pre">UDPServer</span></code> 类是单线程的，也就是说一次只能为一个客户端连接服务。
实际使用中，这个无论是对于UDP还是TCP都不是什么大问题。
如果你想要并发操作，可以实例化一个 <code class="docutils literal"><span class="pre">ForkingUDPServer</span></code> 或 <code class="docutils literal"><span class="pre">ThreadingUDPServer</span></code> 对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socketserver</span> <span class="kn">import</span> <span class="n">ThreadingUDPServer</span>

   <span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">ThreadingUDPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">20000</span><span class="p">),</span> <span class="n">TimeHandler</span><span class="p">)</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>直接使用 <code class="docutils literal"><span class="pre">socket</span></code> 来实现一个UDP服务器也不难，下面是一个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">time_server</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got message from&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span> <span class="n">addr</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">time_server</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c11/p04_generate_range_of_ip_addresses_from_cidr_address"></span><div class="section" id="cidrip">
<h3>11.4 通过CIDR地址生成对应的IP地址集<a class="headerlink" href="#cidrip" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你有一个CIDR网络地址比如“123.45.67.89/27”，你想将其转换成它所代表的所有IP
（比如，“123.45.67.64”, “123.45.67.65”, …, “123.45.67.95”)）</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>可以使用 <code class="docutils literal"><span class="pre">ipaddress</span></code> 模块很容易的实现这样的计算。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ipaddress</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net</span> <span class="o">=</span> <span class="n">ipaddress</span><span class="o">.</span><span class="n">ip_network</span><span class="p">(</span><span class="s1">&#39;123.45.67.64/27&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net</span>
<span class="go">IPv4Network(&#39;123.45.67.64/27&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">net</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">123.45.67.64</span>
<span class="go">123.45.67.65</span>
<span class="go">123.45.67.66</span>
<span class="go">123.45.67.67</span>
<span class="go">123.45.67.68</span>
<span class="gp">...</span>
<span class="go">123.45.67.95</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">net6</span> <span class="o">=</span> <span class="n">ipaddress</span><span class="o">.</span><span class="n">ip_network</span><span class="p">(</span><span class="s1">&#39;12:3456:78:90ab:cd:ef01:23:30/125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net6</span>
<span class="go">IPv6Network(&#39;12:3456:78:90ab:cd:ef01:23:30/125&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">net6</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">12:3456:78:90ab:cd:ef01:23:30</span>
<span class="go">12:3456:78:90ab:cd:ef01:23:31</span>
<span class="go">12:3456:78:90ab:cd:ef01:23:32</span>
<span class="go">12:3456:78:90ab:cd:ef01:23:33</span>
<span class="go">12:3456:78:90ab:cd:ef01:23:34</span>
<span class="go">12:3456:78:90ab:cd:ef01:23:35</span>
<span class="go">12:3456:78:90ab:cd:ef01:23:36</span>
<span class="go">12:3456:78:90ab:cd:ef01:23:37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Network</span></code> 也允许像数组一样的索引取值，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">net</span><span class="o">.</span><span class="n">num_addresses</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="go">IPv4Address(&#39;123.45.67.64&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">IPv4Address(&#39;123.45.67.65&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">IPv4Address(&#39;123.45.67.95&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">IPv4Address(&#39;123.45.67.94&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外，你还可以执行网络成员检查之类的操作：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ipaddress</span><span class="o">.</span><span class="n">ip_address</span><span class="p">(</span><span class="s1">&#39;123.45.67.69&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">in</span> <span class="n">net</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">ipaddress</span><span class="o">.</span><span class="n">ip_address</span><span class="p">(</span><span class="s1">&#39;123.45.67.123&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="ow">in</span> <span class="n">net</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一个IP地址和网络地址能通过一个IP接口来指定，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inet</span> <span class="o">=</span> <span class="n">ipaddress</span><span class="o">.</span><span class="n">ip_interface</span><span class="p">(</span><span class="s1">&#39;123.45.67.73/27&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inet</span><span class="o">.</span><span class="n">network</span>
<span class="go">IPv4Network(&#39;123.45.67.64/27&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inet</span><span class="o">.</span><span class="n">ip</span>
<span class="go">IPv4Address(&#39;123.45.67.73&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">ipaddress</span></code> 模块有很多类可以表示IP地址、网络和接口。
当你需要操作网络地址（比如解析、打印、验证等）的时候会很有用。</p>
<p>要注意的是，<code class="docutils literal"><span class="pre">ipaddress</span></code> 模块跟其他一些和网络相关的模块比如 <code class="docutils literal"><span class="pre">socket</span></code> 库交集很少。
所以，你不能使用 <code class="docutils literal"><span class="pre">IPv4Address</span></code> 的实例来代替一个地址字符串，你首先得显式的使用 <code class="docutils literal"><span class="pre">str()</span></code> 转换它。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ipaddress</span><span class="o">.</span><span class="n">ip_address</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="mi">8080</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">Can&#39;t convert &#39;IPv4Address&#39; object to str implicitly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="mi">8080</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>更多相关内容，请参考 <a class="reference external" href="https://docs.python.org/3/howto/ipaddress.html">An Introduction to the ipaddress Module</a></p>
</div>
</div>
<span id="document-c11/p05_creating_simple_rest_based_interface"></span><div class="section" id="rest">
<h3>11.5 创建一个简单的REST接口<a class="headerlink" href="#rest" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想使用一个简单的REST接口通过网络远程控制或访问你的应用程序，但是你又不想自己去安装一个完整的web框架。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>构建一个REST风格的接口最简单的方法是创建一个基于WSGI标准（PEP 3333）的很小的库，下面是一个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># resty.py</span>

<span class="kn">import</span> <span class="nn">cgi</span>

<span class="k">def</span> <span class="nf">notfound_404</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;404 Not Found&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;Content-type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">)</span> <span class="p">])</span>
    <span class="k">return</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;Not Found&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">PathDispatcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pathmap</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">environ</span><span class="p">[</span><span class="s1">&#39;PATH_INFO&#39;</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">cgi</span><span class="o">.</span><span class="n">FieldStorage</span><span class="p">(</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;wsgi.input&#39;</span><span class="p">],</span>
                                  <span class="n">environ</span><span class="o">=</span><span class="n">environ</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">environ</span><span class="p">[</span><span class="s1">&#39;REQUEST_METHOD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">environ</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span><span class="p">:</span> <span class="n">params</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">params</span> <span class="p">}</span>
        <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathmap</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">method</span><span class="p">,</span><span class="n">path</span><span class="p">),</span> <span class="n">notfound_404</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pathmap</span><span class="p">[</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span>
        <span class="k">return</span> <span class="n">function</span>
</pre></div>
</div>
<p>为了使用这个调度器，你只需要编写不同的处理器，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="n">_hello_resp</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s1">&lt;html&gt;</span>
<span class="s1">  &lt;head&gt;</span>
<span class="s1">     &lt;title&gt;Hello {name}&lt;/title&gt;</span>
<span class="s1">   &lt;/head&gt;</span>
<span class="s1">   &lt;body&gt;</span>
<span class="s1">     &lt;h1&gt;Hello {name}!&lt;/h1&gt;</span>
<span class="s1">   &lt;/body&gt;</span>
<span class="s1">&lt;/html&gt;&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;Content-type&#39;</span><span class="p">,</span><span class="s1">&#39;text/html&#39;</span><span class="p">)])</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">environ</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">_hello_resp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
    <span class="k">yield</span> <span class="n">resp</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

<span class="n">_localtime_resp</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s1">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="s1">&lt;time&gt;</span>
<span class="s1">  &lt;year&gt;{t.tm_year}&lt;/year&gt;</span>
<span class="s1">  &lt;month&gt;{t.tm_mon}&lt;/month&gt;</span>
<span class="s1">  &lt;day&gt;{t.tm_mday}&lt;/day&gt;</span>
<span class="s1">  &lt;hour&gt;{t.tm_hour}&lt;/hour&gt;</span>
<span class="s1">  &lt;minute&gt;{t.tm_min}&lt;/minute&gt;</span>
<span class="s1">  &lt;second&gt;{t.tm_sec}&lt;/second&gt;</span>
<span class="s1">&lt;/time&gt;&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">localtime</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;Content-type&#39;</span><span class="p">,</span> <span class="s1">&#39;application/xml&#39;</span><span class="p">)</span> <span class="p">])</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">_localtime_resp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">())</span>
    <span class="k">yield</span> <span class="n">resp</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">resty</span> <span class="kn">import</span> <span class="n">PathDispatcher</span>
    <span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>

    <span class="c1"># Create the dispatcher and register functions</span>
    <span class="n">dispatcher</span> <span class="o">=</span> <span class="n">PathDispatcher</span><span class="p">()</span>
    <span class="n">dispatcher</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;/hello&#39;</span><span class="p">,</span> <span class="n">hello_world</span><span class="p">)</span>
    <span class="n">dispatcher</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;/localtime&#39;</span><span class="p">,</span> <span class="n">localtime</span><span class="p">)</span>

    <span class="c1"># Launch a basic server</span>
    <span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">dispatcher</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Serving on port 8080...&#39;</span><span class="p">)</span>
    <span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>要测试下这个服务器，你可以使用一个浏览器或 <code class="docutils literal"><span class="pre">urllib</span></code> 和它交互。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://localhost:8080/hello?name=Guido&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;html&gt;</span>
<span class="go">  &lt;head&gt;</span>
<span class="go">     &lt;title&gt;Hello Guido&lt;/title&gt;</span>
<span class="go">   &lt;/head&gt;</span>
<span class="go">   &lt;body&gt;</span>
<span class="go">     &lt;h1&gt;Hello Guido!&lt;/h1&gt;</span>
<span class="go">   &lt;/body&gt;</span>
<span class="go">&lt;/html&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://localhost:8080/localtime&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="go">&lt;time&gt;</span>
<span class="go">  &lt;year&gt;2012&lt;/year&gt;</span>
<span class="go">  &lt;month&gt;11&lt;/month&gt;</span>
<span class="go">  &lt;day&gt;24&lt;/day&gt;</span>
<span class="go">  &lt;hour&gt;14&lt;/hour&gt;</span>
<span class="go">  &lt;minute&gt;49&lt;/minute&gt;</span>
<span class="go">  &lt;second&gt;17&lt;/second&gt;</span>
<span class="go">&lt;/time&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在编写REST接口时，通常都是服务于普通的HTTP请求。但是跟那些功能完整的网站相比，你通常只需要处理数据。
这些数据以各种标准格式编码，比如XML、JSON或CSV。
尽管程序看上去很简单，但是以这种方式提供的API对于很多应用程序来讲是非常有用的。</p>
<p>例如，长期运行的程序可能会使用一个REST API来实现监控或诊断。
大数据应用程序可以使用REST来构建一个数据查询或提取系统。
REST还能用来控制硬件设备比如机器人、传感器、工厂或灯泡。
更重要的是，REST API已经被大量客户端编程环境所支持，比如Javascript, Android, iOS等。
因此，利用这种接口可以让你开发出更加复杂的应用程序。</p>
<p>为了实现一个简单的REST接口，你只需让你的程序代码满足Python的WSGI标准即可。
WSGI被标准库支持，同时也被绝大部分第三方web框架支持。
因此，如果你的代码遵循这个标准，在后面的使用过程中就会更加的灵活！</p>
<p>在WSGI中，你可以像下面这样约定的方式以一个可调用对象形式来实现你的程序。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cgi</span>

<span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">environ</span></code> 属性是一个字典，包含了从web服务器如Apache[参考Internet RFC 3875]提供的CGI接口中获取的值。
要将这些不同的值提取出来，你可以像这么这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">environ</span><span class="p">[</span><span class="s1">&#39;REQUEST_METHOD&#39;</span><span class="p">]</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">environ</span><span class="p">[</span><span class="s1">&#39;PATH_INFO&#39;</span><span class="p">]</span>
    <span class="c1"># Parse the query parameters</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">cgi</span><span class="o">.</span><span class="n">FieldStorage</span><span class="p">(</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;wsgi.input&#39;</span><span class="p">],</span> <span class="n">environ</span><span class="o">=</span><span class="n">environ</span><span class="p">)</span>
</pre></div>
</div>
<p>我们展示了一些常见的值。<code class="docutils literal"><span class="pre">environ['REQUEST_METHOD']</span></code> 代表请求类型如GET、POST、HEAD等。
<code class="docutils literal"><span class="pre">environ['PATH_INFO']</span></code> 表示被请求资源的路径。
调用 <code class="docutils literal"><span class="pre">cgi.FieldStorage()</span></code> 可以从请求中提取查询参数并将它们放入一个类字典对象中以便后面使用。</p>
<p><code class="docutils literal"><span class="pre">start_response</span></code> 参数是一个为了初始化一个请求对象而必须被调用的函数。
第一个参数是返回的HTTP状态值，第二个参数是一个(名,值)元组列表，用来构建返回的HTTP头。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;Content-type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">)])</span>
</pre></div>
</div>
<p>为了返回数据，一个WSGI程序必须返回一个字节字符串序列。可以像下面这样使用一个列表来完成：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;Content-type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">)])</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Goodbye!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
<p>或者，你还可以使用 <code class="docutils literal"><span class="pre">yield</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;Content-type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">)])</span>
    <span class="k">yield</span> <span class="sa">b</span><span class="s1">&#39;Hello World</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">yield</span> <span class="sa">b</span><span class="s1">&#39;Goodbye!</span><span class="se">\n</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>这里要强调的一点是最后返回的必须是字节字符串。如果返回结果包含文本字符串，必须先将其编码成字节。
当然，并没有要求你返回的一定是文本，你可以很轻松的编写一个生成图片的程序。</p>
<p>尽管WSGI程序通常被定义成一个函数，不过你也可以使用类实例来实现，只要它实现了合适的 <code class="docutils literal"><span class="pre">__call__()</span></code> 方法。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WSGIApplication</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
       <span class="o">...</span>
</pre></div>
</div>
<p>我们已经在上面使用这种技术创建 <code class="docutils literal"><span class="pre">PathDispatcher</span></code> 类。
这个分发器仅仅只是管理一个字典，将(方法,路径)对映射到处理器函数上面。
当一个请求到来时，它的方法和路径被提取出来，然后被分发到对应的处理器上面去。
另外，任何查询变量会被解析后放到一个字典中，以 <code class="docutils literal"><span class="pre">environ['params']</span></code> 形式存储。
后面这个步骤太常见，所以建议你在分发器里面完成，这样可以省掉很多重复代码。
使用分发器的时候，你只需简单的创建一个实例，然后通过它注册各种WSGI形式的函数。
编写这些函数应该超级简单了，只要你遵循 <code class="docutils literal"><span class="pre">start_response()</span></code> 函数的编写规则，并且最后返回字节字符串即可。</p>
<p>当编写这种函数的时候还需注意的一点就是对于字符串模板的使用。
没人愿意写那种到处混合着 <code class="docutils literal"><span class="pre">print()</span></code> 函数 、XML和大量格式化操作的代码。
我们上面使用了三引号包含的预先定义好的字符串模板。
这种方式的可以让我们很容易的在以后修改输出格式(只需要修改模板本身，而不用动任何使用它的地方)。</p>
<p>最后，使用WSGI还有一个很重要的部分就是没有什么地方是针对特定web服务器的。
因为标准对于服务器和框架是中立的，你可以将你的程序放入任何类型服务器中。
我们使用下面的代码测试测试本节代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>

    <span class="c1"># Create the dispatcher and register functions</span>
    <span class="n">dispatcher</span> <span class="o">=</span> <span class="n">PathDispatcher</span><span class="p">()</span>
    <span class="k">pass</span>

    <span class="c1"># Launch a basic server</span>
    <span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">dispatcher</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Serving on port 8080...&#39;</span><span class="p">)</span>
    <span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>上面代码创建了一个简单的服务器，然后你就可以来测试下你的实现是否能正常工作。
最后，当你准备进一步扩展你的程序的时候，你可以修改这个代码，让它可以为特定服务器工作。</p>
<p>WSGI本身是一个很小的标准。因此它并没有提供一些高级的特性比如认证、cookies、重定向等。
这些你自己实现起来也不难。不过如果你想要更多的支持，可以考虑第三方库，比如 <code class="docutils literal"><span class="pre">WebOb</span></code> 或者 <code class="docutils literal"><span class="pre">Paste</span></code></p>
</div>
</div>
<span id="document-c11/p06_implement_simple_remote_procedure_call_with_xml_rpc"></span><div class="section" id="xml-rpc">
<h3>11.6 通过XML-RPC实现简单的远程调用<a class="headerlink" href="#xml-rpc" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想找到一个简单的方式去执行运行在远程机器上面的Python程序中的函数或方法。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>实现一个远程方法调用的最简单方式是使用XML-RPC。下面我们演示一下一个实现了键-值存储功能的简单服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="k">class</span> <span class="nc">KeyValueServer</span><span class="p">:</span>
    <span class="n">_rpc_methods_</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="s1">&#39;exists&#39;</span><span class="p">,</span> <span class="s1">&#39;keys&#39;</span><span class="p">]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rpc_methods_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="c1"># Example</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">kvserv</span> <span class="o">=</span> <span class="n">KeyValueServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">))</span>
    <span class="n">kvserv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>下面我们从一个客户端机器上面来访问服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xmlrpc.client</span> <span class="kn">import</span> <span class="n">ServerProxy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s1">&#39;http://localhost:15000&#39;</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;spam&#39;, &#39;foo&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="go">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>XML-RPC 可以让我们很容易的构造一个简单的远程调用服务。你所需要做的仅仅是创建一个服务器实例，
通过它的方法 <code class="docutils literal"><span class="pre">register_function()</span></code> 来注册函数，然后使用方法 <code class="docutils literal"><span class="pre">serve_forever()</span></code> 启动它。
在上面我们将这些步骤放在一起写到一个类中，不够这并不是必须的。比如你还可以像下面这样创建一个服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>

<span class="n">serv</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">))</span>
<span class="n">serv</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="n">serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>XML-RPC暴露出来的函数只能适用于部分数据类型，比如字符串、整形、列表和字典。
对于其他类型就得需要做些额外的功课了。
例如，如果你想通过 XML-RPC 传递一个对象实例，实际上只有他的实例字典被处理：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: 2, &#39;y&#39;: 3}</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>类似的，对于二进制数据的处理也跟你想象的不太一样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="go">&lt;xmlrpc.client.Binary object at 0x10131d410&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">data</span>
<span class="go">b&#39;Hello World&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一般来讲，你不应该将 XML-RPC 服务以公共API的方式暴露出来。
对于这种情况，通常分布式应用程序会是一个更好的选择。</p>
<p>XML-RPC的一个缺点是它的性能。<code class="docutils literal"><span class="pre">SimpleXMLRPCServer</span></code> 的实现是单线程的，
所以它不适合于大型程序，尽管我们在11.2小节中演示过它是可以通过多线程来执行的。
另外，由于 XML-RPC 将所有数据都序列化为XML格式，所以它会比其他的方式运行的慢一些。
但是它也有优点，这种方式的编码可以被绝大部分其他编程语言支持。
通过使用这种方式，其他语言的客户端程序都能访问你的服务。</p>
<p>虽然XML-RPC有很多缺点，但是如果你需要快速构建一个简单远程过程调用系统的话，它仍然值得去学习的。
有时候，简单的方案就已经足够了。</p>
</div>
</div>
<span id="document-c11/p07_communicate_simply_between_interpreters"></span><div class="section" id="python">
<h3>11.7 在不同的Python解释器之间交互<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你在不同的机器上面运行着多个Python解释器实例，并希望能够在这些解释器之间通过消息来交换数据。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>通过使用 <code class="docutils literal"><span class="pre">multiprocessing.connection</span></code> 模块可以很容易的实现解释器之间的通信。
下面是一个简单的应答服务器例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">Listener</span>
<span class="kn">import</span> <span class="nn">traceback</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Connection closed&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">authkey</span><span class="p">):</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">Listener</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="n">authkey</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">serv</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>

            <span class="n">echo_client</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">25000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>然后客户端连接服务器并发送消息的简单示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">((</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">25000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="go">&#39;hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>跟底层socket不同的是，每个消息会完整保存（每一个通过send()发送的对象能通过recv()来完整接受）。
另外，所有对象会通过pickle序列化。因此，任何兼容pickle的对象都能在此连接上面被发送和接受。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>目前有很多用来实现各种消息传输的包和函数库，比如ZeroMQ、Celery等。
你还有另外一种选择就是自己在底层socket基础之上来实现一个消息传输层。
但是你想要简单一点的方案，那么这时候 <code class="docutils literal"><span class="pre">multiprocessing.connection</span></code> 就派上用场了。
仅仅使用一些简单的语句即可实现多个解释器之间的消息通信。</p>
<p>如果你的解释器运行在同一台机器上面，那么你可以使用另外的通信机制，比如Unix域套接字或者是Windows命名管道。
要想使用UNIX域套接字来创建一个连接，只需简单的将地址改写一个文件名即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Listener</span><span class="p">(</span><span class="s1">&#39;/tmp/myconn&#39;</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>要想使用Windows命名管道来创建连接，只需像下面这样使用一个文件名：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Listener</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">.\pipe\myconn&#39;</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>一个通用准则是，你不要使用 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 来实现一个对外的公共服务。
<code class="docutils literal"><span class="pre">Client()</span></code> 和 <code class="docutils literal"><span class="pre">Listener()</span></code> 中的 <code class="docutils literal"><span class="pre">authkey</span></code> 参数用来认证发起连接的终端用户。
如果密钥不对会产生一个异常。此外，该模块最适合用来建立长连接（而不是大量的短连接），
例如，两个解释器之间启动后就开始建立连接并在处理某个问题过程中会一直保持连接状态。</p>
<p>如果你需要对底层连接做更多的控制，比如需要支持超时、非阻塞I/O或其他类似的特性，
你最好使用另外的库或者是在高层socket上来实现这些特性。</p>
</div>
</div>
<span id="document-c11/p08_implementing_remote_procedure_calls"></span><div class="section" id="id1">
<h3>11.8 实现远程方法调用<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在一个消息传输层如 <code class="docutils literal"><span class="pre">sockets</span></code> 、<code class="docutils literal"><span class="pre">multiprocessing</span> <span class="pre">connections</span></code> 或 <code class="docutils literal"><span class="pre">ZeroMQ</span></code>
的基础之上实现一个简单的远程过程调用（RPC）。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>将函数请求、参数和返回值使用pickle编码后，在不同的解释器直接传送pickle字节字符串，可以很容易的实现RPC。
下面是一个简单的PRC处理器，可以被整合到一个服务器中去：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># rpcserver.py</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="k">class</span> <span class="nc">RPCHandler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">def</span> <span class="nf">register_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="c1"># Receive a message</span>
                <span class="n">func_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>
                <span class="c1"># Run the RPC and send a response</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">[</span><span class="n">func_name</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
             <span class="k">pass</span>
</pre></div>
</div>
<p>要使用这个处理器，你需要将它加入到一个消息服务器中。你有很多种选择，
但是使用 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 库是最简单的。下面是一个RPC服务器例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">Listener</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="k">def</span> <span class="nf">rpc_server</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">authkey</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">Listener</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="n">authkey</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">handler</span><span class="o">.</span><span class="n">handle_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">client</span><span class="p">,))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Some remote functions</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

<span class="c1"># Register with a handler</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">RPCHandler</span><span class="p">()</span>
<span class="n">handler</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="n">handler</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>

<span class="c1"># Run the server</span>
<span class="n">rpc_server</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">17000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>为了从一个远程客户端访问服务器，你需要创建一个对应的用来传送请求的RPC代理类。例如</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">class</span> <span class="nc">RPCProxy</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">connection</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">do_rpc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">do_rpc</span>
</pre></div>
</div>
<p>要使用这个代理类，你需要将其包装到一个服务器的连接上面，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">((</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">17000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxy</span> <span class="o">=</span> <span class="n">RPCProxy</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxy</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxy</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;rpcserver.py&quot;</span>, line <span class="m">37</span>, in <span class="n">do_rpc</span>
    <span class="k">raise</span> <span class="n">result</span>
<span class="gr">TypeError</span>: <span class="n">unsupported operand type(s) for -: &#39;list&#39; and &#39;int&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>要注意的是很多消息层（比如 <code class="docutils literal"><span class="pre">multiprocessing</span></code> ）已经使用pickle序列化了数据。
如果是这样的话，对 <code class="docutils literal"><span class="pre">pickle.dumps()</span></code> 和 <code class="docutils literal"><span class="pre">pickle.loads()</span></code> 的调用要去掉。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">RPCHandler</span></code> 和 <code class="docutils literal"><span class="pre">RPCProxy</span></code> 的基本思路是很比较简单的。
如果一个客户端想要调用一个远程函数，比如 <code class="docutils literal"><span class="pre">foo(1,</span> <span class="pre">2,</span> <span class="pre">z=3)</span></code>
,代理类创建一个包含了函数名和参数的元组 <code class="docutils literal"><span class="pre">('foo',</span> <span class="pre">(1,</span> <span class="pre">2),</span> <span class="pre">{'z':</span> <span class="pre">3})</span></code> 。
这个元组被pickle序列化后通过网络连接发生出去。
这一步在 <code class="docutils literal"><span class="pre">RPCProxy</span></code> 的 <code class="docutils literal"><span class="pre">__getattr__()</span></code> 方法返回的 <code class="docutils literal"><span class="pre">do_rpc()</span></code> 闭包中完成。
服务器接收后通过pickle反序列化消息，查找函数名看看是否已经注册过，然后执行相应的函数。
执行结果(或异常)被pickle序列化后返回发送给客户端。我们的实例需要依赖 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 进行通信。
不过，这种方式可以适用于其他任何消息系统。例如，如果你想在ZeroMQ之上实习RPC，
仅仅只需要将连接对象换成合适的ZeroMQ的socket对象即可。</p>
<p>由于底层需要依赖pickle，那么安全问题就需要考虑了
（因为一个聪明的黑客可以创建特定的消息，能够让任意函数通过pickle反序列化后被执行）。
因此你永远不要允许来自不信任或未认证的客户端的RPC。特别是你绝对不要允许来自Internet的任意机器的访问，
这种只能在内部被使用，位于防火墙后面并且不要对外暴露。</p>
<p>作为pickle的替代，你也许可以考虑使用JSON、XML或一些其他的编码格式来序列化消息。
例如，本机实例可以很容易的改写成JSON编码方案。还需要将 <code class="docutils literal"><span class="pre">pickle.loads()</span></code> 和  <code class="docutils literal"><span class="pre">pickle.dumps()</span></code>
替换成 <code class="docutils literal"><span class="pre">json.loads()</span></code> 和 <code class="docutils literal"><span class="pre">json.dumps()</span></code> 即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># jsonrpcserver.py</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="k">class</span> <span class="nc">RPCHandler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">def</span> <span class="nf">register_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="c1"># Receive a message</span>
                <span class="n">func_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>
                <span class="c1"># Run the RPC and send a response</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">[</span><span class="n">func_name</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
             <span class="k">pass</span>

<span class="c1"># jsonrpcclient.py</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="k">class</span> <span class="nc">RPCProxy</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">connection</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">do_rpc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">do_rpc</span>
</pre></div>
</div>
<p>实现RPC的一个比较复杂的问题是如何去处理异常。至少，当方法产生异常时服务器不应该奔溃。
因此，返回给客户端的异常所代表的含义就要好好设计了。
如果你使用pickle，异常对象实例在客户端能被反序列化并抛出。如果你使用其他的协议，那得想想另外的方法了。
不过至少，你应该在响应中返回异常字符串。我们在JSON的例子中就是使用的这种方式。</p>
<p>对于其他的RPC实现例子，我推荐你看看在XML-RPC中使用的 <code class="docutils literal"><span class="pre">SimpleXMLRPCServer</span></code> 和 <code class="docutils literal"><span class="pre">ServerProxy</span></code> 的实现，
也就是11.6小节中的内容。</p>
</div>
</div>
<span id="document-c11/p09_authenticating_clients_simply"></span><div class="section" id="id1">
<h3>11.9 简单的客户端认证<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在分布式系统中实现一个简单的客户端连接认证功能，又不想像SSL那样的复杂。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>可以利用 <code class="docutils literal"><span class="pre">hmac</span></code> 模块实现一个连接握手，从而实现一个简单而高效的认证过程。下面是代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">hmac</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">client_authenticate</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Authenticate client to a remote service.</span>
<span class="sd">    connection represents a network connection.</span>
<span class="sd">    secret_key is a key known only to both client/server.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
    <span class="nb">hash</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="n">digest</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">digest</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">server_authenticate</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Request client authentication.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="nb">hash</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="n">digest</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digest</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">hmac</span><span class="o">.</span><span class="n">compare_digest</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span><span class="n">response</span><span class="p">)</span>
</pre></div>
</div>
<p>基本原理是当连接建立后，服务器给客户端发送一个随机的字节消息（这里例子中使用了 <code class="docutils literal"><span class="pre">os.urandom()</span></code> 返回值）。
客户端和服务器同时利用hmac和一个只有双方知道的密钥来计算出一个加密哈希值。然后客户端将它计算出的摘要发送给服务器，
服务器通过比较这个值和自己计算的是否一致来决定接受或拒绝连接。摘要的比较需要使用 <code class="docutils literal"><span class="pre">hmac.compare_digest()</span></code> 函数。
使用这个函数可以避免遭到时间分析攻击，不要用简单的比较操作符（==）。
为了使用这些函数，你需要将它集成到已有的网络或消息代码中。例如，对于sockets，服务器代码应该类似下面：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="n">secret_key</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span>
<span class="k">def</span> <span class="nf">echo_handler</span><span class="p">(</span><span class="n">client_sock</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">server_authenticate</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
        <span class="n">client_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="n">client_sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">client_sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">c</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">echo_handler</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">18000</span><span class="p">))</span>

<span class="n">Within</span> <span class="n">a</span> <span class="n">client</span><span class="p">,</span> <span class="n">you</span> <span class="n">would</span> <span class="n">do</span> <span class="n">this</span><span class="p">:</span>

<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="n">secret_key</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">18000</span><span class="p">))</span>
<span class="n">client_authenticate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">hmac</span></code> 认证的一个常见使用场景是内部消息通信系统和进程间通信。
例如，如果你编写的系统涉及到一个集群中多个处理器之间的通信，
你可以使用本节方案来确保只有被允许的进程之间才能彼此通信。
事实上，基于 <code class="docutils literal"><span class="pre">hmac</span></code> 的认证被 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 模块使用来实现子进程直接的通信。</p>
<p>还有一点需要强调的是连接认证和加密是两码事。
认证成功之后的通信消息是以明文形式发送的，任何人只要想监听这个连接线路都能看到消息（尽管双方的密钥不会被传输）。</p>
<p>hmac认证算法基于哈希函数如MD5和SHA-1，关于这个在IETF RFC 2104中有详细介绍。</p>
</div>
</div>
<span id="document-c11/p10_add_ssl_to_network_services"></span><div class="section" id="ssl">
<h3>11.10 在网络服务中加入SSL<a class="headerlink" href="#ssl" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想实现一个基于sockets的网络服务，客户端和服务器通过SSL协议认证并加密传输的数据。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">ssl</span></code> 模块能为底层socket连接添加SSL的支持。
<code class="docutils literal"><span class="pre">ssl.wrap_socket()</span></code> 函数接受一个已存在的socket作为参数并使用SSL层来包装它。
例如，下面是一个简单的应答服务器，能在服务器端为所有客户端连接做认证。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="n">KEYFILE</span> <span class="o">=</span> <span class="s1">&#39;server_key.pem&#39;</span>   <span class="c1"># Private key of the server</span>
<span class="n">CERTFILE</span> <span class="o">=</span> <span class="s1">&#39;server_cert.pem&#39;</span> <span class="c1"># Server certificate (given to client)</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Connection closed&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Wrap with an SSL layer requiring client certs</span>
    <span class="n">s_ssl</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
                            <span class="n">keyfile</span><span class="o">=</span><span class="n">KEYFILE</span><span class="p">,</span>
                            <span class="n">certfile</span><span class="o">=</span><span class="n">CERTFILE</span><span class="p">,</span>
                            <span class="n">server_side</span><span class="o">=</span><span class="bp">True</span>
                            <span class="p">)</span>
    <span class="c1"># Wait for connections</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">s_ssl</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">echo_client</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{}: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">))</span>
</pre></div>
</div>
<p>下面我们演示一个客户端连接服务器的交互例子。客户端会请求服务器来认证并确认连接：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ssl</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
<span class="go">                cert_reqs=ssl.CERT_REQUIRED,</span>
<span class="go">                ca_certs = &#39;server_cert.pem&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ssl</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">20000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ssl</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World?&#39;</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ssl</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
<span class="go">b&#39;Hello World?&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种直接处理底层socket方式有个问题就是它不能很好的跟标准库中已存在的网络服务兼容。
例如，绝大部分服务器代码（HTTP、XML-RPC等）实际上是基于 <code class="docutils literal"><span class="pre">socketserver</span></code> 库的。
客户端代码在一个较高层上实现。我们需要另外一种稍微不同的方式来将SSL添加到已存在的服务中：</p>
<p>首先，对于服务器而言，可以通过像下面这样使用一个mixin类来添加SSL：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ssl</span>

<span class="k">class</span> <span class="nc">SSLMixin</span><span class="p">:</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Mixin class that adds support for SSL to existing servers based</span>
<span class="sd">on the socketserver module.</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
             <span class="n">keyfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">certfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ca_certs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">cert_reqs</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_NONE</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_keyfile</span> <span class="o">=</span> <span class="n">keyfile</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_certfile</span> <span class="o">=</span> <span class="n">certfile</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_ca_certs</span> <span class="o">=</span> <span class="n">ca_certs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_cert_reqs</span> <span class="o">=</span> <span class="n">cert_reqs</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">client</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_request</span><span class="p">()</span>
    <span class="n">client_ssl</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">client</span><span class="p">,</span>
                                 <span class="n">keyfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyfile</span><span class="p">,</span>
                                 <span class="n">certfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_certfile</span><span class="p">,</span>
                                 <span class="n">ca_certs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ca_certs</span><span class="p">,</span>
                                 <span class="n">cert_reqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cert_reqs</span><span class="p">,</span>
                                 <span class="n">server_side</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">client_ssl</span><span class="p">,</span> <span class="n">addr</span>
</pre></div>
</div>
<p>为了使用这个mixin类，你可以将它跟其他服务器类混合。例如，下面是定义一个基于SSL的XML-RPC服务器例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># XML-RPC server with SSL</span>

<span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="k">class</span> <span class="nc">SSLSimpleXMLRPCServer</span><span class="p">(</span><span class="n">SSLMixin</span><span class="p">,</span> <span class="n">SimpleXMLRPCServer</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">Here</span><span class="s1">&#39;s the XML-RPC server from Recipe 11.6 modified only slightly to use SSL:</span>

<span class="kn">import</span> <span class="nn">ssl</span>
<span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>
<span class="kn">from</span> <span class="nn">sslmixin</span> <span class="kn">import</span> <span class="n">SSLMixin</span>

<span class="k">class</span> <span class="nc">SSLSimpleXMLRPCServer</span><span class="p">(</span><span class="n">SSLMixin</span><span class="p">,</span> <span class="n">SimpleXMLRPCServer</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">KeyValueServer</span><span class="p">:</span>
    <span class="n">_rpc_methods_</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="s1">&#39;exists&#39;</span><span class="p">,</span> <span class="s1">&#39;keys&#39;</span><span class="p">]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span> <span class="o">=</span> <span class="n">SSLSimpleXMLRPCServer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rpc_methods_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">KEYFILE</span><span class="o">=</span><span class="s1">&#39;server_key.pem&#39;</span>    <span class="c1"># Private key of the server</span>
    <span class="n">CERTFILE</span><span class="o">=</span><span class="s1">&#39;server_cert.pem&#39;</span>  <span class="c1"># Server certificate</span>
    <span class="n">kvserv</span> <span class="o">=</span> <span class="n">KeyValueServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span>
                            <span class="n">keyfile</span><span class="o">=</span><span class="n">KEYFILE</span><span class="p">,</span>
                            <span class="n">certfile</span><span class="o">=</span><span class="n">CERTFILE</span><span class="p">)</span>
    <span class="n">kvserv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>使用这个服务器时，你可以使用普通的 <code class="docutils literal"><span class="pre">xmlrpc.client</span></code> 模块来连接它。
只需要在URL中指定 <code class="docutils literal"><span class="pre">https:</span></code> 即可，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xmlrpc.client</span> <span class="kn">import</span> <span class="n">ServerProxy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s1">&#39;https://localhost:15000&#39;</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;spam&#39;, &#39;foo&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="go">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于SSL客户端来讲一个比较复杂的问题是如何确认服务器证书或为服务器提供客户端认证（比如客户端证书）。
不幸的是，暂时还没有一个标准方法来解决这个问题，需要自己去研究。
不过，下面给出一个例子，用来建立一个安全的XML-RPC连接来确认服务器证书：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.client</span> <span class="kn">import</span> <span class="n">SafeTransport</span><span class="p">,</span> <span class="n">ServerProxy</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="k">class</span> <span class="nc">VerifyCertSafeTransport</span><span class="p">(</span><span class="n">SafeTransport</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cafile</span><span class="p">,</span> <span class="n">certfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">SafeTransport</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="n">cafile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">certfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="p">,</span> <span class="n">keyfile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>

    <span class="k">def</span> <span class="nf">make_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="c1"># Items in the passed dictionary are passed as keyword</span>
        <span class="c1"># arguments to the http.client.HTTPSConnection() constructor.</span>
        <span class="c1"># The context argument allows an ssl.SSLContext instance to</span>
        <span class="c1"># be passed with information about the SSL configuration</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">make_connection</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;context&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span><span class="p">}))</span>

        <span class="k">return</span> <span class="n">s</span>

<span class="c1"># Create the client proxy</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s1">&#39;https://localhost:15000&#39;</span><span class="p">,</span>
                <span class="n">transport</span><span class="o">=</span><span class="n">VerifyCertSafeTransport</span><span class="p">(</span><span class="s1">&#39;server_cert.pem&#39;</span><span class="p">),</span>
                <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>服务器将证书发送给客户端，客户端来确认它的合法性。这种确认可以是相互的。
如果服务器想要确认客户端，可以将服务器启动代码修改如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">KEYFILE</span><span class="o">=</span><span class="s1">&#39;server_key.pem&#39;</span>   <span class="c1"># Private key of the server</span>
    <span class="n">CERTFILE</span><span class="o">=</span><span class="s1">&#39;server_cert.pem&#39;</span> <span class="c1"># Server certificate</span>
    <span class="n">CA_CERTS</span><span class="o">=</span><span class="s1">&#39;client_cert.pem&#39;</span> <span class="c1"># Certificates of accepted clients</span>

    <span class="n">kvserv</span> <span class="o">=</span> <span class="n">KeyValueServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span>
                            <span class="n">keyfile</span><span class="o">=</span><span class="n">KEYFILE</span><span class="p">,</span>
                            <span class="n">certfile</span><span class="o">=</span><span class="n">CERTFILE</span><span class="p">,</span>
                            <span class="n">ca_certs</span><span class="o">=</span><span class="n">CA_CERTS</span><span class="p">,</span>
                            <span class="n">cert_reqs</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span><span class="p">,</span>
                            <span class="p">)</span>
    <span class="n">kvserv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>为了让XML-RPC客户端发送证书，修改 <code class="docutils literal"><span class="pre">ServerProxy</span></code> 的初始化代码如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Create the client proxy</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s1">&#39;https://localhost:15000&#39;</span><span class="p">,</span>
                <span class="n">transport</span><span class="o">=</span><span class="n">VerifyCertSafeTransport</span><span class="p">(</span><span class="s1">&#39;server_cert.pem&#39;</span><span class="p">,</span>
                                                  <span class="s1">&#39;client_cert.pem&#39;</span><span class="p">,</span>
                                                  <span class="s1">&#39;client_key.pem&#39;</span><span class="p">),</span>
                <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>试着去运行本节的代码能测试你的系统配置能力和理解SSL。
可能最大的挑战是如何一步步的获取初始配置key、证书和其他所需依赖。</p>
<p>我解释下到底需要啥，每一个SSL连接终端一般都会有一个私钥和一个签名证书文件。
这个证书包含了公钥并在每一次连接的时候都会发送给对方。
对于公共服务器，它们的证书通常是被权威证书机构比如Verisign、Equifax或其他类似机构（需要付费的）签名过的。
为了确认服务器签名，客户端回保存一份包含了信任授权机构的证书列表文件。
例如，web浏览器保存了主要的认证机构的证书，并使用它来为每一个HTTPS连接确认证书的合法性。
对本小节示例而言，只是为了测试，我们可以创建自签名的证书，下面是主要步骤：</p>
<blockquote>
<div><dl class="docutils">
<dt>bash % openssl req -new -x509 -days 365 -nodes -out server_cert.pem </dt>
<dd>-keyout server_key.pem</dd>
</dl>
<p>Generating a 1024 bit RSA private key
..........................................++++++
...++++++</p>
<p>writing new private key to &#8216;server_key.pem&#8217;</p>
<blockquote>
<div></div></blockquote>
<p>You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#8216;.&#8217;, the field will be left blank.</p>
<blockquote>
<div></div></blockquote>
<p>Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:Illinois
Locality Name (eg, city) []:Chicago
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Dabeaz, LLC
Organizational Unit Name (eg, section) []:
Common Name (eg, YOUR name) []:localhost
Email Address []:
bash %</p>
</div></blockquote>
<p>在创建证书的时候，各个值的设定可以是任意的，但是”Common Name“的值通常要包含服务器的DNS主机名。
如果你只是在本机测试，那么就使用”localhost“，否则使用服务器的域名。</p>
<blockquote>
<div>&#8212;&#8211;BEGIN RSA PRIVATE KEY&#8212;&#8211;
MIICXQIBAAKBgQCZrCNLoEyAKF+f9UNcFaz5Osa6jf7qkbUl8si5xQrY3ZYC7juu
nL1dZLn/VbEFIITaUOgvBtPv1qUWTJGwga62VSG1oFE0ODIx3g2Nh4sRf+rySsx2
L4442nx0z4O5vJQ7k6eRNHAZUUnCL50+YvjyLyt7ryLSjSuKhCcJsbZgPwIDAQAB
AoGAB5evrr7eyL4160tM5rHTeATlaLY3UBOe5Z8XN8Z6gLiB/ucSX9AysviVD/6F
3oD6z2aL8jbeJc1vHqjt0dC2dwwm32vVl8mRdyoAsQpWmiqXrkvP4Bsl04VpBeHw
Qt8xNSW9SFhceL3LEvw9M8i9MV39viih1ILyH8OuHdvJyFECQQDLEjl2d2ppxND9
PoLqVFAirDfX2JnLTdWbc+M11a9Jdn3hKF8TcxfEnFVs5Gav1MusicY5KB0ylYPb
YbTvqKc7AkEAwbnRBO2VYEZsJZp2X0IZqP9ovWokkpYx+PE4+c6MySDgaMcigL7v
WDIHJG1CHudD09GbqENasDzyb2HAIW4CzQJBAKDdkv+xoW6gJx42Auc2WzTcUHCA
eXR/+BLpPrhKykzbvOQ8YvS5W764SUO1u1LWs3G+wnRMvrRvlMCZKgggBjkCQQCG
Jewto2+a+WkOKQXrNNScCDE5aPTmZQc5waCYq4UmCZQcOjkUOiN3ST1U5iuxRqfb
V/yX6fw0qh+fLWtkOs/JAkA+okMSxZwqRtfgOFGBfwQ8/iKrnizeanTQ3L6scFXI
CHZXdJ3XQ6qUmNxNn7iJ7S/LDawo1QfWkCfD9FYoxBlg
&#8212;&#8211;END RSA PRIVATE KEY&#8212;&#8211;</div></blockquote>
<p>服务器证书文件server_cert.pem内容类似下面这样：</p>
<blockquote>
<div><p>&#8212;&#8211;BEGIN CERTIFICATE&#8212;&#8211;
MIIC+DCCAmGgAwIBAgIJAPMd+vi45js3MA0GCSqGSIb3DQEBBQUAMFwxCzAJBgNV
BAYTAlVTMREwDwYDVQQIEwhJbGxpbm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIG
A1UEChMLRGFiZWF6LCBMTEMxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0xMzAxMTEx
ODQyMjdaFw0xNDAxMTExODQyMjdaMFwxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhJ
bGxpbm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIGA1UEChMLRGFiZWF6LCBMTEMx
EjAQBgNVBAMTCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA
mawjS6BMgChfn/VDXBWs+TrGuo3+6pG1JfLIucUK2N2WAu47rpy9XWS5/1WxBSCE
2lDoLwbT79alFkyRsIGutlUhtaBRNDgyMd4NjYeLEX/q8krMdi+OONp8dM+DubyU</p>
<p>O5OnkTRwGVFJwi+dPmL48i8re68i0o0rioQnCbG2YD8CAwEAAaOBwTCBvjAdBgNV
HQ4EFgQUrtoLHHgXiDZTr26NMmgKJLJLFtIwgY4GA1UdIwSBhjCBg4AUrtoLHHgX
iDZTr26NMmgKJLJLFtKhYKReMFwxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhJbGxp
bm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIGA1UEChMLRGFiZWF6LCBMTEMxEjAQ
BgNVBAMTCWxvY2FsaG9zdIIJAPMd+vi45js3MAwGA1UdEwQFMAMBAf8wDQYJKoZI
hvcNAQEFBQADgYEAFci+dqvMG4xF8UTnbGVvZJPIzJDRee6Nbt6AHQo9pOdAIMAu
WsGCplSOaDNdKKzl+b2UT2Zp3AIW4Qd51bouSNnR4M/gnr9ZD1ZctFd3jS+C5XRp
D3vvcW5lAnCCC80P6rXy7d7hTeFu5EYKtRGXNvVNd/06NALGDflrrOwxF3Y=
&#8212;&#8211;END CERTIFICATE&#8212;&#8211;</p>
</div></blockquote>
<p>在服务器端代码中，私钥和证书文件会被传给SSL相关的包装函数。证书来自于客户端，
私钥应该在保存在服务器中，并加以安全保护。</p>
<p>在客户端代码中，需要保存一个合法证书授权文件来确认服务器证书。
如果你没有这个文件，你可以在客户端复制一份服务器的证书并使用它来确认。
连接建立后，服务器会提供它的证书，然后你就能使用已经保存的证书来确认它是否正确。</p>
<p>服务器也能选择是否要确认客户端的身份。如果要这样做的话，客户端需要有自己的私钥和认证文件。
服务器也需要保存一个被信任证书授权文件来确认客户端证书。</p>
<p>如果你要在真实环境中为你的网络服务加上SSL的支持，这小节只是一个入门介绍而已。
你还应该参考其他的文档，做好花费不少时间来测试它正常工作的准备。反正，就是得慢慢折腾吧~ ^_^</p>
</div>
</div>
<span id="document-c11/p11_pass_socket_file_descriptor_between_processes"></span><div class="section" id="socket">
<h3>11.11 进程间传递Socket文件描述符<a class="headerlink" href="#socket" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你有多个Python解释器进程在同时运行，你想将某个打开的文件描述符从一个解释器传递给另外一个。
比如，假设有个服务器进程相应连接请求，但是实际的相应逻辑是在另一个解释器中执行的。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>为了在多个进程中传递文件描述符，你首先需要将它们连接到一起。在Unix机器上，你可能需要使用Unix域套接字，
而在windows上面你需要使用命名管道。不过你无需真的需要去操作这些底层，
通常使用 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 模块来创建这样的连接会更容易一些。</p>
<p>一旦一个连接被创建，你可以使用 <code class="docutils literal"><span class="pre">multiprocessing.reduction</span></code> 中的
<code class="docutils literal"><span class="pre">send_handle()</span></code> 和 <code class="docutils literal"><span class="pre">recv_handle()</span></code> 函数在不同的处理器直接传递文件描述符。
下面的例子演示了最基本的用法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">multiprocessing.reduction</span> <span class="kn">import</span> <span class="n">recv_handle</span><span class="p">,</span> <span class="n">send_handle</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">in_p</span><span class="p">,</span> <span class="n">out_p</span><span class="p">):</span>
    <span class="n">out_p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">recv_handle</span><span class="p">(</span><span class="n">in_p</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;CHILD: GOT FD&#39;</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">fileno</span><span class="o">=</span><span class="n">fd</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;CHILD: RECV {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
                <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">server</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">in_p</span><span class="p">,</span> <span class="n">out_p</span><span class="p">,</span> <span class="n">worker_pid</span><span class="p">):</span>
    <span class="n">in_p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;SERVER: Got connection from&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
        <span class="n">send_handle</span><span class="p">(</span><span class="n">out_p</span><span class="p">,</span> <span class="n">client</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">worker_pid</span><span class="p">)</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pipe</span><span class="p">()</span>
    <span class="n">worker_p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">))</span>
    <span class="n">worker_p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">server_p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">server</span><span class="p">,</span>
                  <span class="n">args</span><span class="o">=</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">worker_p</span><span class="o">.</span><span class="n">pid</span><span class="p">))</span>
    <span class="n">server_p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">c1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">c2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>在这个例子中，两个进程被创建并通过一个 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 管道连接起来。
服务器进程打开一个socket并等待客户端连接请求。
工作进程仅仅使用 <code class="docutils literal"><span class="pre">recv_handle()</span></code> 在管道上面等待接收一个文件描述符。
当服务器接收到一个连接，它将产生的socket文件描述符通过 <code class="docutils literal"><span class="pre">send_handle()</span></code> 传递给工作进程。
工作进程接收到socket后向客户端回应数据，然后此次连接关闭。</p>
<p>如果你使用Telnet或类似工具连接到服务器，下面是一个演示例子：</p>
<blockquote>
<div>bash % python3 passfd.py
SERVER: Got connection from (&#8216;127.0.0.1&#8217;, 55543)
CHILD: GOT FD 7
CHILD: RECV b&#8217;Hellorn&#8217;
CHILD: RECV b&#8217;Worldrn&#8217;</div></blockquote>
<p>此例最重要的部分是服务器接收到的客户端socket实际上被另外一个不同的进程处理。
服务器仅仅只是将其转手并关闭此连接，然后等待下一个连接。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于大部分程序员来讲在不同进程之间传递文件描述符好像没什么必要。
但是，有时候它是构建一个可扩展系统的很有用的工具。例如，在一个多核机器上面，
你可以有多个Python解释器实例，将文件描述符传递给其它解释器来实现负载均衡。</p>
<p><code class="docutils literal"><span class="pre">send_handle()</span></code> 和 <code class="docutils literal"><span class="pre">recv_handle()</span></code> 函数只能够用于 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 连接。
使用它们来代替管道的使用（参考11.7节），只要你使用的是Unix域套接字或Windows管道。
例如，你可以让服务器和工作者各自以单独的程序来启动。下面是服务器的实现例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># servermp.py</span>
<span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">Listener</span>
<span class="kn">from</span> <span class="nn">multiprocessing.reduction</span> <span class="kn">import</span> <span class="n">send_handle</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="k">def</span> <span class="nf">server</span><span class="p">(</span><span class="n">work_address</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="c1"># Wait for the worker to connect</span>
    <span class="n">work_serv</span> <span class="o">=</span> <span class="n">Listener</span><span class="p">(</span><span class="n">work_address</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span><span class="p">)</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="n">work_serv</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">worker_pid</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>

    <span class="c1"># Now run a TCP/IP server and send clients to worker</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;SERVER: Got connection from&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>

        <span class="n">send_handle</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">client</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">worker_pid</span><span class="p">)</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Usage: server.py server_address port&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">server</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
<p>运行这个服务器，只需要执行 <cite>python3 servermp.py /tmp/servconn 15000</cite> ，下面是相应的工作者代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># workermp.py</span>

<span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">multiprocessing.reduction</span> <span class="kn">import</span> <span class="n">recv_handle</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">server_address</span><span class="p">):</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">server_address</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;peekaboo&#39;</span><span class="p">)</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">recv_handle</span><span class="p">(</span><span class="n">serv</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;WORKER: GOT FD&#39;</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">fileno</span><span class="o">=</span><span class="n">fd</span><span class="p">)</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;WORKER: RECV {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
                <span class="n">client</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Usage: worker.py server_address&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">worker</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>要运行工作者，执行执行命令 <cite>python3 workermp.py /tmp/servconn</cite> .
效果跟使用Pipe()例子是完全一样的。
文件描述符的传递会涉及到UNIX域套接字的创建和套接字的 <code class="docutils literal"><span class="pre">sendmsg()</span></code> 方法。
不过这种技术并不常见，下面是使用套接字来传递描述符的另外一种实现：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># server.py</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="kn">import</span> <span class="nn">struct</span>

<span class="k">def</span> <span class="nf">send_fd</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">fd</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Send a single file descriptor.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">sendmsg</span><span class="p">([</span><span class="sa">b</span><span class="s1">&#39;x&#39;</span><span class="p">],</span>
                 <span class="p">[(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">fd</span><span class="p">))])</span>
    <span class="n">ack</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ack</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;OK&#39;</span>

<span class="k">def</span> <span class="nf">server</span><span class="p">(</span><span class="n">work_address</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="c1"># Wait for the worker to connect</span>
    <span class="n">work_serv</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_UNIX</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">work_serv</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">work_address</span><span class="p">)</span>
    <span class="n">work_serv</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">worker</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">work_serv</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>

    <span class="c1"># Now run a TCP/IP server and send clients to worker</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">port</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;SERVER: Got connection from&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
        <span class="n">send_fd</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">client</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
        <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Usage: server.py server_address port&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">server</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
<p>下面是使用套接字的工作者实现：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># worker.py</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>

<span class="k">def</span> <span class="nf">recv_fd</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Receive a single file descriptor</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">ancdata</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvmsg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
                                     <span class="n">socket</span><span class="o">.</span><span class="n">CMSG_LEN</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)))</span>

    <span class="n">cmsg_level</span><span class="p">,</span> <span class="n">cmsg_type</span><span class="p">,</span> <span class="n">cmsg_data</span> <span class="o">=</span> <span class="n">ancdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">cmsg_level</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span> <span class="ow">and</span> <span class="n">cmsg_type</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;OK&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">cmsg_data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">server_address</span><span class="p">):</span>
    <span class="n">serv</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_UNIX</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">serv</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">recv_fd</span><span class="p">(</span><span class="n">serv</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;WORKER: GOT FD&#39;</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">fileno</span><span class="o">=</span><span class="n">fd</span><span class="p">)</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;WORKER: RECV {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
                <span class="n">client</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Usage: worker.py server_address&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">worker</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>如果你想在你的程序中传递文件描述符，建议你参阅其他一些更加高级的文档，
比如 <code class="docutils literal"><span class="pre">Unix</span> <span class="pre">Network</span> <span class="pre">Programming</span> <span class="pre">by</span> <span class="pre">W.</span> <span class="pre">Richard</span> <span class="pre">Stevens</span>&#160; <span class="pre">(Prentice</span>&#160; <span class="pre">Hall,</span>&#160; <span class="pre">1990)</span></code> .
在Windows上传递文件描述符跟Unix是不一样的，建议你研究下 <code class="docutils literal"><span class="pre">multiprocessing.reduction</span></code> 中的源代码看看其工作原理。</p>
</div>
</div>
<span id="document-c11/p12_understanding_event_driven_io"></span><div class="section" id="io">
<h3>11.12 理解事件驱动的IO<a class="headerlink" href="#io" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你应该已经听过基于事件驱动或异步I/O的包，但是你还不能完全理解它的底层到底是怎样工作的，
或者是如果使用它的话会对你的程序产生什么影响。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>事件驱动I/O本质上来讲就是将基本I/O操作（比如读和写）转化为你程序需要处理的事件。
例如，当数据在某个socket上被接受后，它会转换成一个 <code class="docutils literal"><span class="pre">receive</span></code> 事件，然后被你定义的回调方法或函数来处理。
作为一个可能的起始点，一个事件驱动的框架可能会以一个实现了一系列基本事件处理器方法的基类开始：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EventHandler</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Return the associated file descriptor&#39;</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s1">&#39;must implement&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wants_to_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Return True if receiving is allowed&#39;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">handle_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Perform the receive operation&#39;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">wants_to_send</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Return True if sending is requested&#39;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">handle_send</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Send outgoing data&#39;</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>这个类的实例作为插件被放入类似下面这样的事件循环中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">select</span>

<span class="k">def</span> <span class="nf">event_loop</span><span class="p">(</span><span class="n">handlers</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">wants_recv</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">handlers</span> <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">wants_to_receive</span><span class="p">()]</span>
        <span class="n">wants_send</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">handlers</span> <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">wants_to_send</span><span class="p">()]</span>
        <span class="n">can_recv</span><span class="p">,</span> <span class="n">can_send</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">wants_recv</span><span class="p">,</span> <span class="n">wants_send</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">can_recv</span><span class="p">:</span>
            <span class="n">h</span><span class="o">.</span><span class="n">handle_receive</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">can_send</span><span class="p">:</span>
            <span class="n">h</span><span class="o">.</span><span class="n">handle_send</span><span class="p">()</span>
</pre></div>
</div>
<p>事件循环的关键部分是 <code class="docutils literal"><span class="pre">select()</span></code> 调用，它会不断轮询文件描述符从而激活它。
在调用 <code class="docutils literal"><span class="pre">select()</span></code> 之前，时间循环会询问所有的处理器来决定哪一个想接受或发生。
然后它将结果列表提供给 <code class="docutils literal"><span class="pre">select()</span></code> 。然后 <code class="docutils literal"><span class="pre">select()</span></code> 返回准备接受或发送的对象组成的列表。
然后相应的 <code class="docutils literal"><span class="pre">handle_receive()</span></code> 或 <code class="docutils literal"><span class="pre">handle_send()</span></code> 方法被触发。</p>
<p>编写应用程序的时候，<code class="docutils literal"><span class="pre">EventHandler</span></code> 的实例会被创建。例如，下面是两个简单的基于UDP网络服务的处理器例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">UDPServer</span><span class="p">(</span><span class="n">EventHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">wants_to_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

<span class="k">class</span> <span class="nc">UDPTimeServer</span><span class="p">(</span><span class="n">UDPServer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span> <span class="n">addr</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">UDPEchoServer</span><span class="p">(</span><span class="n">UDPServer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">handlers</span> <span class="o">=</span> <span class="p">[</span> <span class="n">UDPTimeServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">14000</span><span class="p">)),</span> <span class="n">UDPEchoServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">15000</span><span class="p">))</span>  <span class="p">]</span>
    <span class="n">event_loop</span><span class="p">(</span><span class="n">handlers</span><span class="p">)</span>
</pre></div>
</div>
<p>测试这段代码，试着从另外一个Python解释器连接它：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">,(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span><span class="mi">14000</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="go">(b&#39;Tue Sep 18 14:29:23 2012&#39;, (&#39;127.0.0.1&#39;, 14000))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">,(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span><span class="mi">15000</span><span class="p">))</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="go">(b&#39;Hello&#39;, (&#39;127.0.0.1&#39;, 15000))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>实现一个TCP服务器会更加复杂一点，因为每一个客户端都要初始化一个新的处理器对象。
下面是一个TCP应答客户端例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">EventHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">client_handler</span><span class="p">,</span> <span class="n">handler_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client_handler</span> <span class="o">=</span> <span class="n">client_handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler_list</span> <span class="o">=</span> <span class="n">handler_list</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">wants_to_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">handle_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">client</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="c1"># Add the client to the event loop&#39;s handler list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client_handler</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler_list</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">TCPClient</span><span class="p">(</span><span class="n">EventHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">handler_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler_list</span> <span class="o">=</span> <span class="n">handler_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outgoing</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># Remove myself from the event loop&#39;s handler list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wants_to_send</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outgoing</span> <span class="k">else</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">handle_send</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nsent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outgoing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outgoing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outgoing</span><span class="p">[</span><span class="n">nsent</span><span class="p">:]</span>

<span class="k">class</span> <span class="nc">TCPEchoClient</span><span class="p">(</span><span class="n">TCPClient</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wants_to_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">handle_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outgoing</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
   <span class="n">handlers</span> <span class="o">=</span> <span class="p">[]</span>
   <span class="n">handlers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TCPServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">16000</span><span class="p">),</span> <span class="n">TCPEchoClient</span><span class="p">,</span> <span class="n">handlers</span><span class="p">))</span>
   <span class="n">event_loop</span><span class="p">(</span><span class="n">handlers</span><span class="p">)</span>
</pre></div>
</div>
<p>TCP例子的关键点是从处理器中列表增加和删除客户端的操作。
对每一个连接，一个新的处理器被创建并加到列表中。当连接被关闭后，每个客户端负责将其从列表中删除。
如果你运行程序并试着用Telnet或类似工具连接，它会将你发送的消息回显给你。并且它能很轻松的处理多客户端连接。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>实际上所有的事件驱动框架原理跟上面的例子相差无几。实际的实现细节和软件架构可能不一样，
但是在最核心的部分，都会有一个轮询的循环来检查活动socket，并执行响应操作。</p>
<p>事件驱动I/O的一个可能好处是它能处理非常大的并发连接，而不需要使用多线程或多进程。
也就是说，<code class="docutils literal"><span class="pre">select()</span></code> 调用（或其他等效的）能监听大量的socket并响应它们中任何一个产生事件的。
在循环中一次处理一个事件，并不需要其他的并发机制。</p>
<p>事件驱动I/O的缺点是没有真正的同步机制。
如果任何事件处理器方法阻塞或执行一个耗时计算，它会阻塞所有的处理进程。
调用那些并不是事件驱动风格的库函数也会有问题，同样要是某些库函数调用会阻塞，那么也会导致整个事件循环停止。</p>
<p>对于阻塞或耗时计算的问题可以通过将事件发送个其他单独的现场或进程来处理。
不过，在事件循环中引入多线程和多进程是比较棘手的，
下面的例子演示了如何使用 <code class="docutils literal"><span class="pre">concurrent.futures</span></code> 模块来实现：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">class</span> <span class="nc">ThreadPoolHandler</span><span class="p">(</span><span class="n">EventHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nworkers</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;posix&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signal_done_sock</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">server</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
            <span class="n">server</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">server</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signal_done_sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span>
                                                  <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signal_done_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">getsockname</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_sock</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="n">server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">nworkers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="c1"># Callback that executes when the thread is done</span>
    <span class="k">def</span> <span class="nf">_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">callback</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">result</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signal_done_sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

    <span class="c1"># Run a function in a thread pool</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span><span class="o">*</span><span class="p">,</span><span class="n">callback</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_complete</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">wants_to_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="c1"># Run callback functions of completed work</span>
    <span class="k">def</span> <span class="nf">handle_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Invoke all pending callback functions</span>
        <span class="k">for</span> <span class="n">callback</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>在代码中，<code class="docutils literal"><span class="pre">run()</span></code> 方法被用来将工作提交给回调函数池，处理完成后被激发。
实际工作被提交给 <code class="docutils literal"><span class="pre">ThreadPoolExecutor</span></code> 实例。
不过一个难点是协调计算结果和事件循环，为了解决它，我们创建了一对socket并将其作为某种信号量机制来使用。
当线程池完成工作后，它会执行类中的 <code class="docutils literal"><span class="pre">_complete()</span></code> 方法。
这个方法再某个socket上写入字节之前会讲挂起的回调函数和结果放入队列中。
<code class="docutils literal"><span class="pre">fileno()</span></code> 方法返回另外的那个socket。
因此，这个字节被写入时，它会通知事件循环，
然后 <code class="docutils literal"><span class="pre">handle_receive()</span></code> 方法被激活并为所有之前提交的工作执行回调函数。
坦白讲，说了这么多连我自己都晕了。
下面是一个简单的服务器，演示了如何使用线程池来实现耗时的计算：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># A really bad Fibonacci implementation</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">UDPFibServer</span><span class="p">(</span><span class="n">UDPServer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,),</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">respond</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">respond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span> <span class="n">addr</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPoolHandler</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">handlers</span> <span class="o">=</span> <span class="p">[</span> <span class="n">pool</span><span class="p">,</span> <span class="n">UDPFibServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">16000</span><span class="p">))]</span>
    <span class="n">event_loop</span><span class="p">(</span><span class="n">handlers</span><span class="p">)</span>
</pre></div>
</div>
<p>运行这个服务器，然后试着用其它Python程序来测试它：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">40</span><span class="p">):</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">16000</span><span class="p">))</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>你应该能在不同窗口中重复的执行这个程序，并且不会影响到其他程序，尽管当数字便越来越大时候它会变得越来越慢。</p>
<p>已经阅读完了这一小节，那么你应该使用这里的代码吗？也许不会。你应该选择一个可以完成同样任务的高级框架。
不过，如果你理解了基本原理，你就能理解这些框架所使用的核心技术。
作为对回调函数编程的替代，事件驱动编码有时候会使用到协程，参考12.12小节的一个例子。</p>
</div>
</div>
<span id="document-c11/p13_sending_receiving_large_arrays"></span><div class="section" id="id1">
<h3>11.13 发送与接收大型数组<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你要通过网络连接发送和接受连续数据的大型数组，并尽量减少数据的复制操作。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>下面的函数利用 <code class="docutils literal"><span class="pre">memoryviews</span></code> 来发送和接受大数组：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># zerocopy.py</span>

<span class="k">def</span> <span class="nf">send_from</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">):</span>
        <span class="n">nsent</span> <span class="o">=</span> <span class="n">dest</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">nsent</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">recv_into</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">):</span>
        <span class="n">nrecv</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">recv_into</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">nrecv</span><span class="p">:]</span>
</pre></div>
</div>
<p>为了测试程序，首先创建一个通过socket连接的服务器和客户端程序：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">25000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在客户端（另外一个解释器中）：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">25000</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>本节的目标是你能通过连接传输一个超大数组。这种情况的话，可以通过 <code class="docutils literal"><span class="pre">array</span></code> 模块或 <code class="docutils literal"><span class="pre">numpy</span></code> 模块来创建数组：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Server</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">50000000.0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">send_from</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>

<span class="c1"># Client</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">50000000</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">recv_into</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在数据密集型分布式计算和平行计算程序中，自己写程序来实现发送/接受大量数据并不常见。
不过，要是你确实想这样做，你可能需要将你的数据转换成原始字节，以便给低层的网络函数使用。
你可能还需要将数据切割成多个块，因为大部分和网络相关的函数并不能一次性发送或接受超大数据块。</p>
<p>一种方法是使用某种机制序列化数据——可能将其转换成一个字节字符串。
不过，这样最终会创建数据的一个复制。
就算你只是零碎的做这些，你的代码最终还是会有大量的小型复制操作。</p>
<p>本节通过使用内存视图展示了一些魔法操作。
本质上，一个内存视图就是一个已存在数组的覆盖层。不仅仅是那样，
内存视图还能以不同的方式转换成不同类型来表现数据。
这个就是下面这个语句的目的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">view</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>它接受一个数组 arr并将其转换为一个无符号字节的内存视图。这个视图能被传递给socket相关函数，
比如 <code class="docutils literal"><span class="pre">socket.send()</span></code> 或 <code class="docutils literal"><span class="pre">send.recv_into()</span></code> 。
在内部，这些方法能够直接操作这个内存区域。例如，<code class="docutils literal"><span class="pre">sock.send()</span></code> 直接从内存中发生数据而不需要复制。
<code class="docutils literal"><span class="pre">send.recv_into()</span></code> 使用这个内存区域作为接受操作的输入缓冲区。</p>
<p>剩下的一个难点就是socket函数可能只操作部分数据。
通常来讲，我们得使用很多不同的 <code class="docutils literal"><span class="pre">send()</span></code> 和 <code class="docutils literal"><span class="pre">recv_into()</span></code> 来传输整个数组。
不用担心，每次操作后，视图会通过发送或接受字节数量被切割成新的视图。
新的视图同样也是内存覆盖层。因此，还是没有任何的复制操作。</p>
<p>这里有个问题就是接受者必须事先知道有多少数据要被发送，
以便它能预分配一个数组或者确保它能将接受的数据放入一个已经存在的数组中。
如果没办法知道的话，发送者就得先将数据大小发送过来，然后再发送实际的数组数据。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p12_concurrency"></span><div class="section" id="id1">
<h2>第十二章：并发编程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>对于并发编程, Python有多种长期支持的方法, 包括多线程, 调用子进程, 以及各种各样的关于生成器函数的技巧.
这一章将会给出并发编程各种方面的技巧, 包括通用的多线程技术以及并行计算的实现方法.</p>
<p>像经验丰富的程序员所知道的那样, 大家担心并发的程序有潜在的危险.
因此, 本章的主要目标之一是给出更加可信赖和易调试的代码.</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c12/p01_start_stop_thread"></span><div class="section" id="id1">
<h3>12.1 启动与停止线程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你要为需要并发执行的代码创建/销毁线程</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">threading</span></code> 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可以创建一个 <code class="docutils literal"><span class="pre">Thread</span></code> 对象并将你要执行的对象以 target 参数的形式提供给该对象。
下面是一个简单的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Code to execute in an independent thread</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;T-minus&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Create and launch a thread</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">countdown</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>当你创建好一个线程对象后，该对象并不会立即执行，除非你调用它的 <code class="docutils literal"><span class="pre">start()</span></code> 方法（当你调用 <code class="docutils literal"><span class="pre">start()</span></code> 方法时，它会调用你传递进来的函数，并把你传递进来的参数传递给该函数）。Python中的线程会在一个单独的系统级线程中执行（比如说一个 POSIX 线程或者一个 Windows 线程），这些线程将由操作系统来全权管理。线程一旦启动，将独立执行直到目标函数返回。你可以查询一个线程对象的状态，看它是否还在执行：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Still running&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Completed&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>你也可以将一个线程加入到当前线程，并等待它终止：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>Python解释器直到所有线程都终止前仍保持运行。对于需要长时间运行的线程或者需要一直运行的后台任务，你应当考虑使用后台线程。
例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">countdown</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,),</span> <span class="n">daemon</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>后台线程无法等待，不过，这些线程会在主线程终止时自动销毁。
除了如上所示的两个操作，并没有太多可以对线程做的事情。你无法结束一个线程，无法给它发送信号，无法调整它的调度，也无法执行其他高级操作。如果需要这些特性，你需要自己添加。比如说，如果你需要终止线程，那么这个线程必须通过编程在某个特定点轮询来退出。你可以像下边这样把线程放入一个类中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CountdownTask</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;T-minus&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">CountdownTask</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span> <span class="c1"># Signal termination</span>
<span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>      <span class="c1"># Wait for actual termination (if needed)</span>
</pre></div>
</div>
<p>如果线程执行一些像I/O这样的阻塞操作，那么通过轮询来终止线程将使得线程之间的协调变得非常棘手。比如，如果一个线程一直阻塞在一个I/O操作上，它就永远无法返回，也就无法检查自己是否已经被结束了。要正确处理这些问题，你需要利用超时循环来小心操作线程。
例子如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IOTask</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="c1"># sock is a socket</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>        <span class="c1"># Set timeout period</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span>
            <span class="c1"># Perform a blocking I/O operation w/ timeout</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">timeout</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Continued processing</span>
            <span class="o">...</span>
        <span class="c1"># Terminated</span>
        <span class="k">return</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>由于全局解释锁（GIL）的原因，Python 的线程被限制到同一时刻只允许一个线程执行这样一个执行模型。所以，Python 的线程更适用于处理I/O和其他需要并发执行的阻塞操作（比如等待I/O、等待从数据库获取数据等等），而不是需要多处理器并行的计算密集型任务。</p>
<p>有时你会看到下边这种通过继承 <code class="docutils literal"><span class="pre">Thread</span></code> 类来实现的线程：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="k">class</span> <span class="nc">CountdownThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;T-minus&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">CountdownThread</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>尽管这样也可以工作，但这使得你的代码依赖于 <code class="docutils literal"><span class="pre">threading</span></code> 库，所以你的这些代码只能在线程上下文中使用。上文所写的那些代码、函数都是与 <code class="docutils literal"><span class="pre">threading</span></code> 库无关的，这样就使得这些代码可以被用在其他的上下文中，可能与线程有关，也可能与线程无关。比如，你可以通过 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 模块在一个单独的进程中执行你的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">CountdownTask</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>再次重申，这段代码仅适用于 CountdownTask 类是以独立于实际的并发手段（多线程、多进程等等）实现的情况。</p>
</div>
</div>
<span id="document-c12/p02_determining_if_thread_has_started"></span><div class="section" id="id1">
<h3>12.2 判断线程是否已经启动<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你已经启动了一个线程，但是你想知道它是不是真的已经开始运行了。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 <code class="docutils literal"><span class="pre">threading</span></code> 库中的 <code class="docutils literal"><span class="pre">Event</span></code> 对象。
<code class="docutils literal"><span class="pre">Event</span></code> 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置为假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。
下边的代码展示了如何使用 <code class="docutils literal"><span class="pre">Event</span></code> 来协调线程的启动：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Event</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Code to execute in an independent thread</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">started_evt</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;countdown starting&#39;</span><span class="p">)</span>
    <span class="n">started_evt</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;T-minus&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Create the event object that will be used to signal startup</span>
<span class="n">started_evt</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>

<span class="c1"># Launch the thread and pass the startup event</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Launching countdown&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">countdown</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">started_evt</span><span class="p">))</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Wait for the thread to start</span>
<span class="n">started_evt</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;countdown is running&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>当你执行这段代码，“countdown is running” 总是显示在 “countdown starting” 之后显示。这是由于使用 event 来协调线程，使得主线程要等到 <code class="docutils literal"><span class="pre">countdown()</span></code> 函数输出启动信息后，才能继续执行。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>event 对象最好单次使用，就是说，你创建一个 event 对象，让某个线程等待这个对象，一旦这个对象被设置为真，你就应该丢弃它。尽管可以通过 <code class="docutils literal"><span class="pre">clear()</span></code> 方法来重置 event 对象，但是很难确保安全地清理 event 对象并对它重新赋值。很可能会发生错过事件、死锁或者其他问题（特别是，你无法保证重置 event 对象的代码会在线程再次等待这个 event 对象之前执行）。如果一个线程需要不停地重复使用 event 对象，你最好使用 <code class="docutils literal"><span class="pre">Condition</span></code> 对象来代替。下面的代码使用 <code class="docutils literal"><span class="pre">Condition</span></code> 对象实现了一个周期定时器，每当定时器超时的时候，其他线程都可以监测到：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">PeriodicTimer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Run the timer and notify waiting threads after each interval</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interval</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="p">:</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span> <span class="o">^=</span> <span class="mi">1</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">wait_for_tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Wait for the next tick of the timer</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="p">:</span>
            <span class="n">last_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span>
            <span class="k">while</span> <span class="n">last_flag</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

<span class="c1"># Example use of the timer</span>
<span class="n">ptimer</span> <span class="o">=</span> <span class="n">PeriodicTimer</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ptimer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Two threads that synchronize on the timer</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">nticks</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">nticks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ptimer</span><span class="o">.</span><span class="n">wait_for_tick</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;T-minus&#39;</span><span class="p">,</span> <span class="n">nticks</span><span class="p">)</span>
        <span class="n">nticks</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">countup</span><span class="p">(</span><span class="n">last</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">:</span>
        <span class="n">ptimer</span><span class="o">.</span><span class="n">wait_for_tick</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Counting&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">countdown</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">countup</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>event对象的一个重要特点是当它被设置为真时会唤醒所有等待它的线程。如果你只想唤醒单个线程，最好是使用信号量或者 <code class="docutils literal"><span class="pre">Condition</span></code> 对象来替代。考虑一下这段使用信号量实现的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Worker thread</span>
<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">sema</span><span class="p">):</span>
    <span class="c1"># Wait to be signaled</span>
    <span class="n">sema</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="c1"># Do some work</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Working&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="c1"># Create some threads</span>
<span class="n">sema</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">nworkers</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nworkers</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">sema</span><span class="p">,))</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>运行上边的代码将会启动一个线程池，但是并没有什么事情发生。这是因为所有的线程都在等待获取信号量。每次信号量被释放，只有一个线程会被唤醒并执行，示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sema</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="go">Working 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sema</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="go">Working 1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>编写涉及到大量的线程间同步问题的代码会让你痛不欲生。比较合适的方式是使用队列来进行线程间通信或者每个把线程当作一个Actor，利用Actor模型来控制并发。下一节将会介绍到队列，而Actor模型将在12.10节介绍。</p>
</div>
</div>
<span id="document-c12/p03_communicating_between_threads"></span><div class="section" id="id1">
<h3>12.3 线程间通信<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序中有多个线程，你需要在这些线程之间安全地交换信息或数据</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 <code class="docutils literal"><span class="pre">queue</span></code> 库中的队列了。创建一个被多个线程共享的 <code class="docutils literal"><span class="pre">Queue</span></code> 对象，这些线程通过使用 <code class="docutils literal"><span class="pre">put()</span></code> 和 <code class="docutils literal"><span class="pre">get()</span></code> 操作来向队列中添加或者删除元素。
例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="c1"># A thread that produces data</span>
<span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">out_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># Produce some data</span>
        <span class="o">...</span>
        <span class="n">out_q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># A thread that consumes data</span>
<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">in_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="c1"># Get some data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">in_q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="c1"># Process the data</span>
        <span class="o">...</span>

<span class="c1"># Create the shared queue and launch both threads</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">consumer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">producer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Queue</span></code> 对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。
当使用队列时，协调生产者和消费者的关闭问题可能会有一些麻烦。一个通用的解决方法是在队列中放置一个特殊的值，当消费者读到这个值的时候，终止执行。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="c1"># Object that signals shutdown</span>
<span class="n">_sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="c1"># A thread that produces data</span>
<span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">out_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="c1"># Produce some data</span>
        <span class="o">...</span>
        <span class="n">out_q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Put the sentinel on the queue to indicate completion</span>
    <span class="n">out_q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">_sentinel</span><span class="p">)</span>

<span class="c1"># A thread that consumes data</span>
<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">in_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># Get some data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">in_q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="c1"># Check for termination</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">_sentinel</span><span class="p">:</span>
            <span class="n">in_q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">_sentinel</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c1"># Process the data</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>本例中有一个特殊的地方：消费者在读到这个特殊值之后立即又把它放回到队列中，将之传递下去。这样，所有监听这个队列的消费者线程就可以全部关闭了。
尽管队列是最常见的线程间通信机制，但是仍然可以自己通过创建自己的数据结构并添加所需的锁和同步机制来实现线程间通信。最常见的方法是使用 <code class="docutils literal"><span class="pre">Condition</span></code> 变量来包装你的数据结构。下边这个例子演示了如何创建一个线程安全的优先级队列，如同1.5节中介绍的那样。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">priority</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="p">:</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>使用队列来进行线程间通信是一个单向、不确定的过程。通常情况下，你没有办法知道接收数据的线程是什么时候接收到的数据并开始工作的。不过队列对象提供一些基本完成的特性，比如下边这个例子中的 <code class="docutils literal"><span class="pre">task_done()</span></code> 和 <code class="docutils literal"><span class="pre">join()</span></code> ：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="c1"># A thread that produces data</span>
<span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">out_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="c1"># Produce some data</span>
        <span class="o">...</span>
        <span class="n">out_q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># A thread that consumes data</span>
<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">in_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># Get some data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">in_q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="c1"># Process the data</span>
        <span class="o">...</span>
        <span class="c1"># Indicate completion</span>
        <span class="n">in_q</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

<span class="c1"># Create the shared queue and launch both threads</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">consumer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">producer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Wait for all produced items to be consumed</span>
<span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>如果一个线程需要在一个“消费者”线程处理完特定的数据项时立即得到通知，你可以把要发送的数据和一个 <code class="docutils literal"><span class="pre">Event</span></code> 放到一起使用，这样“生产者”就可以通过这个Event对象来监测处理的过程了。示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Event</span>

<span class="c1"># A thread that produces data</span>
<span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">out_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="c1"># Produce some data</span>
        <span class="o">...</span>
        <span class="c1"># Make an (data, event) pair and hand it to the consumer</span>
        <span class="n">evt</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="n">out_q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">evt</span><span class="p">))</span>
        <span class="o">...</span>
        <span class="c1"># Wait for the consumer to process the item</span>
        <span class="n">evt</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

<span class="c1"># A thread that consumes data</span>
<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">in_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># Get some data</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">evt</span> <span class="o">=</span> <span class="n">in_q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="c1"># Process the data</span>
        <span class="o">...</span>
        <span class="c1"># Indicate completion</span>
        <span class="n">evt</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>基于简单队列编写多线程程序在多数情况下是一个比较明智的选择。从线程安全队列的底层实现来看，你无需在你的代码中使用锁和其他底层的同步机制，这些只会把你的程序弄得乱七八糟。此外，使用队列这种基于消息的通信机制可以被扩展到更大的应用范畴，比如，你可以把你的程序放入多个进程甚至是分布式系统而无需改变底层的队列结构。
使用线程队列有一个要注意的问题是，向队列中添加数据项时并不会复制此数据项，线程间通信实际上是在线程间传递对象引用。如果你担心对象的共享状态，那你最好只传递不可修改的数据结构（如：整型、字符串或者元组）或者一个对象的深拷贝。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="c1"># A thread that produces data</span>
<span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">out_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># Produce some data</span>
        <span class="o">...</span>
        <span class="n">out_q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

<span class="c1"># A thread that consumes data</span>
<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">in_q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># Get some data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">in_q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="c1"># Process the data</span>
        <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Queue</span></code> 对象提供一些在当前上下文很有用的附加特性。比如在创建 Queue 对象时提供可选的 <code class="docutils literal"><span class="pre">size</span></code> 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，为队列中的元素数量添加上限是有意义的。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。在通信的线程之间进行“流量控制”是一个看起来容易实现起来困难的问题。如果你发现自己曾经试图通过摆弄队列大小来解决一个问题，这也许就标志着你的程序可能存在脆弱设计或者固有的可伸缩问题。
<code class="docutils literal"><span class="pre">get()</span></code> 和 <code class="docutils literal"><span class="pre">put()</span></code> 方法都支持非阻塞方式和设定超时，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">queue</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Full</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
<span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况，比如，一个非阻塞的 <code class="docutils literal"><span class="pre">put()</span></code> 方法和一个固定大小的队列一起使用，这样当队列已满时就可以执行不同的代码。比如输出一条日志信息并丢弃。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Full</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;queued item </span><span class="si">%r</span><span class="s1"> discarded!&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你试图让消费者线程在执行像 <code class="docutils literal"><span class="pre">q.get()</span></code> 这样的操作时，超时自动终止以便检查终止标志，你应该使用 <code class="docutils literal"><span class="pre">q.get()</span></code> 的可选参数 <code class="docutils literal"><span class="pre">timeout</span></code> ，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">_running</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">_running</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
            <span class="c1"># Process item</span>
            <span class="o">...</span>
        <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
<p>最后，有 <code class="docutils literal"><span class="pre">q.qsize()</span></code> ， <code class="docutils literal"><span class="pre">q.full()</span></code> ， <code class="docutils literal"><span class="pre">q.empty()</span></code> 等实用方法可以获取一个队列的当前大小和状态。但要注意，这些方法都不是线程安全的。可能你对一个队列使用 <code class="docutils literal"><span class="pre">empty()</span></code> 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。所以，你最好不要在你的代码中使用这些方法。</p>
</div>
</div>
<span id="document-c12/p04_locking_critical_sections"></span><div class="section" id="id1">
<h3>12.4 给关键部分加锁<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要对多线程程序中的临界区加锁以避免竞争条件。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>要在多线程程序中安全使用可变对象，你需要使用 threading 库中的 <code class="docutils literal"><span class="pre">Lock</span></code> 对象，就像下边这个例子这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">class</span> <span class="nc">SharedCounter</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A counter object that can be shared by multiple threads.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">initial_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Increment the counter with locking</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_lock</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">+=</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Decrement the counter with locking</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_lock</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">-=</span> <span class="n">delta</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Lock</span></code> 对象和 <code class="docutils literal"><span class="pre">with</span></code> 语句块一起使用可以保证互斥执行，就是每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>线程调度本质上是不确定的，因此，在多线程程序中错误地使用锁机制可能会导致随机数据损坏或者其他的异常行为，我们称之为竞争条件。为了避免竞争条件，最好只在临界区（对临界资源进行操作的那部分代码）使用锁。
在一些“老的” Python 代码中，显式获取和释放锁是很常见的。下边是一个上一个例子的变种：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">class</span> <span class="nc">SharedCounter</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A counter object that can be shared by multiple threads.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">initial_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Increment the counter with locking</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">+=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Decrement the counter with locking</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">-=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>相比于这种显式调用的方法，with 语句更加优雅，也更不容易出错，特别是程序员可能会忘记调用 release() 方法或者程序在获得锁之后产生异常这两种情况（使用 with 语句可以保证在这两种情况下仍能正确释放锁）。
为了避免出现死锁的情况，使用锁机制的程序应该设定为每个线程一次只允许获取一个锁。如果不能这样做的话，你就需要更高级的死锁避免机制，我们将在12.5节介绍。
在 <code class="docutils literal"><span class="pre">threading</span></code> 库中还提供了其他的同步原语，比如 <code class="docutils literal"><span class="pre">RLock</span></code> 和 <code class="docutils literal"><span class="pre">Semaphore</span></code> 对象。但是根据以往经验，这些原语是用于一些特殊的情况，如果你只是需要简单地对可变对象进行锁定，那就不应该使用它们。一个 <code class="docutils literal"><span class="pre">RLock</span></code> （可重入锁）可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下，当锁被持有时，只有一个线程可以使用完整的函数或者类中的方法。比如，你可以实现一个这样的 SharedCounter 类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">class</span> <span class="nc">SharedCounter</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A counter object that can be shared by multiple threads.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">initial_value</span>

    <span class="k">def</span> <span class="nf">incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Increment the counter with locking</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="n">SharedCounter</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">+=</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Decrement the counter with locking</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="n">SharedCounter</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span><span class="p">)</span>
</pre></div>
</div>
<p>在上边这个例子中，没有对每一个实例中的可变对象加锁，取而代之的是一个被所有实例共享的类级锁。这个锁用来同步类方法，具体来说就是，这个锁可以保证一次只有一个线程可以调用这个类方法。不过，与一个标准的锁不同的是，已经持有这个锁的方法在调用同样使用这个锁的方法时，无需再次获取锁。比如 decr 方法。
这种实现方式的一个特点是，无论这个类有多少个实例都只用一个锁。因此在需要大量使用计数器的情况下内存效率更高。不过这样做也有缺点，就是在程序中使用大量线程并频繁更新计数器时会有争用锁的问题。
信号量对象是一个建立在共享计数器基础上的同步原语。如果计数器不为0，with 语句将计数器减1，线程被允许执行。with 语句执行结束后，计数器加１。如果计数器为0，线程将被阻塞，直到其他线程结束将计数器加1。尽管你可以在程序中像标准锁一样使用信号量来做线程同步，但是这种方式并不被推荐，因为使用信号量为程序增加的复杂性会影响程序性能。相对于简单地作为锁使用，信号量更适用于那些需要在线程之间引入信号或者限制的程序。比如，你需要限制一段代码的并发访问量，你就可以像下面这样使用信号量完成：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Semaphore</span>
<span class="kn">import</span> <span class="nn">urllib.request</span>

<span class="c1"># At most, five threads allowed to run at once</span>
<span class="n">_fetch_url_sema</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fetch_url</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">_fetch_url_sema</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你对线程同步原语的底层理论和实现感兴趣，可以参考操作系统相关书籍，绝大多数都有提及。</p>
</div>
</div>
<span id="document-c12/p05_locking_with_deadlock_avoidance"></span><div class="section" id="id1">
<h3>12.5 防止死锁的加锁机制<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你正在写一个多线程程序，其中线程需要一次获取多个锁，此时如何避免死锁问题。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在多线程程序中，死锁问题很大一部分是由于线程同时获取多个锁造成的。举个例子：一个线程获取了第一个锁，然后在获取第二个锁的
时候发生阻塞，那么这个线程就可能阻塞其他线程的执行，从而导致整个程序假死。
解决死锁问题的一种方案是为程序中的每一个锁分配一个唯一的id，然后只允许按照升序规则来使用多个锁，这个规则使用上下文管理器
是非常容易实现的，示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="c1"># Thread-local state to stored information on locks already acquired</span>
<span class="n">_local</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="o">*</span><span class="n">locks</span><span class="p">):</span>
    <span class="c1"># Sort locks by object identifier</span>
    <span class="n">locks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">locks</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># Make sure lock order of previously acquired locks is not violated</span>
    <span class="n">acquired</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_local</span><span class="p">,</span><span class="s1">&#39;acquired&#39;</span><span class="p">,[])</span>
    <span class="k">if</span> <span class="n">acquired</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="k">for</span> <span class="n">lock</span> <span class="ow">in</span> <span class="n">acquired</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">id</span><span class="p">(</span><span class="n">locks</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Lock Order Violation&#39;</span><span class="p">)</span>

    <span class="c1"># Acquire all of the locks</span>
    <span class="n">acquired</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locks</span><span class="p">)</span>
    <span class="n">_local</span><span class="o">.</span><span class="n">acquired</span> <span class="o">=</span> <span class="n">acquired</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">lock</span> <span class="ow">in</span> <span class="n">locks</span><span class="p">:</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Release locks in reverse order of acquisition</span>
        <span class="k">for</span> <span class="n">lock</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">locks</span><span class="p">):</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">acquired</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">locks</span><span class="p">):]</span>
</pre></div>
</div>
<p>如何使用这个上下文管理器呢？你可以按照正常途径创建一个锁对象，但不论是单个锁还是多个锁中都使用 <code class="docutils literal"><span class="pre">acquire()</span></code> 函数来申请锁，
示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="n">x_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="n">y_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">thread_1</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">x_lock</span><span class="p">,</span> <span class="n">y_lock</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Thread-1&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">thread_2</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">y_lock</span><span class="p">,</span> <span class="n">x_lock</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Thread-2&#39;</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_1</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_2</span><span class="p">)</span>
<span class="n">t2</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你执行这段代码，你会发现它即使在不同的函数中以不同的顺序获取锁也没有发生死锁。
其关键在于，在第一段代码中，我们对这些锁进行了排序。通过排序，使得不管用户以什么样的顺序来请求锁，这些锁都会按照固定的顺序被获取。
如果有多个 <code class="docutils literal"><span class="pre">acquire()</span></code> 操作被嵌套调用，可以通过线程本地存储（TLS）来检测潜在的死锁问题。
假设你的代码是这样写的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="n">x_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="n">y_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">thread_1</span><span class="p">():</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">x_lock</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">y_lock</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Thread-1&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">thread_2</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">y_lock</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">x_lock</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Thread-2&#39;</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_1</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_2</span><span class="p">)</span>
<span class="n">t2</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你运行这个版本的代码，必定会有一个线程发生崩溃，异常信息可能像这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ne">Exception</span> <span class="ow">in</span> <span class="n">thread</span> <span class="n">Thread</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/threading.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">639</span><span class="p">,</span> <span class="ow">in</span> <span class="n">_bootstrap_inner</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
  <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/threading.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">596</span><span class="p">,</span> <span class="ow">in</span> <span class="n">run</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&quot;deadlock.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">49</span><span class="p">,</span> <span class="ow">in</span> <span class="n">thread_1</span>
    <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">y_lock</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python3.3/contextlib.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">48</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__enter__</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&quot;deadlock.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">15</span><span class="p">,</span> <span class="ow">in</span> <span class="n">acquire</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Lock Order Violation&quot;</span><span class="p">)</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Lock</span> <span class="n">Order</span> <span class="n">Violation</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>发生崩溃的原因在于，每个线程都记录着自己已经获取到的锁。 <code class="docutils literal"><span class="pre">acquire()</span></code> 函数会检查之前已经获取的锁列表，
由于锁是按照升序排列获取的，所以函数会认为之前已获取的锁的id必定小于新申请到的锁，这时就会触发异常。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>死锁是每一个多线程程序都会面临的一个问题（就像它是每一本操作系统课本的共同话题一样）。根据经验来讲，尽可能保证每一个
线程只能同时保持一个锁，这样程序就不会被死锁问题所困扰。一旦有线程同时申请多个锁，一切就不可预料了。</p>
<p>死锁的检测与恢复是一个几乎没有优雅的解决方案的扩展话题。一个比较常用的死锁检测与恢复的方案是引入看门狗计数器。当线程正常
运行的时候会每隔一段时间重置计数器，在没有发生死锁的情况下，一切都正常进行。一旦发生死锁，由于无法重置计数器导致定时器
超时，这时程序会通过重启自身恢复到正常状态。</p>
<p>避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入
死锁状态。证明就留给读者作为练习了。避免死锁的主要思想是，单纯地按照对象id递增的顺序加锁不会产生循环依赖，而循环依赖是
死锁的一个必要条件，从而避免程序进入死锁状态。</p>
<p>下面以一个关于线程死锁的经典问题：“哲学家就餐问题”，作为本节最后一个例子。题目是这样的：五位哲学家围坐在一张桌子前，每个人
面前有一碗饭和一只筷子。在这里每个哲学家可以看做是一个独立的线程，而每只筷子可以看做是一个锁。每个哲学家可以处在静坐、
思考、吃饭三种状态中的一个。需要注意的是，每个哲学家吃饭是需要两只筷子的，这样问题就来了：如果每个哲学家都拿起自己左边的筷子，
那么他们五个都只能拿着一只筷子坐在那儿，直到饿死。此时他们就进入了死锁状态。
下面是一个简单的使用死锁避免机制解决“哲学家就餐问题”的实现：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="c1"># The philosopher thread</span>
<span class="k">def</span> <span class="nf">philosopher</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">acquire</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">):</span>
             <span class="k">print</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span> <span class="s1">&#39;eating&#39;</span><span class="p">)</span>

<span class="c1"># The chopsticks (represented by locks)</span>
<span class="n">NSTICKS</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">chopsticks</span> <span class="o">=</span> <span class="p">[</span><span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NSTICKS</span><span class="p">)]</span>

<span class="c1"># Create all of the philosophers</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NSTICKS</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">philosopher</span><span class="p">,</span>
                         <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">chopsticks</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">chopsticks</span><span class="p">[(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NSTICKS</span><span class="p">]))</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>最后，要特别注意到，为了避免死锁，所有的加锁操作必须使用 <code class="docutils literal"><span class="pre">acquire()</span></code> 函数。如果代码中的某部分绕过acquire
函数直接申请锁，那么整个死锁避免机制就不起作用了。</p>
</div>
</div>
<span id="document-c12/p06_storing_thread_specific_state"></span><div class="section" id="id1">
<h3>12.6 保存线程的状态信息<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要保存正在运行线程的状态，这个状态对于其他的线程是不可见的。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>有时在多线程编程中，你需要只保存当前运行线程的状态。
要这么做，可使用 <code class="docutils literal"><span class="pre">thread.local()</span></code> 创建一个本地线程存储对象。
对这个对象的属性的保存和读取操作都只会对执行线程可见，而其他线程并不可见。</p>
<p>作为使用本地存储的一个有趣的实际例子，
考虑在8.3小节定义过的 <code class="docutils literal"><span class="pre">LazyConnection</span></code> 上下文管理器类。
下面我们对它进行一些小的修改使得它可以适用于多线程：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="k">class</span> <span class="nc">LazyConnection</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">AF_INET</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">,</span> <span class="s1">&#39;sock&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already connected&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_ty</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">sock</span>
</pre></div>
</div>
<p>代码中，自己观察对于 <code class="docutils literal"><span class="pre">self.local</span></code> 属性的使用。
它被初始化尾一个 <code class="docutils literal"><span class="pre">threading.local()</span></code> 实例。
其他方法操作被存储为 <code class="docutils literal"><span class="pre">self.local.sock</span></code> 的套接字对象。
有了这些就可以在多线程中安全的使用 <code class="docutils literal"><span class="pre">LazyConnection</span></code> 实例了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">conn</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;GET /index.html HTTP/1.0</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Host: www.python.org</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">,</span> <span class="mi">8192</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got {} bytes&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resp</span><span class="p">)))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">LazyConnection</span><span class="p">((</span><span class="s1">&#39;www.python.org&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">conn</span><span class="p">,))</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">conn</span><span class="p">,))</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>它之所以行得通的原因是每个线程会创建一个自己专属的套接字连接（存储为self.local.sock）。
因此，当不同的线程执行套接字操作时，由于操作的是不同的套接字，因此它们不会相互影响。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在大部分程序中创建和操作线程特定状态并不会有什么问题。
不过，当出了问题的时候，通常是因为某个对象被多个线程使用到，用来操作一些专用的系统资源，
比如一个套接字或文件。你不能让所有线程贡献一个单独对象，
因为多个线程同时读和写的时候会产生混乱。
本地线程存储通过让这些资源只能在被使用的线程中可见来解决这个问题。</p>
<p>本节中，使用 <code class="docutils literal"><span class="pre">thread.local()</span></code> 可以让 <code class="docutils literal"><span class="pre">LazyConnection</span></code> 类支持一个线程一个连接，
而不是对于所有的进程都只有一个连接。</p>
<p>其原理是，每个 <code class="docutils literal"><span class="pre">threading.local()</span></code> 实例为每个线程维护着一个单独的实例字典。
所有普通实例操作比如获取、修改和删除值仅仅操作这个字典。
每个线程使用一个独立的字典就可以保证数据的隔离了。</p>
</div>
</div>
<span id="document-c12/p07_creating_thread_pool"></span><div class="section" id="id1">
<h3>12.7 创建一个线程池<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你创建一个工作者线程池，用来相应客户端请求或执行其他的工作。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">concurrent.futures</span></code> 函数库有一个 <code class="docutils literal"><span class="pre">ThreadPoolExecutor</span></code> 类可以被用来完成这个任务。
下面是一个简单的TCP服务器，使用了一个线程池来响应客户端：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">socket</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Handle a client connection</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from&#39;</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Client closed connection&#39;</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">echo_client</span><span class="p">,</span> <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">15000</span><span class="p">))</span>
</pre></div>
</div>
<p>如果你想手动创建你自己的线程池，
通常可以使用一个Queue来轻松实现。下面是一个稍微不同但是手动实现的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Handle a client connection</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from&#39;</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Client closed connection&#39;</span><span class="p">)</span>

    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">nworkers</span><span class="p">):</span>
    <span class="c1"># Launch the client workers</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nworkers</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">echo_client</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># Run the server</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">))</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">15000</span><span class="p">),</span> <span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">ThreadPoolExecutor</span></code> 相对于手动实现的一个好处在于它使得
任务提交者更方便的从被调用函数中获取返回值。例如，你可能会像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">import</span> <span class="nn">urllib.request</span>

<span class="k">def</span> <span class="nf">fetch_url</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># Submit work to the pool</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">fetch_url</span><span class="p">,</span> <span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">fetch_url</span><span class="p">,</span> <span class="s1">&#39;http://www.pypy.org&#39;</span><span class="p">)</span>

<span class="c1"># Get the results back</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</pre></div>
</div>
<p>例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。
特别的，<code class="docutils literal"><span class="pre">a.result()</span></code> 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>通常来讲，你应该避免编写线程数量可以无限制增长的程序。例如，看看下面这个服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Handle a client connection</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from&#39;</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Client closed connection&#39;</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">nworkers</span><span class="p">):</span>
    <span class="c1"># Run the server</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">echo_client</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">15000</span><span class="p">))</span>
</pre></div>
</div>
<p>尽管这个也可以工作，
但是它不能抵御有人试图通过创建大量线程让你服务器资源枯竭而崩溃的攻击行为。
通过使用预先初始化的线程池，你可以设置同时运行线程的上限数量。</p>
<p>你可能会关心创建大量线程会有什么后果。
现代操作系统可以很轻松的创建几千个线程的线程池。
甚至，同时几千个线程等待工作并不会对其他代码产生性能影响。
当然了，如果所有线程同时被唤醒并立即在CPU上执行，那就不同了——特别是有了全局解释器锁GIL。
通常，你应该只在I/O处理相关代码中使用线程池。</p>
<p>创建大的线程池的一个可能需要关注的问题是内存的使用。
例如，如果你在OS X系统上面创建2000个线程，系统显示Python进程使用了超过9GB的虚拟内存。
不过，这个计算通常是有误差的。当创建一个线程时，操作系统会预留一个虚拟内存区域来
放置线程的执行栈（通常是8MB大小）。但是这个内存只有一小片段被实际映射到真实内存中。
因此，Python进程使用到的真实内存其实很小
（比如，对于2000个线程来讲，只使用到了70MB的真实内存，而不是9GB）。
如果你担心虚拟内存大小，可以使用 <code class="docutils literal"><span class="pre">threading.stack_size()</span></code> 函数来降低它。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="n">threading</span><span class="o">.</span><span class="n">stack_size</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你加上这条语句并再次运行前面的创建2000个线程试验，
你会发现Python进程只使用到了大概210MB的虚拟内存，而真实内存使用量没有变。
注意线程栈大小必须至少为32768字节，通常是系统内存页大小（4096、8192等）的整数倍。</p>
</div>
</div>
<span id="document-c12/p08_perform_simple_parallel_programming"></span><div class="section" id="id1">
<h3>12.8 简单的并行编程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有个程序要执行CPU密集型工作，你想让他利用多核CPU的优势来运行的快一点。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">concurrent.futures</span></code> 库提供了一个 <code class="docutils literal"><span class="pre">ProcessPoolExecutor</span></code> 类，
可被用来在一个单独的Python解释器中执行计算密集型函数。
不过，要使用它，你首先要有一些计算密集型的任务。
我们通过一个简单而实际的例子来演示它。假定你有个Apache web服务器日志目录的gzip压缩包：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">logs</span><span class="o">/</span>
   <span class="mf">20120701.</span><span class="n">log</span><span class="o">.</span><span class="n">gz</span>
   <span class="mf">20120702.</span><span class="n">log</span><span class="o">.</span><span class="n">gz</span>
   <span class="mf">20120703.</span><span class="n">log</span><span class="o">.</span><span class="n">gz</span>
   <span class="mf">20120704.</span><span class="n">log</span><span class="o">.</span><span class="n">gz</span>
   <span class="mf">20120705.</span><span class="n">log</span><span class="o">.</span><span class="n">gz</span>
   <span class="mf">20120706.</span><span class="n">log</span><span class="o">.</span><span class="n">gz</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>进一步假设每个日志文件内容类似下面这样：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">124.115</span><span class="o">.</span><span class="mf">6.12</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">10</span><span class="o">/</span><span class="n">Jul</span><span class="o">/</span><span class="mi">2012</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">50</span> <span class="o">-</span><span class="mi">0500</span><span class="p">]</span> <span class="s2">&quot;GET /robots.txt ...&quot;</span> <span class="mi">200</span> <span class="mi">71</span>
<span class="mf">210.212</span><span class="o">.</span><span class="mf">209.67</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">10</span><span class="o">/</span><span class="n">Jul</span><span class="o">/</span><span class="mi">2012</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">51</span> <span class="o">-</span><span class="mi">0500</span><span class="p">]</span> <span class="s2">&quot;GET /ply/ ...&quot;</span> <span class="mi">200</span> <span class="mi">11875</span>
<span class="mf">210.212</span><span class="o">.</span><span class="mf">209.67</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">10</span><span class="o">/</span><span class="n">Jul</span><span class="o">/</span><span class="mi">2012</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">51</span> <span class="o">-</span><span class="mi">0500</span><span class="p">]</span> <span class="s2">&quot;GET /favicon.ico ...&quot;</span> <span class="mi">404</span> <span class="mi">369</span>
<span class="mf">61.135</span><span class="o">.</span><span class="mf">216.105</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">10</span><span class="o">/</span><span class="n">Jul</span><span class="o">/</span><span class="mi">2012</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mi">04</span> <span class="o">-</span><span class="mi">0500</span><span class="p">]</span> <span class="s2">&quot;GET /blog/atom.xml ...&quot;</span> <span class="mi">304</span> <span class="o">-</span>
<span class="o">...</span>
</pre></div>
</div>
<p>下面是一个脚本，在这些日志文件中查找出所有访问过robots.txt文件的主机：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># findrobots.py</span>

<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">glob</span>

<span class="k">def</span> <span class="nf">find_robots</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find all of the hosts that access robots.txt in a single log file</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">robots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">io</span><span class="o">.</span><span class="n">TextIOWrapper</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">fields</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/robots.txt&#39;</span><span class="p">:</span>
                <span class="n">robots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">robots</span>

<span class="k">def</span> <span class="nf">find_all_robots</span><span class="p">(</span><span class="n">logdir</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find all hosts across and entire sequence of files</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">logdir</span><span class="o">+</span><span class="s1">&#39;/*.log.gz&#39;</span><span class="p">)</span>
    <span class="n">all_robots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">robots</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">find_robots</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="n">all_robots</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">robots</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_robots</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">robots</span> <span class="o">=</span> <span class="n">find_all_robots</span><span class="p">(</span><span class="s1">&#39;logs&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ipaddr</span> <span class="ow">in</span> <span class="n">robots</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">)</span>
</pre></div>
</div>
<p>前面的程序使用了通常的map-reduce风格来编写。
函数 <code class="docutils literal"><span class="pre">find_robots()</span></code> 在一个文件名集合上做map操作，并将结果汇总为一个单独的结果，
也就是 <code class="docutils literal"><span class="pre">find_all_robots()</span></code> 函数中的 <code class="docutils literal"><span class="pre">all_robots</span></code> 集合。
现在，假设你想要修改这个程序让它使用多核CPU。
很简单——只需要将map()操作替换为一个 <code class="docutils literal"><span class="pre">concurrent.futures</span></code> 库中生成的类似操作即可。
下面是一个简单修改版本：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># findrobots.py</span>

<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">from</span> <span class="nn">concurrent</span> <span class="kn">import</span> <span class="n">futures</span>

<span class="k">def</span> <span class="nf">find_robots</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find all of the hosts that access robots.txt in a single log file</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">robots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">io</span><span class="o">.</span><span class="n">TextIOWrapper</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">fields</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/robots.txt&#39;</span><span class="p">:</span>
                <span class="n">robots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">robots</span>

<span class="k">def</span> <span class="nf">find_all_robots</span><span class="p">(</span><span class="n">logdir</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find all hosts across and entire sequence of files</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">logdir</span><span class="o">+</span><span class="s1">&#39;/*.log.gz&#39;</span><span class="p">)</span>
    <span class="n">all_robots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">robots</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">find_robots</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
            <span class="n">all_robots</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">robots</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_robots</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">robots</span> <span class="o">=</span> <span class="n">find_all_robots</span><span class="p">(</span><span class="s1">&#39;logs&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ipaddr</span> <span class="ow">in</span> <span class="n">robots</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">)</span>
</pre></div>
</div>
<p>通过这个修改后，运行这个脚本产生同样的结果，但是在四核机器上面比之前快了3.5倍。
实际的性能优化效果根据你的机器CPU数量的不同而不同。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">ProcessPoolExecutor</span></code> 的典型用法如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>

<span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">do</span> <span class="n">work</span> <span class="ow">in</span> <span class="n">parallel</span> <span class="n">using</span> <span class="n">pool</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>其原理是，一个 <code class="docutils literal"><span class="pre">ProcessPoolExecutor</span></code> 创建N个独立的Python解释器，
N是系统上面可用CPU的个数。你可以通过提供可选参数给 <code class="docutils literal"><span class="pre">ProcessPoolExecutor(N)</span></code> 来修改
处理器数量。这个处理池会一直运行到with块中最后一个语句执行完成，
然后处理池被关闭。不过，程序会一直等待直到所有提交的工作被处理完成。</p>
<p>被提交到池中的工作必须被定义为一个函数。有两种方法去提交。
如果你想让一个列表推导或一个 <code class="docutils literal"><span class="pre">map()</span></code> 操作并行执行的话，可使用 <code class="docutils literal"><span class="pre">pool.map()</span></code> :</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># A function that performs a lot of work</span>
<span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Nonparallel code</span>
<span class="n">results</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># Parallel implementation</span>
<span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>另外，你可以使用 <code class="docutils literal"><span class="pre">pool.submit()</span></code> 来手动的提交单个任务：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Some function</span>
<span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="c1"># Example of submitting work to the pool</span>
    <span class="n">future_result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="c1"># Obtaining the result (blocks until done)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">future_result</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果你手动提交一个任务，结果是一个 <code class="docutils literal"><span class="pre">Future</span></code> 实例。
要获取最终结果，你需要调用它的 <code class="docutils literal"><span class="pre">result()</span></code> 方法。
它会阻塞进程直到结果被返回来。</p>
<p>如果不想阻塞，你还可以使用一个回调函数，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">when_done</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>

<span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
     <span class="n">future_result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
     <span class="n">future_result</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">when_done</span><span class="p">)</span>
</pre></div>
</div>
<p>回调函数接受一个 <code class="docutils literal"><span class="pre">Future</span></code> 实例，被用来获取最终的结果（比如通过调用它的result()方法）。
尽管处理池很容易使用，在设计大程序的时候还是有很多需要注意的地方，如下几点：</p>
<ul class="simple">
<li>这种并行处理技术只适用于那些可以被分解为互相独立部分的问题。</li>
<li>被提交的任务必须是简单函数形式。对于方法、闭包和其他类型的并行执行还不支持。</li>
<li>函数参数和返回值必须兼容pickle，因为要使用到进程间的通信，所有解释器之间的交换数据必须被序列化</li>
<li>被提交的任务函数不应保留状态或有副作用。除了打印日志之类简单的事情，</li>
</ul>
<p>一旦启动你不能控制子进程的任何行为，因此最好保持简单和纯洁——函数不要去修改环境。</p>
<ul class="simple">
<li>在Unix上进程池通过调用 <code class="docutils literal"><span class="pre">fork()</span></code> 系统调用被创建，</li>
</ul>
<p>它会克隆Python解释器，包括fork时的所有程序状态。
而在Windows上，克隆解释器时不会克隆状态。
实际的fork操作会在第一次调用 <code class="docutils literal"><span class="pre">pool.map()</span></code> 或 <code class="docutils literal"><span class="pre">pool.submit()</span></code> 后发生。</p>
<ul class="simple">
<li>当你混合使用进程池和多线程的时候要特别小心。</li>
</ul>
<p>你应该在创建任何线程之前先创建并激活进程池（比如在程序启动的main线程中创建进程池）。</p>
</div>
</div>
<span id="document-c12/p09_dealing_with_gil_stop_worring_about_it"></span><div class="section" id="python">
<h3>12.9 Python的全局锁问题<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你已经听说过全局解释器锁GIL，担心它会影响到多线程程序的执行性能。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>尽管Python完全支持多线程编程，
但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。
实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。
GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势
（比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。</p>
<p>在讨论普通的GIL之前，有一点要强调的是GIL只会影响到那些严重依赖CPU的程序（比如计算型的）。
如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适，
因为它们大部分时间都在等待。实际上，你完全可以放心的创建几千个Python线程，
现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p>
<p>而对于依赖CPU的程序，你需要弄清楚执行的计算的特点。
例如，优化底层算法要比使用多线程运行快得多。
类似的，由于Python是解释执行的，如果你将那些性能瓶颈代码移到一个C语言扩展模块中，
速度也会提升的很快。如果你要操作数组，那么使用NumPy这样的扩展会非常的高效。
最后，你还可以考虑下其他可选实现方案，比如PyPy，它通过一个JIT编译器来优化执行效率
（不过在写这本书的时候它还不能支持Python 3）。</p>
<p>还有一点要注意的是，线程不是专门用来优化性能的。
一个CPU依赖型程序可能会使用线程来管理一个图形用户界面、一个网络连接或其他服务。
这时候，GIL会产生一些问题，因为如果一个线程长期持有GIL的话会导致其他非CPU型线程一直等待。
事实上，一个写的不好的C语言扩展会导致这个问题更加严重，
尽管代码的计算部分会比之前运行的更快些。</p>
<p>说了这么多，现在想说的是我们有两种策略来解决GIL的缺点。
首先，如果你完全工作于Python环境中，你可以使用 <code class="docutils literal"><span class="pre">multiprocessing</span></code> 模块来创建一个进程池，
并像协同处理器一样的使用它。例如，假如你有如下的线程代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Performs a large calculation (CPU bound)</span>
<span class="k">def</span> <span class="nf">some_work</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># A thread that calls the above function</span>
<span class="k">def</span> <span class="nf">some_thread</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">some_work</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>修改代码，使用进程池：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Processing pool (see below for initiazation)</span>
<span class="n">pool</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># Performs a large calculation (CPU bound)</span>
<span class="k">def</span> <span class="nf">some_work</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># A thread that calls the above function</span>
<span class="k">def</span> <span class="nf">some_thread</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_work</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="o">...</span>

<span class="c1"># Initiaze the pool</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
</pre></div>
</div>
<p>这个通过使用一个技巧利用进程池解决了GIL的问题。
当一个线程想要执行CPU密集型工作时，会将任务发给进程池。
然后进程池会在另外一个进程中启动一个单独的Python解释器来工作。
当线程等待结果的时候会释放GIL。
并且，由于计算任务在单独解释器中执行，那么就不会受限于GIL了。
在一个多核系统上面，你会发现这个技术可以让你很好的利用多CPU的优势。</p>
<p>另外一个解决GIL的策略是使用C扩展编程技术。
主要思想是将计算密集型任务转移给C，跟Python独立，在工作的时候在C代码中释放GIL。
这可以通过在C代码中插入下面这样的特殊宏来完成：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &quot;Python.h&quot;</span>
<span class="o">...</span>

<span class="n">PyObject</span> <span class="o">*</span><span class="n">pyfunc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">...</span>
   <span class="n">Py_BEGIN_ALLOW_THREADS</span>
   <span class="o">//</span> <span class="n">Threaded</span> <span class="n">C</span> <span class="n">code</span>
   <span class="o">...</span>
   <span class="n">Py_END_ALLOW_THREADS</span>
   <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果你使用其他工具访问C语言，比如对于Cython的ctypes库，你不需要做任何事。
例如，ctypes在调用C时会自动释放GIL。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>许多程序员在面对线程性能问题的时候，马上就会怪罪GIL，什么都是它的问题。
其实这样子太不厚道也太天真了点。
作为一个真实的例子，在多线程的网络编程中神秘的 <code class="docutils literal"><span class="pre">stalls</span></code>
可能是因为其他原因比如一个DNS查找延时，而跟GIL毫无关系。
最后你真的需要先去搞懂你的代码是否真的被GIL影响到。
同时还要明白GIL大部分都应该只关注CPU的处理而不是I/O.</p>
<p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。
被执行的操作需要放在一个通过def语句定义的Python函数中，不能是lambda、闭包可调用实例等，
并且函数参数和返回值必须要兼容pickle。
同样，要执行的任务量必须足够大以弥补额外的通信开销。</p>
<p>另外一个难点是当混合使用线程和进程池的时候会让你很头疼。
如果你要同时使用两者，最好在程序启动时，创建任何线程之前先创建一个单例的进程池。
然后线程使用同样的进程池来进行它们的计算密集型工作。</p>
<p>C扩展最重要的特征是它们和Python解释器是保持独立的。
也就是说，如果你准备将Python中的任务分配到C中去执行，
你需要确保C代码的操作跟Python保持独立，
这就意味着不要使用Python数据结构以及不要调用Python的C API。
另外一个就是你要确保C扩展所做的工作是足够的，值得你这样做。
也就是说C扩展担负起了大量的计算任务，而不是少数几个计算。</p>
<p>这些解决GIL的方案并不能适用于所有问题。
例如，某些类型的应用程序如果被分解为多个进程处理的话并不能很好的工作，
也不能将它的部分代码改成C语言执行。
对于这些应用程序，你就要自己需求解决方案了
（比如多进程访问共享内存区，多解析器运行于同一个进程等）。
或者，你还可以考虑下其他的解释器实现，比如PyPy。</p>
<p>了解更多关于在C扩展中释放GIL，请参考15.7和15.10小节。</p>
</div>
</div>
<span id="document-c12/p10_defining_an_actor_task"></span><div class="section" id="actor">
<h3>12.10 定义一个Actor任务<a class="headerlink" href="#actor" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想定义跟actor模式中类似“actors”角色的任务</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>actor模式是一种最古老的也是最简单的并行和分布式计算解决方案。
事实上，它天生的简单性是它如此受欢迎的重要原因之一。
简单来讲，一个actor就是一个并发执行的任务，只是简单的执行发送给它的消息任务。
响应这些消息时，它可能还会给其他actor发送更进一步的消息。
actor之间的通信是单向和异步的。因此，消息发送者不知道消息是什么时候被发送，
也不会接收到一个消息已被处理的回应或通知。</p>
<p>结合使用一个线程和一个队列可以很容易的定义actor，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Event</span>

<span class="c1"># Sentinel used for shutdown</span>
<span class="k">class</span> <span class="nc">ActorExit</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Actor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mailbox</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Send a message to the actor</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mailbox</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">recv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Receive an incoming message</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mailbox</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="n">ActorExit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ActorExit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Close the actor, thus shutting it down</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ActorExit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Start concurrent execution</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_terminated</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bootstrap</span><span class="p">)</span>

        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ActorExit</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_terminated</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_terminated</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Run method to be implemented by the user</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>

<span class="c1"># Sample ActorTask</span>
<span class="k">class</span> <span class="nc">PrintActor</span><span class="p">(</span><span class="n">Actor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got:&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

<span class="c1"># Sample use</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">PrintActor</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;World&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>这个例子中，你使用actor实例的 <code class="docutils literal"><span class="pre">send()</span></code> 方法发送消息给它们。
其机制是，这个方法会将消息放入一个队里中，
然后将其转交给处理被接受消息的一个内部线程。
<code class="docutils literal"><span class="pre">close()</span></code> 方法通过在队列中放入一个特殊的哨兵值（ActorExit）来关闭这个actor。
用户可以通过继承Actor并定义实现自己处理逻辑run()方法来定义新的actor。
<code class="docutils literal"><span class="pre">ActorExit</span></code> 异常的使用就是用户自定义代码可以在需要的时候来捕获终止请求
（异常被get()方法抛出并传播出去）。</p>
<p>如果你放宽对于同步和异步消息发送的要求，
类actor对象还可以通过生成器来简化定义。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_actor</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="k">yield</span>      <span class="c1"># Get a message</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got:&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Actor terminating&#39;</span><span class="p">)</span>

<span class="c1"># Sample use</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">print_actor</span><span class="p">()</span>
<span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>     <span class="c1"># Advance to the yield (ready to receive)</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;World&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>actor模式的魅力就在于它的简单性。
实际上，这里仅仅只有一个核心操作 <code class="docutils literal"><span class="pre">send()</span></code> .
甚至，对于在基于actor系统中的“消息”的泛化概念可以已多种方式被扩展。
例如，你可以以元组形式传递标签消息，让actor执行不同的操作，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TaggedActor</span><span class="p">(</span><span class="n">Actor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
             <span class="n">tag</span><span class="p">,</span> <span class="o">*</span><span class="n">payload</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
             <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;do_&#39;</span><span class="o">+</span><span class="n">tag</span><span class="p">)(</span><span class="o">*</span><span class="n">payload</span><span class="p">)</span>

    <span class="c1"># Methods correponding to different message tags</span>
    <span class="k">def</span> <span class="nf">do_A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Running A&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Running B&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Example</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">TaggedActor</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">send</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>      <span class="c1"># Invokes do_A(1)</span>
<span class="n">a</span><span class="o">.</span><span class="n">send</span><span class="p">((</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>   <span class="c1"># Invokes do_B(2,3)</span>
</pre></div>
</div>
<p>作为另外一个例子，下面的actor允许在一个工作者中运行任意的函数，
并且通过一个特殊的Result对象返回结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Event</span>
<span class="k">class</span> <span class="nc">Result</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evt</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_evt</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evt</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result</span>

<span class="k">class</span> <span class="nc">Worker</span><span class="p">(</span><span class="n">Actor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">submit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">((</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="n">r</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

<span class="c1"># Example use</span>
<span class="n">worker</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">()</span>
<span class="n">worker</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="nb">pow</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
</pre></div>
</div>
<p>最后，“发送”一个任务消息的概念可以被扩展到多进程甚至是大型分布式系统中去。
例如，一个类actor对象的 <code class="docutils literal"><span class="pre">send()</span></code> 方法可以被编程让它能在一个套接字连接上传输数据
或通过某些消息中间件（比如AMQP、ZMQ等）来发送。</p>
</div>
</div>
<span id="document-c12/p11_implement_publish_subscribe_messaging"></span><div class="section" id="id1">
<h3>12.11 实现消息发布/订阅模型<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个基于线程通信的程序，想让它们实现发布/订阅模式的消息通信。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>要实现发布/订阅的消息通信模式，
你通常要引入一个单独的“交换机”或“网关”对象作为所有消息的中介。
也就是说，不直接将消息从一个任务发送到另一个，而是将其发送给交换机，
然后由交换机将它发送给一个或多个被关联任务。下面是一个非常简单的交换机实现例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span> <span class="nc">Exchange</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subscribers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subscribers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subscribers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subscriber</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subscribers</span><span class="p">:</span>
            <span class="n">subscriber</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="c1"># Dictionary of all created exchanges</span>
<span class="n">_exchanges</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">Exchange</span><span class="p">)</span>

<span class="c1"># Return the Exchange instance associated with a given name</span>
<span class="k">def</span> <span class="nf">get_exchange</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_exchanges</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>一个交换机就是一个普通对象，负责维护一个活跃的订阅者集合，并为绑定、解绑和发送消息提供相应的方法。
每个交换机通过一个名称定位，<code class="docutils literal"><span class="pre">get_exchange()</span></code> 通过给定一个名称返回相应的 <code class="docutils literal"><span class="pre">Exchange</span></code> 实例。</p>
<p>下面是一个简单例子，演示了如何使用一个交换机：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Example of a task.  Any object with a send() method</span>

<span class="k">class</span> <span class="nc">Task</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="o">...</span>

<span class="n">task_a</span> <span class="o">=</span> <span class="n">Task</span><span class="p">()</span>
<span class="n">task_b</span> <span class="o">=</span> <span class="n">Task</span><span class="p">()</span>

<span class="c1"># Example of getting an exchange</span>
<span class="n">exc</span> <span class="o">=</span> <span class="n">get_exchange</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>

<span class="c1"># Examples of subscribing tasks to it</span>
<span class="n">exc</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">task_a</span><span class="p">)</span>
<span class="n">exc</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">task_b</span><span class="p">)</span>

<span class="c1"># Example of sending messages</span>
<span class="n">exc</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;msg1&#39;</span><span class="p">)</span>
<span class="n">exc</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;msg2&#39;</span><span class="p">)</span>

<span class="c1"># Example of unsubscribing</span>
<span class="n">exc</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">task_a</span><span class="p">)</span>
<span class="n">exc</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">task_b</span><span class="p">)</span>
</pre></div>
</div>
<p>尽管对于这个问题有很多的变种，不过万变不离其宗。
消息会被发送给一个交换机，然后交换机会将它们发送给被绑定的订阅者。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>通过队列发送消息的任务或线程的模式很容易被实现并且也非常普遍。
不过，使用发布/订阅模式的好处更加明显。</p>
<p>首先，使用一个交换机可以简化大部分涉及到线程通信的工作。
无需去写通过多进程模块来操作多个线程，你只需要使用这个交换机来连接它们。
某种程度上，这个就跟日志模块的工作原理类似。
实际上，它可以轻松的解耦程序中多个任务。</p>
<p>其次，交换机广播消息给多个订阅者的能力带来了一个全新的通信模式。
例如，你可以使用多任务系统、广播或扇出。
你还可以通过以普通订阅者身份绑定来构建调试和诊断工具。
例如，下面是一个简单的诊断类，可以显示被发送的消息：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DisplayMessages</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;msg[{}]: {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>

<span class="n">exc</span> <span class="o">=</span> <span class="n">get_exchange</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">DisplayMessages</span><span class="p">()</span>
<span class="n">exc</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，该实现的一个重要特点是它能兼容多个“task-like”对象。
例如，消息接受者可以是actor（12.10小节介绍）、协程、网络连接或任何实现了正确的 <code class="docutils literal"><span class="pre">send()</span></code> 方法的东西。</p>
<p>关于交换机的一个可能问题是对于订阅者的正确绑定和解绑。
为了正确的管理资源，每一个绑定的订阅者必须最终要解绑。
在代码中通常会是像下面这样的模式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">exc</span> <span class="o">=</span> <span class="n">get_exchange</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="n">exc</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">some_task</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">exc</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">some_task</span><span class="p">)</span>
</pre></div>
</div>
<p>某种意义上，这个和使用文件、锁和类似对象很像。
通常很容易会忘记最后的 <code class="docutils literal"><span class="pre">detach()</span></code> 步骤。
为了简化这个，你可以考虑使用上下文管理器协议。
例如，在交换机对象上增加一个 <code class="docutils literal"><span class="pre">subscribe()</span></code> 方法，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span> <span class="nc">Exchange</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subscribers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subscribers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subscribers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tasks</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subscriber</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subscribers</span><span class="p">:</span>
            <span class="n">subscriber</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="c1"># Dictionary of all created exchanges</span>
<span class="n">_exchanges</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">Exchange</span><span class="p">)</span>

<span class="c1"># Return the Exchange instance associated with a given name</span>
<span class="k">def</span> <span class="nf">get_exchange</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_exchanges</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

<span class="c1"># Example of using the subscribe() method</span>
<span class="n">exc</span> <span class="o">=</span> <span class="n">get_exchange</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">exc</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">task_a</span><span class="p">,</span> <span class="n">task_b</span><span class="p">):</span>
     <span class="o">...</span>
     <span class="n">exc</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;msg1&#39;</span><span class="p">)</span>
     <span class="n">exc</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;msg2&#39;</span><span class="p">)</span>
     <span class="o">...</span>

<span class="c1"># task_a and task_b detached here</span>
</pre></div>
</div>
<p>最后还应该注意的是关于交换机的思想有很多种的扩展实现。
例如，交换机可以实现一整个消息通道集合或提供交换机名称的模式匹配规则。
交换机还可以被扩展到分布式计算程序中（比如，将消息路由到不同机器上面的任务中去）。</p>
</div>
</div>
<span id="document-c12/p12_using_generators_as_alternative_to_threads"></span><div class="section" id="id1">
<h3>12.12 使用生成器代替线程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想使用生成器（协程）替代系统线程来实现并发。这个有时又被称为用户级线程或绿色线程。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>要使用生成器实现自己的并发，你首先要对生成器函数和 <code class="docutils literal"><span class="pre">yield</span></code> 语句有深刻理解。
<code class="docutils literal"><span class="pre">yield</span></code> 语句会让一个生成器挂起它的执行，这样就可以编写一个调度器，
将生成器当做某种“任务”并使用任务协作切换来替换它们的执行。
要演示这种思想，考虑下面两个使用简单的 <code class="docutils literal"><span class="pre">yield</span></code> 语句的生成器函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Two simple generator functions</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;T-minus&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">yield</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Blastoff!&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">countup</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Counting up&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">yield</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>这些函数在内部使用yield语句，下面是一个实现了简单任务调度器的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">TaskScheduler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">new_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Admit a newly started task to the scheduler</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Run until there are no more tasks</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_queue</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Run until the next yield statement</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_task_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># Generator is no longer executing</span>
                <span class="k">pass</span>

<span class="c1"># Example use</span>
<span class="n">sched</span> <span class="o">=</span> <span class="n">TaskScheduler</span><span class="p">()</span>
<span class="n">sched</span><span class="o">.</span><span class="n">new_task</span><span class="p">(</span><span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">sched</span><span class="o">.</span><span class="n">new_task</span><span class="p">(</span><span class="n">countdown</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="n">sched</span><span class="o">.</span><span class="n">new_task</span><span class="p">(</span><span class="n">countup</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
<span class="n">sched</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">TaskScheduler</span></code> 类在一个循环中运行生成器集合——每个都运行到碰到yield语句为止。
运行这个例子，输出如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">10</span>
<span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">5</span>
<span class="n">Counting</span> <span class="n">up</span> <span class="mi">0</span>
<span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">9</span>
<span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">4</span>
<span class="n">Counting</span> <span class="n">up</span> <span class="mi">1</span>
<span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">8</span>
<span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">3</span>
<span class="n">Counting</span> <span class="n">up</span> <span class="mi">2</span>
<span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">7</span>
<span class="n">T</span><span class="o">-</span><span class="n">minus</span> <span class="mi">2</span>
<span class="o">...</span>
</pre></div>
</div>
<p>到此为止，我们实际上已经实现了一个“操作系统”的最小核心部分。
生成器函数就是认为，而yield语句是任务挂起的信号。
调度器循环检查任务列表直到没有任务要执行为止。</p>
<p>实际上，你可能想要使用生成器来实现简单的并发。
那么，在实现actor或网络服务器的时候你可以使用生成器来替代线程的使用。</p>
<p>下面的代码演示了使用生成器来实现一个不依赖线程的actor：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">ActorScheduler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actors</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>          <span class="c1"># Mapping of names to actors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_msg_queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>   <span class="c1"># Message queue</span>

    <span class="k">def</span> <span class="nf">new_actor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">actor</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Admit a newly started actor to the scheduler and give it a name</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_msg_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">actor</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actors</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">actor</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Send a message to a named actor</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">actor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">actor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_msg_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">actor</span><span class="p">,</span><span class="n">msg</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Run as long as there are pending messages.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_msg_queue</span><span class="p">:</span>
            <span class="n">actor</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_msg_queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                 <span class="n">actor</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                 <span class="k">pass</span>

<span class="c1"># Example use</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">printer</span><span class="p">():</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="k">yield</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got:&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">counter</span><span class="p">(</span><span class="n">sched</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c1"># Receive the current count</span>
            <span class="n">n</span> <span class="o">=</span> <span class="k">yield</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># Send to the printer task</span>
            <span class="n">sched</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;printer&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="c1"># Send the next count to the counter task (recursive)</span>

            <span class="n">sched</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">sched</span> <span class="o">=</span> <span class="n">ActorScheduler</span><span class="p">()</span>
    <span class="c1"># Create the initial actors</span>
    <span class="n">sched</span><span class="o">.</span><span class="n">new_actor</span><span class="p">(</span><span class="s1">&#39;printer&#39;</span><span class="p">,</span> <span class="n">printer</span><span class="p">())</span>
    <span class="n">sched</span><span class="o">.</span><span class="n">new_actor</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">,</span> <span class="n">counter</span><span class="p">(</span><span class="n">sched</span><span class="p">))</span>

    <span class="c1"># Send an initial message to the counter to initiate</span>
    <span class="n">sched</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="n">sched</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>完全弄懂这段代码需要更深入的学习，但是关键点在于收集消息的队列。
本质上，调度器在有需要发送的消息时会一直运行着。
计数生成器会给自己发送消息并在一个递归循环中结束。</p>
<p>下面是一个更加高级的例子，演示了使用生成器来实现一个并发网络应用程序：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">select</span> <span class="kn">import</span> <span class="n">select</span>

<span class="c1"># This class represents a generic yield event in the scheduler</span>
<span class="k">class</span> <span class="nc">YieldEvent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">handle_yield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">handle_resume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="c1"># Task Scheduler</span>
<span class="k">class</span> <span class="nc">Scheduler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_numtasks</span> <span class="o">=</span> <span class="mi">0</span>       <span class="c1"># Total num of tasks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>    <span class="c1"># Tasks ready to run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_waiting</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Tasks waiting to read</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_waiting</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Tasks waiting to write</span>

    <span class="c1"># Poll for I/O events and restart waiting tasks</span>
    <span class="k">def</span> <span class="nf">_iopoll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rset</span><span class="p">,</span><span class="n">wset</span><span class="p">,</span><span class="n">eset</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_waiting</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_write_waiting</span><span class="p">,[])</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rset</span><span class="p">:</span>
            <span class="n">evt</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_waiting</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">evt</span><span class="o">.</span><span class="n">handle_resume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wset</span><span class="p">:</span>
            <span class="n">evt</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_waiting</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">evt</span><span class="o">.</span><span class="n">handle_resume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">task</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add a newly started task to the scheduler</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">task</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_numtasks</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">add_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Append an already started task to the ready queue.</span>
<span class="sd">        msg is what to send into the task when it resumes.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">task</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>

    <span class="c1"># Add a task to the reading set</span>
    <span class="k">def</span> <span class="nf">_read_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileno</span><span class="p">,</span> <span class="n">evt</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_waiting</span><span class="p">[</span><span class="n">fileno</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">evt</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="c1"># Add a task to the write set</span>
    <span class="k">def</span> <span class="nf">_write_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileno</span><span class="p">,</span> <span class="n">evt</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_waiting</span><span class="p">[</span><span class="n">fileno</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">evt</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Run the task scheduler until there are no tasks</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_numtasks</span><span class="p">:</span>
             <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="p">:</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">_iopoll</span><span class="p">()</span>
             <span class="n">task</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
             <span class="k">try</span><span class="p">:</span>
                 <span class="c1"># Run the coroutine to the next yield</span>
                 <span class="n">r</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                 <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">YieldEvent</span><span class="p">):</span>
                     <span class="n">r</span><span class="o">.</span><span class="n">handle_yield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
                 <span class="k">else</span><span class="p">:</span>
                     <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;unrecognized yield event&#39;</span><span class="p">)</span>
             <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_numtasks</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="c1"># Example implementation of coroutine-based socket I/O</span>
<span class="k">class</span> <span class="nc">ReadSocket</span><span class="p">(</span><span class="n">YieldEvent</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">nbytes</span>
    <span class="k">def</span> <span class="nf">handle_yield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="n">sched</span><span class="o">.</span><span class="n">_read_wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">handle_resume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)</span>
        <span class="n">sched</span><span class="o">.</span><span class="n">add_ready</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WriteSocket</span><span class="p">(</span><span class="n">YieldEvent</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">def</span> <span class="nf">handle_yield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>

        <span class="n">sched</span><span class="o">.</span><span class="n">_write_wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">handle_resume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="n">nsent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">sched</span><span class="o">.</span><span class="n">add_ready</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">nsent</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AcceptSocket</span><span class="p">(</span><span class="n">YieldEvent</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>
    <span class="k">def</span> <span class="nf">handle_yield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="n">sched</span><span class="o">.</span><span class="n">_read_wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">handle_resume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">sched</span><span class="o">.</span><span class="n">add_ready</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

<span class="c1"># Wrapper around a socket object for use with yield</span>
<span class="k">class</span> <span class="nc">Socket</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="o">=</span> <span class="n">sock</span>
    <span class="k">def</span> <span class="nf">recv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxbytes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ReadSocket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">,</span> <span class="n">maxbytes</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">WriteSocket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AcceptSocket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="c1"># Example of a function involving generators.  This should</span>
    <span class="c1"># be called using line = yield from readline(sock)</span>
    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
        <span class="n">chars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>

    <span class="c1"># Echo server using generators</span>
    <span class="k">class</span> <span class="nc">EchoServer</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">sched</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sched</span> <span class="o">=</span> <span class="n">sched</span>
            <span class="n">sched</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">server_loop</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">server_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">addr</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="n">SOCK_STREAM</span><span class="p">))</span>

            <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">c</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got connection from &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sched</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client_handler</span><span class="p">(</span><span class="n">Socket</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>

        <span class="k">def</span> <span class="nf">client_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">client</span><span class="p">):</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">readline</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">line</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;GOT:&#39;</span> <span class="o">+</span> <span class="n">line</span>
                <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">nsent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">client</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">nsent</span><span class="p">:]</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Client closed&#39;</span><span class="p">)</span>

    <span class="n">sched</span> <span class="o">=</span> <span class="n">Scheduler</span><span class="p">()</span>
    <span class="n">EchoServer</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">16000</span><span class="p">),</span><span class="n">sched</span><span class="p">)</span>
    <span class="n">sched</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>这段代码有点复杂。不过，它实现了一个小型的操作系统。
有一个就绪的任务队列，并且还有因I/O休眠的任务等待区域。
还有很多调度器负责在就绪队列和I/O等待区域之间移动任务。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在构建基于生成器的并发框架时，通常会使用更常见的yield形式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">some_generator</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">data</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>使用这种形式的yield语句的函数通常被称为“协程”。
通过调度器，yield语句在一个循环中被处理，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">some_generator</span><span class="p">()</span>

<span class="c1"># Initial result. Is None to start since nothing has been computed</span>
<span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">do</span> <span class="n">some</span> <span class="n">calculation</span> <span class="o">...</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>
</div>
<p>这里的逻辑稍微有点复杂。不过，被传给 <code class="docutils literal"><span class="pre">send()</span></code> 的值定义了在yield语句醒来时的返回值。
因此，如果一个yield准备在对之前yield数据的回应中返回结果时，会在下一次 <code class="docutils literal"><span class="pre">send()</span></code> 操作返回。
如果一个生成器函数刚开始运行，发送一个None值会让它排在第一个yield语句前面。</p>
<p>除了发送值外，还可以在一个生成器上面执行一个 <code class="docutils literal"><span class="pre">close()</span></code> 方法。
它会导致在执行yield语句时抛出一个 <code class="docutils literal"><span class="pre">GeneratorExit</span></code> 异常，从而终止执行。
如果进一步设计，一个生成器可以捕获这个异常并执行清理操作。
同样还可以使用生成器的 <code class="docutils literal"><span class="pre">throw()</span></code> 方法在yield语句执行时生成一个任意的执行指令。
一个任务调度器可利用它来在运行的生成器中处理错误。</p>
<p>最后一个例子中使用的 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 语句被用来实现协程，可以被其它生成器作为子程序或过程来调用。
本质上就是将控制权透明的传输给新的函数。
不像普通的生成器，一个使用 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 被调用的函数可以返回一个作为 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 语句结果的值。
关于 <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 的更多信息可以在 <a class="reference external" href="http://www.python.org/dev/peps/pep-0380">PEP 380</a> 中找到。</p>
<p>最后，如果使用生成器编程，要提醒你的是它还是有很多缺点的。
特别是，你得不到任何线程可以提供的好处。例如，如果你执行CPU依赖或I/O阻塞程序，
它会将整个任务挂起知道操作完成。为了解决这个问题，
你只能选择将操作委派给另外一个可以独立运行的线程或进程。
另外一个限制是大部分Python库并不能很好的兼容基于生成器的线程。
如果你选择这个方案，你会发现你需要自己改写很多标准库函数。
作为本节提到的协程和相关技术的一个基础背景，可以查看 <a class="reference external" href="http://www.python.org/dev/peps/pep-0342">PEP 342</a>
和 <a class="reference external" href="http://www.dabeaz.com/coroutines">“协程和并发的一门有趣课程”</a></p>
<p>PEP 3156 同样有一个关于使用协程的异步I/O模型。
特别的，你不可能自己去实现一个底层的协程调度器。
不过，关于协程的思想是很多流行库的基础，
包括 <a class="reference external" href="http://www.gevent.org/">gevent</a>,
<a class="reference external" href="http://pypi.python.org/pypi/greenlet">greenlet</a>,
<a class="reference external" href="http://www.stackless.com/">Stackless Python</a> 以及其他类似工程。</p>
</div>
</div>
<span id="document-c12/p13_polling_multiple_thread_queues"></span><div class="section" id="id1">
<h3>12.13 多个线程队列轮询<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个线程队列集合，想为到来的元素轮询它们，
就跟你为一个客户端请求去轮询一个网络连接集合的方式一样。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于轮询问题的一个常见解决方案中有个很少有人知道的技巧，包含了一个隐藏的回路网络连接。
本质上讲其思想就是：对于每个你想要轮询的队列，你创建一对连接的套接字。
然后你在其中一个套接字上面编写代码来标识存在的数据，
另外一个套接字被传给 <code class="docutils literal"><span class="pre">select()</span></code> 或类似的一个轮询数据到达的函数。下面的例子演示了这个思想：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">class</span> <span class="nc">PollableQueue</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Create a pair of connected sockets</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;posix&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_putsocket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compatibility on non-POSIX systems</span>
            <span class="n">server</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
            <span class="n">server</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">server</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_putsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_putsocket</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">getsockname</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getsocket</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="n">server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getsocket</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_putsocket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_getsocket</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>在这个代码中，一个新的 <code class="docutils literal"><span class="pre">Queue</span></code> 实例类型被定义，底层是一个被连接套接字对。
在Unix机器上的 <code class="docutils literal"><span class="pre">socketpair()</span></code> 函数能轻松的创建这样的套接字。
在Windows上面，你必须使用类似代码来模拟它。
然后定义普通的 <code class="docutils literal"><span class="pre">get()</span></code> 和 <code class="docutils literal"><span class="pre">put()</span></code> 方法在这些套接字上面来执行I/O操作。
<code class="docutils literal"><span class="pre">put()</span></code> 方法再将数据放入队列后会写一个单字节到某个套接字中去。
而 <code class="docutils literal"><span class="pre">get()</span></code> 方法在从队列中移除一个元素时会从另外一个套接字中读取到这个单字节数据。</p>
<p><code class="docutils literal"><span class="pre">fileno()</span></code> 方法使用一个函数比如 <code class="docutils literal"><span class="pre">select()</span></code> 来让这个队列可以被轮询。
它仅仅只是暴露了底层被 <code class="docutils literal"><span class="pre">get()</span></code> 函数使用到的socket的文件描述符而已。</p>
<p>下面是一个例子，定义了一个为到来的元素监控多个队列的消费者：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">select</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">queues</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Consumer that reads data on multiple queues simultaneously</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">can_read</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">queues</span><span class="p">,[],[])</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">can_read</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got:&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

<span class="n">q1</span> <span class="o">=</span> <span class="n">PollableQueue</span><span class="p">()</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">PollableQueue</span><span class="p">()</span>
<span class="n">q3</span> <span class="o">=</span> <span class="n">PollableQueue</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">consumer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="p">,</span><span class="n">q3</span><span class="p">],))</span>
<span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Feed data to the queues</span>
<span class="n">q1</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">q2</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">q3</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="n">q2</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>如果你试着运行它，你会发现这个消费者会接受到所有的被放入的元素，不管元素被放进了哪个队列中。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>对于轮询非类文件对象，比如队列通常都是比较棘手的问题。
例如，如果你不使用上面的套接字技术，
你唯一的选择就是编写代码来循环遍历这些队列并使用一个定时器。像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">queues</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got:&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

        <span class="c1"># Sleep briefly to avoid 100% CPU</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<p>这样做其实不合理，还会引入其他的性能问题。
例如，如果新的数据被加入到一个队列中，至少要花10毫秒才能被发现。
如果你之前的轮询还要去轮询其他对象，比如网络套接字那还会有更多问题。
例如，如果你想同时轮询套接字和队列，你可能要像下面这样使用：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">select</span>

<span class="k">def</span> <span class="nf">event_loop</span><span class="p">(</span><span class="n">sockets</span><span class="p">,</span> <span class="n">queues</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># polling with a timeout</span>
        <span class="n">can_read</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sockets</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">can_read</span><span class="p">:</span>
            <span class="n">handle_read</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Got:&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>这个方案通过将队列和套接字等同对待来解决了大部分的问题。
一个单独的 <code class="docutils literal"><span class="pre">select()</span></code> 调用可被同时用来轮询。
使用超时或其他基于时间的机制来执行周期性检查并没有必要。
甚至，如果数据被加入到一个队列，消费者几乎可以实时的被通知。
尽管会有一点点底层的I/O损耗，使用它通常会获得更好的响应时间并简化编程。</p>
</div>
</div>
<span id="document-c12/p14_launching_daemon_process_on_unix"></span><div class="section" id="unix">
<h3>12.14 在Unix系统上面启动守护进程<a class="headerlink" href="#unix" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想编写一个作为一个在Unix或类Unix系统上面运行的守护进程运行的程序。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>创建一个正确的守护进程需要一个精确的系统调用序列以及对于细节的控制。
下面的代码展示了怎样定义一个守护进程，可以启动后很容易的停止它。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># daemon.py</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">atexit</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">daemonize</span><span class="p">(</span><span class="n">pidfile</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="s1">&#39;/dev/null&#39;</span><span class="p">,</span>
                          <span class="n">stdout</span><span class="o">=</span><span class="s1">&#39;/dev/null&#39;</span><span class="p">,</span>
                          <span class="n">stderr</span><span class="o">=</span><span class="s1">&#39;/dev/null&#39;</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pidfile</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already running&#39;</span><span class="p">)</span>

    <span class="c1"># First fork (detaches from parent)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Parent exit</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;fork #1 failed.&#39;</span><span class="p">)</span>

    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">umask</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">setsid</span><span class="p">()</span>
    <span class="c1"># Second fork (relinquish session leadership)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;fork #2 failed.&#39;</span><span class="p">)</span>

    <span class="c1"># Flush I/O buffers</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="c1"># Replace file descriptors for stdin, stdout, and stderr</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">dup2</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">dup2</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">dup2</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>

    <span class="c1"># Write the PID file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pidfile</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span><span class="nb">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

    <span class="c1"># Arrange to have the PID file removed on exit/signal</span>
    <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pidfile</span><span class="p">))</span>

    <span class="c1"># Signal handler for termination (required)</span>
    <span class="k">def</span> <span class="nf">sigterm_handler</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">sigterm_handler</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Daemon started with pid {}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Daemon Alive! {}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">PIDFILE</span> <span class="o">=</span> <span class="s1">&#39;/tmp/daemon.pid&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Usage: {} [start|stop]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">daemonize</span><span class="p">(</span><span class="n">PIDFILE</span><span class="p">,</span>
                      <span class="n">stdout</span><span class="o">=</span><span class="s1">&#39;/tmp/daemon.log&#39;</span><span class="p">,</span>
                      <span class="n">stderr</span><span class="o">=</span><span class="s1">&#39;/tmp/dameon.log&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">main</span><span class="p">()</span>

    <span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">PIDFILE</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">PIDFILE</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()),</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Not running&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Unknown command {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>要启动这个守护进程，用户需要使用如下的命令：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>bash % daemon.py start
bash % cat /tmp/daemon.pid
2882
bash % tail -f /tmp/daemon.log
Daemon started with pid 2882
Daemon Alive! Fri Oct 12 13:45:37 2012
Daemon Alive! Fri Oct 12 13:45:47 2012
...
</pre></div>
</div>
<p>守护进程可以完全在后台运行，因此这个命令会立即返回。
不过，你可以像上面那样查看与它相关的pid文件和日志。要停止这个守护进程，使用：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">daemon</span><span class="o">.</span><span class="n">py</span> <span class="n">stop</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>本节定义了一个函数 <code class="docutils literal"><span class="pre">daemonize()</span></code> ，在程序启动时被调用使得程序以一个守护进程来运行。
<code class="docutils literal"><span class="pre">daemonize()</span></code> 函数只接受关键字参数，这样的话可选参数在被使用时就更清晰了。
它会强制用户像下面这样使用它：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">daemonize</span><span class="p">(</span><span class="s1">&#39;daemon.pid&#39;</span><span class="p">,</span>
          <span class="n">stdin</span><span class="o">=</span><span class="s1">&#39;/dev/null,</span>
          <span class="n">stdout</span><span class="o">=</span><span class="s1">&#39;/tmp/daemon.log&#39;</span><span class="p">,</span>
          <span class="n">stderr</span><span class="o">=</span><span class="s1">&#39;/tmp/daemon.log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>而不是像下面这样含糊不清的调用：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Illegal. Must use keyword arguments</span>
<span class="n">daemonize</span><span class="p">(</span><span class="s1">&#39;daemon.pid&#39;</span><span class="p">,</span>
          <span class="s1">&#39;/dev/null&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp/daemon.log&#39;</span><span class="p">,</span><span class="s1">&#39;/tmp/daemon.log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>创建一个守护进程的步骤看上去不是很易懂，但是大体思想是这样的，
首先，一个守护进程必须要从父进程中脱离。
这是由 <code class="docutils literal"><span class="pre">os.fork()</span></code> 操作来完成的，并立即被父进程终止。</p>
<p>在子进程变成孤儿后，调用 <code class="docutils literal"><span class="pre">os.setsid()</span></code> 创建了一个全新的进程会话，并设置子进程为首领。
它会设置这个子进程为新的进程组的首领，并确保不会再有控制终端。
如果这些听上去太魔幻，因为它需要将守护进程同终端分离开并确保信号机制对它不起作用。
调用 <code class="docutils literal"><span class="pre">os.chdir()</span></code> 和 <code class="docutils literal"><span class="pre">os.umask(0)</span></code> 改变了当前工作目录并重置文件权限掩码。
修改目录通常是个好主意，因为这样可以使得它不再工作在被启动时的目录。</p>
<p>另外一个调用 <code class="docutils literal"><span class="pre">os.fork()</span></code> 在这里更加神秘点。
这一步使得守护进程失去了获取新的控制终端的能力并且让它更加独立
（本质上，该daemon放弃了它的会话首领低位，因此再也没有权限去打开控制终端了）。
尽管你可以忽略这一步，但是最好不要这么做。</p>
<p>一旦守护进程被正确的分离，它会重新初始化标准I/O流指向用户指定的文件。
这一部分有点难懂。跟标准I/O流相关的文件对象的引用在解释器中多个地方被找到
（sys.stdout, sys.__stdout__等）。
仅仅简单的关闭 <code class="docutils literal"><span class="pre">sys.stdout</span></code> 并重新指定它是行不通的，
因为没办法知道它是否全部都是用的是 <code class="docutils literal"><span class="pre">sys.stdout</span></code> 。
这里，我们打开了一个单独的文件对象，并调用 <code class="docutils literal"><span class="pre">os.dup2()</span></code> ，
用它来代替被 <code class="docutils literal"><span class="pre">sys.stdout</span></code> 使用的文件描述符。
这样，<code class="docutils literal"><span class="pre">sys.stdout</span></code> 使用的原始文件会被关闭并由新的来替换。
还要强调的是任何用于文件编码或文本处理的标准I/O流还会保留原状。</p>
<p>守护进程的一个通常实践是在一个文件中写入进程ID，可以被其他程序后面使用到。
<code class="docutils literal"><span class="pre">daemonize()</span></code> 函数的最后部分写了这个文件，但是在程序终止时删除了它。
<code class="docutils literal"><span class="pre">atexit.register()</span></code> 函数注册了一个函数在Python解释器终止时执行。
一个对于SIGTERM的信号处理器的定义同样需要被优雅的关闭。
信号处理器简单的抛出了 <code class="docutils literal"><span class="pre">SystemExit()</span></code> 异常。
或许这一步看上去没必要，但是没有它，
终止信号会使得不执行 <code class="docutils literal"><span class="pre">atexit.register()</span></code> 注册的清理操作的时候就杀掉了解释器。
一个杀掉进程的例子代码可以在程序最后的 <code class="docutils literal"><span class="pre">stop</span></code> 命令的操作中看到。</p>
<p>更多关于编写守护进程的信息可以查看《UNIX 环境高级编程》, 第二版
by W. Richard Stevens and Stephen A. Rago (Addison-Wesley, 2005)。
尽管它是关注与C语言编程，但是所有的内容都适用于Python，
因为所有需要的POSIX函数都可以在标准库中找到。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p13_utility_script_and_system_manage"></span><div class="section" id="id1">
<h2>第十三章：脚本编程与系统管理<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>许多人使用Python作为一个shell脚本的替代，用来实现常用系统任务的自动化，如文件的操作，系统的配置等。本章的主要目标是描述关于编写脚本时候经常遇到的一些功能。例如，解析命令行选项、获取有用的系统配置数据等等。第5章也包含了与文件和目录相关的一般信息。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c13/p01_accept_input_via_redirect_pips_or_input_files"></span><div class="section" id="id1">
<h3>13.1 通过重定向/管道/文件接受输入<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你希望你的脚本接受任何用户认为最简单的输入方式。包括将命令行的输出通过管道传递给该脚本、
重定向文件到该脚本，或在命令行中传递一个文件名或文件名列表给该脚本。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Python内置的 <code class="docutils literal"><span class="pre">fileinput</span></code> 模块让这个变得简单。如果你有一个下面这样的脚本：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="kn">import</span> <span class="nn">fileinput</span>

<span class="k">with</span> <span class="n">fileinput</span><span class="o">.</span><span class="n">input</span><span class="p">()</span> <span class="k">as</span> <span class="n">f_input</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f_input</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>那么你就能以前面提到的所有方式来为此脚本提供输入。假设你将此脚本保存为 <code class="docutils literal"><span class="pre">filein.py</span></code> 并将其变为可执行文件，
那么你可以像下面这样调用它，得到期望的输出：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ ls <span class="p">|</span> ./filein.py          <span class="c1"># Prints a directory listing to stdout.</span>
$ ./filein.py /etc/passwd   <span class="c1"># Reads /etc/passwd to stdout.</span>
$ ./filein.py &lt; /etc/passwd <span class="c1"># Reads /etc/passwd to stdout.</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">fileinput.input()</span></code> 创建并返回一个 <code class="docutils literal"><span class="pre">FileInput</span></code> 类的实例。
该实例除了拥有一些有用的帮助方法外，它还可被当做一个上下文管理器使用。
因此，整合起来，如果我们要写一个打印多个文件输出的脚本，那么我们需要在输出中包含文件名和行号，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fileinput</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">fileinput</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">filename</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">lineno</span><span class="p">(),</span> <span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">/etc/passwd 1 ##</span>
<span class="go">/etc/passwd 2 # User Database</span>
<span class="go">/etc/passwd 3 #</span>

<span class="go">&lt;other output omitted&gt;</span>
</pre></div>
</div>
<p>通过将它作为一个上下文管理器使用，可以确保它不再使用时文件能自动关闭，
而且我们在之后还演示了 <code class="docutils literal"><span class="pre">FileInput</span></code> 的一些有用的帮助方法来获取输出中的一些其他信息。</p>
</div>
</div>
<span id="document-c13/p02_terminate_program_with_an_error_message"></span><div class="section" id="id1">
<h3>13.2 终止程序并给出错误信息<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想向标准错误打印一条消息并返回某个非零状态码来终止程序运行</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>你有一个程序像下面这样终止，抛出一个 <code class="docutils literal"><span class="pre">SystemExit</span></code> 异常，使用错误消息作为参数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="s1">&#39;It failed!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>它会将消息在 <code class="docutils literal"><span class="pre">sys.stderr</span></code> 中打印，然后程序以状态码1退出。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本节虽然很短小，但是它能解决在写脚本时的一个常见问题。
也就是说，当你想要终止某个程序时，你可能会像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;It failed!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你直接将消息作为参数传给 <code class="docutils literal"><span class="pre">SystemExit()</span></code> ，那么你可以省略其他步骤，
比如import语句或将错误消息写入 <code class="docutils literal"><span class="pre">sys.stderr</span></code></p>
</div>
</div>
<span id="document-c13/p03_parsing_command_line_options"></span><div class="section" id="id1">
<h3>13.3 解析命令行选项<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序如何能够解析命令行选项（位于sys.argv中）</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">argparse</span></code> 模块可被用来解析命令行选项。下面一个简单例子演示了最基本的用法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># search.py</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Hypothetical command-line tool for searching a collection of</span>
<span class="sd">files for one or more text patterns.</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Search some files&#39;</span><span class="p">)</span>

<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="s1">&#39;filenames&#39;</span><span class="p">,</span><span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>

<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-p&#39;</span><span class="p">,</span> <span class="s1">&#39;--pat&#39;</span><span class="p">,</span><span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;pattern&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;patterns&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;text pattern to search for&#39;</span><span class="p">)</span>

<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-v&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;verbose mode&#39;</span><span class="p">)</span>

<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;outfile&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;output file&#39;</span><span class="p">)</span>

<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--speed&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;speed&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span>
                    <span class="n">choices</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;slow&#39;</span><span class="p">,</span><span class="s1">&#39;fast&#39;</span><span class="p">},</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;slow&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;search speed&#39;</span><span class="p">)</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

<span class="c1"># Output the collected arguments</span>
<span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">filenames</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">patterns</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">outfile</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
<p>该程序定义了一个如下使用的命令行解析器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">search</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">h</span>
<span class="n">usage</span><span class="p">:</span> <span class="n">search</span><span class="o">.</span><span class="n">py</span> <span class="p">[</span><span class="o">-</span><span class="n">h</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">p</span> <span class="n">pattern</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">v</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">o</span> <span class="n">OUTFILE</span><span class="p">]</span> <span class="p">[</span><span class="o">--</span><span class="n">speed</span> <span class="p">{</span><span class="n">slow</span><span class="p">,</span><span class="n">fast</span><span class="p">}]</span>
                 <span class="p">[</span><span class="n">filename</span> <span class="p">[</span><span class="n">filename</span> <span class="o">...</span><span class="p">]]</span>

<span class="n">Search</span> <span class="n">some</span> <span class="n">files</span>

<span class="n">positional</span> <span class="n">arguments</span><span class="p">:</span>
  <span class="n">filename</span>

<span class="n">optional</span> <span class="n">arguments</span><span class="p">:</span>
  <span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="o">--</span><span class="n">help</span>            <span class="n">show</span> <span class="n">this</span> <span class="n">help</span> <span class="n">message</span> <span class="ow">and</span> <span class="nb">exit</span>
  <span class="o">-</span><span class="n">p</span> <span class="n">pattern</span><span class="p">,</span> <span class="o">--</span><span class="n">pat</span> <span class="n">pattern</span>
                        <span class="n">text</span> <span class="n">pattern</span> <span class="n">to</span> <span class="n">search</span> <span class="k">for</span>
  <span class="o">-</span><span class="n">v</span>                    <span class="n">verbose</span> <span class="n">mode</span>
  <span class="o">-</span><span class="n">o</span> <span class="n">OUTFILE</span>            <span class="n">output</span> <span class="nb">file</span>
  <span class="o">--</span><span class="n">speed</span> <span class="p">{</span><span class="n">slow</span><span class="p">,</span><span class="n">fast</span><span class="p">}</span>   <span class="n">search</span> <span class="n">speed</span>
</pre></div>
</div>
<p>下面的部分演示了程序中的数据部分。仔细观察print()语句的打印输出。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">search</span><span class="o">.</span><span class="n">py</span> <span class="n">foo</span><span class="o">.</span><span class="n">txt</span> <span class="n">bar</span><span class="o">.</span><span class="n">txt</span>
<span class="n">usage</span><span class="p">:</span> <span class="n">search</span><span class="o">.</span><span class="n">py</span> <span class="p">[</span><span class="o">-</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span><span class="n">p</span> <span class="n">pattern</span> <span class="p">[</span><span class="o">-</span><span class="n">v</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">o</span> <span class="n">OUTFILE</span><span class="p">]</span> <span class="p">[</span><span class="o">--</span><span class="n">speed</span> <span class="p">{</span><span class="n">fast</span><span class="p">,</span><span class="n">slow</span><span class="p">}]</span>
                 <span class="p">[</span><span class="n">filename</span> <span class="p">[</span><span class="n">filename</span> <span class="o">...</span><span class="p">]]</span>
<span class="n">search</span><span class="o">.</span><span class="n">py</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">the</span> <span class="n">following</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">required</span><span class="p">:</span> <span class="o">-</span><span class="n">p</span><span class="o">/--</span><span class="n">pat</span>

<span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">search</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">v</span> <span class="o">-</span><span class="n">p</span> <span class="n">spam</span> <span class="o">--</span><span class="n">pat</span><span class="o">=</span><span class="n">eggs</span> <span class="n">foo</span><span class="o">.</span><span class="n">txt</span> <span class="n">bar</span><span class="o">.</span><span class="n">txt</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;bar.txt&#39;</span><span class="p">]</span>
<span class="n">patterns</span>  <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="n">verbose</span>   <span class="o">=</span> <span class="bp">True</span>
<span class="n">outfile</span>   <span class="o">=</span> <span class="bp">None</span>
<span class="n">speed</span>     <span class="o">=</span> <span class="n">slow</span>

<span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">search</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">v</span> <span class="o">-</span><span class="n">p</span> <span class="n">spam</span> <span class="o">--</span><span class="n">pat</span><span class="o">=</span><span class="n">eggs</span> <span class="n">foo</span><span class="o">.</span><span class="n">txt</span> <span class="n">bar</span><span class="o">.</span><span class="n">txt</span> <span class="o">-</span><span class="n">o</span> <span class="n">results</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;bar.txt&#39;</span><span class="p">]</span>
<span class="n">patterns</span>  <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="n">verbose</span>   <span class="o">=</span> <span class="bp">True</span>
<span class="n">outfile</span>   <span class="o">=</span> <span class="n">results</span>
<span class="n">speed</span>     <span class="o">=</span> <span class="n">slow</span>

<span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">search</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">v</span> <span class="o">-</span><span class="n">p</span> <span class="n">spam</span> <span class="o">--</span><span class="n">pat</span><span class="o">=</span><span class="n">eggs</span> <span class="n">foo</span><span class="o">.</span><span class="n">txt</span> <span class="n">bar</span><span class="o">.</span><span class="n">txt</span> <span class="o">-</span><span class="n">o</span> <span class="n">results</span> \
             <span class="o">--</span><span class="n">speed</span><span class="o">=</span><span class="n">fast</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;bar.txt&#39;</span><span class="p">]</span>
<span class="n">patterns</span>  <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="n">verbose</span>   <span class="o">=</span> <span class="bp">True</span>
<span class="n">outfile</span>   <span class="o">=</span> <span class="n">results</span>
<span class="n">speed</span>     <span class="o">=</span> <span class="n">fast</span>
</pre></div>
</div>
<p>对于选项值的进一步处理由程序来决定，用你自己的逻辑来替代 <code class="docutils literal"><span class="pre">print()</span></code> 函数。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">argparse</span></code> 模块是标准库中最大的模块之一，拥有大量的配置选项。
本节只是演示了其中最基础的一些特性，帮助你入门。</p>
<p>为了解析命令行选项，你首先要创建一个 <code class="docutils literal"><span class="pre">ArgumentParser</span></code> 实例，
并使用 <code class="docutils literal"><span class="pre">add_argument()</span></code> 方法声明你想要支持的选项。
在每个 <code class="docutils literal"><span class="pre">add_argument()</span></code> 调用中，<code class="docutils literal"><span class="pre">dest</span></code> 参数指定解析结果被指派给属性的名字。
<code class="docutils literal"><span class="pre">metavar</span></code> 参数被用来生成帮助信息。<code class="docutils literal"><span class="pre">action</span></code> 参数指定跟属性对应的处理逻辑，
通常的值为 <code class="docutils literal"><span class="pre">store</span></code> ,被用来存储某个值或讲多个参数值收集到一个列表中。
下面的参数收集所有剩余的命令行参数到一个列表中。在本例中它被用来构造一个文件名列表：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="s1">&#39;filenames&#39;</span><span class="p">,</span><span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>下面的参数根据参数是否存在来设置一个 <code class="docutils literal"><span class="pre">Boolean</span></code> 标志：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-v&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;verbose mode&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>下面的参数接受一个单独值并将其存储为一个字符串：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;outfile&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;output file&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>下面的参数说明允许某个参数重复出现多次，并将它们追加到一个列表中去。
<code class="docutils literal"><span class="pre">required</span></code> 标志表示该参数至少要有一个。<code class="docutils literal"><span class="pre">-p</span></code> 和 <code class="docutils literal"><span class="pre">--pat</span></code> 表示两个参数名形式都可使用。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-p&#39;</span><span class="p">,</span> <span class="s1">&#39;--pat&#39;</span><span class="p">,</span><span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;pattern&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;patterns&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;text pattern to search for&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，下面的参数说明接受一个值，但是会将其和可能的选择值做比较，以检测其合法性：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--speed&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;speed&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span>
                    <span class="n">choices</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;slow&#39;</span><span class="p">,</span><span class="s1">&#39;fast&#39;</span><span class="p">},</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;slow&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;search speed&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>一旦参数选项被指定，你就可以执行 <code class="docutils literal"><span class="pre">parser.parse()</span></code> 方法了。
它会处理 <code class="docutils literal"><span class="pre">sys.argv</span></code> 的值并返回一个结果实例。
每个参数值会被设置成该实例中 <code class="docutils literal"><span class="pre">add_argument()</span></code> 方法的 <code class="docutils literal"><span class="pre">dest</span></code> 参数指定的属性值。</p>
<p>还很多种其他方法解析命令行选项。
例如，你可能会手动的处理 <code class="docutils literal"><span class="pre">sys.argv</span></code> 或者使用 <code class="docutils literal"><span class="pre">getopt</span></code> 模块。
但是，如果你采用本节的方式，将会减少很多冗余代码，底层细节 <code class="docutils literal"><span class="pre">argparse</span></code> 模块已经帮你处理了。
你可能还会碰到使用 <code class="docutils literal"><span class="pre">optparse</span></code> 库解析选项的代码。
尽管 <code class="docutils literal"><span class="pre">optparse</span></code> 和 <code class="docutils literal"><span class="pre">argparse</span></code> 很像，但是后者更先进，因此在新的程序中你应该使用它。</p>
</div>
</div>
<span id="document-c13/p04_prompt_for_password_at_runtime"></span><div class="section" id="id1">
<h3>13.4 运行时弹出密码输入提示<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你写了个脚本，运行时需要一个密码。此脚本是交互式的，因此不能将密码在脚本中硬编码，
而是需要弹出一个密码输入提示，让用户自己输入。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>这时候Python的 <code class="docutils literal"><span class="pre">getpass</span></code> 模块正是你所需要的。你可以让你很轻松的弹出密码输入提示，
并且不会在用户终端回显密码。下面是具体代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">getpass</span>

<span class="n">user</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getuser</span><span class="p">()</span>
<span class="n">passwd</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getpass</span><span class="p">()</span>

<span class="k">if</span> <span class="n">svc_login</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">passwd</span><span class="p">):</span>    <span class="c1"># You must write svc_login()</span>
   <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Yay!&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
   <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Boo!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在此代码中，<code class="docutils literal"><span class="pre">svc_login()</span></code> 是你要实现的处理密码的函数，具体的处理过程你自己决定。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>注意在前面代码中 <code class="docutils literal"><span class="pre">getpass.getuser()</span></code> 不会弹出用户名的输入提示。
它会根据该用户的shell环境或者会依据本地系统的密码库（支持 <cite>pwd</cite> 模块的平台）来使用当前用户的登录名，</p>
<p>如果你想显示的弹出用户名输入提示，使用内置的 <code class="docutils literal"><span class="pre">input</span></code> 函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">user</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Enter your username: &#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>还有一点很重要，有些系统可能不支持 <code class="docutils literal"><span class="pre">getpass()</span></code> 方法隐藏输入密码。
这种情况下，Python会提前警告你这些问题（例如它会警告你说密码会以明文形式显示）</p>
</div>
</div>
<span id="document-c13/p05_getting_terminal_size"></span><div class="section" id="id1">
<h3>13.5 获取终端的大小<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要知道当前终端的大小以便正确的格式化输出。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">os.get_terminal_size()</span></code> 函数来做到这一点。</p>
<p>代码示例：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">get_terminal_size</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span>
<span class="go">os.terminal_size(columns=80, lines=24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span><span class="o">.</span><span class="n">columns</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span><span class="o">.</span><span class="n">lines</span>
<span class="go">24</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>有太多方式来得知终端大小了，从读取环境变量到执行底层的 <code class="docutils literal"><span class="pre">ioctl()</span></code> 函数等等。
不过，为什么要去研究这些复杂的办法而不是仅仅调用一个简单的函数呢？</p>
</div>
</div>
<span id="document-c13/p06_executing_external_command_and_get_its_output"></span><div class="section" id="id1">
<h3>13.6 执行外部命令并获取它的输出<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想执行一个外部命令并以Python字符串的形式获取执行结果。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">subprocess.check_output()</span></code> 函数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">subprocess</span>
<span class="n">out_bytes</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;netstat&#39;</span><span class="p">,</span><span class="s1">&#39;-a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>这段代码执行一个指定的命令并将执行结果以一个字节字符串的形式返回。
如果你需要文本形式返回，加一个解码步骤即可。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">out_text</span> <span class="o">=</span> <span class="n">out_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果被执行的命令以非零码返回，就会抛出异常。
下面的例子捕获到错误并获取返回码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">out_bytes</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;cmd&#39;</span><span class="p">,</span><span class="s1">&#39;arg1&#39;</span><span class="p">,</span><span class="s1">&#39;arg2&#39;</span><span class="p">])</span>
<span class="k">except</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">CalledProcessError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">out_bytes</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">output</span>       <span class="c1"># Output generated before error</span>
    <span class="n">code</span>      <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">returncode</span>   <span class="c1"># Return code</span>
</pre></div>
</div>
<p>默认情况下，<code class="docutils literal"><span class="pre">check_output()</span></code> 仅仅返回输入到标准输出的值。
如果你需要同时收集标准输出和错误输出，使用 <code class="docutils literal"><span class="pre">stderr</span></code> 参数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">out_bytes</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;cmd&#39;</span><span class="p">,</span><span class="s1">&#39;arg1&#39;</span><span class="p">,</span><span class="s1">&#39;arg2&#39;</span><span class="p">],</span>
                                    <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你需要用一个超时机制来执行命令，使用 <code class="docutils literal"><span class="pre">timeout</span></code> 参数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">out_bytes</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;cmd&#39;</span><span class="p">,</span><span class="s1">&#39;arg1&#39;</span><span class="p">,</span><span class="s1">&#39;arg2&#39;</span><span class="p">],</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">except</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">TimeoutExpired</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>通常来讲，命令的执行不需要使用到底层shell环境（比如sh、bash）。
一个字符串列表会被传递给一个低级系统命令，比如 <code class="docutils literal"><span class="pre">os.execve()</span></code> 。
如果你想让命令被一个shell执行，传递一个字符串参数，并设置参数 <code class="docutils literal"><span class="pre">shell=True</span></code> .
有时候你想要Python去执行一个复杂的shell命令的时候这个就很有用了，比如管道流、I/O重定向和其他特性。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">out_bytes</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">(</span><span class="s1">&#39;grep python | wc &gt; out&#39;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>需要注意的是在shell中执行命令会存在一定的安全风险，特别是当参数来自于用户输入时。
这时候可以使用 <code class="docutils literal"><span class="pre">shlex.quote()</span></code> 函数来讲参数正确的用双引用引起来。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">check_output()</span></code> 函数是执行外部命令并获取其返回值的最简单方式。
但是，如果你需要对子进程做更复杂的交互，比如给它发送输入，你得采用另外一种方法。
这时候可直接使用 <code class="docutils literal"><span class="pre">subprocess.Popen</span></code> 类。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">subprocess</span>

<span class="c1"># Some text to send</span>
<span class="n">text</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">hello world</span>
<span class="s1">this is a test</span>
<span class="s1">goodbye</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="c1"># Launch a command with pipes</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;wc&#39;</span><span class="p">],</span>
          <span class="n">stdout</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
          <span class="n">stdin</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>

<span class="c1"># Send the data and get the output</span>
<span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

<span class="c1"># To interpret as text, decode</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">stdout</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">stderr</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">subprocess</span></code> 模块对于依赖TTY的外部命令不合适用。
例如，你不能使用它来自动化一个用户输入密码的任务（比如一个ssh会话）。
这时候，你需要使用到第三方模块了，比如基于著名的 <code class="docutils literal"><span class="pre">expect</span></code> 家族的工具（pexpect或类似的）</p>
</div>
</div>
<span id="document-c13/p07_copy_move_files_and_directories"></span><div class="section" id="id1">
<h3>13.7 复制或者移动文件和目录<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想要复制或移动文件和目录，但是又不想调用shell命令。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">shutil</span></code> 模块有很多便捷的函数可以复制文件和目录。使用起来非常简单，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">shutil</span>

<span class="c1"># Copy src to dst. (cp src dst)</span>
<span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

<span class="c1"># Copy files, but preserve metadata (cp -p src dst)</span>
<span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

<span class="c1"># Copy directory tree (cp -R src dst)</span>
<span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

<span class="c1"># Move src to dst (mv src dst)</span>
<span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<p>这些函数的参数都是字符串形式的文件或目录名。
底层语义模拟了类似的Unix命令，如上面的注释部分。</p>
<p>默认情况下，对于符号链接而已这些命令处理的是它指向的东西。
例如，如果源文件是一个符号链接，那么目标文件将会是符号链接指向的文件。
如果你只想复制符号链接本身，那么需要指定关键字参数 <code class="docutils literal"><span class="pre">follow_symlinks</span></code> ,如下：</p>
<p>如果你想保留被复制目录中的符号链接，像这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">symlinks</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">copytree()</span></code> 可以让你在复制过程中选择性的忽略某些文件或目录。
你可以提供一个忽略函数，接受一个目录名和文件名列表作为输入，返回一个忽略的名称列表。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ignore_pyc_files</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">filenames</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="ow">in</span> <span class="n">filenames</span> <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.pyc&#39;</span><span class="p">)]</span>

<span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore_pyc_files</span><span class="p">)</span>
</pre></div>
</div>
<p>由于忽略某种模式的文件名是很常见的，因此一个便捷的函数 <code class="docutils literal"><span class="pre">ignore_patterns()</span></code> 已经包含在里面了。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">shutil</span><span class="o">.</span><span class="n">ignore_patterns</span><span class="p">(</span><span class="s1">&#39;*~&#39;</span><span class="p">,</span> <span class="s1">&#39;*.pyc&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">shutil</span></code> 复制文件和目录也忒简单了点吧。
不过，对于文件元数据信息，<code class="docutils literal"><span class="pre">copy2()</span></code> 这样的函数只能尽自己最大能力来保留它。
访问时间、创建时间和权限这些基本信息会被保留，
但是对于所有者、ACLs、资源fork和其他更深层次的文件元信息就说不准了，
这个还得依赖于底层操作系统类型和用户所拥有的访问权限。
你通常不会去使用 <code class="docutils literal"><span class="pre">shutil.copytree()</span></code> 函数来执行系统备份。
当处理文件名的时候，最好使用 <code class="docutils literal"><span class="pre">os.path</span></code> 中的函数来确保最大的可移植性（特别是同时要适用于Unix和Windows）。
例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;/Users/guido/programs/spam.py&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os.path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">&#39;spam.py&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">&#39;/Users/guido/programs&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">(&#39;/Users/guido/programs&#39;, &#39;spam.py&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;/new/dir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
<span class="go">&#39;/new/dir/spam.py&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~/guido/programs/spam.py&#39;</span><span class="p">)</span>
<span class="go">&#39;/Users/guido/programs/spam.py&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">copytree()</span></code> 复制文件夹的一个棘手的问题是对于错误的处理。
例如，在复制过程中，函数可能会碰到损坏的符号链接，因为权限无法访问文件的问题等等。
为了解决这个问题，所有碰到的问题会被收集到一个列表中并打包为一个单独的异常，到了最后再抛出。
下面是一个例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
<span class="k">except</span> <span class="n">shutil</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
         <span class="c1"># src is source name</span>
         <span class="c1"># dst is destination name</span>
         <span class="c1"># msg is error message from exception</span>
         <span class="k">print</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你提供关键字参数 <code class="docutils literal"><span class="pre">ignore_dangling_symlinks=True</span></code> ，
这时候 <code class="docutils literal"><span class="pre">copytree()</span></code> 会忽略掉无效符号链接。</p>
<p>本节演示的这些函数都是最常见的。不过，<code class="docutils literal"><span class="pre">shutil</span></code> 还有更多的和复制数据相关的操作。
它的文档很值得一看，参考 <a class="reference external" href="https://docs.python.org/3/library/shutil.html">Python documentation</a></p>
</div>
</div>
<span id="document-c13/p08_creating_and_unpacking_archives"></span><div class="section" id="id1">
<h3>13.8 创建和解压归档文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要创建或解压常见格式的归档文件（比如.tar, .tgz或.zip）</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">shutil</span></code> 模块拥有两个函数—— <code class="docutils literal"><span class="pre">make_archive()</span></code> 和 <code class="docutils literal"><span class="pre">unpack_archive()</span></code> 可派上用场。
例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">shutil</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shutil</span><span class="o">.</span><span class="n">unpack_archive</span><span class="p">(</span><span class="s1">&#39;Python-3.3.0.tgz&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">shutil</span><span class="o">.</span><span class="n">make_archive</span><span class="p">(</span><span class="s1">&#39;py33&#39;</span><span class="p">,</span><span class="s1">&#39;zip&#39;</span><span class="p">,</span><span class="s1">&#39;Python-3.3.0&#39;</span><span class="p">)</span>
<span class="go">&#39;/Users/beazley/Downloads/py33.zip&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">make_archive()</span></code> 的第二个参数是期望的输出格式。
可以使用 <code class="docutils literal"><span class="pre">get_archive_formats()</span></code> 获取所有支持的归档格式列表。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shutil</span><span class="o">.</span><span class="n">get_archive_formats</span><span class="p">()</span>
<span class="go">[(&#39;bztar&#39;, &quot;bzip2&#39;ed tar-file&quot;), (&#39;gztar&#39;, &quot;gzip&#39;ed tar-file&quot;),</span>
<span class="go"> (&#39;tar&#39;, &#39;uncompressed tar file&#39;), (&#39;zip&#39;, &#39;ZIP file&#39;)]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>Python还有其他的模块可用来处理多种归档格式（比如tarfile, zipfile, gzip, bz2）的底层细节。
不过，如果你仅仅只是要创建或提取某个归档，就没有必要使用底层库了。
可以直接使用 <code class="docutils literal"><span class="pre">shutil</span></code> 中的这些高层函数。</p>
<p>这些函数还有很多其他选项，用于日志打印、预检、文件权限等等。
参考 <a class="reference external" href="https://docs.python.org/3/library/shutil.html">shutil文档</a></p>
</div>
</div>
<span id="document-c13/p09_find_files_by_name"></span><div class="section" id="id1">
<h3>13.9 通过文件名查找文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你需要写一个涉及到文件查找操作的脚本，比如对日志归档文件的重命名工具，
你不想在Python脚本中调用shell，或者你要实现一些shell不能做的功能。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>查找文件，可使用 <code class="docutils literal"><span class="pre">os.walk()</span></code> 函数，传一个顶级目录名给它。
下面是一个例子，查找特定的文件名并答应所有符合条件的文件全路径：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3.3</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">findfile</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">relpath</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="n">full_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">relpath</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">full_path</span><span class="p">)))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">findfile</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>保存脚本为文件findfile.py，然后在命令行中执行它。
指定初始查找目录以及名字作为位置参数，如下：</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">os.walk()</span></code> 方法为我们遍历目录树，
每次进入一个目录，它会返回一个三元组，包含相对于查找目录的相对路径，一个该目录下的目录名列表，
以及那个目录下面的文件名列表。</p>
<p>对于每个元组，只需检测一下目标文件名是否在文件列表中。如果是就使用 <code class="docutils literal"><span class="pre">os.path.join()</span></code> 合并路径。
为了避免奇怪的路径名比如 <code class="docutils literal"><span class="pre">././foo//bar</span></code> ，使用了另外两个函数来修正结果。
第一个是 <code class="docutils literal"><span class="pre">os.path.abspath()</span></code> ,它接受一个路径，可能是相对路径，最后返回绝对路径。
第二个是 <code class="docutils literal"><span class="pre">os.path.normpath()</span></code> ，用来返回正常路径，可以解决双斜杆、对目录的多重引用的问题等。</p>
<p>尽管这个脚本相对于UNIX平台上面的很多查找来讲要简单很多，它还有跨平台的优势。
并且，还能很轻松的加入其他的功能。
我们再演示一个例子，下面的函数打印所有最近被修改过的文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3.3</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">modified_within</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
    <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">top</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="n">fullpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fullpath</span><span class="p">):</span>
                <span class="n">mtime</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="n">fullpath</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mtime</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">seconds</span><span class="p">):</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">fullpath</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Usage: {} dir seconds&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">modified_within</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
<p>在此函数的基础之上，使用os,os.path,glob等类似模块，你就能实现更加复杂的操作了。
可参考5.11小节和5.13小节等相关章节。</p>
</div>
</div>
<span id="document-c13/p10_read_configuration_files"></span><div class="section" id="id1">
<h3>13.10 读取配置文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>怎样读取普通.ini格式的配置文件？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">configparser</span></code> 模块能被用来读取配置文件。例如，假设你有如下的配置文件：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="n">config</span><span class="o">.</span><span class="n">ini</span>
<span class="p">;</span> <span class="n">Sample</span> <span class="n">configuration</span> <span class="n">file</span>

<span class="p">[</span><span class="n">installation</span><span class="p">]</span>
<span class="n">library</span><span class="o">=%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="n">lib</span>
<span class="n">include</span><span class="o">=%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="n">include</span>
<span class="nb">bin</span><span class="o">=%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="nb">bin</span>
<span class="n">prefix</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span>

<span class="c1"># Setting related to debug configuration</span>
<span class="p">[</span><span class="n">debug</span><span class="p">]</span>
<span class="n">log_errors</span><span class="o">=</span><span class="n">true</span>
<span class="n">show_warnings</span><span class="o">=</span><span class="kc">False</span>

<span class="p">[</span><span class="n">server</span><span class="p">]</span>
<span class="n">port</span><span class="p">:</span> <span class="mi">8080</span>
<span class="n">nworkers</span><span class="p">:</span> <span class="mi">32</span>
<span class="n">pid</span><span class="o">-</span><span class="n">file</span><span class="o">=/</span><span class="n">tmp</span><span class="o">/</span><span class="n">spam</span><span class="o">.</span><span class="n">pid</span>
<span class="n">root</span><span class="o">=/</span><span class="n">www</span><span class="o">/</span><span class="n">root</span>
<span class="n">signature</span><span class="p">:</span>
    <span class="o">=================================</span>
    <span class="n">Brought</span> <span class="n">to</span> <span class="n">you</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Python</span> <span class="n">Cookbook</span>
    <span class="o">=================================</span>
</pre></div>
</div>
<p>下面是一个读取和提取其中值的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">configparser</span> <span class="kn">import</span> <span class="n">ConfigParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;config.ini&#39;</span><span class="p">)</span>
<span class="go">[&#39;config.ini&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">[&#39;installation&#39;, &#39;debug&#39;, &#39;server&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span><span class="s1">&#39;library&#39;</span><span class="p">)</span>
<span class="go">&#39;/usr/local/lib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span><span class="s1">&#39;log_errors&#39;</span><span class="p">)</span>

<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;server&#39;</span><span class="p">,</span><span class="s1">&#39;port&#39;</span><span class="p">)</span>
<span class="go">8080</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;server&#39;</span><span class="p">,</span><span class="s1">&#39;nworkers&#39;</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;server&#39;</span><span class="p">,</span><span class="s1">&#39;signature&#39;</span><span class="p">))</span>

<span class="go">\=================================</span>
<span class="go">Brought to you by the Python Cookbook</span>
<span class="go">\=================================</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果有需要，你还能修改配置并使用 <code class="docutils literal"><span class="pre">cfg.write()</span></code> 方法将其写回到文件中。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;server&#39;</span><span class="p">,</span><span class="s1">&#39;port&#39;</span><span class="p">,</span><span class="s1">&#39;9000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span><span class="s1">&#39;log_errors&#39;</span><span class="p">,</span><span class="s1">&#39;False&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">installation</span><span class="p">]</span>
<span class="n">library</span> <span class="o">=</span> <span class="o">%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="n">lib</span>
<span class="n">include</span> <span class="o">=</span> <span class="o">%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="n">include</span>
<span class="nb">bin</span> <span class="o">=</span> <span class="o">%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="nb">bin</span>
<span class="n">prefix</span> <span class="o">=</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span>

<span class="p">[</span><span class="n">debug</span><span class="p">]</span>
<span class="n">log_errors</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">show_warnings</span> <span class="o">=</span> <span class="kc">False</span>

<span class="p">[</span><span class="n">server</span><span class="p">]</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">nworkers</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">pid</span><span class="o">-</span><span class="n">file</span> <span class="o">=</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">spam</span><span class="o">.</span><span class="n">pid</span>
<span class="n">root</span> <span class="o">=</span> <span class="o">/</span><span class="n">www</span><span class="o">/</span><span class="n">root</span>
<span class="n">signature</span> <span class="o">=</span>
          <span class="o">=================================</span>
          <span class="n">Brought</span> <span class="n">to</span> <span class="n">you</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Python</span> <span class="n">Cookbook</span>
          <span class="o">=================================</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>配置文件作为一种可读性很好的格式，非常适用于存储程序中的配置数据。
在每个配置文件中，配置数据会被分组（比如例子中的“installation”、 “debug” 和 “server”）。
每个分组在其中指定对应的各个变量值。</p>
<p>对于可实现同样功能的配置文件和Python源文件是有很大的不同的。
首先，配置文件的语法要更自由些，下面的赋值语句是等效的：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">prefix</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span>
<span class="n">prefix</span><span class="p">:</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span>
</pre></div>
</div>
<p>配置文件中的名字是不区分大小写的。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span><span class="s1">&#39;PREFIX&#39;</span><span class="p">)</span>
<span class="go">&#39;/usr/local&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span><span class="s1">&#39;prefix&#39;</span><span class="p">)</span>
<span class="go">&#39;/usr/local&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在解析值的时候，<code class="docutils literal"><span class="pre">getboolean()</span></code> 方法查找任何可行的值。例如下面都是等价的：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">log_errors</span> <span class="o">=</span> <span class="n">true</span>
<span class="n">log_errors</span> <span class="o">=</span> <span class="n">TRUE</span>
<span class="n">log_errors</span> <span class="o">=</span> <span class="n">Yes</span>
<span class="n">log_errors</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>或许配置文件和Python代码最大的不同在于，它并不是从上而下的顺序执行。
文件是安装一个整体被读取的。如果碰到了变量替换，它实际上已经被替换完成了。
例如，在下面这个配置中，<code class="docutils literal"><span class="pre">prefix</span></code> 变量在使用它的变量之前或之后定义都是可以的：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">installation</span><span class="p">]</span>
<span class="n">library</span><span class="o">=%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="n">lib</span>
<span class="n">include</span><span class="o">=%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="n">include</span>
<span class="nb">bin</span><span class="o">=%</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="n">s</span><span class="o">/</span><span class="nb">bin</span>
<span class="n">prefix</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ConfigParser</span></code> 有个容易被忽视的特性是它能一次读取多个配置文件然后合并成一个配置。
例如，假设一个用户像下面这样构造了他们的配置文件：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="o">~/.</span><span class="n">config</span><span class="o">.</span><span class="n">ini</span>
<span class="p">[</span><span class="n">installation</span><span class="p">]</span>
<span class="n">prefix</span><span class="o">=/</span><span class="n">Users</span><span class="o">/</span><span class="n">beazley</span><span class="o">/</span><span class="n">test</span>

<span class="p">[</span><span class="n">debug</span><span class="p">]</span>
<span class="n">log_errors</span><span class="o">=</span><span class="kc">False</span>
</pre></div>
</div>
<p>读取这个文件，它就能跟之前的配置合并起来。如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Previously read configuration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span> <span class="s1">&#39;prefix&#39;</span><span class="p">)</span>
<span class="go">&#39;/usr/local&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Merge in user-specific configuration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~/.config.ini&#39;</span><span class="p">))</span>
<span class="go">[&#39;/Users/beazley/.config.ini&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span> <span class="s1">&#39;prefix&#39;</span><span class="p">)</span>
<span class="go">&#39;/Users/beazley/test&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span> <span class="s1">&#39;library&#39;</span><span class="p">)</span>
<span class="go">&#39;/Users/beazley/test/lib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="s1">&#39;log_errors&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>仔细观察下 <code class="docutils literal"><span class="pre">prefix</span></code> 变量是怎样覆盖其他相关变量的，比如 <code class="docutils literal"><span class="pre">library</span></code> 的设定值。
产生这种结果的原因是变量的改写采取的是后发制人策略，以最后一个为准。
你可以像下面这样做试验：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span><span class="s1">&#39;library&#39;</span><span class="p">)</span>
<span class="go">&#39;/Users/beazley/test/lib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span><span class="s1">&#39;prefix&#39;</span><span class="p">,</span><span class="s1">&#39;/tmp/dir&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;installation&#39;</span><span class="p">,</span><span class="s1">&#39;library&#39;</span><span class="p">)</span>
<span class="go">&#39;/tmp/dir/lib&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后还有很重要一点要注意的是Python并不能支持.ini文件在其他程序（比如windows应用程序）中的所有特性。
确保你已经参阅了configparser文档中的语法详情以及支持特性。</p>
</div>
</div>
<span id="document-c13/p11_add_logging_to_simple_scripts"></span><div class="section" id="id1">
<h3>13.11 给简单脚本增加日志功能<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你希望在脚本和程序中将诊断信息写入日志文件。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>打印日志最简单方式是使用 <code class="docutils literal"><span class="pre">logging</span></code> 模块。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Configure the logging system</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
        <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;app.log&#39;</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span>
    <span class="p">)</span>

    <span class="c1"># Variables (to make the calls that follow work)</span>
    <span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;data.csv&#39;</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>

    <span class="c1"># Example logging calls (insert into your program)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Host </span><span class="si">%s</span><span class="s1"> unknown&#39;</span><span class="p">,</span> <span class="n">hostname</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t find </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Feature is deprecated&#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Opening file </span><span class="si">%r</span><span class="s1">, mode=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Got here&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>上面五个日志调用（critical(), error(), warning(), info(), debug()）以降序方式表示不同的严重级别。
<code class="docutils literal"><span class="pre">basicConfig()</span></code> 的 <code class="docutils literal"><span class="pre">level</span></code> 参数是一个过滤器。
所有级别低于此级别的日志消息都会被忽略掉。
每个logging操作的参数是一个消息字符串，后面再跟一个或多个参数。
构造最终的日志消息的时候我们使用了%操作符来格式化消息字符串。</p>
<p>运行这个程序后，在文件 <code class="docutils literal"><span class="pre">app.log</span></code> 中的内容应该是下面这样：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CRITICAL</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Host</span> <span class="n">www</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">org</span> <span class="n">unknown</span>
<span class="n">ERROR</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Could</span> <span class="ow">not</span> <span class="n">find</span> <span class="s1">&#39;spam&#39;</span>
</pre></div>
</div>
<p>如果你想改变输出等级，你可以修改 <code class="docutils literal"><span class="pre">basicConfig()</span></code> 调用中的参数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
     <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;app.log&#39;</span><span class="p">,</span>
     <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span>
     <span class="n">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(levelname)s</span><span class="s1">:</span><span class="si">%(asctime)s</span><span class="s1">:</span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>最后输出变成如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CRITICAL</span><span class="p">:</span><span class="mi">2012</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">20</span> <span class="mi">12</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span><span class="mi">595</span><span class="p">:</span><span class="n">Host</span> <span class="n">www</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">org</span> <span class="n">unknown</span>
<span class="n">ERROR</span><span class="p">:</span><span class="mi">2012</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">20</span> <span class="mi">12</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span><span class="mi">595</span><span class="p">:</span><span class="n">Could</span> <span class="ow">not</span> <span class="n">find</span> <span class="s1">&#39;spam&#39;</span>
<span class="n">WARNING</span><span class="p">:</span><span class="mi">2012</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">20</span> <span class="mi">12</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span><span class="mi">595</span><span class="p">:</span><span class="n">Feature</span> <span class="ow">is</span> <span class="n">deprecated</span>
</pre></div>
</div>
<p>上面的日志配置都是硬编码到程序中的。如果你想使用配置文件，
可以像下面这样修改 <code class="docutils literal"><span class="pre">basicConfig()</span></code> 调用：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">logging.config</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Configure the logging system</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">fileConfig</span><span class="p">(</span><span class="s1">&#39;logconfig.ini&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>创建一个下面这样的文件，名字叫 <code class="docutils literal"><span class="pre">logconfig.ini</span></code> ：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">loggers</span><span class="p">]</span>
<span class="n">keys</span><span class="o">=</span><span class="n">root</span>

<span class="p">[</span><span class="n">handlers</span><span class="p">]</span>
<span class="n">keys</span><span class="o">=</span><span class="n">defaultHandler</span>

<span class="p">[</span><span class="n">formatters</span><span class="p">]</span>
<span class="n">keys</span><span class="o">=</span><span class="n">defaultFormatter</span>

<span class="p">[</span><span class="n">logger_root</span><span class="p">]</span>
<span class="n">level</span><span class="o">=</span><span class="n">INFO</span>
<span class="n">handlers</span><span class="o">=</span><span class="n">defaultHandler</span>
<span class="n">qualname</span><span class="o">=</span><span class="n">root</span>

<span class="p">[</span><span class="n">handler_defaultHandler</span><span class="p">]</span>
<span class="n">class</span><span class="o">=</span><span class="n">FileHandler</span>
<span class="n">formatter</span><span class="o">=</span><span class="n">defaultFormatter</span>
<span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;app.log&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>

<span class="p">[</span><span class="n">formatter_defaultFormatter</span><span class="p">]</span>
<span class="nb">format</span><span class="o">=%</span><span class="p">(</span><span class="n">levelname</span><span class="p">)</span><span class="n">s</span><span class="p">:</span><span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="n">s</span><span class="p">:</span><span class="o">%</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="n">s</span>
</pre></div>
</div>
<p>如果你想修改配置，可以直接编辑文件logconfig.ini即可。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>尽管对于 <code class="docutils literal"><span class="pre">logging</span></code> 模块而已有很多更高级的配置选项，
不过这里的方案对于简单的程序和脚本已经足够了。
只想在调用日志操作前先执行下basicConfig()函数方法，你的程序就能产生日志输出了。</p>
<p>如果你想要你的日志消息写到标准错误中，而不是日志文件中，调用 <code class="docutils literal"><span class="pre">basicConfig()</span></code> 时不传文件名参数即可。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">basicConfig()</span></code> 在程序中只能被执行一次。如果你稍后想改变日志配置，
就需要先获取 <code class="docutils literal"><span class="pre">root</span> <span class="pre">logger</span></code> ，然后直接修改它。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span>
</pre></div>
</div>
<p>需要强调的是本节只是演示了 <code class="docutils literal"><span class="pre">logging</span></code> 模块的一些基本用法。
它可以做更多更高级的定制。
关于日志定制化一个很好的资源是 <a class="reference external" href="https://docs.python.org/3/howto/logging-cookbook.html">Logging Cookbook</a></p>
</div>
</div>
<span id="document-c13/p12_add_logging_to_libraries"></span><div class="section" id="id1">
<h3>13.12 给函数库增加日志功能<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想给某个函数库增加日志功能，但是又不能影响到那些不使用日志功能的程序。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于想要执行日志操作的函数库而已，你应该创建一个专属的 <code class="docutils literal"><span class="pre">logger</span></code> 对象，并且像下面这样初始化配置：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># somelib.py</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NullHandler</span><span class="p">())</span>

<span class="c1"># Example function (for testing)</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;A Critical Error!&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;A debug message&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用这个配置，默认情况下不会打印日志。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">somelib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">somelib</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>不过，如果配置过日志系统，那么日志消息打印就开始生效，例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">logging</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">somelib</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>
<span class="go">CRITICAL:somelib:A Critical Error!</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>通常来讲，你不应该在函数库代码中自己配置日志系统，或者是已经假定有个已经存在的日志配置了。</p>
<p>调用 <code class="docutils literal"><span class="pre">getLogger(__name__)</span></code> 创建一个和调用模块同名的logger模块。
由于模块都是唯一的，因此创建的logger也将是唯一的。</p>
<p><code class="docutils literal"><span class="pre">log.addHandler(logging.NullHandler())</span></code> 操作将一个空处理器绑定到刚刚已经创建好的logger对象上。
一个空处理器默认会忽略调用所有的日志消息。
因此，如果使用该函数库的时候还没有配置日志，那么将不会有消息或警告出现。</p>
<p>还有一点就是对于各个函数库的日志配置可以是相互独立的，不影响其他库的日志配置。
例如，对于如下的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">logging</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">somelib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">somelib</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>
<span class="go">CRITICAL:somelib:A Critical Error!</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Change the logging level for &#39;somelib&#39; only</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;somelib&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">somelib</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>
<span class="go">CRITICAL:somelib:A Critical Error!</span>
<span class="go">DEBUG:somelib:A debug message</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这里，根日志被配置成仅仅输出ERROR或更高级别的消息。
不过 ，<code class="docutils literal"><span class="pre">somelib</span></code> 的日志级别被单独配置成可以输出debug级别的消息，它的优先级比全局配置高。
像这样更改单独模块的日志配置对于调试来讲是很方便的，
因为你无需去更改任何的全局日志配置——只需要修改你想要更多输出的模块的日志等级。</p>
<p><a class="reference external" href="https://docs.python.org/3/howto/logging.html">Logging HOWTO</a>
详细介绍了如何配置日志模块和其他有用技巧，可以参阅下。</p>
</div>
</div>
<span id="document-c13/p13_making_stopwatch_timer"></span><div class="section" id="id1">
<h3>13.13 实现一个计时器<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想记录程序执行多个任务所花费的时间</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">time</span></code> 模块包含很多函数来执行跟时间有关的函数。
尽管如此，通常我们会在此基础之上构造一个更高级的接口来模拟一个计时器。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Timer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elapsed</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Already started&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not started&#39;</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elapsed</span> <span class="o">+=</span> <span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elapsed</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">running</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p>这个类定义了一个可以被用户根据需要启动、停止和重置的计时器。
它会在 <code class="docutils literal"><span class="pre">elapsed</span></code> 属性中记录整个消耗时间。
下面是一个例子来演示怎样使用它：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="c1"># Use 1: Explicit start/stop</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">countdown</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">elapsed</span><span class="p">)</span>

<span class="c1"># Use 2: As a context manager</span>
<span class="k">with</span> <span class="n">t</span><span class="p">:</span>
    <span class="n">countdown</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">elapsed</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">t2</span><span class="p">:</span>
    <span class="n">countdown</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">elapsed</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本节提供了一个简单而实用的类来实现时间记录以及耗时计算。
同时也是对使用with语句以及上下文管理器协议的一个很好的演示。</p>
<p>在计时中要考虑一个底层的时间函数问题。一般来说，
使用 <code class="docutils literal"><span class="pre">time.time()</span></code> 或 <code class="docutils literal"><span class="pre">time.clock()</span></code> 计算的时间精度因操作系统的不同会有所不同。
而使用 <code class="docutils literal"><span class="pre">time.perf_counter()</span></code> 函数可以确保使用系统上面最精确的计时器。</p>
<p>上述代码中由 <code class="docutils literal"><span class="pre">Timer</span></code> 类记录的时间是钟表时间，并包含了所有休眠时间。
如果你只想计算该进程所花费的CPU时间，应该使用 <code class="docutils literal"><span class="pre">time.process_time()</span></code> 来代替：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">)</span>
<span class="k">with</span> <span class="n">t</span><span class="p">:</span>
    <span class="n">countdown</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">elapsed</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">time.perf_counter()</span></code> 和 <code class="docutils literal"><span class="pre">time.process_time()</span></code> 都会返回小数形式的秒数时间。
实际的时间值没有任何意义，为了得到有意义的结果，你得执行两次函数然后计算它们的差值。</p>
<p>更多关于计时和性能分析的例子请参考14.13小节。</p>
</div>
</div>
<span id="document-c13/p14_putting_limits_on_memory_and_cpu_usage"></span><div class="section" id="cpu">
<h3>13.14 限制内存和CPU的使用量<a class="headerlink" href="#cpu" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想对在Unix系统上面运行的程序设置内存或CPU的使用限制。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">resource</span></code> 模块能同时执行这两个任务。例如，要限制CPU时间，可以像下面这样做：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">resource</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">time_exceeded</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Time&#39;s up!&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">set_max_runtime</span><span class="p">(</span><span class="n">seconds</span><span class="p">):</span>
    <span class="c1"># Install the signal handler and set a resource limit</span>
    <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span> <span class="o">=</span> <span class="n">resource</span><span class="o">.</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_CPU</span><span class="p">)</span>
    <span class="n">resource</span><span class="o">.</span><span class="n">setrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_CPU</span><span class="p">,</span> <span class="p">(</span><span class="n">seconds</span><span class="p">,</span> <span class="n">hard</span><span class="p">))</span>
    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGXCPU</span><span class="p">,</span> <span class="n">time_exceeded</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">set_max_runtime</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>程序运行时，<code class="docutils literal"><span class="pre">SIGXCPU</span></code> 信号在时间过期时被生成，然后执行清理并退出。</p>
<p>要限制内存使用，设置可使用的总内存值即可，如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">resource</span>

<span class="k">def</span> <span class="nf">limit_memory</span><span class="p">(</span><span class="n">maxsize</span><span class="p">):</span>
    <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span> <span class="o">=</span> <span class="n">resource</span><span class="o">.</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_AS</span><span class="p">)</span>
    <span class="n">resource</span><span class="o">.</span><span class="n">setrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_AS</span><span class="p">,</span> <span class="p">(</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">hard</span><span class="p">))</span>
</pre></div>
</div>
<p>像这样设置了内存限制后，程序运行到没有多余内存时会抛出 <code class="docutils literal"><span class="pre">MemoryError</span></code> 异常。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在本节例子中，<code class="docutils literal"><span class="pre">setrlimit()</span></code> 函数被用来设置特定资源上面的软限制和硬限制。
软限制是一个值，当超过这个值的时候操作系统通常会发送一个信号来限制或通知该进程。
硬限制是用来指定软限制能设定的最大值。通常来讲，这个由系统管理员通过设置系统级参数来决定。
尽管硬限制可以改小一点，但是最好不要使用用户进程去修改。</p>
<p><code class="docutils literal"><span class="pre">setrlimit()</span></code> 函数还能被用来设置子进程数量、打开文件数以及类似系统资源的限制。
更多详情请参考 <code class="docutils literal"><span class="pre">resource</span></code> 模块的文档。</p>
<p>需要注意的是本节内容只能适用于Unix系统，并且不保证所有系统都能如期工作。
比如我们在测试的时候，它能在Linux上面正常运行，但是在OS X上却不能。</p>
</div>
</div>
<span id="document-c13/p15_luanch_a_web_browser"></span><div class="section" id="web">
<h3>13.15 启动一个WEB浏览器<a class="headerlink" href="#web" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想通过脚本启动浏览器并打开指定的URL网页</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">webbrowser</span></code> 模块能被用来启动一个浏览器，并且与平台无关。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">webbrowser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">webbrowser</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>它会使用默认浏览器打开指定网页。如果你还想对网页打开方式做更多控制，还可以使用下面这些函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Open the page in a new browser window</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">webbrowser</span><span class="o">.</span><span class="n">open_new</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Open the page in a new browser tab</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">webbrowser</span><span class="o">.</span><span class="n">open_new_tab</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这样就可以打开一个新的浏览器窗口或者标签，只要浏览器支持就行。</p>
<p>如果你想指定浏览器类型，可以使用 <code class="docutils literal"><span class="pre">webbrowser.get()</span></code> 函数来指定某个特定浏览器。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">webbrowser</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;firefox&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">open_new_tab</span><span class="p">(</span><span class="s1">&#39;http://docs.python.org&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于支持的浏览器名称列表可查阅`Python文档 &lt;<a class="reference external" href="http://docs.python.org/3/library/webbrowser.html">http://docs.python.org/3/library/webbrowser.html</a>&gt;`_</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在脚本中打开浏览器有时候会很有用。例如，某个脚本执行某个服务器发布任务，
你想快速打开一个浏览器来确保它已经正常运行了。
或者是某个程序以HTML网页格式输出数据，你想打开浏览器查看结果。
不管是上面哪种情况，使用 <code class="docutils literal"><span class="pre">webbrowser</span></code> 模块都是一个简单实用的解决方案。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p14_test_debug_and_exceptions"></span><div class="section" id="id1">
<h2>第十四章：测试、调试和异常<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>试验还是很棒的，但是调试？就没那么有趣了。事实是，在Python测试代码之前没有编译器来分析你的代码，因此使的测试成为开发的一个重要部分。本章的目标是讨论一些关于测试、调试和异常处理的常见问题。但是并不是为测试驱动开发或者单元测试模块做一个简要的介绍。因此，笔者假定读者熟悉测试概念。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c14/p01_testing_output_sent_to_stdout"></span><div class="section" id="stdout">
<h3>14.1 测试stdout输出<a class="headerlink" href="#stdout" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你的程序中有个方法会输出到标准输出中（sys.stdout）。也就是说它会将文本打印到屏幕上面。
你想写个测试来证明它，给定一个输入，相应的输出能正常显示出来。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>使用 <code class="docutils literal"><span class="pre">unittest.mock</span></code> 模块中的 <code class="docutils literal"><span class="pre">patch()</span></code> 函数，
使用起来非常简单，可以为单个测试模拟 <code class="docutils literal"><span class="pre">sys.stdout</span></code> 然后回滚，
并且不产生大量的临时变量或在测试用例直接暴露状态变量。</p>
<p>作为一个例子，我们在 <code class="docutils literal"><span class="pre">mymodule</span></code> 模块中定义如下一个函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># mymodule.py</span>

<span class="k">def</span> <span class="nf">urlprint</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;{}://{}.{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>默认情况下内置的 <code class="docutils literal"><span class="pre">print</span></code> 函数会将输出发送到 <code class="docutils literal"><span class="pre">sys.stdout</span></code> 。
为了测试输出真的在那里，你可以使用一个替身对象来模拟它，然后使用断言来确认结果。
使用 <code class="docutils literal"><span class="pre">unittest.mock</span></code> 模块的 <code class="docutils literal"><span class="pre">patch()</span></code> 方法可以很方便的在测试运行的上下文中替换对象，
并且当测试完成时候自动返回它们的原有状态。下面是对 <code class="docutils literal"><span class="pre">mymodule</span></code> 模块的测试代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">TestCase</span>
<span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="kn">import</span> <span class="n">patch</span>
<span class="kn">import</span> <span class="nn">mymodule</span>

<span class="k">class</span> <span class="nc">TestURLPrint</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_url_gets_to_stdout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">protocol</span> <span class="o">=</span> <span class="s1">&#39;http&#39;</span>
        <span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;www&#39;</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="s1">&#39;example.com&#39;</span>
        <span class="n">expected_url</span> <span class="o">=</span> <span class="s1">&#39;{}://{}.{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;sys.stdout&#39;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">StringIO</span><span class="p">())</span> <span class="k">as</span> <span class="n">fake_out</span><span class="p">:</span>
            <span class="n">mymodule</span><span class="o">.</span><span class="n">urlprint</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">fake_out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(),</span> <span class="n">expected_url</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">urlprint()</span></code> 函数接受三个参数，测试方法开始会先设置每一个参数的值。
<code class="docutils literal"><span class="pre">expected_url</span></code> 变量被设置成包含期望的输出的字符串。</p>
<p><code class="docutils literal"><span class="pre">unittest.mock.patch()</span></code> 函数被用作一个上下文管理器，使用 <code class="docutils literal"><span class="pre">StringIO</span></code> 对象来代替 <code class="docutils literal"><span class="pre">sys.stdout</span></code> .
<code class="docutils literal"><span class="pre">fake_out</span></code> 变量是在该进程中被创建的模拟对象。
在with语句中使用它可以执行各种检查。当with语句结束时，<code class="docutils literal"><span class="pre">patch</span></code> 会将所有东西恢复到测试开始前的状态。
有一点需要注意的是某些对Python的C扩展可能会忽略掉 <code class="docutils literal"><span class="pre">sys.stdout</span></code> 的配置二直接写入到标准输出中。
限于篇幅，本节不会涉及到这方面的讲解，它适用于纯Python代码。
如果你真的需要在C扩展中捕获I/O，你可以先打开一个临时文件，然后将标准输出重定向到该文件中。
更多关于捕获以字符串形式捕获I/O和 <code class="docutils literal"><span class="pre">StringIO</span></code> 对象请参阅5.6小节。</p>
</div>
</div>
<span id="document-c14/p02_patching_objects_in_unit_tests"></span><div class="section" id="id1">
<h3>14.2 在单元测试中给对象打补丁<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你写的单元测试中需要给指定的对象打补丁，
用来断言它们在测试中的期望行为（比如，断言被调用时的参数个数，访问指定的属性等）。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">unittest.mock.patch()</span></code> 函数可被用来解决这个问题。
<code class="docutils literal"><span class="pre">patch()</span></code> 还可被用作一个装饰器、上下文管理器或单独使用，尽管并不常见。
例如，下面是一个将它当做装饰器使用的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="kn">import</span> <span class="n">patch</span>
<span class="kn">import</span> <span class="nn">example</span>

<span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;example.func&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mock_func</span><span class="p">):</span>
    <span class="n">example</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>       <span class="c1"># Uses patched example.func</span>
    <span class="n">mock_func</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>它还可以被当做一个上下文管理器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;example.func&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_func</span><span class="p">:</span>
    <span class="n">example</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>      <span class="c1"># Uses patched example.func</span>
    <span class="n">mock_func</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，你还可以手动的使用它打补丁：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;example.func&#39;</span><span class="p">)</span>
<span class="n">mock_func</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">example</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">mock_func</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p>如果可能的话，你能够叠加装饰器和上下文管理器来给多个对象打补丁。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;example.func1&#39;</span><span class="p">)</span>
<span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;example.func2&#39;</span><span class="p">)</span>
<span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;example.func3&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test1</span><span class="p">(</span><span class="n">mock1</span><span class="p">,</span> <span class="n">mock2</span><span class="p">,</span> <span class="n">mock3</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">test2</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;example.patch1&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock1</span><span class="p">,</span> \
         <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;example.patch2&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock2</span><span class="p">,</span> \
         <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;example.patch3&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock3</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">patch()</span></code> 接受一个已存在对象的全路径名，将其替换为一个新的值。
原来的值会在装饰器函数或上下文管理器完成后自动恢复回来。
默认情况下，所有值会被 <code class="docutils literal"><span class="pre">MagicMock</span></code> 实例替代。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;__main__.x&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&lt;MagicMock name=&#39;x&#39; id=&#39;4314230032&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">42</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>不过，你可以通过给 <code class="docutils literal"><span class="pre">patch()</span></code> 提供第二个参数来将值替换成任何你想要的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;__main__.x&#39;</span><span class="p">,</span> <span class="s1">&#39;patched_value&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">patched_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">42</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>被用来作为替换值的 <code class="docutils literal"><span class="pre">MagicMock</span></code> 实例能够模拟可调用对象和实例。
他们记录对象的使用信息并允许你执行断言检查，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="kn">import</span> <span class="n">MagicMock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;.../unittest/mock.py&quot;</span>, line <span class="m">726</span>, in <span class="n">assert_called_with</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gr">AssertionError</span>: <span class="n">Expected call: mock(1, 2)</span>
<span class="go">Actual call: mock(1, 2, debug=True)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">&#39;HELLO&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">&#39;HELLO&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">m</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">called</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">split</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">)</span>
<span class="go">[&#39;hello&#39;, &#39;world&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">split</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;blah&#39;</span><span class="p">]</span>
<span class="go">&lt;MagicMock name=&#39;mock.__getitem__()&#39; id=&#39;4314412048&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="fm">__getitem__</span><span class="o">.</span><span class="n">called</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="fm">__getitem__</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="s1">&#39;blah&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一般来讲，这些操作会在一个单元测试中完成。例如，假设你已经有了像下面这样的函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># example.py</span>
<span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>
<span class="kn">import</span> <span class="nn">csv</span>

<span class="k">def</span> <span class="nf">dowprices</span><span class="p">():</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://finance.yahoo.com/d/quotes.csv?s=@^DJI&amp;f=sl1&#39;</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">prices</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span><span class="nb">float</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">rows</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">prices</span>
</pre></div>
</div>
<p>正常来讲，这个函数会使用 <code class="docutils literal"><span class="pre">urlopen()</span></code> 从Web上面获取数据并解析它。
在单元测试中，你可以给它一个预先定义好的数据集。下面是使用补丁操作的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="kn">import</span> <span class="n">patch</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">example</span>

<span class="n">sample_data</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s1">&quot;IBM&quot;,91.1</span><span class="se">\r</span><span class="s1"></span>
<span class="s1">&quot;AA&quot;,13.25</span><span class="se">\r</span><span class="s1"></span>
<span class="s1">&quot;MSFT&quot;,27.72</span><span class="se">\r</span><span class="s1"></span>
<span class="se">\r</span><span class="s1"></span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Tests</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;example.urlopen&#39;</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="n">sample_data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_dowprices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mock_urlopen</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">example</span><span class="o">.</span><span class="n">dowprices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">mock_urlopen</span><span class="o">.</span><span class="n">called</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span>
                         <span class="p">{</span><span class="s1">&#39;IBM&#39;</span><span class="p">:</span> <span class="mf">91.1</span><span class="p">,</span>
                          <span class="s1">&#39;AA&#39;</span><span class="p">:</span> <span class="mf">13.25</span><span class="p">,</span>
                          <span class="s1">&#39;MSFT&#39;</span> <span class="p">:</span> <span class="mf">27.72</span><span class="p">})</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>本例中，位于 <code class="docutils literal"><span class="pre">example</span></code> 模块中的 <code class="docutils literal"><span class="pre">urlopen()</span></code> 函数被一个模拟对象替代，
该对象会返回一个包含测试数据的 <code class="docutils literal"><span class="pre">ByteIO()</span></code>.</p>
<p>还有一点，在打补丁时我们使用了 <code class="docutils literal"><span class="pre">example.urlopen</span></code> 来代替 <code class="docutils literal"><span class="pre">urllib.request.urlopen</span></code> 。
当你创建补丁的时候，你必须使用它们在测试代码中的名称。
由于测试代码使用了 <code class="docutils literal"><span class="pre">from</span> <span class="pre">urllib.request</span> <span class="pre">import</span> <span class="pre">urlopen</span></code> ,那么 <code class="docutils literal"><span class="pre">dowprices()</span></code> 函数
中使用的 <code class="docutils literal"><span class="pre">urlopen()</span></code> 函数实际上就位于 <code class="docutils literal"><span class="pre">example</span></code> 模块了。</p>
<p>本节实际上只是对 <code class="docutils literal"><span class="pre">unittest.mock</span></code> 模块的一次浅尝辄止。
更多更高级的特性，请参考 <a class="reference external" href="http://docs.python.org/3/library/unittest.mock">官方文档</a></p>
</div>
</div>
<span id="document-c14/p03_testing_for_exceptional_conditions_in_unit_tests"></span><div class="section" id="id1">
<h3>14.3 在单元测试中测试异常情况<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想写个测试用例来准确的判断某个异常是否被抛出。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>对于异常的测试可使用 <code class="docutils literal"><span class="pre">assertRaises()</span></code> 方法。
例如，如果你想测试某个函数抛出了 <code class="docutils literal"><span class="pre">ValueError</span></code> 异常，像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="c1"># A simple function to illustrate</span>
<span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TestConversion</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_bad_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">parse_int</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你想测试异常的具体值，需要用到另外一种方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">errno</span>

<span class="k">class</span> <span class="nc">TestIO</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_file_not_found</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/file/not/found&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s1">&#39;IOError not raised&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">assertRaises()</span></code> 方法为测试异常存在性提供了一个简便方法。
一个常见的陷阱是手动去进行异常检测。比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestConversion</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_bad_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">parse_int</span><span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="ne">ValueError</span><span class="p">)</span>
</pre></div>
</div>
<p>这种方法的问题在于它很容易遗漏其他情况，比如没有任何异常抛出的时候。
那么你还得需要增加另外的检测过程，如下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestConversion</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_bad_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">parse_int</span><span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="ne">ValueError</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s1">&#39;ValueError not raised&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">assertRaises()</span></code> 方法会处理所有细节，因此你应该使用它。</p>
<p><code class="docutils literal"><span class="pre">assertRaises()</span></code> 的一个缺点是它测不了异常具体的值是多少。
为了测试异常值，可以使用 <code class="docutils literal"><span class="pre">assertRaisesRegex()</span></code> 方法，
它可同时测试异常的存在以及通过正则式匹配异常的字符串表示。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestConversion</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_bad_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;invalid literal .*&#39;</span><span class="p">,</span>
                                       <span class="n">parse_int</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">assertRaises()</span></code> 和 <code class="docutils literal"><span class="pre">assertRaisesRegex()</span></code>
还有一个容易忽略的地方就是它们还能被当做上下文管理器使用：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestConversion</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_bad_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;invalid literal .*&#39;</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">parse_int</span><span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>但你的测试涉及到多个执行步骤的时候这种方法就很有用了。</p>
</div>
</div>
<span id="document-c14/p04_logging_test_output_to_file"></span><div class="section" id="id1">
<h3>14.4 将测试输出用日志记录到文件中<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你希望将单元测试的输出写到到某个文件中去，而不是打印到标准输出。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>运行单元测试一个常见技术就是在测试文件底部加入下面这段代码片段：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>这样的话测试文件就是可执行的，并且会将运行测试的结果打印到标准输出上。
如果你想重定向输出，就需要像下面这样修改 <code class="docutils literal"><span class="pre">main()</span></code> 函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">loader</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestLoader</span><span class="p">()</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromModule</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">])</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">verbosity</span><span class="o">=</span><span class="n">verbosity</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;testing.out&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">main</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>本节感兴趣的部分并不是将测试结果重定向到一个文件中，
而是通过这样做向你展示了 <code class="docutils literal"><span class="pre">unittest</span></code> 模块中一些值得关注的内部工作原理。</p>
<p><code class="docutils literal"><span class="pre">unittest</span></code> 模块首先会组装一个测试套件。
这个测试套件包含了你定义的各种方法。一旦套件组装完成，它所包含的测试就可以被执行了。</p>
<p>这两步是分开的，<code class="docutils literal"><span class="pre">unittest.TestLoader</span></code> 实例被用来组装测试套件。
<code class="docutils literal"><span class="pre">loadTestsFromModule()</span></code> 是它定义的方法之一，用来收集测试用例。
它会为 <code class="docutils literal"><span class="pre">TestCase</span></code> 类扫描某个模块并将其中的测试方法提取出来。
如果你想进行细粒度的控制，
可以使用 <code class="docutils literal"><span class="pre">loadTestsFromTestCase()</span></code> 方法来从某个继承TestCase的类中提取测试方法。
<code class="docutils literal"><span class="pre">TextTestRunner</span></code> 类是一个测试运行类的例子，
这个类的主要用途是执行某个测试套件中包含的测试方法。
这个类跟执行 <code class="docutils literal"><span class="pre">unittest.main()</span></code> 函数所使用的测试运行器是一样的。
不过，我们在这里对它进行了一些列底层配置，包括输出文件和提升级别。
尽管本节例子代码很少，但是能指导你如何对 <code class="docutils literal"><span class="pre">unittest</span></code> 框架进行更进一步的自定义。
要想自定义测试套件的装配方式，你可以对 <code class="docutils literal"><span class="pre">TestLoader</span></code> 类执行更多的操作。
为了自定义测试运行，你可以构造一个自己的测试运行类来模拟 <code class="docutils literal"><span class="pre">TextTestRunner</span></code> 的功能。
而这些已经超出了本节的范围。<code class="docutils literal"><span class="pre">unittest</span></code> 模块的文档对底层实现原理有更深入的讲解，可以去看看。</p>
</div>
</div>
<span id="document-c14/p05_skip_or_anticipate_test_failures"></span><div class="section" id="id1">
<h3>14.5 忽略或期望测试失败<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想在单元测试中忽略或标记某些测试会按照预期运行失败。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">unittest</span></code> 模块有装饰器可用来控制对指定测试方法的处理，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">platform</span>

<span class="k">class</span> <span class="nc">Tests</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s1">&#39;skipped test&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s1">&#39;should have failed!&#39;</span><span class="p">)</span>

    <span class="nd">@unittest.skipIf</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;posix&#39;</span><span class="p">,</span> <span class="s1">&#39;Not supported on Unix&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">winreg</span>

    <span class="nd">@unittest.skipUnless</span><span class="p">(</span><span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Darwin&#39;</span><span class="p">,</span> <span class="s1">&#39;Mac specific test&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="nd">@unittest.expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_4</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你在Mac上运行这段代码，你会得到如下输出：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">testsample</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">v</span>
<span class="n">test_0</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">Tests</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_1</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">Tests</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;skipped test&#39;</span>
<span class="n">test_2</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">Tests</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;Not supported on Unix&#39;</span>
<span class="n">test_3</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">Tests</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_4</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">Tests</span><span class="p">)</span> <span class="o">...</span> <span class="n">expected</span> <span class="n">failure</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">5</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.002</span><span class="n">s</span>

<span class="n">OK</span> <span class="p">(</span><span class="n">skipped</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">expected</span> <span class="n">failures</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">skip()</span></code> 装饰器能被用来忽略某个你不想运行的测试。
<code class="docutils literal"><span class="pre">skipIf()</span></code> 和 <code class="docutils literal"><span class="pre">skipUnless()</span></code>
对于你只想在某个特定平台或Python版本或其他依赖成立时才运行测试的时候非常有用。
使用 <code class="docutils literal"><span class="pre">&#64;expected</span></code> 的失败装饰器来标记那些确定会失败的测试，并且对这些测试你不想让测试框架打印更多信息。</p>
<p>忽略方法的装饰器还可以被用来装饰整个测试类，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@unittest.skipUnless</span><span class="p">(</span><span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Darwin&#39;</span><span class="p">,</span> <span class="s1">&#39;Mac specific tests&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DarwinTests</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c14/p06_handle_multiple_exceptions"></span><div class="section" id="id1">
<h3>14.6 处理多个异常<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你有一个代码片段可能会抛出多个不同的异常，怎样才能不创建大量重复代码就能处理所有的可能异常呢？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你可以用单个代码块处理不同的异常，可以将它们放入一个元组中，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">client_obj</span><span class="o">.</span><span class="n">get_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="k">except</span> <span class="p">(</span><span class="n">URLError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">SocketTimeout</span><span class="p">):</span>
    <span class="n">client_obj</span><span class="o">.</span><span class="n">remove_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>在这个例子中，元祖中任何一个异常发生时都会执行 <code class="docutils literal"><span class="pre">remove_url()</span></code> 方法。
如果你想对其中某个异常进行不同的处理，可以将其放入另外一个 <code class="docutils literal"><span class="pre">except</span></code> 语句中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">client_obj</span><span class="o">.</span><span class="n">get_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="k">except</span> <span class="p">(</span><span class="n">URLError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
    <span class="n">client_obj</span><span class="o">.</span><span class="n">remove_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="k">except</span> <span class="n">SocketTimeout</span><span class="p">:</span>
    <span class="n">client_obj</span><span class="o">.</span><span class="n">handle_url_timeout</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>很多的异常会有层级关系，对于这种情况，你可能使用它们的一个基类来捕获所有的异常。例如，下面的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="k">except</span> <span class="p">(</span><span class="n">FileNotFoundError</span><span class="p">,</span> <span class="n">PermissionError</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>可以被重写为：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">OSError</span></code> 是 <code class="docutils literal"><span class="pre">FileNotFoundError</span></code> 和 <code class="docutils literal"><span class="pre">PermissionError</span></code> 异常的基类。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>尽管处理多个异常本身并没什么特殊的，不过你可以使用 <code class="docutils literal"><span class="pre">as</span></code> 关键字来获得被抛出异常的引用：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;File not found&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EACCES</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Permission denied&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Unexpected error: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span><span class="p">)</span>
</pre></div>
</div>
<p>这个例子中， <code class="docutils literal"><span class="pre">e</span></code> 变量指向一个被抛出的 <code class="docutils literal"><span class="pre">OSError</span></code> 异常实例。
这个在你想更进一步分析这个异常的时候会很有用，比如基于某个状态码来处理它。</p>
<p>同时还要注意的时候 <code class="docutils literal"><span class="pre">except</span></code> 语句是顺序检查的，第一个匹配的会执行。
你可以很容易的构造多个 <code class="docutils literal"><span class="pre">except</span></code> 同时匹配的情形，比如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;missing&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">FileNotFoundError</span>: <span class="n">[Errno 2] No such file or directory: &#39;missing&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;missing&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;It failed&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;File not found&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">It failed</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这里的 <code class="docutils literal"><span class="pre">FileNotFoundError</span></code> 语句并没有执行的原因是 <code class="docutils literal"><span class="pre">OSError</span></code> 更一般，它可匹配 <code class="docutils literal"><span class="pre">FileNotFoundError</span></code> 异常，
于是就是第一个匹配的。
在调试的时候，如果你对某个特定异常的类成层级关系不是很确定，
你可以通过查看该异常的 <code class="docutils literal"><span class="pre">__mro__</span></code> 属性来快速浏览。比如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="ne">FileNotFoundError</span><span class="o">.</span><span class="vm">__mro__</span>
<span class="go">(&lt;class &#39;FileNotFoundError&#39;&gt;, &lt;class &#39;OSError&#39;&gt;, &lt;class &#39;Exception&#39;&gt;,</span>
<span class="go"> &lt;class &#39;BaseException&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>上面列表中任何一个直到 <code class="docutils literal"><span class="pre">BaseException</span></code> 的类都能被用于 <code class="docutils literal"><span class="pre">except</span></code> 语句。</p>
</div>
</div>
<span id="document-c14/p07_catching_all_exceptions"></span><div class="section" id="id1">
<h3>14.7 捕获所有异常<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>怎样捕获代码中的所有异常？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>想要捕获所有的异常，可以直接捕获 <code class="docutils literal"><span class="pre">Exception</span></code> 即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
   <span class="o">...</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
   <span class="o">...</span>
   <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Reason:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>       <span class="c1"># Important!</span>
</pre></div>
</div>
<p>这个将会捕获除了 <code class="docutils literal"><span class="pre">SystemExit</span></code> 、 <code class="docutils literal"><span class="pre">KeyboardInterrupt</span></code> 和 <code class="docutils literal"><span class="pre">GeneratorExit</span></code> 之外的所有异常。
如果你还想捕获这三个异常，将 <code class="docutils literal"><span class="pre">Exception</span></code> 改成 <code class="docutils literal"><span class="pre">BaseException</span></code> 即可。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>捕获所有异常通常是由于程序员在某些复杂操作中并不能记住所有可能的异常。
如果你不是很细心的人，这也是编写不易调试代码的一个简单方法。</p>
<p>正因如此，如果你选择捕获所有异常，那么在某个地方（比如日志文件、打印异常到屏幕）打印确切原因就比较重要了。
如果你没有这样做，有时候你看到异常打印时可能摸不着头脑，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t parse&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>试着运行这个函数，结果如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_int</span><span class="p">(</span><span class="s1">&#39;n/a&#39;</span><span class="p">)</span>
<span class="go">Couldn&#39;t parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parse_int</span><span class="p">(</span><span class="s1">&#39;42&#39;</span><span class="p">)</span>
<span class="go">Couldn&#39;t parse</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这时候你就会挠头想：“这咋回事啊？” 假如你像下面这样重写这个函数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t parse&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Reason:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>这时候你能获取如下输出，指明了有个编程错误：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_int</span><span class="p">(</span><span class="s1">&#39;42&#39;</span><span class="p">)</span>
<span class="go">Couldn&#39;t parse</span>
<span class="go">Reason: global name &#39;v&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>很明显，你应该尽可能将异常处理器定义的精准一些。
不过，要是你必须捕获所有异常，确保打印正确的诊断信息或将异常传播出去，这样不会丢失掉异常。</p>
</div>
</div>
<span id="document-c14/p08_creating_custom_exceptions"></span><div class="section" id="id1">
<h3>14.8 创建自定义异常<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>在你构建的应用程序中，你想将底层异常包装成自定义的异常。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>创建新的异常很简单——定义新的类，让它继承自 <code class="docutils literal"><span class="pre">Exception</span></code> （或者是任何一个已存在的异常类型）。
例如，如果你编写网络相关的程序，你可能会定义一些类似如下的异常：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NetworkError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HostnameError</span><span class="p">(</span><span class="n">NetworkError</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">TimeoutError</span><span class="p">(</span><span class="n">NetworkError</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ProtocolError</span><span class="p">(</span><span class="n">NetworkError</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>然后用户就可以像通常那样使用这些异常了，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="k">except</span> <span class="n">TimeoutError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">ProtocolError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>自定义异常类应该总是继承自内置的 <code class="docutils literal"><span class="pre">Exception</span></code> 类，
或者是继承自那些本身就是从 <code class="docutils literal"><span class="pre">Exception</span></code> 继承而来的类。
尽管所有类同时也继承自 <code class="docutils literal"><span class="pre">BaseException</span></code> ，但你不应该使用这个基类来定义新的异常。
<code class="docutils literal"><span class="pre">BaseException</span></code> 是为系统退出异常而保留的，比如 <code class="docutils literal"><span class="pre">KeyboardInterrupt</span></code> 或 <code class="docutils literal"><span class="pre">SystemExit</span></code>
以及其他那些会给应用发送信号而退出的异常。
因此，捕获这些异常本身没什么意义。
这样的话，假如你继承 <code class="docutils literal"><span class="pre">BaseException</span></code>
可能会导致你的自定义异常不会被捕获而直接发送信号退出程序运行。</p>
<p>在程序中引入自定义异常可以使得你的代码更具可读性，能清晰显示谁应该阅读这个代码。
还有一种设计是将自定义异常通过继承组合起来。在复杂应用程序中，
使用基类来分组各种异常类也是很有用的。它可以让用户捕获一个范围很窄的特定异常，比如下面这样的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ProtocolError</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>你还能捕获更大范围的异常，就像下面这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="k">except</span> <span class="n">NetworkError</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果你想定义的新异常重写了 <code class="docutils literal"><span class="pre">__init__()</span></code> 方法，
确保你使用所有参数调用 <code class="docutils literal"><span class="pre">Exception.__init__()</span></code> ，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span>
</pre></div>
</div>
<p>看上去有点奇怪，不过Exception的默认行为是接受所有传递的参数并将它们以元组形式存储在 <code class="docutils literal"><span class="pre">.args</span></code> 属性中.
很多其他函数库和部分Python库默认所有异常都必须有 <code class="docutils literal"><span class="pre">.args</span></code> 属性，
因此如果你忽略了这一步，你会发现有些时候你定义的新异常不会按照期望运行。
为了演示 <code class="docutils literal"><span class="pre">.args</span></code> 的使用，考虑下下面这个使用内置的 <cite>RuntimeError`</cite> 异常的交互会话，
注意看raise语句中使用的参数个数是怎样的：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;It failed&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;It failed&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;It failed&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>

<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;It failed&#39;, 42, &#39;spam&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>关于创建自定义异常的更多信息，请参考`Python官方文档 &lt;<a class="reference external" href="https://docs.python.org/3/tutorial/errors.html">https://docs.python.org/3/tutorial/errors.html</a>&gt;`_</p>
</div>
</div>
<span id="document-c14/p09_raise_exception_in_response_to_another_exception"></span><div class="section" id="id1">
<h3>14.9 捕获异常后抛出另外的异常<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想捕获一个异常后抛出另外一个不同的异常，同时还得在异常回溯中保留两个异常的信息。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了链接异常，使用 <code class="docutils literal"><span class="pre">raise</span> <span class="pre">from</span></code> 语句来代替简单的 <code class="docutils literal"><span class="pre">raise</span></code> 语句。
它会让你同时保留两个异常的信息。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;A parsing error occurred&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">example</span>
<span class="gr">ValueError</span>: <span class="n">invalid literal for int() with base 10: &#39;N/A&#39;</span>
</pre></div>
</div>
<p>上面的异常是下面的异常产生的直接原因：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">example</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">A</span> <span class="n">parsing</span> <span class="n">error</span> <span class="n">occurred</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在回溯中可以看到，两个异常都被捕获。
要想捕获这样的异常，你可以使用一个简单的 <code class="docutils literal"><span class="pre">except</span></code> 语句。
不过，你还可以通过查看异常对象的 <code class="docutils literal"><span class="pre">__cause__</span></code> 属性来跟踪异常链。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">example</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;It didn&#39;t work:&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">__cause__</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Cause:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">__cause__</span><span class="p">)</span>
</pre></div>
</div>
<p>当在 <code class="docutils literal"><span class="pre">except</span></code> 块中又有另外的异常被抛出时会导致一个隐藏的异常链的出现。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">example2</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t parse:&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example2</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">example2</span>
<span class="gr">ValueError</span>: <span class="n">invalid literal for int() with base 10: &#39;N/A&#39;</span>
</pre></div>
</div>
<p>在处理上述异常的时候，另外一个异常发生了：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">example2</span>
<span class="ne">NameError</span><span class="p">:</span> <span class="k">global</span> <span class="n">name</span> <span class="s1">&#39;err&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这个例子中，你同时获得了两个异常的信息，但是对异常的解释不同。
这时候，<code class="docutils literal"><span class="pre">NameError</span></code> 异常被作为程序最终异常被抛出，而不是位于解析异常的直接回应中。</p>
<p>如果，你想忽略掉异常链，可使用 <code class="docutils literal"><span class="pre">raise</span> <span class="pre">from</span> <span class="pre">None</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">example3</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;A parsing error occurred&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">None</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">example3()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">5</span>, in <span class="n">example3</span>
<span class="gr">RuntimeError</span>: <span class="n">A parsing error occurred</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在设计代码时，在另外一个 <code class="docutils literal"><span class="pre">except</span></code> 代码块中使用 <code class="docutils literal"><span class="pre">raise</span></code> 语句的时候你要特别小心了。
大多数情况下，这种 <code class="docutils literal"><span class="pre">raise</span></code> 语句都应该被改成 <code class="docutils literal"><span class="pre">raise</span> <span class="pre">from</span></code> 语句。也就是说你应该使用下面这种形式：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
   <span class="o">...</span>
<span class="k">except</span> <span class="n">SomeException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
   <span class="k">raise</span> <span class="n">DifferentException</span><span class="p">()</span> <span class="kn">from</span> <span class="nn">e</span>
</pre></div>
</div>
<p>这样做的原因是你应该显示的将原因链接起来。
也就是说，<code class="docutils literal"><span class="pre">DifferentException</span></code> 是直接从 <code class="docutils literal"><span class="pre">SomeException</span></code> 衍生而来。
这种关系可以从回溯结果中看出来。</p>
<p>如果你像下面这样写代码，你仍然会得到一个链接异常，
不过这个并没有很清晰的说明这个异常链到底是内部异常还是某个未知的编程错误。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
   <span class="o">...</span>
<span class="k">except</span> <span class="n">SomeException</span><span class="p">:</span>
   <span class="k">raise</span> <span class="n">DifferentException</span><span class="p">()</span>
</pre></div>
</div>
<p>当你使用 <code class="docutils literal"><span class="pre">raise</span> <span class="pre">from</span></code> 语句的话，就很清楚的表明抛出的是第二个异常。</p>
<p>最后一个例子中隐藏异常链信息。
尽管隐藏异常链信息不利于回溯，同时它也丢失了很多有用的调试信息。
不过万事皆平等，有时候只保留适当的信息也是很有用的。</p>
</div>
</div>
<span id="document-c14/p10_reraising_the_last_exception"></span><div class="section" id="id1">
<h3>14.10 重新抛出被捕获的异常<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你在一个 <code class="docutils literal"><span class="pre">except</span></code> 块中捕获了一个异常，现在想重新抛出它。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>简单的使用一个单独的 <code class="docutils literal"><span class="pre">rasie</span></code> 语句即可，例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t work&quot;</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">raise</span>
<span class="gp">...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">example</span><span class="p">()</span>
<span class="go">Didn&#39;t work</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">example</span>
<span class="gr">ValueError</span>: <span class="n">invalid literal for int() with base 10: &#39;N/A&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>这个问题通常是当你需要在捕获异常后执行某个操作（比如记录日志、清理等），但是之后想将异常传播下去。
一个很常见的用法是在捕获所有异常的处理器中：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
   <span class="o">...</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
   <span class="c1"># Process exception information in some way</span>
   <span class="o">...</span>

   <span class="c1"># Propagate the exception</span>
   <span class="k">raise</span>
</pre></div>
</div>
</div>
</div>
<span id="document-c14/p11_issuing_warning_messages"></span><div class="section" id="id1">
<h3>14.11 输出警告信息<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你希望自己的程序能生成警告信息（比如废弃特性或使用问题）。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>要输出一个警告消息，可使用 <code class="docutils literal"><span class="pre">warning.warn()</span></code> 函数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">logfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
         <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;logfile argument deprecated&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">warn()</span></code> 的参数是一个警告消息和一个警告类，警告类有如下几种：UserWarning,  DeprecationWarning,
SyntaxWarning, RuntimeWarning, ResourceWarning, 或 FutureWarning.</p>
<p>对警告的处理取决于你如何运行解释器以及一些其他配置。
例如，如果你使用 <code class="docutils literal"><span class="pre">-W</span> <span class="pre">all</span></code> 选项去运行Python，你会得到如下的输出：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="o">-</span><span class="n">W</span> <span class="nb">all</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span>
<span class="n">example</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="ne">DeprecationWarning</span><span class="p">:</span> <span class="n">logfile</span> <span class="n">argument</span> <span class="ow">is</span> <span class="n">deprecated</span>
  <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;logfile argument is deprecated&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
</pre></div>
</div>
<p>通常来讲，警告会输出到标准错误上。如果你想讲警告转换为异常，可以使用 <code class="docutils literal"><span class="pre">-W</span> <span class="pre">error</span></code> 选项：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="o">-</span><span class="n">W</span> <span class="n">error</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">10</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;log.txt&#39;</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">func</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;logfile argument is deprecated&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
<span class="ne">DeprecationWarning</span><span class="p">:</span> <span class="n">logfile</span> <span class="n">argument</span> <span class="ow">is</span> <span class="n">deprecated</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在你维护软件，提示用户某些信息，但是又不需要将其上升为异常级别，那么输出警告信息就会很有用了。
例如，假设你准备修改某个函数库或框架的功能，你可以先为你要更改的部分输出警告信息，同时向后兼容一段时间。
你还可以警告用户一些对代码有问题的使用方式。</p>
<p>作为另外一个内置函数库的警告使用例子，下面演示了一个没有关闭文件就销毁它时产生的警告消息：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;always&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">f</span>
<span class="go">__main__:1: ResourceWarning: unclosed file &lt;_io.TextIOWrapper name=&#39;/etc/passwd&#39;</span>
<span class="go"> mode=&#39;r&#39; encoding=&#39;UTF-8&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>默认情况下，并不是所有警告消息都会出现。<code class="docutils literal"><span class="pre">-W</span></code> 选项能控制警告消息的输出。
<code class="docutils literal"><span class="pre">-W</span> <span class="pre">all</span></code> 会输出所有警告消息，<code class="docutils literal"><span class="pre">-W</span> <span class="pre">ignore</span></code> 忽略掉所有警告，<code class="docutils literal"><span class="pre">-W</span> <span class="pre">error</span></code> 将警告转换成异常。
另外一种选择，你还可以使用 <code class="docutils literal"><span class="pre">warnings.simplefilter()</span></code> 函数控制输出。
<code class="docutils literal"><span class="pre">always</span></code> 参数会让所有警告消息出现，<code class="docutils literal"><span class="pre">`ignore</span></code> 忽略调所有的警告，<code class="docutils literal"><span class="pre">error</span></code> 将警告转换成异常。</p>
<p>对于简单的生成警告消息的情况这些已经足够了。
<code class="docutils literal"><span class="pre">warnings</span></code> 模块对过滤和警告消息处理提供了大量的更高级的配置选项。
更多信息请参考 <a class="reference external" href="https://docs.python.org/3/library/warnings.html">Python文档</a></p>
</div>
</div>
<span id="document-c14/p12_debugging_basic_program_crashes"></span><div class="section" id="id1">
<h3>14.12 调试基本的程序崩溃错误<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序崩溃后该怎样去调试它？</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你的程序因为某个异常而崩溃，运行 <code class="docutils literal"><span class="pre">python3</span> <span class="pre">-i</span> <span class="pre">someprogram.py</span></code> 可执行简单的调试。
<code class="docutils literal"><span class="pre">-i</span></code> 选项可让程序结束后打开一个交互式shell。
然后你就能查看环境，例如，假设你有下面的代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># sample.py</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">10</span>

<span class="n">func</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>运行 <code class="docutils literal"><span class="pre">python3</span> <span class="pre">-i</span> <span class="pre">sample.py</span></code> 会有类似如下的输出：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="o">-</span><span class="n">i</span> <span class="n">sample</span><span class="o">.</span><span class="n">py</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;sample.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">func</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&quot;sample.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">10</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="n">Can</span><span class="s1">&#39;t convert &#39;</span><span class="nb">int</span><span class="s1">&#39; object to str implicitly</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">func</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你看不到上面这样的，可以在程序崩溃后打开Python的调试器。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pdb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdb</span><span class="o">.</span><span class="n">pm</span><span class="p">()</span>
<span class="go">&gt; sample.py(4)func()</span>
<span class="go">-&gt; return n + 10</span>
<span class="go">(Pdb) w</span>
<span class="go">  sample.py(6)&lt;module&gt;()</span>
<span class="go">-&gt; func(&#39;Hello&#39;)</span>
<span class="go">&gt; sample.py(4)func()</span>
<span class="go">-&gt; return n + 10</span>
<span class="go">(Pdb) print n</span>
<span class="go">&#39;Hello&#39;</span>
<span class="go">(Pdb) q</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你的代码所在的环境很难获取交互shell（比如在某个服务器上面），
通常可以捕获异常后自己打印跟踪信息。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;**** AN ERROR OCCURRED ****&#39;</span><span class="p">)</span>
    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
</pre></div>
</div>
<p>要是你的程序没有崩溃，而只是产生了一些你看不懂的结果，
你在感兴趣的地方插入一下 <code class="docutils literal"><span class="pre">print()</span></code> 语句也是个不错的选择。
不过，要是你打算这样做，有一些小技巧可以帮助你。
首先，<code class="docutils literal"><span class="pre">traceback.print_stack()</span></code> 函数会你程序运行到那个点的时候创建一个跟踪栈。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">traceback</span><span class="o">.</span><span class="n">print_stack</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 3, in sample</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 3, in sample</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 3, in sample</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 3, in sample</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 3, in sample</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 5, in sample</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外，你还可以像下面这样使用 <code class="docutils literal"><span class="pre">pdb.set_trace()</span></code> 在任何地方手动的启动调试器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pdb</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>当程序比较大而你想调试控制流程以及函数参数的时候这个就比较有用了。
例如，一旦调试器开始运行，你就能够使用 <code class="docutils literal"><span class="pre">print</span></code> 来观测变量值或敲击某个命令比如 <code class="docutils literal"><span class="pre">w</span></code> 来获取追踪信息。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>不要将调试弄的过于复杂化。一些简单的错误只需要观察程序堆栈信息就能知道了，
实际的错误一般是堆栈的最后一行。
你在开发的时候，也可以在你需要调试的地方插入一下 <code class="docutils literal"><span class="pre">print()</span></code>
函数来诊断信息（只需要最后发布的时候删除这些打印语句即可）。</p>
<p>调试器的一个常见用法是观测某个已经崩溃的函数中的变量。
知道怎样在函数崩溃后进入调试器是一个很有用的技能。</p>
<p>当你想解剖一个非常复杂的程序，底层的控制逻辑你不是很清楚的时候，
插入 <code class="docutils literal"><span class="pre">pdb.set_trace()</span></code> 这样的语句就很有用了。</p>
<p>实际上，程序会一直运行到碰到 <code class="docutils literal"><span class="pre">set_trace()</span></code> 语句位置，然后立马进入调试器。
然后你就可以做更多的事了。</p>
<p>如果你使用IDE来做Python开发，通常IDE都会提供自己的调试器来替代pdb。
更多这方面的信息可以参考你使用的IDE手册。</p>
</div>
</div>
<span id="document-c14/p13_profiling_and_timing_your_program"></span><div class="section" id="id1">
<h3>14.13 给你的程序做性能测试<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想测试你的程序运行所花费的时间并做性能测试。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你只是简单的想测试下你的程序整体花费的时间，
通常使用Unix时间函数就行了，比如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">time</span> <span class="n">python3</span> <span class="n">someprogram</span><span class="o">.</span><span class="n">py</span>
<span class="n">real</span> <span class="mi">0</span><span class="n">m13</span><span class="o">.</span><span class="mi">937</span><span class="n">s</span>
<span class="n">user</span> <span class="mi">0</span><span class="n">m12</span><span class="o">.</span><span class="mi">162</span><span class="n">s</span>
<span class="n">sys</span>  <span class="mi">0</span><span class="n">m0</span><span class="o">.</span><span class="mi">098</span><span class="n">s</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
<p>如果你还需要一个程序各个细节的详细报告，可以使用 <code class="docutils literal"><span class="pre">cProfile</span></code> 模块：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="o">-</span><span class="n">m</span> <span class="n">cProfile</span> <span class="n">someprogram</span><span class="o">.</span><span class="n">py</span>
         <span class="mi">859647</span> <span class="n">function</span> <span class="n">calls</span> <span class="ow">in</span> <span class="mf">16.016</span> <span class="n">CPU</span> <span class="n">seconds</span>

   <span class="n">Ordered</span> <span class="n">by</span><span class="p">:</span> <span class="n">standard</span> <span class="n">name</span>

   <span class="n">ncalls</span>  <span class="n">tottime</span>  <span class="n">percall</span>  <span class="n">cumtime</span>  <span class="n">percall</span> <span class="n">filename</span><span class="p">:</span><span class="n">lineno</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
   <span class="mi">263169</span>    <span class="mf">0.080</span>    <span class="mf">0.000</span>    <span class="mf">0.080</span>    <span class="mf">0.000</span> <span class="n">someprogram</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">16</span><span class="p">(</span><span class="n">frange</span><span class="p">)</span>
      <span class="mi">513</span>    <span class="mf">0.001</span>    <span class="mf">0.000</span>    <span class="mf">0.002</span>    <span class="mf">0.000</span> <span class="n">someprogram</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">30</span><span class="p">(</span><span class="n">generate_mandel</span><span class="p">)</span>
   <span class="mi">262656</span>    <span class="mf">0.194</span>    <span class="mf">0.000</span>   <span class="mf">15.295</span>    <span class="mf">0.000</span> <span class="n">someprogram</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">32</span><span class="p">(</span><span class="o">&lt;</span><span class="n">genexpr</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="mi">1</span>    <span class="mf">0.036</span>    <span class="mf">0.036</span>   <span class="mf">16.077</span>   <span class="mf">16.077</span> <span class="n">someprogram</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">4</span><span class="p">(</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">)</span>
   <span class="mi">262144</span>   <span class="mf">15.021</span>    <span class="mf">0.000</span>   <span class="mf">15.021</span>    <span class="mf">0.000</span> <span class="n">someprogram</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">4</span><span class="p">(</span><span class="n">in_mandelbrot</span><span class="p">)</span>
        <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">os</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">746</span><span class="p">(</span><span class="n">urandom</span><span class="p">)</span>
        <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">png</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">1056</span><span class="p">(</span><span class="n">_readable</span><span class="p">)</span>
        <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">png</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">1073</span><span class="p">(</span><span class="n">Reader</span><span class="p">)</span>
        <span class="mi">1</span>    <span class="mf">0.227</span>    <span class="mf">0.227</span>    <span class="mf">0.438</span>    <span class="mf">0.438</span> <span class="n">png</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">163</span><span class="p">(</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">)</span>
      <span class="mi">512</span>    <span class="mf">0.010</span>    <span class="mf">0.000</span>    <span class="mf">0.010</span>    <span class="mf">0.000</span> <span class="n">png</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">200</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
    <span class="o">...</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
<p>不过通常情况是介于这两个极端之间。比如你已经知道代码运行时在少数几个函数中花费了绝大部分时间。
对于这些函数的性能测试，可以使用一个简单的装饰器：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># timethis.py</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">timethis</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{}.{} : {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>要使用这个装饰器，只需要将其放置在你要进行性能测试的函数定义前即可，比如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@timethis</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="p">(</span><span class="mi">10000000</span><span class="p">)</span>
<span class="go">__main__.countdown : 0.803001880645752</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>要测试某个代码块运行时间，你可以定义一个上下文管理器，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">timeblock</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{} : {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
<p>下面是使用这个上下文管理器的例子：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">timeblock</span><span class="p">(</span><span class="s1">&#39;counting&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">=</span> <span class="mi">10000000</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="go">counting : 1.5551159381866455</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于测试很小的代码片段运行性能，使用 <code class="docutils literal"><span class="pre">timeit</span></code> 模块会很方便，例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">timeit</span> <span class="k">import</span> <span class="n">timeit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;math.sqrt(2)&#39;</span><span class="p">,</span> <span class="s1">&#39;import math&#39;</span><span class="p">)</span>
<span class="go">0.1432319980012835</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;sqrt(2)&#39;</span><span class="p">,</span> <span class="s1">&#39;from math import sqrt&#39;</span><span class="p">)</span>
<span class="go">0.10836604500218527</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">timeit</span></code> 会执行第一个参数中语句100万次并计算运行时间。
第二个参数是运行测试之前配置环境。如果你想改变循环执行次数，
可以像下面这样设置 <code class="docutils literal"><span class="pre">number</span></code> 参数的值：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;math.sqrt(2)&#39;</span><span class="p">,</span> <span class="s1">&#39;import math&#39;</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">10000000</span><span class="p">)</span>
<span class="go">1.434852126003534</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;sqrt(2)&#39;</span><span class="p">,</span> <span class="s1">&#39;from math import sqrt&#39;</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">10000000</span><span class="p">)</span>
<span class="go">1.0270336690009572</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>当执行性能测试的时候，需要注意的是你获取的结果都是近似值。
<code class="docutils literal"><span class="pre">time.perf_counter()</span></code> 函数会在给定平台上获取最高精度的计时值。
不过，它仍然还是基于时钟时间，很多因素会影响到它的精确度，比如机器负载。
如果你对于执行时间更感兴趣，使用 <code class="docutils literal"><span class="pre">time.process_time()</span></code> 来代替它。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="k">def</span> <span class="nf">timethis</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{}.{} : {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p>最后，如果你想进行更深入的性能分析，那么你需要详细阅读 <code class="docutils literal"><span class="pre">time</span></code> 、<code class="docutils literal"><span class="pre">timeit</span></code> 和其他相关模块的文档。
这样你可以理解和平台相关的差异以及一些其他陷阱。
还可以参考13.13小节中相关的一个创建计时器类的例子。</p>
</div>
</div>
<span id="document-c14/p14_make_your_program_run_faster"></span><div class="section" id="id1">
<h3>14.14 加速程序运行<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你的程序运行太慢，你想在不使用复杂技术比如C扩展或JIT编译器的情况下加快程序运行速度。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>关于程序优化的第一个准则是“不要优化”，第二个准则是“不要优化那些无关紧要的部分”。
如果你的程序运行缓慢，首先你得使用14.13小节的技术先对它进行性能测试找到问题所在。</p>
<p>通常来讲你会发现你得程序在少数几个热点地方花费了大量时间，
比如内存的数据处理循环。一旦你定位到这些点，你就可以使用下面这些实用技术来加速程序运行。</p>
<p><strong>使用函数</strong></p>
<p>很多程序员刚开始会使用Python语言写一些简单脚本。
当编写脚本的时候，通常习惯了写毫无结构的代码，比如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># somescript.py</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">csv</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
     <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>

         <span class="c1"># Some kind of processing</span>
         <span class="k">pass</span>
</pre></div>
</div>
<p>很少有人知道，像这样定义在全局范围的代码运行起来要比定义在函数中运行慢的多。
这种速度差异是由于局部变量和全局变量的实现方式（使用局部变量要更快些）。
因此，如果你想让程序运行更快些，只需要将脚本语句放入函数中即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># somescript.py</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">csv</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
         <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
             <span class="c1"># Some kind of processing</span>
             <span class="k">pass</span>

<span class="n">main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>速度的差异取决于实际运行的程序，不过根据经验，使用函数带来15-30%的性能提升是很常见的。</p>
<p><strong>尽可能去掉属性访问</strong></p>
<p>每一次使用点(.)操作符来访问属性的时候会带来额外的开销。
它会触发特定的方法，比如 <code class="docutils literal"><span class="pre">__getattribute__()</span></code> 和 <code class="docutils literal"><span class="pre">__getattr__()</span></code> ，这些方法会进行字典操作操作。</p>
<p>通常你可以使用 <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span></code> 这样的导入形式，以及使用绑定的方法。
假设你有如下的代码片段：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">compute_roots</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Test</span>
<span class="n">nums</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">compute_roots</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</pre></div>
</div>
<p>在我们机器上面测试的时候，这个程序花费了大概40秒。现在我们修改 <code class="docutils literal"><span class="pre">compute_roots()</span></code> 函数如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="k">def</span> <span class="nf">compute_roots</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">result_append</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">result_append</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>修改后的版本运行时间大概是29秒。唯一不同之处就是消除了属性访问。
用 <code class="docutils literal"><span class="pre">sqrt()</span></code> 代替了 <code class="docutils literal"><span class="pre">math.sqrt()</span></code> 。
<code class="docutils literal"><span class="pre">The</span> <span class="pre">result.append()</span></code> 方法被赋给一个局部变量 <code class="docutils literal"><span class="pre">result_append</span></code> ，然后在内部循环中使用它。</p>
<p>不过，这些改变只有在大量重复代码中才有意义，比如循环。
因此，这些优化也只是在某些特定地方才应该被使用。</p>
<p><strong>理解局部变量</strong></p>
<p>之前提过，局部变量会比全局变量运行速度快。
对于频繁访问的名称，通过将这些名称变成局部变量可以加速程序运行。
例如，看下之前对于 <code class="docutils literal"><span class="pre">compute_roots()</span></code> 函数进行修改后的版本：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">compute_roots</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">sqrt</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">result_append</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">result_append</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>在这个版本中，<code class="docutils literal"><span class="pre">sqrt</span></code> 从 <code class="docutils literal"><span class="pre">match</span></code> 模块被拿出并放入了一个局部变量中。
如果你运行这个代码，大概花费25秒（对于之前29秒又是一个改进）。
这个额外的加速原因是因为对于局部变量 <code class="docutils literal"><span class="pre">sqrt</span></code> 的查找要快于全局变量 <code class="docutils literal"><span class="pre">sqrt</span></code></p>
<p>对于类中的属性访问也同样适用于这个原理。
通常来讲，查找某个值比如 <code class="docutils literal"><span class="pre">self.name</span></code> 会比访问一个局部变量要慢一些。
在内部循环中，可以将某个需要频繁访问的属性放入到一个局部变量中。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Slower</span>
<span class="k">class</span> <span class="nc">SomeClass</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
             <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># Faster</span>
<span class="k">class</span> <span class="nc">SomeClass</span><span class="p">:</span>

    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
             <span class="n">op</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>避免不必要的抽象</strong></p>
<p>任何时候当你使用额外的处理层（比如装饰器、属性访问、描述器）去包装你的代码时，都会让程序运行变慢。
比如看下如下的这个类：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>
    <span class="nd">@y.setter</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>现在进行一个简单测试：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">timeit</span> <span class="k">import</span> <span class="n">timeit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;a.x&#39;</span><span class="p">,</span> <span class="s1">&#39;from __main__ import a&#39;</span><span class="p">)</span>
<span class="go">0.07817923510447145</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;a.y&#39;</span><span class="p">,</span> <span class="s1">&#39;from __main__ import a&#39;</span><span class="p">)</span>
<span class="go">0.35766440676525235</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以看到，访问属性y相比属性x而言慢的不止一点点，大概慢了4.5倍。
如果你在意性能的话，那么就需要重新审视下对于y的属性访问器的定义是否真的有必要了。
如果没有必要，就使用简单属性吧。
如果仅仅是因为其他编程语言需要使用getter/setter函数就去修改代码风格，这个真的没有必要。</p>
<p><strong>使用内置的容器</strong></p>
<p>内置的数据类型比如字符串、元组、列表、集合和字典都是使用C来实现的，运行起来非常快。
如果你想自己实现新的数据结构（比如链接列表、平衡树等），
那么要想在性能上达到内置的速度几乎不可能，因此，还是乖乖的使用内置的吧。</p>
<p><strong>避免创建不必要的数据结构或复制</strong></p>
<p>有时候程序员想显摆下，构造一些并没有必要的数据结构。例如，有人可能会像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">]</span>
<span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<p>也许这里的想法是首先将一些值收集到一个列表中，然后使用列表推导来执行操作。
不过，第一个列表完全没有必要，可以简单的像下面这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">]</span>
</pre></div>
</div>
<p>与此相关，还要注意下那些对Python的共享数据机制过于偏执的程序所写的代码。
有些人并没有很好的理解或信任Python的内存模型，滥用 <code class="docutils literal"><span class="pre">copy.deepcopy()</span></code> 之类的函数。
通常在这些代码中是可以去掉复制操作的。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在优化之前，有必要先研究下使用的算法。
选择一个复杂度为 O(n log n) 的算法要比你去调整一个复杂度为 O(n**2) 的算法所带来的性能提升要大得多。</p>
<p>如果你觉得你还是得进行优化，那么请从整体考虑。
作为一般准则，不要对程序的每一个部分都去优化,因为这些修改会导致代码难以阅读和理解。
你应该专注于优化产生性能瓶颈的地方，比如内部循环。</p>
<p>你还要注意微小优化的结果。例如考虑下面创建一个字典的两种方式：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="s1">&#39;AAPL&#39;</span><span class="p">,</span>
    <span class="s1">&#39;shares&#39;</span> <span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="s1">&#39;price&#39;</span> <span class="p">:</span> <span class="mf">534.22</span>
<span class="p">}</span>

<span class="n">b</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;AAPL&#39;</span><span class="p">,</span> <span class="n">shares</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mf">534.22</span><span class="p">)</span>
</pre></div>
</div>
<p>后面一种写法更简洁一些（你不需要在关键字上输入引号）。
不过，如果你将这两个代码片段进行性能测试对比时，会发现使用 <code class="docutils literal"><span class="pre">dict()</span></code> 的方式会慢了3倍。
看到这个，你是不是有冲动把所有使用 <code class="docutils literal"><span class="pre">dict()</span></code> 的代码都替换成第一种。
不够，聪明的程序员只会关注他应该关注的地方，比如内部循环。在其他地方，这点性能损失没有什么影响。</p>
<p>如果你的优化要求比较高，本节的这些简单技术满足不了，那么你可以研究下基于即时编译（JIT）技术的一些工具。
例如，PyPy工程是Python解释器的另外一种实现，它会分析你的程序运行并对那些频繁执行的部分生成本机机器码。
它有时候能极大的提升性能，通常可以接近C代码的速度。
不过可惜的是，到写这本书位置，PyPy还不能完全支持Python3.
因此，这个是你将来需要去研究的。你还可以考虑下Numba工程，
Numba是一个在你使用装饰器来选择Python函数进行优化时的动态编译器。
这些函数会使用LLVM被编译成本地机器码。它同样可以极大的提升性能。
但是，跟PyPy一样，它对于Python 3的支持现在还停留在实验阶段。</p>
<p>最后我引用John Ousterhout说过的话作为结尾：“最好的性能优化是从不工作到工作状态的迁移”。
直到你真的需要优化的时候再去考虑它。确保你程序正确的运行通常比让它运行更快要更重要一些（至少开始是这样的）.</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p15_c_extensions"></span><div class="section" id="c">
<h2>第十五章：C语言扩展<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h2>
<p>本章着眼于从Python访问C代码的问题。许多Python内置库是用C写的，
访问C是让Python的对现有库进行交互一个重要的组成部分。
这也是一个当你面临从Python 2 到 Python 3扩展代码的问题。
虽然Python提供了一个广泛的编程API，实际上有很多方法来处理C的代码。
相比试图给出对于每一个可能的工具或技术的详细参考，
我么采用的是是集中在一个小片段的C++代码，以及一些有代表性的例子来展示如何与代码交互。
这个目标是提供一系列的编程模板，有经验的程序员可以扩展自己的使用。</p>
<p>这里是我们将在大部分秘籍中工作的代码：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* sample.c */</span><span class="n">_method</span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>

<span class="cm">/* Compute the greatest common divisor */</span>
<span class="kt">int</span> <span class="n">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">%</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Test if (x0,y0) is in the Mandelbrot set or not */</span>
<span class="kt">int</span> <span class="n">in_mandel</span><span class="p">(</span><span class="kt">double</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">xtemp</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">xtemp</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">x0</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">y0</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xtemp</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Divide two numbers */</span>
<span class="kt">int</span> <span class="n">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">remainder</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">quot</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">remainder</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">quot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Average values in an array */</span>
<span class="kt">double</span> <span class="n">avg</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A C data structure */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Point</span><span class="p">;</span>

<span class="cm">/* Function involving a C data structure */</span>
<span class="kt">double</span> <span class="nf">distance</span><span class="p">(</span><span class="n">Point</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">Point</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">hypot</span><span class="p">(</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这段代码包含了多种不同的C语言编程特性。
首先，这里有很多函数比如 <code class="docutils literal"><span class="pre">gcd()</span></code> 和 <code class="docutils literal"><span class="pre">is_mandel()</span></code> 。
<code class="docutils literal"><span class="pre">divide()</span></code> 函数是一个返回多个值的C函数例子，其中有一个是通过指针参数的方式。
<code class="docutils literal"><span class="pre">avg()</span></code> 函数通过一个C数组执行数据聚集操作。<code class="docutils literal"><span class="pre">Point</span></code> 和 <code class="docutils literal"><span class="pre">distance()</span></code> 函数涉及到了C结构体。</p>
<p>对于接下来的所有小节，先假定上面的代码已经被写入了一个名叫“sample.c”的文件中，
然后它们的定义被写入一个名叫“sample.h”的头文件中，
并且被编译为一个库叫“libsample”，能被链接到其他C语言代码中。
编译和链接的细节依据系统的不同而不同，但是这个不是我们关注的。
如果你要处理C代码，我们假定这些基础的东西你都掌握了。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<span id="document-c15/p01_access_ccode_using_ctypes"></span><div class="section" id="ctypesc">
<h3>15.1 使用ctypes访问C代码<a class="headerlink" href="#ctypesc" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你有一些C函数已经被编译到共享库或DLL中。你希望可以使用纯Python代码调用这些函数，
而不用编写额外的C代码或使用第三方扩展工具。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>对于需要调用C代码的一些小的问题，通常使用Python标准库中的 <code class="docutils literal"><span class="pre">ctypes</span></code> 模块就足够了。
要使用 <code class="docutils literal"><span class="pre">ctypes</span></code> ，你首先要确保你要访问的C代码已经被编译到和Python解释器兼容
（同样的架构、字大小、编译器等）的某个共享库中了。
为了进行本节的演示，假设你有一个共享库名字叫 <code class="docutils literal"><span class="pre">libsample.so</span></code> ，里面的内容就是15章介绍部分那样。
另外还假设这个 <code class="docutils literal"><span class="pre">libsample.so</span></code> 文件被放置到位于 <code class="docutils literal"><span class="pre">sample.py</span></code> 文件相同的目录中了。</p>
<p>要访问这个函数库，你要先构建一个包装它的Python模块，如下这样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># sample.py</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Try to locate the .so file in the same directory as this file</span>
<span class="n">_file</span> <span class="o">=</span> <span class="s1">&#39;libsample.so&#39;</span>
<span class="n">_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">_file</span><span class="p">,)))</span>
<span class="n">_mod</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="n">_path</span><span class="p">)</span>

<span class="c1"># int gcd(int, int)</span>
<span class="n">gcd</span> <span class="o">=</span> <span class="n">_mod</span><span class="o">.</span><span class="n">gcd</span>
<span class="n">gcd</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>
<span class="n">gcd</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span>

<span class="c1"># int in_mandel(double, double, int)</span>
<span class="n">in_mandel</span> <span class="o">=</span> <span class="n">_mod</span><span class="o">.</span><span class="n">in_mandel</span>
<span class="n">in_mandel</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>
<span class="n">in_mandel</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span>

<span class="c1"># int divide(int, int, int *)</span>
<span class="n">_divide</span> <span class="o">=</span> <span class="n">_mod</span><span class="o">.</span><span class="n">divide</span>
<span class="n">_divide</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
<span class="n">_divide</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span>

<span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">rem</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
    <span class="n">quot</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rem</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">quot</span><span class="p">,</span><span class="n">rem</span><span class="o">.</span><span class="n">value</span>

<span class="c1"># void avg(double *, int n)</span>
<span class="c1"># Define a special type for the &#39;double *&#39; argument</span>
<span class="k">class</span> <span class="nc">DoubleArrayType</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">from_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="n">typename</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;from_&#39;</span> <span class="o">+</span> <span class="n">typename</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;from_&#39;</span> <span class="o">+</span> <span class="n">typename</span><span class="p">)(</span><span class="n">param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">param</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t convert </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">typename</span><span class="p">)</span>

    <span class="c1"># Cast from array.array objects</span>
    <span class="k">def</span> <span class="nf">from_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">typecode</span> <span class="o">!=</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;must be an array of doubles&#39;</span><span class="p">)</span>
        <span class="n">ptr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">buffer_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>

    <span class="c1"># Cast from lists/tuples</span>
    <span class="k">def</span> <span class="nf">from_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">))(</span><span class="o">*</span><span class="n">param</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="n">from_tuple</span> <span class="o">=</span> <span class="n">from_list</span>

    <span class="c1"># Cast from a numpy array</span>
    <span class="k">def</span> <span class="nf">from_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>

<span class="n">DoubleArray</span> <span class="o">=</span> <span class="n">DoubleArrayType</span><span class="p">()</span>
<span class="n">_avg</span> <span class="o">=</span> <span class="n">_mod</span><span class="o">.</span><span class="n">avg</span>
<span class="n">_avg</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">DoubleArray</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>
<span class="n">_avg</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>

<span class="k">def</span> <span class="nf">avg</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_avg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

<span class="c1"># struct Point { }</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)]</span>

<span class="c1"># double distance(Point *, Point *)</span>
<span class="n">distance</span> <span class="o">=</span> <span class="n">_mod</span><span class="o">.</span><span class="n">distance</span>
<span class="n">distance</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">Point</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">Point</span><span class="p">))</span>
<span class="n">distance</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
</pre></div>
</div>
<p>如果一切正常，你就可以加载并使用里面定义的C函数了。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span><span class="mi">42</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">in_mandel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">in_mandel</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="go">(5, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
<span class="go">4.242640687119285</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>本小节有很多值得我们详细讨论的地方。
首先是对于C和Python代码一起打包的问题，如果你在使用 <code class="docutils literal"><span class="pre">ctypes</span></code> 来访问编译后的C代码，
那么需要确保这个共享库放在 <code class="docutils literal"><span class="pre">sample.py</span></code> 模块同一个地方。
一种可能是将生成的 <code class="docutils literal"><span class="pre">.so</span></code> 文件放置在要使用它的Python代码同一个目录下。
我们在 <code class="docutils literal"><span class="pre">recipe—sample.py</span></code> 中使用 <code class="docutils literal"><span class="pre">__file__</span></code> 变量来查看它被安装的位置，
然后构造一个指向同一个目录中的 <code class="docutils literal"><span class="pre">libsample.so</span></code> 文件的路径。</p>
<p>如果C函数库被安装到其他地方，那么你就要修改相应的路径。
如果C函数库在你机器上被安装为一个标准库了，
那么可以使用 <code class="docutils literal"><span class="pre">ctypes.util.find_library()</span></code> 函数来查找：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="k">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s1">&#39;pthread&#39;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libpthread.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>
<span class="go">&#39;/usr/local/lib/libsample.so&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一旦你知道了C函数库的位置，那么就可以像下面这样使用 <code class="docutils literal"><span class="pre">ctypes.cdll.LoadLibrary()</span></code> 来加载它，
其中 <code class="docutils literal"><span class="pre">_path</span></code> 是标准库的全路径：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">_mod</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="n">_path</span><span class="p">)</span>
</pre></div>
</div>
<p>函数库被加载后，你需要编写几个语句来提取特定的符号并指定它们的类型。
就像下面这个代码片段一样：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># int in_mandel(double, double, int)</span>
<span class="n">in_mandel</span> <span class="o">=</span> <span class="n">_mod</span><span class="o">.</span><span class="n">in_mandel</span>
<span class="n">in_mandel</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>
<span class="n">in_mandel</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span>
</pre></div>
</div>
<p>在这段代码中，<code class="docutils literal"><span class="pre">.argtypes</span></code> 属性是一个元组，包含了某个函数的输入按时，
而 <code class="docutils literal"><span class="pre">.restype</span></code> 就是相应的返回类型。
<code class="docutils literal"><span class="pre">ctypes</span></code> 定义了大量的类型对象（比如c_double, c_int, c_short, c_float等），
代表了对应的C数据类型。如果你想让Python能够传递正确的参数类型并且正确的转换数据的话，
那么这些类型签名的绑定是很重要的一步。如果你没有这么做，不但代码不能正常运行，
还可能会导致整个解释器进程挂掉。
使用ctypes有一个麻烦点的地方是原生的C代码使用的术语可能跟Python不能明确的对应上来。
<code class="docutils literal"><span class="pre">divide()</span></code> 函数是一个很好的例子，它通过一个参数除以另一个参数返回一个结果值。
尽管这是一个很常见的C技术，但是在Python中却不知道怎样清晰的表达出来。
例如，你不能像下面这样简单的做：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">divide</span> <span class="o">=</span> <span class="n">_mod</span><span class="o">.</span><span class="n">divide</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divide</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ctypes.ArgumentError</span>: <span class="n">argument 3: &lt;class &#39;TypeError&#39;&gt;: expected LP_c_int</span>
<span class="go">instance instead of int</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>就算这个能正确的工作，它会违反Python对于整数的不可更改原则，并且可能会导致整个解释器陷入一个黑洞中。
对于涉及到指针的参数，你通常需要先构建一个相应的ctypes对象并像下面这样传进去：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在这里，一个 <code class="docutils literal"><span class="pre">ctypes.c_int</span></code> 实例被创建并作为一个指针被传进去。
跟普通Python整形不同的是，一个 <code class="docutils literal"><span class="pre">c_int</span></code> 对象是可以被修改的。
<code class="docutils literal"><span class="pre">.value</span></code> 属性可被用来获取或更改这个值。</p>
<p>对于那些不像Python的C调用，通常可以写一个小的包装函数。
这里，我们让 <code class="docutils literal"><span class="pre">divide()</span></code> 函数通过元组来返回两个结果：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># int divide(int, int, int *)</span>
<span class="n">_divide</span> <span class="o">=</span> <span class="n">_mod</span><span class="o">.</span><span class="n">divide</span>
<span class="n">_divide</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
<span class="n">_divide</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span>

<span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">rem</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
    <span class="n">quot</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">rem</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quot</span><span class="p">,</span> <span class="n">rem</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">avg()</span></code> 函数又是一个新的挑战。C代码期望接受到一个指针和一个数组的长度值。
但是，在Python中，我们必须考虑这个问题：数组是啥？它是一个列表？一个元组？
还是 <code class="docutils literal"><span class="pre">array</span></code> 模块中的一个数组？还是一个 <code class="docutils literal"><span class="pre">numpy</span></code> 数组？还是说所有都是？
实际上，一个Python“数组”有多种形式，你可能想要支持多种可能性。</p>
<p><code class="docutils literal"><span class="pre">DoubleArrayType</span></code> 演示了怎样处理这种情况。
在这个类中定义了一个单个方法 <code class="docutils literal"><span class="pre">from_param()</span></code> 。
这个方法的角色是接受一个单个参数然后将其向下转换为一个合适的ctypes对象
（本例中是一个 <code class="docutils literal"><span class="pre">ctypes.c_double</span></code> 的指针）。
在 <code class="docutils literal"><span class="pre">from_param()</span></code> 中，你可以做任何你想做的事。
参数的类型名被提取出来并被用于分发到一个更具体的方法中去。
例如，如果一个列表被传递过来，那么 <code class="docutils literal"><span class="pre">typename</span></code> 就是 <code class="docutils literal"><span class="pre">list</span></code> ，
然后 <code class="docutils literal"><span class="pre">from_list</span></code> 方法被调用。</p>
<p>对于列表和元组，<code class="docutils literal"><span class="pre">from_list</span></code> 方法将其转换为一个 <code class="docutils literal"><span class="pre">ctypes</span></code> 的数组对象。
这个看上去有点奇怪，下面我们使用一个交互式例子来将一个列表转换为一个 <code class="docutils literal"><span class="pre">ctypes</span></code> 数组：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))(</span><span class="o">*</span><span class="n">nums</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&lt;__main__.c_double_Array_3 object at 0x10069cd40&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">3.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于数组对象，<code class="docutils literal"><span class="pre">from_array()</span></code> 提取底层的内存指针并将其转换为一个 <code class="docutils literal"><span class="pre">ctypes</span></code> 指针对象。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array(&#39;d&#39;, [1.0, 2.0, 3.0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ptr_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">buffer_info</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ptr</span>
<span class="go">4298687200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>
<span class="go">&lt;__main__.LP_c_double object at 0x10069cd40&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">from_ndarray()</span></code> 演示了对于 <code class="docutils literal"><span class="pre">numpy</span></code> 数组的转换操作。
通过定义 <code class="docutils literal"><span class="pre">DoubleArrayType</span></code> 类并在 <code class="docutils literal"><span class="pre">avg()</span></code> 类型签名中使用它，
那么这个函数就能接受多个不同的类数组输入了：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">]))</span>
<span class="go">2.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>本节最后一部分向你演示了怎样处理一个简单的C结构。
对于结构体，你只需要像下面这样简单的定义一个类，包含相应的字段和类型即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)]</span>
</pre></div>
</div>
<p>一旦类被定义后，你就可以在类型签名中或者是需要实例化结构体的代码中使用它。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">x</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">y</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
<span class="go">4.242640687119285</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后一些小的提示：如果你想在Python中访问一些小的C函数，那么 <code class="docutils literal"><span class="pre">ctypes</span></code> 是一个很有用的函数库。
尽管如此，如果你想要去访问一个很大的库，那么可能就需要其他的方法了，比如 <code class="docutils literal"><span class="pre">Swig</span></code> (15.9节会讲到) 或
Cython（15.10节）。</p>
<p>对于大型库的访问有个主要问题，由于ctypes并不是完全自动化，
那么你就必须花费大量时间来编写所有的类型签名，就像例子中那样。
如果函数库够复杂，你还得去编写很多小的包装函数和支持类。
另外，除非你已经完全精通了所有底层的C接口细节，包括内存分配和错误处理机制，
通常一个很小的代码缺陷、访问越界或其他类似错误就能让Python程序奔溃。</p>
<p>作为 <code class="docutils literal"><span class="pre">ctypes</span></code> 的一个替代，你还可以考虑下CFFI。CFFI提供了很多类似的功能，
但是使用C语法并支持更多高级的C代码类型。
到写这本书为止，CFFI还是一个相对较新的工程，
但是它的流行度正在快速上升。
甚至还有在讨论在Python将来的版本中将它包含进去。因此，这个真的值得一看。</p>
</div>
</div>
<span id="document-c15/p02_write_simple_c_extension_module"></span><div class="section" id="c">
<h3>15.2 简单的C扩展模块<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想不依靠其他工具，直接使用Python的扩展API来编写一些简单的C扩展模块。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>对于简单的C代码，构建一个自定义扩展模块是很容易的。
作为第一步，你需要确保你的C代码有一个正确的头文件。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">sample</span><span class="o">.</span><span class="n">h</span> <span class="o">*/</span>

<span class="c1">#include &lt;math.h&gt;</span>

<span class="n">extern</span> <span class="nb">int</span> <span class="n">gcd</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">in_mandel</span><span class="p">(</span><span class="n">double</span> <span class="n">x0</span><span class="p">,</span> <span class="n">double</span> <span class="n">y0</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">divide</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">remainder</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">double</span> <span class="n">avg</span><span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">double</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Point</span><span class="p">;</span>

<span class="n">extern</span> <span class="n">double</span> <span class="n">distance</span><span class="p">(</span><span class="n">Point</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">Point</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
<p>通常来讲，这个头文件要对应一个已经被单独编译过的库。
有了这些，下面我们演示下编写扩展函数的一个简单例子：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#include &quot;Python.h&quot;
#include &quot;sample.h&quot;

/* int gcd(int, int) */
static PyObject *py_gcd(PyObject *self, PyObject *args) {
  int x, y, result;

  if (!PyArg_ParseTuple(args,&quot;ii&quot;, &amp;x, &amp;y)) {
    return NULL;
  }
  result = gcd(x,y);
  return Py_BuildValue(&quot;i&quot;, result);
}

/* int in_mandel(double, double, int) */
static PyObject *py_in_mandel(PyObject *self, PyObject *args) {
  double x0, y0;
  int n;
  int result;

  if (!PyArg_ParseTuple(args, &quot;ddi&quot;, &amp;x0, &amp;y0, &amp;n)) {
    return NULL;
  }
  result = in_mandel(x0,y0,n);
  return Py_BuildValue(&quot;i&quot;, result);
}

/* int divide(int, int, int *) */
static PyObject *py_divide(PyObject *self, PyObject *args) {
  int a, b, quotient, remainder;
  if (!PyArg_ParseTuple(args, &quot;ii&quot;, &amp;a, &amp;b)) {
    return NULL;
  }
  quotient = divide(a,b, &amp;remainder);
  return Py_BuildValue(&quot;(ii)&quot;, quotient, remainder);
}

/* Module method table */
static PyMethodDef SampleMethods[] = {
  {&quot;gcd&quot;,  py_gcd, METH_VARARGS, &quot;Greatest common divisor&quot;},
  {&quot;in_mandel&quot;, py_in_mandel, METH_VARARGS, &quot;Mandelbrot test&quot;},
  {&quot;divide&quot;, py_divide, METH_VARARGS, &quot;Integer division&quot;},
  { NULL, NULL, 0, NULL}
};

/* Module structure */
static struct PyModuleDef samplemodule = {
  PyModuleDef_HEAD_INIT,

  &quot;sample&quot;,           /* name of module */
  &quot;A sample module&quot;,  /* Doc string (may be NULL) */
  -1,                 /* Size of per-interpreter state or -1 */
  SampleMethods       /* Method table */
};

/* Module initialization function */
PyMODINIT_FUNC
PyInit_sample(void) {
  return PyModule_Create(&amp;samplemodule);
}
</pre></div>
</div>
<p>要绑定这个扩展模块，像下面这样创建一个 <code class="docutils literal"><span class="pre">setup.py</span></code> 文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># setup.py</span>
<span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span>
                  <span class="p">[</span><span class="s1">&#39;pysample.c&#39;</span><span class="p">],</span>
                  <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/some/dir&#39;</span><span class="p">],</span>
                  <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;FOO&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">)],</span>
                  <span class="n">undef_macros</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;BAR&#39;</span><span class="p">],</span>
                  <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/usr/local/lib&#39;</span><span class="p">],</span>
                  <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">]</span>
                  <span class="p">)</span>
        <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>为了构建最终的函数库，只需简单的使用 <code class="docutils literal"><span class="pre">python3</span> <span class="pre">buildlib.py</span> <span class="pre">build_ext</span> <span class="pre">--inplace</span></code> 命令即可：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">build_ext</span> <span class="o">--</span><span class="n">inplace</span>
<span class="n">running</span> <span class="n">build_ext</span>
<span class="n">building</span> <span class="s1">&#39;sample&#39;</span> <span class="n">extension</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">fno</span><span class="o">-</span><span class="n">strict</span><span class="o">-</span><span class="n">aliasing</span> <span class="o">-</span><span class="n">DNDEBUG</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">fwrapv</span> <span class="o">-</span><span class="n">O3</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">Wstrict</span><span class="o">-</span><span class="n">prototypes</span>
 <span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">python3</span><span class="o">.</span><span class="mi">3</span><span class="n">m</span> <span class="o">-</span><span class="n">c</span> <span class="n">pysample</span><span class="o">.</span><span class="n">c</span>
 <span class="o">-</span><span class="n">o</span> <span class="n">build</span><span class="o">/</span><span class="n">temp</span><span class="o">.</span><span class="n">macosx</span><span class="o">-</span><span class="mf">10.6</span><span class="o">-</span><span class="n">x86_64</span><span class="o">-</span><span class="mf">3.3</span><span class="o">/</span><span class="n">pysample</span><span class="o">.</span><span class="n">o</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">bundle</span> <span class="o">-</span><span class="n">undefined</span> <span class="n">dynamic_lookup</span>
<span class="n">build</span><span class="o">/</span><span class="n">temp</span><span class="o">.</span><span class="n">macosx</span><span class="o">-</span><span class="mf">10.6</span><span class="o">-</span><span class="n">x86_64</span><span class="o">-</span><span class="mf">3.3</span><span class="o">/</span><span class="n">pysample</span><span class="o">.</span><span class="n">o</span> \
 <span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span> <span class="o">-</span><span class="n">lsample</span> <span class="o">-</span><span class="n">o</span> <span class="n">sample</span><span class="o">.</span><span class="n">so</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
<p>如上所示，它会创建一个名字叫 <code class="docutils literal"><span class="pre">sample.so</span></code> 的共享库。当被编译后，你就能将它作为一个模块导入进来了：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">in_mandel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">in_mandel</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>

<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">(5, 2)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你是在Windows机器上面尝试这些步骤，可能会遇到各种环境和编译问题，你需要花更多点时间去配置。
Python的二进制分发通常使用了Microsoft  Visual Studio来构建。
为了让这些扩展能正常工作，你需要使用同样或兼容的工具来编译它。
参考相应的 <a class="reference external" href="https://docs.python.org/3/extending/windows.html">Python文档</a></p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在尝试任何手写扩展之前，最好能先参考下Python文档中的
<a class="reference external" href="https://docs.python.org/3/extending/index.html">扩展和嵌入Python解释器</a> .
Python的C扩展API很大，在这里整个去讲述它没什么实际意义。
不过对于最核心的部分还是可以讨论下的。</p>
<p>首先，在扩展模块中，你写的函数都是像下面这样的一个普通原型：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">py_func</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">PyObject</span></code> 是一个能表示任何Python对象的C数据类型。
在一个高级层面，一个扩展函数就是一个接受一个Python对象
（在 PyObject <a href="#id5"><span class="problematic" id="id6">*</span></a>args中）元组并返回一个新Python对象的C函数。
函数的 <code class="docutils literal"><span class="pre">self</span></code> 参数对于简单的扩展函数没有被使用到，
不过如果你想定义新的类或者是C中的对象类型的话就能派上用场了。比如如果扩展函数是一个类的一个方法，
那么 <code class="docutils literal"><span class="pre">self</span></code> 就能引用那个实例了。</p>
<p><code class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></code> 函数被用来将Python中的值转换成C中对应表示。
它接受一个指定输入格式的格式化字符串作为输入，比如“i”代表整数，“d”代表双精度浮点数，
同样还有存放转换后结果的C变量的地址。
如果输入的值不匹配这个格式化字符串，就会抛出一个异常并返回一个NULL值。
通过检查并返回NULL，一个合适的异常会在调用代码中被抛出。</p>
<p><code class="docutils literal"><span class="pre">Py_BuildValue()</span></code> 函数被用来根据C数据类型创建Python对象。
它同样接受一个格式化字符串来指定期望类型。
在扩展函数中，它被用来返回结果给Python。
<code class="docutils literal"><span class="pre">Py_BuildValue()</span></code> 的一个特性是它能构建更加复杂的对象类型，比如元组和字典。
在 <code class="docutils literal"><span class="pre">py_divide()</span></code> 代码中，一个例子演示了怎样返回一个元组。不过，下面还有一些实例：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="mi">34</span><span class="p">);</span>      <span class="o">//</span> <span class="n">Return</span> <span class="n">an</span> <span class="n">integer</span>
<span class="k">return</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>     <span class="o">//</span> <span class="n">Return</span> <span class="n">a</span> <span class="n">double</span>
<span class="k">return</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">);</span> <span class="o">//</span> <span class="n">Null</span><span class="o">-</span><span class="n">terminated</span> <span class="n">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="n">string</span>
<span class="k">return</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;(ii)&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="o">//</span> <span class="n">Tuple</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>在扩展模块底部，你会发现一个函数表，比如本节中的 <code class="docutils literal"><span class="pre">SampleMethods</span></code> 表。
这个表可以列出C函数、Python中使用的名字、文档字符串。
所有模块都需要指定这个表，因为它在模块初始化时要被使用到。</p>
<p>最后的函数 <code class="docutils literal"><span class="pre">PyInit_sample()</span></code> 是模块初始化函数，但该模块第一次被导入时执行。
这个函数的主要工作是在解释器中注册模块对象。</p>
<p>最后一个要点需要提出来，使用C函数来扩展Python要考虑的事情还有很多，本节只是一小部分。
（实际上，C API包含了超过500个函数）。你应该将本节当做是一个入门篇。
更多高级内容，可以看看 <code class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></code> 和 <code class="docutils literal"><span class="pre">Py_BuildValue()</span></code> 函数的文档，
然后进一步扩展开。</p>
</div>
</div>
<span id="document-c15/p03_write_extension_function_operate_on_arrays"></span><div class="section" id="id1">
<h3>15.3 编写扩展函数操作数组<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你想编写一个C扩展函数来操作数组，可能是被array模块或类似Numpy库所创建。
不过，你想让你的函数更加通用，而不是针对某个特定的库所生成的数组。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>为了能让接受和处理数组具有可移植性，你需要使用到 <cite>Buffer Protocol</cite> .
下面是一个手写的C扩展函数例子，
用来接受数组数据并调用本章开篇部分的 <code class="docutils literal"><span class="pre">avg(double</span> <span class="pre">*buf,</span> <span class="pre">int</span> <span class="pre">len)</span></code> 函数：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* Call double avg(double *, int) */
static PyObject *py_avg(PyObject *self, PyObject *args) {
  PyObject *bufobj;
  Py_buffer view;
  double result;
  /* Get the passed Python object */
  if (!PyArg_ParseTuple(args, &quot;O&quot;, &amp;bufobj)) {
    return NULL;
  }

  /* Attempt to extract buffer information from it */

  if (PyObject_GetBuffer(bufobj, &amp;view,
      PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) == -1) {
    return NULL;
  }

  if (view.ndim != 1) {
    PyErr_SetString(PyExc_TypeError, &quot;Expected a 1-dimensional array&quot;);
    PyBuffer_Release(&amp;view);
    return NULL;
  }

  /* Check the type of items in the array */
  if (strcmp(view.format,&quot;d&quot;) != 0) {
    PyErr_SetString(PyExc_TypeError, &quot;Expected an array of doubles&quot;);
    PyBuffer_Release(&amp;view);
    return NULL;
  }

  /* Pass the raw buffer and size to the C function */
  result = avg(view.buf, view.shape[0]);

  /* Indicate we&#39;re done working with the buffer */
  PyBuffer_Release(&amp;view);
  return Py_BuildValue(&quot;d&quot;, result);
}
</pre></div>
</div>
<p>下面我们演示下这个扩展函数是如何工作的：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">]))</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;list&#39; does not support the buffer interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">Expected an array of doubles</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">],[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">ndarray is not contiguous</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">Expected a 1-dimensional array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="go">2.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>将一个数组对象传给C函数可能是一个扩展函数做的最常见的事。
很多Python应用程序，从图像处理到科学计算，都是基于高性能的数组处理。
通过编写能接受并操作数组的代码，你可以编写很好的兼容这些应用程序的自定义代码，
而不是只能兼容你自己的代码。</p>
<p>代码的关键点在于 <code class="docutils literal"><span class="pre">PyBuffer_GetBuffer()</span></code> 函数。
给定一个任意的Python对象，它会试着去获取底层内存信息，它简单的抛出一个异常并返回-1.
传给 <code class="docutils literal"><span class="pre">PyBuffer_GetBuffer()</span></code> 的特殊标志给出了所需的内存缓冲类型。
例如，<code class="docutils literal"><span class="pre">PyBUF_ANY_CONTIGUOUS</span></code> 表示是一个联系的内存区域。</p>
<p>对于数组、字节字符串和其他类似对象而言，一个 <code class="docutils literal"><span class="pre">Py_buffer</span></code> 结构体包含了所有底层内存的信息。
它包含一个指向内存地址、大小、元素大小、格式和其他细节的指针。下面是这个结构体的定义：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">bufferinfo</span> <span class="p">{</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>              <span class="o">/*</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">buffer</span> <span class="n">memory</span> <span class="o">*/</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>          <span class="o">/*</span> <span class="n">Python</span> <span class="nb">object</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">owner</span> <span class="o">*/</span>
    <span class="n">Py_ssize_t</span> <span class="nb">len</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">Total</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">bytes</span> <span class="o">*/</span>
    <span class="n">Py_ssize_t</span> <span class="n">itemsize</span><span class="p">;</span>    <span class="o">/*</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">a</span> <span class="n">single</span> <span class="n">item</span> <span class="o">*/</span>
    <span class="nb">int</span> <span class="n">readonly</span><span class="p">;</span>           <span class="o">/*</span> <span class="n">Read</span><span class="o">-</span><span class="n">only</span> <span class="n">access</span> <span class="n">flag</span> <span class="o">*/</span>
    <span class="nb">int</span> <span class="n">ndim</span><span class="p">;</span>               <span class="o">/*</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">dimensions</span> <span class="o">*/</span>
    <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">;</span>           <span class="o">/*</span> <span class="n">struct</span> <span class="n">code</span> <span class="n">of</span> <span class="n">a</span> <span class="n">single</span> <span class="n">item</span> <span class="o">*/</span>
    <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">shape</span><span class="p">;</span>      <span class="o">/*</span> <span class="n">Array</span> <span class="n">containing</span> <span class="n">dimensions</span> <span class="o">*/</span>
    <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">strides</span><span class="p">;</span>    <span class="o">/*</span> <span class="n">Array</span> <span class="n">containing</span> <span class="n">strides</span> <span class="o">*/</span>
    <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">suboffsets</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Array</span> <span class="n">containing</span> <span class="n">suboffsets</span> <span class="o">*/</span>
<span class="p">}</span> <span class="n">Py_buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>本节中，我们只关注接受一个双精度浮点数数组作为参数。
要检查元素是否是一个双精度浮点数，只需验证 <code class="docutils literal"><span class="pre">format</span></code> 属性是不是字符串&#8221;d&#8221;.
这个也是 <code class="docutils literal"><span class="pre">struct</span></code> 模块用来编码二进制数据的。
通常来讲，<code class="docutils literal"><span class="pre">format</span></code> 可以是任何兼容 <code class="docutils literal"><span class="pre">struct</span></code> 模块的格式化字符串，
并且如果数组包含了C结构的话它可以包含多个值。
一旦我们已经确定了底层的缓存区信息，那只需要简单的将它传给C函数，然后会被当做是一个普通的C数组了。
实际上，我们不必担心是怎样的数组类型或者它是被什么库创建出来的。
这也是为什么这个函数能兼容 <code class="docutils literal"><span class="pre">array</span></code> 模块也能兼容 <code class="docutils literal"><span class="pre">numpy</span></code> 模块中的数组了。</p>
<p>在返回最终结果之前，底层的缓冲区视图必须使用 <code class="docutils literal"><span class="pre">PyBuffer_Release()</span></code> 释放掉。
之所以要这一步是为了能正确的管理对象的引用计数。</p>
<p>同样，本节也仅仅只是演示了接受数组的一个小的代码片段。
如果你真的要处理数组，你可能会碰到多维数据、大数据、不同的数据类型等等问题，
那么就得去学更高级的东西了。你需要参考官方文档来获取更多详细的细节。</p>
<p>如果你需要编写涉及到数组处理的多个扩展，那么通过Cython来实现会更容易下。参考15.11节。</p>
</div>
</div>
<span id="document-c15/p04_manage_opaque_pointers_in_c_extension_modules"></span><div class="section" id="c">
<h3>15.4 在C扩展模块中操作隐形指针<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你有一个扩展模块需要处理C结构体中的指针，
但是你又不想暴露结构体中任何内部细节给Python。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>隐形结构体可以很容易的通过将它们包装在胶囊对象中来处理。
考虑我们例子代码中的下列C代码片段：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">double</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Point</span><span class="p">;</span>

<span class="n">extern</span> <span class="n">double</span> <span class="n">distance</span><span class="p">(</span><span class="n">Point</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">Point</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
<p>下面是一个使用胶囊包装Point结构体和 <code class="docutils literal"><span class="pre">distance()</span></code> 函数的扩展代码实例：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* Destructor function for points */
static void del_Point(PyObject *obj) {
  free(PyCapsule_GetPointer(obj,&quot;Point&quot;));
}

/* Utility functions */
static Point *PyPoint_AsPoint(PyObject *obj) {
  return (Point *) PyCapsule_GetPointer(obj, &quot;Point&quot;);
}

static PyObject *PyPoint_FromPoint(Point *p, int must_free) {
  return PyCapsule_New(p, &quot;Point&quot;, must_free ? del_Point : NULL);
}

/* Create a new Point object */
static PyObject *py_Point(PyObject *self, PyObject *args) {

  Point *p;
  double x,y;
  if (!PyArg_ParseTuple(args,&quot;dd&quot;,&amp;x,&amp;y)) {
    return NULL;
  }
  p = (Point *) malloc(sizeof(Point));
  p-&gt;x = x;
  p-&gt;y = y;
  return PyPoint_FromPoint(p, 1);
}

static PyObject *py_distance(PyObject *self, PyObject *args) {
  Point *p1, *p2;
  PyObject *py_p1, *py_p2;
  double result;

  if (!PyArg_ParseTuple(args,&quot;OO&quot;,&amp;py_p1, &amp;py_p2)) {
    return NULL;
  }
  if (!(p1 = PyPoint_AsPoint(py_p1))) {
    return NULL;
  }
  if (!(p2 = PyPoint_AsPoint(py_p2))) {
    return NULL;
  }
  result = distance(p1,p2);
  return Py_BuildValue(&quot;d&quot;, result);
}
</pre></div>
</div>
<p>在Python中可以像下面这样来使用这些函数：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span>
<span class="go">&lt;capsule object &quot;Point&quot; at 0x1004ea330&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">&lt;capsule object &quot;Point&quot; at 0x1005d1db0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
<span class="go">2.8284271247461903</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>胶囊和C指针类似。在内部，它们获取一个通用指针和一个名称，可以使用 <code class="docutils literal"><span class="pre">PyCapsule_New()</span></code> 函数很容易的被创建。
另外，一个可选的析构函数能被绑定到胶囊上，用来在胶囊对象被垃圾回收时释放底层的内存。</p>
<p>要提取胶囊中的指针，可使用 <code class="docutils literal"><span class="pre">PyCapsule_GetPointer()</span></code> 函数并指定名称。
如果提供的名称和胶囊不匹配或其他错误出现，那么就会抛出异常并返回NULL。</p>
<p>本节中，一对工具函数—— <code class="docutils literal"><span class="pre">PyPoint_FromPoint()</span></code> 和 <code class="docutils literal"><span class="pre">PyPoint_AsPoint()</span></code>
被用来创建和从胶囊对象中提取Point实例。
在任何扩展函数中，我们会使用这些函数而不是直接使用胶囊对象。
这种设计使得我们可以很容易的应对将来对Point底下的包装的更改。
例如，如果你决定使用另外一个胶囊了，那么只需要更改这两个函数即可。</p>
<p>对于胶囊对象一个难点在于垃圾回收和内存管理。
<code class="docutils literal"><span class="pre">PyPoint_FromPoint()</span></code> 函数接受一个 <code class="docutils literal"><span class="pre">must_free</span></code> 参数，
用来指定当胶囊被销毁时底层Point * 结构体是否应该被回收。
在某些C代码中，归属问题通常很难被处理（比如一个Point结构体被嵌入到一个被单独管理的大结构体中）。
程序员可以使用 <code class="docutils literal"><span class="pre">extra</span></code> 参数来控制，而不是单方面的决定垃圾回收。
要注意的是和现有胶囊有关的析构器能使用 <code class="docutils literal"><span class="pre">PyCapsule_SetDestructor()</span></code> 函数来更改。</p>
<p>对于涉及到结构体的C代码而言，使用胶囊是一个比较合理的解决方案。
例如，有时候你并不关心暴露结构体的内部信息或者将其转换成一个完整的扩展类型。
通过使用胶囊，你可以在它上面放一个轻量级的包装器，然后将它传给其他的扩展函数。</p>
</div>
</div>
<span id="document-c15/p05_define_and_export_c_api_from_extension_modules"></span><div class="section" id="capi">
<h3>15.5 从扩展模块中定义和导出C的API<a class="headerlink" href="#capi" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你有一个C扩展模块，在内部定义了很多有用的函数，你想将它们导出为一个公共的C API供其他地方使用。
你想在其他扩展模块中使用这些函数，但是不知道怎样将它们链接起来，
并且通过C编译器/链接器来做看上去特别复杂（或者不可能做到）。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>本节主要问题是如何处理15.4小节中提到的Point对象。仔细回一下，在C代码中包含了如下这些工具函数：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* Destructor function for points */
static void del_Point(PyObject *obj) {

  free(PyCapsule_GetPointer(obj,&quot;Point&quot;));
}

/* Utility functions */
static Point *PyPoint_AsPoint(PyObject *obj) {
  return (Point *) PyCapsule_GetPointer(obj, &quot;Point&quot;);
}

static PyObject *PyPoint_FromPoint(Point *p, int must_free) {
  return PyCapsule_New(p, &quot;Point&quot;, must_free ? del_Point : NULL);
}
</pre></div>
</div>
<p>现在的问题是怎样将 <code class="docutils literal"><span class="pre">PyPoint_AsPoint()</span></code> 和 <code class="docutils literal"><span class="pre">Point_FromPoint()</span></code> 函数作为API导出，
这样其他扩展模块能使用并链接它们，比如如果你有其他扩展也想使用包装的Point对象。</p>
<p>要解决这个问题，首先要为 <code class="docutils literal"><span class="pre">sample</span></code> 扩展写个新的头文件名叫 <code class="docutils literal"><span class="pre">pysample.h</span></code> ，如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* pysample.h */
#include &quot;Python.h&quot;
#include &quot;sample.h&quot;
#ifdef __cplusplus
extern &quot;C&quot; {
#endif

/* Public API Table */
typedef struct {
  Point *(*aspoint)(PyObject *);
  PyObject *(*frompoint)(Point *, int);
} _PointAPIMethods;

#ifndef PYSAMPLE_MODULE
/* Method table in external module */
static _PointAPIMethods *_point_api = 0;

/* Import the API table from sample */
static int import_sample(void) {
  _point_api = (_PointAPIMethods *) PyCapsule_Import(&quot;sample._point_api&quot;,0);
  return (_point_api != NULL) ? 1 : 0;
}

/* Macros to implement the programming interface */
#define PyPoint_AsPoint(obj) (_point_api-&gt;aspoint)(obj)
#define PyPoint_FromPoint(obj) (_point_api-&gt;frompoint)(obj)
#endif

#ifdef __cplusplus
}
#endif
</pre></div>
</div>
<p>这里最重要的部分是函数指针表 <code class="docutils literal"><span class="pre">_PointAPIMethods</span></code> .
它会在导出模块时被初始化，然后导入模块时被查找到。
修改原始的扩展模块来填充表格并将它像下面这样导出：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* pysample.c */

#include &quot;Python.h&quot;
#define PYSAMPLE_MODULE
#include &quot;pysample.h&quot;

...
/* Destructor function for points */
static void del_Point(PyObject *obj) {
  printf(&quot;Deleting point\n&quot;);
  free(PyCapsule_GetPointer(obj,&quot;Point&quot;));
}

/* Utility functions */
static Point *PyPoint_AsPoint(PyObject *obj) {
  return (Point *) PyCapsule_GetPointer(obj, &quot;Point&quot;);
}

static PyObject *PyPoint_FromPoint(Point *p, int free) {
  return PyCapsule_New(p, &quot;Point&quot;, free ? del_Point : NULL);
}

static _PointAPIMethods _point_api = {
  PyPoint_AsPoint,
  PyPoint_FromPoint
};
...

/* Module initialization function */
PyMODINIT_FUNC
PyInit_sample(void) {
  PyObject *m;
  PyObject *py_point_api;

  m = PyModule_Create(&amp;samplemodule);
  if (m == NULL)
    return NULL;

  /* Add the Point C API functions */
  py_point_api = PyCapsule_New((void *) &amp;_point_api, &quot;sample._point_api&quot;, NULL);
  if (py_point_api) {
    PyModule_AddObject(m, &quot;_point_api&quot;, py_point_api);
  }
  return m;
}
</pre></div>
</div>
<p>最后，下面是一个新的扩展模块例子，用来加载并使用这些API函数：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* ptexample.c */

/* Include the header associated with the other module */
#include &quot;pysample.h&quot;

/* An extension function that uses the exported API */
static PyObject *print_point(PyObject *self, PyObject *args) {
  PyObject *obj;
  Point *p;
  if (!PyArg_ParseTuple(args,&quot;O&quot;, &amp;obj)) {
    return NULL;
  }

  /* Note: This is defined in a different module */
  p = PyPoint_AsPoint(obj);
  if (!p) {
    return NULL;
  }
  printf(&quot;%f %f\n&quot;, p-&gt;x, p-&gt;y);
  return Py_BuildValue(&quot;&quot;);
}

static PyMethodDef PtExampleMethods[] = {
  {&quot;print_point&quot;, print_point, METH_VARARGS, &quot;output a point&quot;},
  { NULL, NULL, 0, NULL}
};

static struct PyModuleDef ptexamplemodule = {
  PyModuleDef_HEAD_INIT,
  &quot;ptexample&quot;,           /* name of module */
  &quot;A module that imports an API&quot;,  /* Doc string (may be NULL) */
  -1,                 /* Size of per-interpreter state or -1 */
  PtExampleMethods       /* Method table */
};

/* Module initialization function */
PyMODINIT_FUNC
PyInit_ptexample(void) {
  PyObject *m;

  m = PyModule_Create(&amp;ptexamplemodule);
  if (m == NULL)
    return NULL;

  /* Import sample, loading its API functions */
  if (!import_sample()) {
    return NULL;
  }

  return m;
}
</pre></div>
</div>
<p>编译这个新模块时，你甚至不需要去考虑怎样将函数库或代码跟其他模块链接起来。
例如，你可以像下面这样创建一个简单的 <code class="docutils literal"><span class="pre">setup.py</span></code> 文件：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># setup.py</span>
<span class="kn">from</span> <span class="nn">distutils.core</span> <span class="k">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ptexample&#39;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;ptexample&#39;</span><span class="p">,</span>
                  <span class="p">[</span><span class="s1">&#39;ptexample.c&#39;</span><span class="p">],</span>
                  <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[],</span>  <span class="c1"># May need pysample.h directory</span>
                  <span class="p">)</span>
        <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>如果一切正常，你会发现你的新扩展函数能和定义在其他模块中的C API函数一起运行的很好。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span>
<span class="go">&lt;capsule object &quot;Point *&quot; at 0x1004ea330&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ptexample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ptexample</span><span class="o">.</span><span class="n">print_point</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="go">2.000000 3.000000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>本节基于一个前提就是，胶囊对象能获取任何你想要的对象的指针。
这样的话，定义模块会填充一个函数指针的结构体，创建一个指向它的胶囊，并在一个模块级属性中保存这个胶囊，
例如 <code class="docutils literal"><span class="pre">sample._point_api</span></code> .</p>
<p>其他模块能够在导入时获取到这个属性并提取底层的指针。
事实上，Python提供了 <code class="docutils literal"><span class="pre">PyCapsule_Import()</span></code> 工具函数，为了完成所有的步骤。
你只需提供属性的名字即可（比如sample._point_api），然后他就会一次性找到胶囊对象并提取出指针来。</p>
<p>在将被导出函数变为其他模块中普通函数时，有一些C编程陷阱需要指出来。
在 <code class="docutils literal"><span class="pre">pysample.h</span></code> 文件中，一个 <code class="docutils literal"><span class="pre">_point_api</span></code> 指针被用来指向在导出模块中被初始化的方法表。
一个相关的函数 <code class="docutils literal"><span class="pre">import_sample()</span></code> 被用来指向胶囊导入并初始化这个指针。
这个函数必须在任何函数被使用之前被调用。通常来讲，它会在模块初始化时被调用到。
最后，C的预处理宏被定义，被用来通过方法表去分发这些API函数。
用户只需要使用这些原始函数名称即可，不需要通过宏去了解其他信息。</p>
<p>最后，还有一个重要的原因让你去使用这个技术来链接模块——它非常简单并且可以使得各个模块很清晰的解耦。
如果你不想使用本机的技术，那你就必须使用共享库的高级特性和动态加载器来链接模块。
例如，将一个普通的API函数放入一个共享库并确保所有扩展模块链接到那个共享库。
这种方法确实可行，但是它相对繁琐，特别是在大型系统中。
本节演示了如何通过Python的普通导入机制和仅仅几个胶囊调用来将多个模块链接起来的魔法。
对于模块的编译，你只需要定义头文件，而不需要考虑函数库的内部细节。</p>
<p>更多关于利用C API来构造扩展模块的信息可以参考
<a class="reference external" href="http://docs.python.org/3/extending/extending.html">Python的文档</a></p>
</div>
</div>
<span id="document-c15/p06_calling_python_from_c"></span><div class="section" id="cpython">
<h3>15.6 从C语言中调用Python代码<a class="headerlink" href="#cpython" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想在C中安全的执行某个Python调用并返回结果给C。
例如，你想在C语言中使用某个Python函数作为一个回调。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>在C语言中调用Python非常简单，不过设计到一些小窍门。
下面的C代码告诉你怎样安全的调用：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#include &lt;Python.h&gt;

/* Execute func(x,y) in the Python interpreter.  The
   arguments and return result of the function must
   be Python floats */

double call_func(PyObject *func, double x, double y) {
  PyObject *args;
  PyObject *kwargs;
  PyObject *result = 0;
  double retval;

  /* Make sure we own the GIL */
  PyGILState_STATE state = PyGILState_Ensure();

  /* Verify that func is a proper callable */
  if (!PyCallable_Check(func)) {
    fprintf(stderr,&quot;call_func: expected a callable\n&quot;);
    goto fail;
  }
  /* Build arguments */
  args = Py_BuildValue(&quot;(dd)&quot;, x, y);
  kwargs = NULL;

  /* Call the function */
  result = PyObject_Call(func, args, kwargs);
  Py_DECREF(args);
  Py_XDECREF(kwargs);

  /* Check for Python exceptions (if any) */
  if (PyErr_Occurred()) {
    PyErr_Print();
    goto fail;
  }

  /* Verify the result is a float object */
  if (!PyFloat_Check(result)) {
    fprintf(stderr,&quot;call_func: callable didn&#39;t return a float\n&quot;);
    goto fail;
  }

  /* Create the return value */
  retval = PyFloat_AsDouble(result);
  Py_DECREF(result);

  /* Restore previous GIL state and return */
  PyGILState_Release(state);
  return retval;

fail:
  Py_XDECREF(result);
  PyGILState_Release(state);
  abort();   // Change to something more appropriate
}
</pre></div>
</div>
<p>要使用这个函数，你需要获取传递过来的某个已存在Python调用的引用。
有很多种方法可以让你这样做，
比如将一个可调用对象传给一个扩展模块或直接写C代码从已存在模块中提取出来。</p>
<p>下面是一个简单例子用来掩饰从一个嵌入的Python解释器中调用一个函数：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &lt;Python.h&gt;</span>

<span class="o">/*</span> <span class="n">Definition</span> <span class="n">of</span> <span class="n">call_func</span><span class="p">()</span> <span class="n">same</span> <span class="k">as</span> <span class="n">above</span> <span class="o">*/</span>
<span class="o">...</span>

<span class="o">/*</span> <span class="n">Load</span> <span class="n">a</span> <span class="n">symbol</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">module</span> <span class="o">*/</span>
<span class="n">PyObject</span> <span class="o">*</span><span class="n">import_name</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">PyObject</span> <span class="o">*</span><span class="n">u_name</span><span class="p">,</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
  <span class="n">u_name</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="n">modname</span><span class="p">);</span>
  <span class="n">module</span> <span class="o">=</span> <span class="n">PyImport_Import</span><span class="p">(</span><span class="n">u_name</span><span class="p">);</span>
  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">u_name</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">PyObject_GetAttrString</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">symbol</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">/*</span> <span class="n">Simple</span> <span class="n">embedding</span> <span class="n">example</span> <span class="o">*/</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">PyObject</span> <span class="o">*</span><span class="n">pow_func</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">x</span><span class="p">;</span>

  <span class="n">Py_Initialize</span><span class="p">();</span>
  <span class="o">/*</span> <span class="n">Get</span> <span class="n">a</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">the</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span> <span class="n">function</span> <span class="o">*/</span>
  <span class="n">pow_func</span> <span class="o">=</span> <span class="n">import_name</span><span class="p">(</span><span class="s2">&quot;math&quot;</span><span class="p">,</span><span class="s2">&quot;pow&quot;</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">Call</span> <span class="n">it</span> <span class="n">using</span> <span class="n">our</span> <span class="n">call_func</span><span class="p">()</span> <span class="n">code</span> <span class="o">*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">10.0</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%0.2f</span><span class="s2"> </span><span class="si">%0.2f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">call_func</span><span class="p">(</span><span class="n">pow_func</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mf">2.0</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="o">/*</span> <span class="n">Done</span> <span class="o">*/</span>
  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">pow_func</span><span class="p">);</span>
  <span class="n">Py_Finalize</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>要构建例子代码，你需要编译C并将它链接到Python解释器。
下面的Makefile可以教你怎样做（不过在你机器上面需要一些配置）。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">all</span><span class="p">::</span>
        <span class="n">cc</span> <span class="o">-</span><span class="n">g</span> <span class="n">embed</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">python3</span><span class="o">.</span><span class="mi">3</span><span class="n">m</span> \
          <span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">python3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">config</span><span class="o">-</span><span class="mf">3.3</span><span class="n">m</span> <span class="o">-</span><span class="n">lpython3</span><span class="o">.</span><span class="mi">3</span><span class="n">m</span>
</pre></div>
</div>
<p>编译并运行会产生类似下面的输出：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">0.00</span> <span class="mf">0.00</span>
<span class="mf">0.10</span> <span class="mf">0.01</span>
<span class="mf">0.20</span> <span class="mf">0.04</span>
<span class="mf">0.30</span> <span class="mf">0.09</span>
<span class="mf">0.40</span> <span class="mf">0.16</span>
<span class="o">...</span>
</pre></div>
</div>
<p>下面是一个稍微不同的例子，展示了一个扩展函数，
它接受一个可调用对象和其他参数，并将它们传递给 <code class="docutils literal"><span class="pre">call_func()</span></code> 来做测试：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* Extension function for testing the C-Python callback */
PyObject *py_call_func(PyObject *self, PyObject *args) {
  PyObject *func;

  double x, y, result;
  if (!PyArg_ParseTuple(args,&quot;Odd&quot;, &amp;func,&amp;x,&amp;y)) {
    return NULL;
  }
  result = call_func(func, x, y);
  return Py_BuildValue(&quot;d&quot;, result);
}
</pre></div>
</div>
<p>使用这个扩展函数，你要像下面这样测试它：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">call_func</span><span class="p">(</span><span class="n">add</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">7.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果你在C语言中调用Python，要记住最重要的是C语言会是主体。
也就是说，C语言负责构造参数、调用Python函数、检查异常、检查类型、提取返回值等。</p>
<p>作为第一步，你必须先有一个表示你将要调用的Python可调用对象。
这可以是一个函数、类、方法、内置方法或其他任意实现了 <code class="docutils literal"><span class="pre">__call__()</span></code> 操作的东西。
为了确保是可调用的，可以像下面的代码这样利用 <code class="docutils literal"><span class="pre">PyCallable_Check()</span></code> 做检查：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>double call_func(PyObject *func, double x, double y) {
  ...
  /* Verify that func is a proper callable */
  if (!PyCallable_Check(func)) {
    fprintf(stderr,&quot;call_func: expected a callable\n&quot;);
    goto fail;
  }
  ...
</pre></div>
</div>
<p>在C代码里处理错误你需要格外的小心。一般来讲，你不能仅仅抛出一个Python异常。
错误应该使用C代码方式来被处理。在这里，我们打算将对错误的控制传给一个叫 <code class="docutils literal"><span class="pre">abort()</span></code> 的错误处理器。
它会结束掉整个程序，在真实环境下面你应该要处理的更加优雅些（返回一个状态码）。
你要记住的是在这里C是主角，因此并没有跟抛出异常相对应的操作。
错误处理是你在编程时必须要考虑的事情。</p>
<p>调用一个函数相对来讲很简单——只需要使用 <code class="docutils literal"><span class="pre">PyObject_Call()</span></code> ，
传一个可调用对象给它、一个参数元组和一个可选的关键字字典。
要构建参数元组或字典，你可以使用 <code class="docutils literal"><span class="pre">Py_BuildValue()</span></code> ,如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">call_func</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
  <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">;</span>

  <span class="o">...</span>
  <span class="o">/*</span> <span class="n">Build</span> <span class="n">arguments</span> <span class="o">*/</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;(dd)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">kwargs</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">function</span> <span class="o">*/</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">PyObject_Call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">);</span>
  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
  <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">kwargs</span><span class="p">);</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>如果没有关键字参数，你可以传递NULL。当你要调用函数时，
需要确保使用了 <code class="docutils literal"><span class="pre">Py_DECREF()</span></code> 或者 <code class="docutils literal"><span class="pre">Py_XDECREF()</span></code> 清理参数。
第二个函数相对安全点，因为它允许传递NULL指针（直接忽略它），
这也是为什么我们使用它来清理可选的关键字参数。</p>
<p>调用万Python函数之后，你必须检查是否有异常发生。
<code class="docutils literal"><span class="pre">PyErr_Occurred()</span></code> 函数可被用来做这件事。
对对于异常的处理就有点麻烦了，由于是用C语言写的，你没有像Python那么的异常机制。
因此，你必须要设置一个异常状态码，打印异常信息或其他相应处理。
在这里，我们选择了简单的 <code class="docutils literal"><span class="pre">abort()</span></code> 来处理。另外，传统C程序员可能会直接让程序奔溃。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">/*</span> <span class="n">Check</span> <span class="k">for</span> <span class="n">Python</span> <span class="n">exceptions</span> <span class="p">(</span><span class="k">if</span> <span class="nb">any</span><span class="p">)</span> <span class="o">*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">PyErr_Print</span><span class="p">();</span>
  <span class="n">goto</span> <span class="n">fail</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">...</span>
<span class="n">fail</span><span class="p">:</span>
  <span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
  <span class="n">abort</span><span class="p">();</span>
</pre></div>
</div>
<p>从调用Python函数的返回值中提取信息通常要进行类型检查和提取值。
要这样做的话，你必须使用Python对象层中的函数。
在这里我们使用了 <code class="docutils literal"><span class="pre">PyFloat_Check()</span></code> 和 <code class="docutils literal"><span class="pre">PyFloat_AsDouble()</span></code> 来检查和提取Python浮点数。</p>
<p>最后一个问题是对于Python全局锁的管理。
在C语言中访问Python的时候，你需要确保GIL被正确的获取和释放了。
不然的话，可能会导致解释器返回错误数据或者直接奔溃。
调用 <code class="docutils literal"><span class="pre">PyGILState_Ensure()</span></code> 和 <code class="docutils literal"><span class="pre">PyGILState_Release()</span></code> 可以确保一切都能正常。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">call_func</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">double</span> <span class="n">retval</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">Make</span> <span class="n">sure</span> <span class="n">we</span> <span class="n">own</span> <span class="n">the</span> <span class="n">GIL</span> <span class="o">*/</span>
  <span class="n">PyGILState_STATE</span> <span class="n">state</span> <span class="o">=</span> <span class="n">PyGILState_Ensure</span><span class="p">();</span>
  <span class="o">...</span>
  <span class="o">/*</span> <span class="n">Code</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">Python</span> <span class="n">C</span> <span class="n">API</span> <span class="n">functions</span> <span class="o">*/</span>
  <span class="o">...</span>
  <span class="o">/*</span> <span class="n">Restore</span> <span class="n">previous</span> <span class="n">GIL</span> <span class="n">state</span> <span class="ow">and</span> <span class="k">return</span> <span class="o">*/</span>
  <span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="n">fail</span><span class="p">:</span>
  <span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
  <span class="n">abort</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一旦返回，<code class="docutils literal"><span class="pre">PyGILState_Ensure()</span></code> 可以确保调用线程独占Python解释器。
就算C代码运行于另外一个解释器不知道的线程也没事。
这时候，C代码可以自由的使用任何它想要的Python C-API 函数。
调用成功后，PyGILState_Release()被用来讲解释器恢复到原始状态。</p>
<p>要注意的是每一个 <code class="docutils literal"><span class="pre">PyGILState_Ensure()</span></code>
调用必须跟着一个匹配的 <code class="docutils literal"><span class="pre">PyGILState_Release()</span></code> 调用——即便有错误发生。
在这里，我们使用一个 <code class="docutils literal"><span class="pre">goto</span></code> 语句看上去是个可怕的设计，
但是实际上我们使用它来讲控制权转移给一个普通的exit块来执行相应的操作。
在 <code class="docutils literal"><span class="pre">fail:</span></code> 标签后面的代码和Python的 <code class="docutils literal"><span class="pre">fianl:</span></code> 块的用途是一样的。</p>
<p>如果你使用所有这些约定来编写C代码，包括对GIL的管理、异常检查和错误检查，
你会发现从C语言中调用Python解释器是可靠的——就算再复杂的程序，用到了高级编程技巧比如多线程都没问题。</p>
</div>
</div>
<span id="document-c15/p07_release_the_gil_in_c_extensions"></span><div class="section" id="c">
<h3>15.7 从C扩展中释放全局锁<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想让C扩展代码和Python解释器中的其他进程一起正确的执行，
那么你就需要去释放并重新获取全局解释器锁（GIL）。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>在C扩展代码中，GIL可以通过在代码中插入下面这样的宏来释放和重新获取：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &quot;Python.h&quot;</span>
<span class="o">...</span>

<span class="n">PyObject</span> <span class="o">*</span><span class="n">pyfunc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">...</span>
   <span class="n">Py_BEGIN_ALLOW_THREADS</span>
   <span class="o">//</span> <span class="n">Threaded</span> <span class="n">C</span> <span class="n">code</span><span class="o">.</span>  <span class="n">Must</span> <span class="ow">not</span> <span class="n">use</span> <span class="n">Python</span> <span class="n">API</span> <span class="n">functions</span>
   <span class="o">...</span>
   <span class="n">Py_END_ALLOW_THREADS</span>
   <span class="o">...</span>
   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>只有当你确保没有Python C API函数在C中执行的时候你才能安全的释放GIL。
GIL需要被释放的常见的场景是在计算密集型代码中需要在C数组上执行计算（比如在numpy中）
或者是要执行阻塞的I/O操作时（比如在一个文件描述符上读取或写入时）。</p>
<p>当GIL被释放后，其他Python线程才被允许在解释器中执行。
<code class="docutils literal"><span class="pre">Py_END_ALLOW_THREADS</span></code> 宏会阻塞执行直到调用线程重新获取了GIL。</p>
</div>
</div>
<span id="document-c15/p08_mix_threads_from_c_and_python"></span><div class="section" id="cpython">
<h3>15.8 C和Python中的线程混用<a class="headerlink" href="#cpython" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你有一个程序需要混合使用C、Python和线程，
有些线程是在C中创建的，超出了Python解释器的控制范围。
并且一些线程还使用了Python C API中的函数。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>如果你想将C、Python和线程混合在一起，你需要确保正确的初始化和管理Python的全局解释器锁（GIL）。
要想这样做，可以将下列代码放到你的C代码中并确保它在任何线程被创建之前被调用。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#include &lt;Python.h&gt;
  ...
  if (!PyEval_ThreadsInitialized()) {
    PyEval_InitThreads();
  }
  ...
</pre></div>
</div>
<p>对于任何调用Python对象或Python C API的C代码，确保你首先已经正确地获取和释放了GIL。
这可以用 <code class="docutils literal"><span class="pre">PyGILState_Ensure()</span></code> 和 <code class="docutils literal"><span class="pre">PyGILState_Release()</span></code> 来做到，如下所示：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">/*</span> <span class="n">Make</span> <span class="n">sure</span> <span class="n">we</span> <span class="n">own</span> <span class="n">the</span> <span class="n">GIL</span> <span class="o">*/</span>
<span class="n">PyGILState_STATE</span> <span class="n">state</span> <span class="o">=</span> <span class="n">PyGILState_Ensure</span><span class="p">();</span>

<span class="o">/*</span> <span class="n">Use</span> <span class="n">functions</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">interpreter</span> <span class="o">*/</span>
<span class="o">...</span>
<span class="o">/*</span> <span class="n">Restore</span> <span class="n">previous</span> <span class="n">GIL</span> <span class="n">state</span> <span class="ow">and</span> <span class="k">return</span> <span class="o">*/</span>
<span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>每次调用 <code class="docutils literal"><span class="pre">PyGILState_Ensure()</span></code> 都要相应的调用 <code class="docutils literal"><span class="pre">PyGILState_Release()</span></code> .</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在涉及到C和Python的高级程序中，很多事情一起做是很常见的——
可能是对C、Python、C线程、Python线程的混合使用。
只要你确保解释器被正确的初始化，并且涉及到解释器的C代码执行了正确的GIL管理，应该没什么问题。</p>
<p>要注意的是调用 <code class="docutils literal"><span class="pre">PyGILState_Ensure()</span></code> 并不会立刻抢占或中断解释器。
如果有其他代码正在执行，这个函数被中断知道那个执行代码释放掉GIL。
在内部，解释器会执行周期性的线程切换，因此如果其他线程在执行，
调用者最终还是可以运行的（尽管可能要先等一会）。</p>
</div>
</div>
<span id="document-c15/p09_wrap_c_code_with_swig"></span><div class="section" id="wsigc">
<h3>15.9 用WSIG包装C代码<a class="headerlink" href="#wsigc" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想让你写的C代码作为一个C扩展模块来访问，想通过使用 <a class="reference external" href="http://www.swig.org/">Swig包装生成器</a> 来完成。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>Swig通过解析C头文件并自动创建扩展代码来操作。
要使用它，你先要有一个C头文件。例如，我们示例的头文件如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">sample</span><span class="o">.</span><span class="n">h</span> <span class="o">*/</span>

<span class="c1">#include &lt;math.h&gt;</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">gcd</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">in_mandel</span><span class="p">(</span><span class="n">double</span> <span class="n">x0</span><span class="p">,</span> <span class="n">double</span> <span class="n">y0</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">divide</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">remainder</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">double</span> <span class="n">avg</span><span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">double</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Point</span><span class="p">;</span>

<span class="n">extern</span> <span class="n">double</span> <span class="n">distance</span><span class="p">(</span><span class="n">Point</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">Point</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
<p>一旦你有了这个头文件，下一步就是编写一个Swig&#8221;接口&#8221;文件。
按照约定，这些文件以&#8221;.i&#8221;后缀并且类似下面这样：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// sample.i - Swig interface
%module sample
%{
#include &quot;sample.h&quot;
%}

/* Customizations */
%extend Point {
    /* Constructor for Point objects */
    Point(double x, double y) {
        Point *p = (Point *) malloc(sizeof(Point));
        p-&gt;x = x;
        p-&gt;y = y;
        return p;
   };
};

/* Map int *remainder as an output argument */
%include typemaps.i
%apply int *OUTPUT { int * remainder };

/* Map the argument pattern (double *a, int n) to arrays */
%typemap(in) (double *a, int n)(Py_buffer view) {
  view.obj = NULL;
  if (PyObject_GetBuffer($input, &amp;view, PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) == -1) {
    SWIG_fail;
  }
  if (strcmp(view.format,&quot;d&quot;) != 0) {
    PyErr_SetString(PyExc_TypeError, &quot;Expected an array of doubles&quot;);
    SWIG_fail;
  }
  $1 = (double *) view.buf;
  $2 = view.len / sizeof(double);
}

%typemap(freearg) (double *a, int n) {
  if (view$argnum.obj) {
    PyBuffer_Release(&amp;view$argnum);
  }
}

/* C declarations to be included in the extension module */

extern int gcd(int, int);
extern int in_mandel(double x0, double y0, int n);
extern int divide(int a, int b, int *remainder);
extern double avg(double *a, int n);

typedef struct Point {
    double x,y;
} Point;

extern double distance(Point *p1, Point *p2);
</pre></div>
</div>
<p>一旦你写好了接口文件，就可以在命令行工具中调用Swig了：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">swig</span> <span class="o">-</span><span class="n">python</span> <span class="o">-</span><span class="n">py3</span> <span class="n">sample</span><span class="o">.</span><span class="n">i</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
<p>swig的输出就是两个文件，sample_wrap.c和sample.py。
后面的文件就是用户需要导入的。
而sample_wrap.c文件是需要被编译到名叫 <code class="docutils literal"><span class="pre">_sample</span></code> 的支持模块的C代码。
这个可以通过跟普通扩展模块一样的技术来完成。
例如，你创建了一个如下所示的 <code class="docutils literal"><span class="pre">setup.py</span></code> 文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># setup.py</span>
<span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span>
      <span class="n">py_modules</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sample.py&#39;</span><span class="p">],</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;_sample&#39;</span><span class="p">,</span>
                  <span class="p">[</span><span class="s1">&#39;sample_wrap.c&#39;</span><span class="p">],</span>
                  <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[],</span>
                  <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[],</span>

                  <span class="n">undef_macros</span> <span class="o">=</span> <span class="p">[],</span>
                  <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[],</span>
                  <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">]</span>
                  <span class="p">)</span>
        <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>要编译和测试，在setup.py上执行python3，如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>bash % python3 setup.py build_ext --inplace
running build_ext
building &#39;_sample&#39; extension
gcc -fno-strict-aliasing -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes
-I/usr/local/include/python3.3m -c sample_wrap.c
 -o build/temp.macosx-10.6-x86_64-3.3/sample_wrap.o
sample_wrap.c: In function ‘SWIG_InitializeModule’:
sample_wrap.c:3589: warning: statement with no effect
gcc -bundle -undefined dynamic_lookup build/temp.macosx-10.6-x86_64-3.3/sample.o
 build/temp.macosx-10.6-x86_64-3.3/sample_wrap.o -o _sample.so -lsample
bash %
</pre></div>
</div>
<p>如果一切正常的话，你会发现你就可以很方便的使用生成的C扩展模块了。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="go">[5, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
<span class="go">2.8284271247461903</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">x</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">y</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Swig是Python历史中构建扩展模块的最古老的工具之一。
Swig能自动化很多包装生成器的处理。</p>
<p>所有Swig接口都以类似下面这样的为开头：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">module</span> <span class="n">sample</span>
<span class="o">%</span><span class="p">{</span>
<span class="c1">#include &quot;sample.h&quot;</span>
<span class="o">%</span><span class="p">}</span>
</pre></div>
</div>
<p>这个仅仅只是声明了扩展模块的名称并指定了C头文件，
为了能让编译通过必须要包含这些头文件（位于 %{ 和 %} 的代码），
将它们之间复制粘贴到输出代码中，这也是你要放置所有包含文件和其他编译需要的定义的地方。</p>
<p>Swig接口的底下部分是一个C声明列表，你需要在扩展中包含它。
这通常从头文件中被复制。在我们的例子中，我们仅仅像下面这样直接粘贴在头文件中：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">module</span> <span class="n">sample</span>
<span class="o">%</span><span class="p">{</span>
<span class="c1">#include &quot;sample.h&quot;</span>
<span class="o">%</span><span class="p">}</span>
<span class="o">...</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">gcd</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">in_mandel</span><span class="p">(</span><span class="n">double</span> <span class="n">x0</span><span class="p">,</span> <span class="n">double</span> <span class="n">y0</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">divide</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">remainder</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">double</span> <span class="n">avg</span><span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">double</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Point</span><span class="p">;</span>

<span class="n">extern</span> <span class="n">double</span> <span class="n">distance</span><span class="p">(</span><span class="n">Point</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">Point</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
<p>有一点需要强调的是这些声明会告诉Swig你想要在Python模块中包含哪些东西。
通常你需要编辑这个声明列表或相应的修改下它。
例如，如果你不想某些声明被包含进来，你要将它从声明列表中移除掉。</p>
<p>使用Swig最复杂的地方是它能给C代码提供大量的自定义操作。
这个主题太大，这里无法展开，但是我们在本节还剩展示了一些自定义的东西。</p>
<p>第一个自定义是 <code class="docutils literal"><span class="pre">%extend</span></code> 指令允许方法被附加到已存在的结构体和类定义上。
我例子中，这个被用来添加一个Point结构体的构造器方法。
它可以让你像下面这样使用这个结构体：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果略过的话，Point对象就必须以更加复杂的方式来被创建：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Usage if %extend Point is omitted</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>第二个自定义涉及到对 <code class="docutils literal"><span class="pre">typemaps.i</span></code> 库的引入和 <code class="docutils literal"><span class="pre">%apply</span></code> 指令，
它会指示Swig参数签名 <code class="docutils literal"><span class="pre">int</span> <span class="pre">*remainder</span></code> 要被当做是输出值。
这个实际上是一个模式匹配规则。
在接下来的所有声明中，任何时候只要碰上 <code class="docutils literal"><span class="pre">int</span>&#160; <span class="pre">*remainder</span></code> ，他就会被作为输出。
这个自定义方法可以让 <code class="docutils literal"><span class="pre">divide()</span></code> 函数返回两个值。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="go">[5, 2]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>最后一个涉及到 <code class="docutils literal"><span class="pre">%typemap</span></code> 指令的自定义可能是这里展示的最高级的特性了。
一个typemap就是一个在输入中特定参数模式的规则。
在本节中，一个typemap被定义为匹配参数模式 <code class="docutils literal"><span class="pre">(double</span> <span class="pre">*a,</span> <span class="pre">int</span> <span class="pre">n)</span></code> .
在typemap内部是一个C代码片段，它告诉Swig怎样将一个Python对象转换为相应的C参数。
本节代码使用了Python的缓存协议去匹配任何看上去类似双精度数组的输入参数
（比如NumPy数组、array模块创建的数组等），更多请参考15.3小节。</p>
<p>在typemap代码内部，$1和$2这样的变量替换会获取typemap模式的C参数值
（比如$1映射为 <code class="docutils literal"><span class="pre">double</span> <span class="pre">*a</span></code> ）。$input指向一个作为输入的 <code class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code> 参数，
而 <code class="docutils literal"><span class="pre">$argnum</span></code> 就代表参数的个数。</p>
<p>编写和理解typemaps是使用Swig最基本的前提。
不仅是说代码更神秘，而且你需要理解Python C API和Swig和它交互的方式。
Swig文档有更多这方面的细节，可以参考下。</p>
<p>不过，如果你有大量的C代码需要被暴露为扩展模块。
Swig是一个非常强大的工具。关键点在于Swig是一个处理C声明的编译器，
通过强大的模式匹配和自定义组件，可以让你更改声明指定和类型处理方式。
更多信息请去查阅 <a class="reference external" href="http://www.swig.org/">Swig网站</a> ，
还有 <a class="reference external" href="http://www.swig.org/Doc2.0/Python.html">特定于Python的相关文档</a></p>
</div>
</div>
<span id="document-c15/p10_wrap_existing_c_code_with_cython"></span><div class="section" id="cythonc">
<h3>15.10 用Cython包装C代码<a class="headerlink" href="#cythonc" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想使用Cython来创建一个Python扩展模块，用来包装某个已存在的C函数库。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>使用Cython构建一个扩展模块看上去很手写扩展有些类似，
因为你需要创建很多包装函数。不过，跟前面不同的是，你不需要在C语言中做这些——代码看上去更像是Python。</p>
<p>作为准备，假设本章介绍部分的示例代码已经被编译到某个叫 <code class="docutils literal"><span class="pre">libsample</span></code> 的C函数库中了。
首先创建一个名叫 <code class="docutils literal"><span class="pre">csample.pxd</span></code> 的文件，如下所示：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># csample.pxd</span>
<span class="c1">#</span>
<span class="c1"># Declarations of &quot;external&quot; C functions and structures</span>

<span class="n">cdef</span> <span class="n">extern</span> <span class="kn">from</span> <span class="s2">&quot;sample.h&quot;</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">gcd</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">bint</span> <span class="n">in_mandel</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="nb">int</span> <span class="n">divide</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="p">)</span>
    <span class="n">double</span> <span class="n">avg</span><span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="n">nogil</span>

    <span class="n">ctypedef</span> <span class="n">struct</span> <span class="n">Point</span><span class="p">:</span>
         <span class="n">double</span> <span class="n">x</span>
         <span class="n">double</span> <span class="n">y</span>

    <span class="n">double</span> <span class="n">distance</span><span class="p">(</span><span class="n">Point</span> <span class="o">*</span><span class="p">,</span> <span class="n">Point</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>这个文件在Cython中的作用就跟C的头文件一样。
初始声明 <code class="docutils literal"><span class="pre">cdef</span>&#160; <span class="pre">extern</span>&#160; <span class="pre">from</span>&#160; <span class="pre">&quot;sample.h&quot;</span></code> 指定了所学的C头文件。
接下来的声明都是来自于那个头文件。文件名是 <code class="docutils literal"><span class="pre">csample.pxd</span></code> ，而不是 <code class="docutils literal"><span class="pre">sample.pxd</span></code> ——这点很重要。</p>
<p>下一步，创建一个名为 <code class="docutils literal"><span class="pre">sample.pyx</span></code> 的问题。
该文件会定义包装器，用来桥接Python解释器到 <code class="docutils literal"><span class="pre">csample.pxd</span></code> 中声明的C代码。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># sample.pyx</span>

<span class="c1"># Import the low-level C declarations</span>
<span class="n">cimport</span> <span class="n">csample</span>

<span class="c1"># Import some functionality from Python and the C stdlib</span>
<span class="kn">from</span> <span class="nn">cpython.pycapsule</span> <span class="n">cimport</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">libc.stdlib</span> <span class="n">cimport</span> <span class="n">malloc</span><span class="p">,</span> <span class="n">free</span>

<span class="c1"># Wrappers</span>
<span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">csample</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">in_mandel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">csample</span><span class="o">.</span><span class="n">in_mandel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">cdef</span> <span class="nb">int</span> <span class="n">rem</span>
    <span class="n">quot</span> <span class="o">=</span> <span class="n">csample</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quot</span><span class="p">,</span> <span class="n">rem</span>

<span class="k">def</span> <span class="nf">avg</span><span class="p">(</span><span class="n">double</span><span class="p">[:]</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">cdef</span><span class="p">:</span>
        <span class="nb">int</span> <span class="n">sz</span>
        <span class="n">double</span> <span class="n">result</span>

    <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
    <span class="k">with</span> <span class="n">nogil</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">csample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="o">&lt;</span><span class="n">double</span> <span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Destructor for cleaning up Point objects</span>
<span class="n">cdef</span> <span class="n">del_Point</span><span class="p">(</span><span class="nb">object</span> <span class="n">obj</span><span class="p">):</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">csample</span><span class="o">.</span><span class="n">Point</span> <span class="o">*&gt;</span> <span class="n">PyCapsule_GetPointer</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="s2">&quot;Point&quot;</span><span class="p">)</span>
    <span class="n">free</span><span class="p">(</span><span class="o">&lt;</span><span class="n">void</span> <span class="o">*&gt;</span> <span class="n">pt</span><span class="p">)</span>

<span class="c1"># Create a Point object and return as a capsule</span>
<span class="k">def</span> <span class="nf">Point</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span><span class="n">double</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">cdef</span> <span class="n">csample</span><span class="o">.</span><span class="n">Point</span> <span class="o">*</span><span class="n">p</span>
    <span class="n">p</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">csample</span><span class="o">.</span><span class="n">Point</span> <span class="o">*&gt;</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">csample</span><span class="o">.</span><span class="n">Point</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s2">&quot;No memory to make a Point&quot;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">PyCapsule_New</span><span class="p">(</span><span class="o">&lt;</span><span class="n">void</span> <span class="o">*&gt;</span><span class="n">p</span><span class="p">,</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span><span class="o">&lt;</span><span class="n">PyCapsule_Destructor</span><span class="o">&gt;</span><span class="n">del_Point</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="n">pt1</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">csample</span><span class="o">.</span><span class="n">Point</span> <span class="o">*&gt;</span> <span class="n">PyCapsule_GetPointer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="s2">&quot;Point&quot;</span><span class="p">)</span>
    <span class="n">pt2</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">csample</span><span class="o">.</span><span class="n">Point</span> <span class="o">*&gt;</span> <span class="n">PyCapsule_GetPointer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="s2">&quot;Point&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">csample</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span><span class="p">)</span>
</pre></div>
</div>
<p>该文件更多的细节部分会在讨论部分详细展开。
最后，为了构建扩展模块，像下面这样创建一个 <code class="docutils literal"><span class="pre">setup.py</span></code> 文件：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">distutils.extension</span> <span class="kn">import</span> <span class="n">Extension</span>
<span class="kn">from</span> <span class="nn">Cython.Distutils</span> <span class="kn">import</span> <span class="n">build_ext</span>

<span class="n">ext_modules</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span>

              <span class="p">[</span><span class="s1">&#39;sample.pyx&#39;</span><span class="p">],</span>
              <span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">],</span>
              <span class="n">library_dirs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">])]</span>
<span class="n">setup</span><span class="p">(</span>
  <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Sample extension module&#39;</span><span class="p">,</span>
  <span class="n">cmdclass</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;build_ext&#39;</span><span class="p">:</span> <span class="n">build_ext</span><span class="p">},</span>
  <span class="n">ext_modules</span> <span class="o">=</span> <span class="n">ext_modules</span>
<span class="p">)</span>
</pre></div>
</div>
<p>要构建我们测试的目标模块，像下面这样做：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">build_ext</span> <span class="o">--</span><span class="n">inplace</span>
<span class="n">running</span> <span class="n">build_ext</span>
<span class="n">cythoning</span> <span class="n">sample</span><span class="o">.</span><span class="n">pyx</span> <span class="n">to</span> <span class="n">sample</span><span class="o">.</span><span class="n">c</span>
<span class="n">building</span> <span class="s1">&#39;sample&#39;</span> <span class="n">extension</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">fno</span><span class="o">-</span><span class="n">strict</span><span class="o">-</span><span class="n">aliasing</span> <span class="o">-</span><span class="n">DNDEBUG</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">fwrapv</span> <span class="o">-</span><span class="n">O3</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">Wstrict</span><span class="o">-</span><span class="n">prototypes</span>
 <span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">python3</span><span class="o">.</span><span class="mi">3</span><span class="n">m</span> <span class="o">-</span><span class="n">c</span> <span class="n">sample</span><span class="o">.</span><span class="n">c</span>
 <span class="o">-</span><span class="n">o</span> <span class="n">build</span><span class="o">/</span><span class="n">temp</span><span class="o">.</span><span class="n">macosx</span><span class="o">-</span><span class="mf">10.6</span><span class="o">-</span><span class="n">x86_64</span><span class="o">-</span><span class="mf">3.3</span><span class="o">/</span><span class="n">sample</span><span class="o">.</span><span class="n">o</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">bundle</span> <span class="o">-</span><span class="n">undefined</span> <span class="n">dynamic_lookup</span> <span class="n">build</span><span class="o">/</span><span class="n">temp</span><span class="o">.</span><span class="n">macosx</span><span class="o">-</span><span class="mf">10.6</span><span class="o">-</span><span class="n">x86_64</span><span class="o">-</span><span class="mf">3.3</span><span class="o">/</span><span class="n">sample</span><span class="o">.</span><span class="n">o</span>
  <span class="o">-</span><span class="n">L</span><span class="o">.</span> <span class="o">-</span><span class="n">lsample</span> <span class="o">-</span><span class="n">o</span> <span class="n">sample</span><span class="o">.</span><span class="n">so</span>
<span class="n">bash</span> <span class="o">%</span>
</pre></div>
</div>
<p>如果一切顺利的话，你应该有了一个扩展模块 <code class="docutils literal"><span class="pre">sample.so</span></code> ，可在下面例子中使用：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">in_mandel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">400</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">in_mandel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">400</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="go">(4, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span>
<span class="go">&lt;capsule object &quot;Point&quot; at 0x1005d1e70&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">&lt;capsule object &quot;Point&quot; at 0x1005d1ea0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
<span class="go">2.8284271247461903</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>本节包含了很多前面所讲的高级特性，包括数组操作、包装隐形指针和释放GIL。
每一部分都会逐个被讲述到，但是我们最好能复习一下前面几小节。
在顶层，使用Cython是基于C之上。.pxd文件仅仅只包含C定义（类似.h文件），
.pyx文件包含了实现（类似.c文件）。<code class="docutils literal"><span class="pre">cimport</span></code> 语句被Cython用来导入.pxd文件中的定义。
它跟使用普通的加载Python模块的导入语句是不同的。</p>
<p>尽管 <cite>.pxd</cite> 文件包含了定义，但它们并不是用来自动创建扩展代码的。
因此，你还是要写包装函数。例如，就算 <code class="docutils literal"><span class="pre">csample.pxd</span></code> 文件声明了 <code class="docutils literal"><span class="pre">int</span> <span class="pre">gcd(int,</span> <span class="pre">int)</span></code> 函数，
你仍然需要在 <code class="docutils literal"><span class="pre">sample.pyx</span></code> 中为它写一个包装函数。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cimport</span> <span class="n">csample</span>

<span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">csample</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>对于简单的函数，你并不需要去做太多的时。
Cython会生成包装代码来正确的转换参数和返回值。
绑定到属性上的C数据类型是可选的。不过，如果你包含了它们，你可以另外做一些错误检查。
例如，如果有人使用负数来调用这个函数，会抛出一个异常：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;sample.pyx&quot;</span>, line <span class="m">7</span>, in <span class="n">sample.gcd (sample.c:1284)</span>
    <span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">x</span><span class="p">,</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">y</span><span class="p">):</span>
<span class="gr">OverflowError</span>: <span class="n">can&#39;t convert negative value to unsigned int</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想对包装函数做另外的检查，只需要使用另外的包装代码。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be &gt; 0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y must be &gt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">csample</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>在csample.pxd文件中的``in_mandel()`` 声明有个很有趣但是比较难理解的定义。
在这个文件中，函数被声明为然后一个bint而不是一个int。
它会让函数创建一个正确的Boolean值而不是简单的整数。
因此，返回值0表示False而1表示True。</p>
<p>在Cython包装器中，你可以选择声明C数据类型，也可以使用所有的常见Python对象。
对于 <code class="docutils literal"><span class="pre">divide()</span></code> 的包装器展示了这样一个例子，同时还有如何去处理一个指针参数。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="n">cdef</span> <span class="nb">int</span> <span class="n">rem</span>
    <span class="n">quot</span> <span class="o">=</span> <span class="n">csample</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="o">&amp;</span><span class="n">rem</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quot</span><span class="p">,</span> <span class="n">rem</span>
</pre></div>
</div>
<p>在这里，<code class="docutils literal"><span class="pre">rem</span></code> 变量被显示的声明为一个C整型变量。
当它被传入 <code class="docutils literal"><span class="pre">divide()</span></code> 函数的时候，<code class="docutils literal"><span class="pre">&amp;rem</span></code> 创建一个跟C一样的指向它的指针。
<code class="docutils literal"><span class="pre">avg()</span></code> 函数的代码演示了Cython更高级的特性。
首先 <code class="docutils literal"><span class="pre">def</span> <span class="pre">avg(double[:]</span> <span class="pre">a)</span></code> 声明了 <code class="docutils literal"><span class="pre">avg()</span></code> 接受一个一维的双精度内存视图。
最惊奇的部分是返回的结果函数可以接受任何兼容的数组对象，包括被numpy创建的。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">avg</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在此包装器中，<code class="docutils literal"><span class="pre">a.size0</span></code> 和 <code class="docutils literal"><span class="pre">&amp;a[0]</span></code> 分别引用数组元素个数和底层指针。
语法 <code class="docutils literal"><span class="pre">&lt;double</span> <span class="pre">*&gt;</span> <span class="pre">&amp;a[0]</span></code> 教你怎样将指针转换为不同的类型。
前提是C中的 <code class="docutils literal"><span class="pre">avg()</span></code> 接受一个正确类型的指针。
参考下一节关于Cython内存视图的更高级讲述。</p>
<p>除了处理通常的数组外，<code class="docutils literal"><span class="pre">avg()</span></code> 的这个例子还展示了如何处理全局解释器锁。
语句 <code class="docutils literal"><span class="pre">with</span> <span class="pre">nogil:</span></code> 声明了一个不需要GIL就能执行的代码块。
在这个块中，不能有任何的普通Python对象——只能使用被声明为 <code class="docutils literal"><span class="pre">cdef</span></code> 的对象和函数。
另外，外部函数必须现实的声明它们能不依赖GIL就能执行。
因此，在csample.pxd文件中，<code class="docutils literal"><span class="pre">avg()</span></code> 被声明为 <code class="docutils literal"><span class="pre">double</span> <span class="pre">avg(double</span> <span class="pre">*,</span> <span class="pre">int)</span> <span class="pre">nogil</span></code> .</p>
<p>对Point结构体的处理是一个挑战。本节使用胶囊对象将Point对象当做隐形指针来处理，这个在15.4小节介绍过。
要这样做的话，底层Cython代码稍微有点复杂。
首先，下面的导入被用来引入C函数库和Python C API中定义的函数：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cpython.pycapsule</span> <span class="n">cimport</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">libc.stdlib</span> <span class="n">cimport</span> <span class="n">malloc</span><span class="p">,</span> <span class="n">free</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal"><span class="pre">del_Point()</span></code> 和 <code class="docutils literal"><span class="pre">Point()</span></code> 使用这个功能来创建一个胶囊对象，
它会包装一个 <code class="docutils literal"><span class="pre">Point</span>&#160; <span class="pre">*</span></code> 指针。<code class="docutils literal"><span class="pre">cdef</span>&#160; <span class="pre">del_Point()</span></code> 将 <code class="docutils literal"><span class="pre">del_Point()</span></code> 声明为一个函数，
只能通过Cython访问，而不能从Python中访问。
因此，这个函数对外部是不可见的——它被用来当做一个回调函数来清理胶囊分配的内存。
函数调用比如 <code class="docutils literal"><span class="pre">PyCapsule_New()</span></code> 、<code class="docutils literal"><span class="pre">PyCapsule_GetPointer()</span></code>
直接来自Python C API并且以同样的方式被使用。</p>
<p><code class="docutils literal"><span class="pre">distance</span></code> 函数从 <code class="docutils literal"><span class="pre">Point()</span></code> 创建的胶囊对象中提取指针。
这里要注意的是你不需要担心异常处理。
如果一个错误的对象被传进来，<code class="docutils literal"><span class="pre">PyCapsule_GetPointer()</span></code> 会抛出一个异常，
但是Cython已经知道怎么查找到它，并将它从 <code class="docutils literal"><span class="pre">distance()</span></code> 传递出去。</p>
<p>处理Point结构体一个缺点是它的实现是不可见的。
你不能访问任何属性来查看它的内部。
这里有另外一种方法去包装它，就是定义一个扩展类型，如下所示：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># sample.pyx</span>

<span class="n">cimport</span> <span class="n">csample</span>
<span class="kn">from</span> <span class="nn">libc.stdlib</span> <span class="n">cimport</span> <span class="n">malloc</span><span class="p">,</span> <span class="n">free</span>
<span class="o">...</span>

<span class="n">cdef</span> <span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">cdef</span> <span class="n">csample</span><span class="o">.</span><span class="n">Point</span> <span class="o">*</span><span class="n">_c_point</span>
    <span class="k">def</span> <span class="nf">__cinit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">double</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_point</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">csample</span><span class="o">.</span><span class="n">Point</span> <span class="o">*&gt;</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">csample</span><span class="o">.</span><span class="n">Point</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_point</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_point</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">__dealloc__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">free</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_point</span><span class="p">)</span>

    <span class="nb">property</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_point</span><span class="o">.</span><span class="n">x</span>
        <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c_point</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nb">property</span> <span class="n">y</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_point</span><span class="o">.</span><span class="n">y</span>
        <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c_point</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">Point</span> <span class="n">p1</span><span class="p">,</span> <span class="n">Point</span> <span class="n">p2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">csample</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">_c_point</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">_c_point</span><span class="p">)</span>
</pre></div>
</div>
<p>在这里，cdif类 <code class="docutils literal"><span class="pre">Point</span></code> 将Point声明为一个扩展类型。
类属性 <code class="docutils literal"><span class="pre">cdef</span> <span class="pre">csample.Point</span> <span class="pre">*_c_point</span></code> 声明了一个实例变量，
拥有一个指向底层Point结构体的指针。
<code class="docutils literal"><span class="pre">__cinit__()</span></code> 和 <code class="docutils literal"><span class="pre">__dealloc__()</span></code> 方法通过 <code class="docutils literal"><span class="pre">malloc()</span></code> 和 <code class="docutils literal"><span class="pre">free()</span></code> 创建并销毁底层C结构体。
x和y属性的声明让你获取和设置底层结构体的属性值。
<code class="docutils literal"><span class="pre">distance()</span></code> 的包装器还可以被修改，使得它能接受 <code class="docutils literal"><span class="pre">Point</span></code> 扩展类型实例作为参数，
而传递底层指针给C函数。</p>
<p>做了这个改变后，你会发现操作Point对象就显得更加自然了：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span>
<span class="go">&lt;sample.Point object at 0x100447288&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">&lt;sample.Point object at 0x1004472a0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">x</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">y</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
<span class="go">2.8284271247461903</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>本节已经演示了很多Cython的核心特性，你可以以此为基准来构建更多更高级的包装。
不过，你最好先去阅读下官方文档来了解更多信息。</p>
<p>接下来几节还会继续演示一些Cython的其他特性。</p>
</div>
</div>
<span id="document-c15/p11_use_cython_to_write_high_performance_array_operation"></span><div class="section" id="cython">
<h3>15.11 用Cython写高性能的数组操作<a class="headerlink" href="#cython" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你要写高性能的操作来自NumPy之类的数组计算函数。
你已经知道了Cython这样的工具会让它变得简单，但是并不确定该怎样去做。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>作为一个例子，下面的代码演示了一个Cython函数，用来修整一个简单的一维双精度浮点数数组中元素的值。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># sample.pyx (Cython)</span>

<span class="n">cimport</span> <span class="n">cython</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">cpdef</span> <span class="n">clip</span><span class="p">(</span><span class="n">double</span><span class="p">[:]</span> <span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="nb">min</span><span class="p">,</span> <span class="n">double</span> <span class="nb">max</span><span class="p">,</span> <span class="n">double</span><span class="p">[:]</span> <span class="n">out</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Clip the values in a to be between min and max. Result in out</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">min</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min must be &lt;= max&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input and output arrays must be the same size&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span>
        <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>要编译和构建这个扩展，你需要一个像下面这样的 <code class="docutils literal"><span class="pre">setup.py</span></code> 文件
（使用 <code class="docutils literal"><span class="pre">python3</span> <span class="pre">setup.py</span> <span class="pre">build_ext</span> <span class="pre">--inplace</span></code> 来构建它）：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">distutils.extension</span> <span class="kn">import</span> <span class="n">Extension</span>
<span class="kn">from</span> <span class="nn">Cython.Distutils</span> <span class="kn">import</span> <span class="n">build_ext</span>

<span class="n">ext_modules</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span>
              <span class="p">[</span><span class="s1">&#39;sample.pyx&#39;</span><span class="p">])</span>
<span class="p">]</span>

<span class="n">setup</span><span class="p">(</span>
  <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Sample app&#39;</span><span class="p">,</span>
  <span class="n">cmdclass</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;build_ext&#39;</span><span class="p">:</span> <span class="n">build_ext</span><span class="p">},</span>
  <span class="n">ext_modules</span> <span class="o">=</span> <span class="n">ext_modules</span>
<span class="p">)</span>
</pre></div>
</div>
<p>你会发现结果函数确实对数组进行的修正，并且可以适用于多种类型的数组对象。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># array module example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>

<span class="go">array(&#39;d&#39;, [1.0, -3.0, 4.0, 7.0, 2.0, 0.0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array(&#39;d&#39;, [1.0, 1.0, 4.0, 4.0, 2.0, 1.0])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># numpy example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([-9.55546017,  7.45599334,  0.69248932, ...,  0.69583148,</span>
<span class="go">       -3.86290931,  2.37266888])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([ 0.,  0.,  0., ...,  0.,  0.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([-5.        ,  5.        ,  0.69248932, ...,  0.69583148,</span>
<span class="go">       -3.86290931,  2.37266888])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">-5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">5.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你还会发现运行生成结果非常的快。
下面我们将本例和numpy中的已存在的 <code class="docutils literal"><span class="pre">clip()</span></code> 函数做一个性能对比：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;numpy.clip(b,-5,5,c)&#39;</span><span class="p">,</span><span class="s1">&#39;from __main__ import b,c,numpy&#39;</span><span class="p">,</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">8.093049556000551</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;sample.clip(b,-5,5,c)&#39;</span><span class="p">,</span><span class="s1">&#39;from __main__ import b,c,sample&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">3.760528204000366</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正如你看到的，它要快很多——这是一个很有趣的结果，因为NumPy版本的核心代码还是用C语言写的。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>本节利用了Cython类型的内存视图，极大的简化了数组的操作。
<code class="docutils literal"><span class="pre">cpdef</span> <span class="pre">clip()</span></code> 声明了 <code class="docutils literal"><span class="pre">clip()</span></code> 同时为C级别函数以及Python级别函数。
在Cython中，这个是很重要的，因为它表示此函数调用要比其他Cython函数更加高效
（比如你想在另外一个不同的Cython函数中调用clip()）。</p>
<p>类型参数 <code class="docutils literal"><span class="pre">double[:]</span> <span class="pre">a</span></code> 和 <code class="docutils literal"><span class="pre">double[:]</span> <span class="pre">out</span></code> 声明这些参数为一维的双精度数组。
作为输入，它们会访问任何实现了内存视图接口的数组对象，这个在PEP 3118有详细定义。
包括了NumPy中的数组和内置的array库。</p>
<p>当你编写生成结果为数组的代码时，你应该遵循上面示例那样设置一个输出参数。
它会将创建输出数组的责任给调用者，不需要知道你操作的数组的具体细节
（它仅仅假设数组已经准备好了，只需要做一些小的检查比如确保数组大小是正确的）。
在像NumPy之类的库中，使用 <code class="docutils literal"><span class="pre">numpy.zeros()</span></code> 或 <code class="docutils literal"><span class="pre">numpy.zeros_like()</span></code>
创建输出数组相对而言比较容易。另外，要创建未初始化数组，
你可以使用 <code class="docutils literal"><span class="pre">numpy.empty()</span></code> 或 <code class="docutils literal"><span class="pre">numpy.empty_like()</span></code> .
如果你想覆盖数组内容作为结果的话选择这两个会比较快点。</p>
<p>你你的函数实现中，你只需要简单的通过下标运算和数组查找（比如a[i],out[i]等）来编写代码操作数组。
Cython会负责为你生成高效的代码。</p>
<p><code class="docutils literal"><span class="pre">clip()</span></code> 定义之前的两个装饰器可以优化下性能。
<code class="docutils literal"><span class="pre">&#64;cython.boundscheck(False)</span></code> 省去了所有的数组越界检查，
当你知道下标访问不会越界的时候可以使用它。
<code class="docutils literal"><span class="pre">&#64;cython.wraparound(False)</span></code> 消除了相对数组尾部的负数下标的处理（类似Python列表）。
引入这两个装饰器可以极大的提升性能（测试这个例子的时候大概快了2.5倍）。</p>
<p>任何时候处理数组时，研究并改善底层算法同样可以极大的提示性能。
例如，考虑对 <code class="docutils literal"><span class="pre">clip()</span></code> 函数的如下修正，使用条件表达式：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">cpdef</span> <span class="n">clip</span><span class="p">(</span><span class="n">double</span><span class="p">[:]</span> <span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="nb">min</span><span class="p">,</span> <span class="n">double</span> <span class="nb">max</span><span class="p">,</span> <span class="n">double</span><span class="p">[:]</span> <span class="n">out</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">min</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min must be &lt;= max&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input and output arrays must be the same size&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">max</span> <span class="k">else</span> <span class="nb">max</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">min</span> <span class="k">else</span> <span class="nb">min</span>
</pre></div>
</div>
<p>实际测试结果是，这个版本的代码运行速度要快50%以上（2.44秒对比之前使用 <code class="docutils literal"><span class="pre">timeit()</span></code> 测试的3.76秒）。</p>
<p>到这里为止，你可能想知道这种代码怎么能跟手写C语言PK呢？
例如，你可能写了如下的C函数并使用前面几节的技术来手写扩展：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>void clip(double *a, int n, double min, double max, double *out) {
  double x;
  for (; n &gt;= 0; n--, a++, out++) {
    x = *a;

    *out = x &gt; max ? max : (x &lt; min ? min : x);
  }
}
</pre></div>
</div>
<p>我们没有展示这个的扩展代码，但是试验之后，我们发现一个手写C扩展要比使用Cython版本的慢了大概10%。
最底下的一行比你想象的运行的快很多。</p>
<p>你可以对实例代码构建多个扩展。
对于某些数组操作，最好要释放GIL，这样多个线程能并行运行。
要这样做的话，需要修改代码，使用 <code class="docutils literal"><span class="pre">with</span> <span class="pre">nogil:</span></code> 语句：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">cpdef</span> <span class="n">clip</span><span class="p">(</span><span class="n">double</span><span class="p">[:]</span> <span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="nb">min</span><span class="p">,</span> <span class="n">double</span> <span class="nb">max</span><span class="p">,</span> <span class="n">double</span><span class="p">[:]</span> <span class="n">out</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">min</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min must be &lt;= max&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input and output arrays must be the same size&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">nogil</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">max</span> <span class="k">else</span> <span class="nb">max</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">min</span> <span class="k">else</span> <span class="nb">min</span>
</pre></div>
</div>
<p>如果你想写一个操作二维数组的版本，下面是可以参考下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">cpdef</span> <span class="n">clip2d</span><span class="p">(</span><span class="n">double</span><span class="p">[:,:]</span> <span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="nb">min</span><span class="p">,</span> <span class="n">double</span> <span class="nb">max</span><span class="p">,</span> <span class="n">double</span><span class="p">[:,:]</span> <span class="n">out</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">min</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min must be &lt;= max&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;a and out have different shapes&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span>
            <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>希望读者不要忘了本节所有代码都不会绑定到某个特定数组库（比如NumPy）上面。
这样代码就更有灵活性。
不过，要注意的是如果处理数组要涉及到多维数组、切片、偏移和其他因素的时候情况会变得复杂起来。
这些内容已经超出本节范围，更多信息请参考 <a class="reference external" href="http://www.python.org/dev/peps/pep-3118">PEP 3118</a> ，
同时 <a class="reference external" href="http://docs.cython.org/src/userguide/memoryviews.html">Cython文档中关于“类型内存视图”</a>
篇也值得一读。</p>
</div>
</div>
<span id="document-c15/p12_turning_function_pointer_into_callable"></span><div class="section" id="id1">
<h3>15.12 将函数指针转换为可调用对象<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>你已经获得了一个被编译函数的内存地址，想将它转换成一个Python可调用对象，
这样的话你就可以将它作为一个扩展函数使用了。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">ctypes</span></code> 模块可被用来创建包装任意内存地址的Python可调用对象。
下面的例子演示了怎样获取C函数的原始、底层地址，以及如何将其转换为一个可调用对象：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the address of sin() from the C math library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span>
<span class="go">140735505915760</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Turn the address into a callable function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">functype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="n">functype</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span>
<span class="go">&lt;CFunctionType object at 0x1006816d0&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Call the resulting function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.9092974268256817</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>要构建一个可调用对象，你首先需要创建一个 <code class="docutils literal"><span class="pre">CFUNCTYPE</span></code> 实例。
<code class="docutils literal"><span class="pre">CFUNCTYPE()</span></code> 的第一个参数是返回类型。
接下来的参数是参数类型。一旦你定义了函数类型，你就能将它包装在一个整型内存地址上来创建一个可调用对象了。
生成的对象被当做普通的可通过 <code class="docutils literal"><span class="pre">ctypes</span></code> 访问的函数来使用。</p>
<p>本节看上去可能有点神秘，偏底层一点。
但是，但是它被广泛使用于各种高级代码生成技术比如即时编译，在LLVM函数库中可以看到。</p>
<p>例如，下面是一个使用 <code class="docutils literal"><span class="pre">llvmpy</span></code> 扩展的简单例子，用来构建一个小的聚集函数，获取它的函数指针，
并将其转换为一个Python可调用对象。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">llvm.core</span> <span class="k">import</span> <span class="n">Module</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Builder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span> <span class="o">=</span> <span class="n">Module</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;example&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span><span class="n">Type</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> \
<span class="go">                     [Type.double(), Type.double()], False), &#39;foo&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">append_basic_block</span><span class="p">(</span><span class="s1">&#39;entry&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">builder</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">fmul</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y2</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">fmul</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">fadd</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">builder</span><span class="o">.</span><span class="n">ret</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="go">&lt;llvm.core.Instruction object at 0x10078e990&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">llvm.ee</span> <span class="k">import</span> <span class="n">ExecutionEngine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span> <span class="o">=</span> <span class="n">ExecutionEngine</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ptr</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">get_pointer_to_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ptr</span>
<span class="go">4325863440</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)(</span><span class="n">ptr</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Call the resulting function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">13.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">41.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">5.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>并不是说在这个层面犯了任何错误就会导致Python解释器挂掉。
要记得的是你是在直接跟机器级别的内存地址和本地机器码打交道，而不是Python函数。</p>
</div>
</div>
<span id="document-c15/p13_pass_null_terminated_string_to_c_libraries"></span><div class="section" id="nullc">
<h3>15.13 传递NULL结尾的字符串给C函数库<a class="headerlink" href="#nullc" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你要写一个扩展模块，需要传递一个NULL结尾的字符串给C函数库。
不过，你不是很确定怎样使用Python的Unicode字符串去实现它。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>许多C函数库包含一些操作NULL结尾的字符串，被声明类型为 <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> .
考虑如下的C函数，我们用来做演示和测试用的：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">print_chars</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%2x</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">)</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>此函数会打印被传进来字符串的每个字符的十六进制表示，这样的话可以很容易的进行调试了。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">print_chars</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">);</span>   <span class="o">//</span> <span class="n">Outputs</span><span class="p">:</span> <span class="mi">48</span> <span class="mi">65</span> <span class="mi">6</span><span class="n">c</span> <span class="mi">6</span><span class="n">c</span> <span class="mi">6</span><span class="n">f</span>
</pre></div>
</div>
<p>对于在Python中调用这样的C函数，你有几种选择。
首先，你可以通过调用 <code class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></code> 并指定”y“转换码来限制它只能操作字节，如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_chars(PyObject *self, PyObject *args) {
  char *s;

  if (!PyArg_ParseTuple(args, &quot;y&quot;, &amp;s)) {
    return NULL;
  }
  print_chars(s);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>结果函数的使用方法如下。仔细观察嵌入了NULL字节的字符串以及Unicode支持是怎样被拒绝的：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="go">48 65 6c 6c 6f 20 57 6f 72 6c 64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello</span><span class="se">\x00</span><span class="s1">World&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">must be bytes without null bytes, not bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;str&#39; does not support the buffer interface</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想传递Unicode字符串，在 <code class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></code> 中使用”s“格式码，如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_chars(PyObject *self, PyObject *args) {
  char *s;

  if (!PyArg_ParseTuple(args, &quot;s&quot;, &amp;s)) {
    return NULL;
  }
  print_chars(s);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>当被使用的时候，它会自动将所有字符串转换为以NULL结尾的UTF-8编码。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="go">48 65 6c 6c 6f 20 57 6f 72 6c 64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="s1">&#39;Spicy Jalape</span><span class="se">\u00f1</span><span class="s1">o&#39;</span><span class="p">)</span>  <span class="c1"># Note: UTF-8 encoding</span>
<span class="go">53 70 69 63 79 20 4a 61 6c 61 70 65 c3 b1 6f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="s1">&#39;Hello</span><span class="se">\x00</span><span class="s1">World&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">must be str without null characters, not str</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">must be str, not bytes</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果因为某些原因，你要直接使用 <code class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code> 而不能使用 <code class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></code> ，
下面的例子向你展示了怎样从字节和字符串对象中检查和提取一个合适的 <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> 引用：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* Some Python Object (obtained somehow) */
PyObject *obj;

/* Conversion from bytes */
{
   char *s;
   s = PyBytes_AsString(o);
   if (!s) {
      return NULL;   /* TypeError already raised */
   }
   print_chars(s);
}

/* Conversion to UTF-8 bytes from a string */
{
   PyObject *bytes;
   char *s;
   if (!PyUnicode_Check(obj)) {
       PyErr_SetString(PyExc_TypeError, &quot;Expected string&quot;);
       return NULL;
   }
   bytes = PyUnicode_AsUTF8String(obj);
   s = PyBytes_AsString(bytes);
   print_chars(s);
   Py_DECREF(bytes);
}
</pre></div>
</div>
<p>前面两种转换都可以确保是NULL结尾的数据，
但是它们并不检查字符串中间是否嵌入了NULL字节。
因此，如果这个很重要的话，那你需要自己去做检查了。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果可能的话，你应该避免去写一些依赖于NULL结尾的字符串，因为Python并没有这个需要。
最好结合使用一个指针和长度值来处理字符串。
不过，有时候你必须去处理C语言遗留代码时就没得选择了。</p>
<p>尽管很容易使用，但是很容易忽视的一个问题是在 <code class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></code>
中使用“s”格式化码会有内存损耗。
但你需要使用这种转换的时候，一个UTF-8字符串被创建并永久附加在原始字符串对象上面。
如果原始字符串包含非ASCII字符的话，就会导致字符串的尺寸增到一直到被垃圾回收。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Spicy Jalape</span><span class="se">\u00f1</span><span class="s1">o&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">87</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>     <span class="c1"># Passing string</span>
<span class="go">53 70 69 63 79 20 4a 61 6c 61 70 65 c3 b1 6f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>   <span class="c1"># Notice increased size</span>
<span class="go">103</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你在乎这个内存的损耗，你最好重写你的C扩展代码，让它使用 <code class="docutils literal"><span class="pre">PyUnicode_AsUTF8String()</span></code> 函数。如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_chars(PyObject *self, PyObject *args) {
  PyObject *o, *bytes;
  char *s;

  if (!PyArg_ParseTuple(args, &quot;U&quot;, &amp;o)) {
    return NULL;
  }
  bytes = PyUnicode_AsUTF8String(o);
  s = PyBytes_AsString(bytes);
  print_chars(s);
  Py_DECREF(bytes);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>通过这个修改，一个UTF-8编码的字符串根据需要被创建，然后在使用过后被丢弃。下面是修订后的效果：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Spicy Jalape</span><span class="se">\u00f1</span><span class="s1">o&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">87</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">53 70 69 63 79 20 4a 61 6c 61 70 65 c3 b1 6f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">87</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你试着传递NULL结尾字符串给ctypes包装过的函数，
要注意的是ctypes只能允许传递字节，并且它不会检查中间嵌入的NULL字节。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;./libsample.so&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">print_chars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="go">48 65 6c 6c 6f 20 57 6f 72 6c 64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello</span><span class="se">\x00</span><span class="s1">World&#39;</span><span class="p">)</span>
<span class="go">48 65 6c 6c 6f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ctypes.ArgumentError</span>: <span class="n">argument 1: &lt;class &#39;TypeError&#39;&gt;: wrong type</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想传递字符串而不是字节，你需要先执行手动的UTF-8编码。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">48 65 6c 6c 6f 20 57 6f 72 6c 64</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于其他扩展工具（比如Swig、Cython），
在你使用它们传递字符串给C代码时要先好好学习相应的东西了。</p>
</div>
</div>
<span id="document-c15/p14_pass_unicode_strings_to_c_libraries"></span><div class="section" id="unicodec">
<h3>15.14 传递Unicode字符串给C函数库<a class="headerlink" href="#unicodec" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你要写一个扩展模块，需要将一个Python字符串传递给C的某个库函数，但是这个函数不知道该怎么处理Unicode。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>这里我们需要考虑很多的问题，但是最主要的问题是现存的C函数库并不理解Python的原生Unicode表示。
因此，你的挑战是将Python字符串转换为一个能被C理解的形式。</p>
<p>为了演示的目的，下面有两个C函数，用来操作字符串数据并输出它来调试和测试。
一个使用形式为 <code class="docutils literal"><span class="pre">char</span> <span class="pre">*,</span> <span class="pre">int</span></code> 形式的字节，
而另一个使用形式为 <code class="docutils literal"><span class="pre">wchar_t</span> <span class="pre">*,</span> <span class="pre">int</span></code> 的宽字符形式：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">print_chars</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span> <span class="nb">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%2x</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">)</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
    <span class="n">n</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">print_wchars</span><span class="p">(</span><span class="n">wchar_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span> <span class="nb">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%x</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
    <span class="n">n</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于面向字节的函数 <code class="docutils literal"><span class="pre">print_chars()</span></code> ，你需要将Python字符串转换为一个合适的编码比如UTF-8.
下面是一个这样的扩展函数例子：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_chars(PyObject *self, PyObject *args) {
  char *s;
  Py_ssize_t  len;

  if (!PyArg_ParseTuple(args, &quot;s#&quot;, &amp;s, &amp;len)) {
    return NULL;
  }
  print_chars(s, len);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>对于那些需要处理机器本地 <code class="docutils literal"><span class="pre">wchar_t</span></code> 类型的库函数，你可以像下面这样编写扩展代码：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_wchars(PyObject *self, PyObject *args) {
  wchar_t *s;
  Py_ssize_t  len;

  if (!PyArg_ParseTuple(args, &quot;u#&quot;, &amp;s, &amp;len)) {
    return NULL;
  }
  print_wchars(s,len);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>下面是一个交互会话来演示这个函数是如何工作的：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Spicy Jalape</span><span class="se">\u00f1</span><span class="s1">o&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">53 70 69 63 79 20 4a 61 6c 61 70 65 c3 b1 6f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_wchars</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">53 70 69 63 79 20 4a 61 6c 61 70 65 f1 6f</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>仔细观察这个面向字节的函数 <code class="docutils literal"><span class="pre">print_chars()</span></code> 是怎样接受UTF-8编码数据的，
以及 <code class="docutils literal"><span class="pre">print_wchars()</span></code> 是怎样接受Unicode编码值的</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在继续本节之前，你应该首先学习你访问的C函数库的特征。
对于很多C函数库，通常传递字节而不是字符串会比较好些。要这样做，请使用如下的转换代码：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_chars(PyObject *self, PyObject *args) {
  char *s;
  Py_ssize_t  len;

  /* accepts bytes, bytearray, or other byte-like object */
  if (!PyArg_ParseTuple(args, &quot;y#&quot;, &amp;s, &amp;len)) {
    return NULL;
  }
  print_chars(s, len);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>如果你仍然还是想要传递字符串，
你需要知道Python 3可使用一个合适的字符串表示，
它并不直接映射到使用标准类型 <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> 或 <code class="docutils literal"><span class="pre">wchar_t</span> <span class="pre">*</span></code> （更多细节参考PEP 393）的C函数库。
因此，要在C中表示这个字符串数据，一些转换还是必须要的。
在 <code class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></code> 中使用&#8221;s#&#8221; 和&#8221;u#&#8221;格式化码可以安全的执行这样的转换。</p>
<p>不过这种转换有个缺点就是它可能会导致原始字符串对象的尺寸增大。
一旦转换过后，会有一个转换数据的复制附加到原始字符串对象上面，之后可以被重用。
你可以观察下这种效果：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Spicy Jalape</span><span class="se">\u00f1</span><span class="s1">o&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">87</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">53 70 69 63 79 20 4a 61 6c 61 70 65 c3 b1 6f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">103</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_wchars</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">53 70 69 63 79 20 4a 61 6c 61 70 65 f1 6f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">163</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于少量的字符串对象，可能没什么影响，
但是如果你需要在扩展中处理大量的文本，你可能想避免这个损耗了。
下面是一个修订版本可以避免这种内存损耗：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_chars(PyObject *self, PyObject *args) {
  PyObject *obj, *bytes;
  char *s;
  Py_ssize_t   len;

  if (!PyArg_ParseTuple(args, &quot;U&quot;, &amp;obj)) {
    return NULL;
  }
  bytes = PyUnicode_AsUTF8String(obj);
  PyBytes_AsStringAndSize(bytes, &amp;s, &amp;len);
  print_chars(s, len);
  Py_DECREF(bytes);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>而对 <code class="docutils literal"><span class="pre">wchar_t</span></code> 的处理时想要避免内存损耗就更加难办了。
在内部，Python使用最高效的表示来存储字符串。
例如，只包含ASCII的字符串被存储为字节数组，
而包含范围从U+0000到U+FFFF的字符的字符串使用双字节表示。
由于对于数据的表示形式不是单一的，你不能将内部数组转换为 <code class="docutils literal"><span class="pre">wchar_t</span> <span class="pre">*</span></code> 然后期望它能正确的工作。
你应该创建一个 <code class="docutils literal"><span class="pre">wchar_t</span></code> 数组并向其中复制文本。
<code class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></code> 的&#8221;u#&#8221;格式码可以帮助你高效的完成它（它将复制结果附加到字符串对象上）。</p>
<p>如果你想避免长时间内存损耗，你唯一的选择就是复制Unicode数据懂啊一个临时的数组，
将它传递给C函数，然后回收这个数组的内存。下面是一个可能的实现：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_wchars(PyObject *self, PyObject *args) {
  PyObject *obj;
  wchar_t *s;
  Py_ssize_t len;

  if (!PyArg_ParseTuple(args, &quot;U&quot;, &amp;obj)) {
    return NULL;
  }
  if ((s = PyUnicode_AsWideCharString(obj, &amp;len)) == NULL) {
    return NULL;
  }
  print_wchars(s, len);
  PyMem_Free(s);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>在这个实现中，<code class="docutils literal"><span class="pre">PyUnicode_AsWideCharString()</span></code> 创建一个临时的wchar_t缓冲并复制数据进去。
这个缓冲被传递给C然后被释放掉。
但是我写这本书的时候，这里可能有个bug，后面的Python问题页有介绍。</p>
<p>如果你知道C函数库需要的字节编码并不是UTF-8，
你可以强制Python使用扩展码来执行正确的转换，就像下面这样：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_chars(PyObject *self, PyObject *args) {
  char *s = 0;
  int   len;
  if (!PyArg_ParseTuple(args, &quot;es#&quot;, &quot;encoding-name&quot;, &amp;s, &amp;len)) {
    return NULL;
  }
  print_chars(s, len);
  PyMem_Free(s);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>最后，如果你想直接处理Unicode字符串，下面的是例子，演示了底层操作访问：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_print_wchars(PyObject *self, PyObject *args) {
  PyObject *obj;
  int n, len;
  int kind;
  void *data;

  if (!PyArg_ParseTuple(args, &quot;U&quot;, &amp;obj)) {
    return NULL;
  }
  if (PyUnicode_READY(obj) &lt; 0) {
    return NULL;
  }

  len = PyUnicode_GET_LENGTH(obj);
  kind = PyUnicode_KIND(obj);
  data = PyUnicode_DATA(obj);

  for (n = 0; n &lt; len; n++) {
    Py_UCS4 ch = PyUnicode_READ(kind, data, n);
    printf(&quot;%x &quot;, ch);
  }
  printf(&quot;\n&quot;);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>在这个代码中，<code class="docutils literal"><span class="pre">PyUnicode_KIND()</span></code> 和 <code class="docutils literal"><span class="pre">PyUnicode_DATA()</span></code>
这两个宏和Unicode的可变宽度存储有关，这个在PEP 393中有描述。
<code class="docutils literal"><span class="pre">kind</span></code> 变量编码底层存储（8位、16位或32位）以及指向缓存的数据指针相关的信息。
在实际情况中，你并不需要知道任何跟这些值有关的东西，
只需要在提取字符的时候将它们传给 <code class="docutils literal"><span class="pre">PyUnicode_READ()</span></code> 宏。</p>
<p>还有最后几句：当从Python传递Unicode字符串给C的时候，你应该尽量简单点。
如果有UTF-8和宽字符两种选择，请选择UTF-8.
对UTF-8的支持更加普遍一些，也不容易犯错，解释器也能支持的更好些。
最后，确保你仔细阅读了 <a class="reference external" href="https://docs.python.org/3/c-api/unicode.html">关于处理Unicode的相关文档</a></p>
</div>
</div>
<span id="document-c15/p15_converting_c_string_to_python"></span><div class="section" id="cpython">
<h3>15.15 C字符串转换为Python字符串<a class="headerlink" href="#cpython" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>怎样将C中的字符串转换为Python字节或一个字符串对象？</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>C字符串使用一对 <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> 和 <code class="docutils literal"><span class="pre">int</span></code> 来表示，
你需要决定字符串到底是用一个原始字节字符串还是一个Unicode字符串来表示。
字节对象可以像下面这样使用 <code class="docutils literal"><span class="pre">Py_BuildValue()</span></code> 来构建：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>     <span class="o">/*</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">C</span> <span class="n">string</span> <span class="n">data</span> <span class="o">*/</span>
<span class="nb">int</span>   <span class="nb">len</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">Length</span> <span class="n">of</span> <span class="n">data</span> <span class="o">*/</span>

<span class="o">/*</span> <span class="n">Make</span> <span class="n">a</span> <span class="nb">bytes</span> <span class="nb">object</span> <span class="o">*/</span>
<span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;y#&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">);</span>
</pre></div>
</div>
<p>如果你要创建一个Unicode字符串，并且你知道 <code class="docutils literal"><span class="pre">s</span></code> 指向了UTF-8编码的数据，可以使用下面的方式：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;s#&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">);</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">s</span></code> 使用其他编码方式，那么可以像下面使用 <code class="docutils literal"><span class="pre">PyUnicode_Decode()</span></code> 来构建一个字符串：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">PyUnicode_Decode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">,</span> <span class="s2">&quot;errors&quot;</span><span class="p">);</span>

<span class="o">/*</span> <span class="n">Examples</span> <span class="o">/*</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">PyUnicode_Decode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="s2">&quot;latin-1&quot;</span><span class="p">,</span> <span class="s2">&quot;strict&quot;</span><span class="p">);</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">PyUnicode_Decode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="s2">&quot;ascii&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>如果你恰好有一个用 <code class="docutils literal"><span class="pre">wchar_t</span> <span class="pre">*,</span> <span class="pre">len</span></code> 对表示的宽字符串，
有几种选择性。首先你可以使用 <code class="docutils literal"><span class="pre">Py_BuildValue()</span></code> ：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">wchar_t</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>    <span class="o">/*</span> <span class="n">Wide</span> <span class="n">character</span> <span class="n">string</span> <span class="o">*/</span>
<span class="nb">int</span> <span class="nb">len</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">Length</span> <span class="o">*/</span>

<span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;u#&quot;</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="nb">len</span><span class="p">);</span>
</pre></div>
</div>
<p>另外，你还可以使用 <code class="docutils literal"><span class="pre">PyUnicode_FromWideChar()</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">PyUnicode_FromWideChar</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">len</span><span class="p">);</span>
</pre></div>
</div>
<p>对于宽字符串，并没有对字符数据进行解析——它被假定是原始Unicode编码指针，可以被直接转换成Python。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>将C中的字符串转换为Python字符串遵循和I/O同样的原则。
也就是说，来自C中的数据必须根据一些解码器被显式的解码为一个字符串。
通常编码格式包括ASCII、Latin-1和UTF-8.
如果你并不确定编码方式或者数据是二进制的，你最好将字符串编码成字节。
当构造一个对象的时候，Python通常会复制你提供的字符串数据。
如果有必要的话，你需要在后面去释放C字符串。
同时，为了让程序更加健壮，你应该同时使用一个指针和一个大小值，
而不是依赖NULL结尾数据来创建字符串。</p>
</div>
</div>
<span id="document-c15/p16_work_with_c_strings_of_dubious_encoding"></span><div class="section" id="c">
<h3>15.16 不确定编码格式的C字符串<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你要在C和Python直接来回转换字符串，但是C中的编码格式并不确定。
例如，可能C中的数据期望是UTF-8，但是并没有强制它必须是。
你想编写代码来以一种优雅的方式处理这些不合格数据，这样就不会让Python奔溃或者破坏进程中的字符串数据。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>下面是一些C的数据和一个函数来演示这个问题：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Some</span> <span class="n">dubious</span> <span class="n">string</span> <span class="n">data</span> <span class="p">(</span><span class="n">malformed</span> <span class="n">UTF</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span> <span class="o">*/</span>
<span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">sdata</span> <span class="o">=</span> <span class="s2">&quot;Spicy Jalape</span><span class="se">\xc3\xb1</span><span class="s2">o</span><span class="se">\xae</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">slen</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">Output</span> <span class="n">character</span> <span class="n">data</span> <span class="o">*/</span>
<span class="n">void</span> <span class="n">print_chars</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span> <span class="nb">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%2x</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">)</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
    <span class="n">n</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在这个代码中，字符串 <code class="docutils literal"><span class="pre">sdata</span></code> 包含了UTF-8和不合格数据。
不过，如果用户在C中调用 <code class="docutils literal"><span class="pre">print_chars(sdata,</span> <span class="pre">slen)</span></code> ，它缺能正常工作。
现在假设你想将 <code class="docutils literal"><span class="pre">sdata</span></code> 的内容转换为一个Python字符串。
进一步假设你在后面还想通过一个扩展将那个字符串传个 <code class="docutils literal"><span class="pre">print_chars()</span></code> 函数。
下面是一种用来保护原始数据的方法，就算它编码有问题。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* Return the C string back to Python */
static PyObject *py_retstr(PyObject *self, PyObject *args) {
  if (!PyArg_ParseTuple(args, &quot;&quot;)) {
    return NULL;
  }
  return PyUnicode_Decode(sdata, slen, &quot;utf-8&quot;, &quot;surrogateescape&quot;);
}

/* Wrapper for the print_chars() function */
static PyObject *py_print_chars(PyObject *self, PyObject *args) {
  PyObject *obj, *bytes;
  char *s = 0;
  Py_ssize_t   len;

  if (!PyArg_ParseTuple(args, &quot;U&quot;, &amp;obj)) {
    return NULL;
  }

  if ((bytes = PyUnicode_AsEncodedString(obj,&quot;utf-8&quot;,&quot;surrogateescape&quot;))
        == NULL) {
    return NULL;
  }
  PyBytes_AsStringAndSize(bytes, &amp;s, &amp;len);
  print_chars(s, len);
  Py_DECREF(bytes);
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>如果你在Python中尝试这些函数，下面是运行效果：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">retstr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;Spicy Jalapeño\udcae&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_chars</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">53 70 69 63 79 20 4a 61 6c 61 70 65 c3 b1 6f ae</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>仔细观察结果你会发现，不合格字符串被编码到一个Python字符串中，并且并没有产生错误，
并且当它被回传给C的时候，被转换为和之前原始C字符串一样的字节。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>本节展示了在扩展模块中处理字符串时会配到的一个棘手又很恼火的问题。
也就是说，在扩展中的C字符串可能不会严格遵循Python所期望的Unicode编码/解码规则。
因此，很可能一些不合格C数据传递到Python中去。
一个很好的例子就是涉及到底层系统调用比如文件名这样的字符串。
例如，如果一个系统调用返回给解释器一个损坏的字符串，不能被正确解码的时候会怎样呢？</p>
<p>一般来讲，可以通过制定一些错误策略比如严格、忽略、替代或其他类似的来处理Unicode错误。
不过，这些策略的一个缺点是它们永久性破坏了原始字符串的内容。
例如，如果例子中的不合格数据使用这些策略之一解码，你会得到下面这样的结果：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">raw</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;Spicy Jalape</span><span class="se">\xc3\xb1</span><span class="s1">o</span><span class="se">\xae</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="go">&#39;Spicy Jalapeño&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span><span class="s1">&#39;replace&#39;</span><span class="p">)</span>
<span class="go">&#39;Spicy Jalapeño?&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">surrogateescape</span></code> 错误处理策略会将所有不可解码字节转化为一个代理对的低位字节（udcXX中XX是原始字节值）。
例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">raw</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span><span class="s1">&#39;surrogateescape&#39;</span><span class="p">)</span>
<span class="go">&#39;Spicy Jalapeño\udcae&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>单独的低位代理字符比如 <code class="docutils literal"><span class="pre">\udcae</span></code> 在Unicode中是非法的。
因此，这个字符串就是一个非法表示。
实际上，如果你将它传个一个执行输出的函数，你会得到一个错误：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="s1">&#39;surrogateescape&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">UnicodeEncodeError</span>: <span class="n">&#39;utf-8&#39; codec can&#39;t encode character &#39;\udcae&#39;</span>
<span class="go">in position 14: surrogates not allowed</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然而，允许代理转换的关键点在于从C传给Python又回传给C的不合格字符串不会有任何数据丢失。
当这个字符串再次使用 <code class="docutils literal"><span class="pre">surrogateescape</span></code> 编码时，代理字符会转换回原始字节。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&#39;Spicy Jalapeño\udcae&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span><span class="s1">&#39;surrogateescape&#39;</span><span class="p">)</span>
<span class="go">b&#39;Spicy Jalape\xc3\xb1o\xae&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>作为一般准则，最好避免代理编码——如果你正确的使用了编码，那么你的代码就值得信赖。
不过，有时候确实会出现你并不能控制数据编码并且你又不能忽略或替换坏数据，因为其他函数可能会用到它。
那么就可以使用本节的技术了。</p>
<p>最后一点要注意的是，Python中许多面向系统的函数，特别是和文件名、环境变量和命令行参数相关的
都会使用代理编码。例如，如果你使用像 <code class="docutils literal"><span class="pre">os.listdir()</span></code> 这样的函数，
传入一个包含了不可解码文件名的目录的话，它会返回一个代理转换后的字符串。
参考5.15的相关章节。</p>
<p><a class="reference external" href="https://www.python.org/dev/peps/pep-0383/">PEP 383</a>
中有更多关于本机提到的以及和surrogateescape错误处理相关的信息。</p>
</div>
</div>
<span id="document-c15/p17_pass_filenames_to_c_extensions"></span><div class="section" id="c">
<h3>15.17 传递文件名给C扩展<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你需要向C库函数传递文件名，但是需要确保文件名根据系统期望的文件名编码方式编码过。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>写一个接受一个文件名为参数的扩展函数，如下这样：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_get_filename(PyObject *self, PyObject *args) {
  PyObject *bytes;
  char *filename;
  Py_ssize_t len;
  if (!PyArg_ParseTuple(args,&quot;O&amp;&quot;, PyUnicode_FSConverter, &amp;bytes)) {
    return NULL;
  }
  PyBytes_AsStringAndSize(bytes, &amp;filename, &amp;len);
  /* Use filename */
  ...

  /* Cleanup and return */
  Py_DECREF(bytes)
  Py_RETURN_NONE;
}
</pre></div>
</div>
<p>如果你已经有了一个 <code class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code> ，希望将其转换成一个文件名，可以像下面这样做：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>    <span class="o">/*</span> <span class="n">Object</span> <span class="k">with</span> <span class="n">the</span> <span class="n">filename</span> <span class="o">*/</span>
<span class="n">PyObject</span> <span class="o">*</span><span class="nb">bytes</span><span class="p">;</span>
<span class="n">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
<span class="n">Py_ssize_t</span> <span class="nb">len</span><span class="p">;</span>

<span class="nb">bytes</span> <span class="o">=</span> <span class="n">PyUnicode_EncodeFSDefault</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="n">PyBytes_AsStringAndSize</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">len</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">Use</span> <span class="n">filename</span> <span class="o">*/</span>
<span class="o">...</span>

<span class="o">/*</span> <span class="n">Cleanup</span> <span class="o">*/</span>
<span class="n">Py_DECREF</span><span class="p">(</span><span class="nb">bytes</span><span class="p">);</span>

<span class="n">If</span> <span class="n">you</span> <span class="n">need</span> <span class="n">to</span> <span class="k">return</span> <span class="n">a</span> <span class="n">filename</span> <span class="n">back</span> <span class="n">to</span> <span class="n">Python</span><span class="p">,</span> <span class="n">use</span> <span class="n">the</span> <span class="n">following</span> <span class="n">code</span><span class="p">:</span>

<span class="o">/*</span> <span class="n">Turn</span> <span class="n">a</span> <span class="n">filename</span> <span class="n">into</span> <span class="n">a</span> <span class="n">Python</span> <span class="nb">object</span> <span class="o">*/</span>

<span class="n">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">Already</span> <span class="nb">set</span> <span class="o">*/</span>
<span class="nb">int</span>   <span class="n">filename_len</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">Already</span> <span class="nb">set</span> <span class="o">*/</span>

<span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">PyUnicode_DecodeFSDefaultAndSize</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">filename_len</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>以可移植方式来处理文件名是一个很棘手的问题，最后交由Python来处理。
如果你在扩展代码中使用本节的技术，文件名的处理方式和和Python中是一致的。
包括编码/界面字节，处理坏字符，代理转换和其他复杂情况。</p>
</div>
</div>
<span id="document-c15/p18_pass_open_files_to_c_extensions"></span><div class="section" id="c">
<h3>15.18 传递已打开的文件给C扩展<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你在Python中有一个打开的文件对象，但是需要将它传给要使用这个文件的C扩展。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>要将一个文件转换为一个整型的文件描述符，使用 <code class="docutils literal"><span class="pre">PyFile_FromFd()</span></code> ，如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">fobj</span><span class="p">;</span>     <span class="o">/*</span> <span class="n">File</span> <span class="nb">object</span> <span class="p">(</span><span class="n">already</span> <span class="n">obtained</span> <span class="n">somehow</span><span class="p">)</span> <span class="o">*/</span>
<span class="nb">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">PyObject_AsFileDescriptor</span><span class="p">(</span><span class="n">fobj</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>结果文件描述符是通过调用 <code class="docutils literal"><span class="pre">fobj</span></code> 中的 <code class="docutils literal"><span class="pre">fileno()</span></code> 方法获得的。
因此，任何以这种方式暴露给一个描述器的对象都适用（比如文件、套接字等）。
一旦你有了这个描述器，它就能被传递给多个低级的可处理文件的C函数。</p>
<p>如果你需要转换一个整型文件描述符为一个Python对象，适用下面的 <code class="docutils literal"><span class="pre">PyFile_FromFd()</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">fd</span><span class="p">;</span>     <span class="o">/*</span> <span class="n">Existing</span> <span class="n">file</span> <span class="n">descriptor</span> <span class="p">(</span><span class="n">already</span> <span class="nb">open</span><span class="p">)</span> <span class="o">*/</span>
<span class="n">PyObject</span> <span class="o">*</span><span class="n">fobj</span> <span class="o">=</span> <span class="n">PyFile_FromFd</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s2">&quot;filename&quot;</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">NULL</span><span class="p">,</span><span class="n">NULL</span><span class="p">,</span><span class="n">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">PyFile_FromFd()</span></code> 的参数对应内置的 <code class="docutils literal"><span class="pre">open()</span></code> 函数。
NULL表示编码、错误和换行参数使用默认值。</p>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>如果将Python中的文件对象传给C，有一些注意事项。
首先，Python通过 <code class="docutils literal"><span class="pre">io</span></code> 模块执行自己的I/O缓冲。
在传递任何类型的文件描述符给C之前，你都要首先在相应文件对象上刷新I/O缓冲。
不然的话，你会打乱文件系统上面的数据。</p>
<p>其次，你需要特别注意文件的归属者以及关闭文件的职责。
如果一个文件描述符被传给C，但是在Python中还在被使用着，你需要确保C没有意外的关闭它。
类似的，如果一个文件描述符被转换为一个Python文件对象，你需要清楚谁应该去关闭它。
<code class="docutils literal"><span class="pre">PyFile_FromFd()</span></code> 的最后一个参数被设置成1，用来指出Python应该关闭这个文件。</p>
<p>如果你需要从C标准I/O库中使用如　<code class="docutils literal"><span class="pre">fdopen()</span></code> 函数来创建不同类型的文件对象比如 <code class="docutils literal"><span class="pre">FILE</span> <span class="pre">*</span></code> 对象，
你需要特别小心了。这样做会在I/O堆栈中产生两个完全不同的I/O缓冲层
（一个是来自Python的 <code class="docutils literal"><span class="pre">io</span></code> 模块，另一个来自C的 <code class="docutils literal"><span class="pre">stdio</span></code> ）。
像C中的 <code class="docutils literal"><span class="pre">fclose()</span></code> 会关闭Python要使用的文件。
如果让你选的话，你应该会选择去构建一个扩展代码来处理底层的整型文件描述符，
而不是使用来自&lt;stdio.h&gt;的高层抽象功能。</p>
</div>
</div>
<span id="document-c15/p19_read_file_like_objects_from_c"></span><div class="section" id="c">
<h3>15.19 从C语言中读取类文件对象<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你要写C扩展来读取来自任何Python类文件对象中的数据（比如普通文件、StringIO对象等）。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>要读取一个类文件对象的数据，你需要重复调用 <code class="docutils literal"><span class="pre">read()</span></code> 方法，然后正确的解码获得的数据。</p>
<p>下面是一个C扩展函数例子，仅仅只是读取一个类文件对象中的所有数据并将其输出到标准输出：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#define CHUNK_SIZE 8192

/* Consume a &quot;file-like&quot; object and write bytes to stdout */
static PyObject *py_consume_file(PyObject *self, PyObject *args) {
  PyObject *obj;
  PyObject *read_meth;
  PyObject *result = NULL;
  PyObject *read_args;

  if (!PyArg_ParseTuple(args,&quot;O&quot;, &amp;obj)) {
    return NULL;
  }

  /* Get the read method of the passed object */
  if ((read_meth = PyObject_GetAttrString(obj, &quot;read&quot;)) == NULL) {
    return NULL;
  }

  /* Build the argument list to read() */
  read_args = Py_BuildValue(&quot;(i)&quot;, CHUNK_SIZE);
  while (1) {
    PyObject *data;
    PyObject *enc_data;
    char *buf;
    Py_ssize_t len;

    /* Call read() */
    if ((data = PyObject_Call(read_meth, read_args, NULL)) == NULL) {
      goto final;
    }

    /* Check for EOF */
    if (PySequence_Length(data) == 0) {
      Py_DECREF(data);
      break;
    }

    /* Encode Unicode as Bytes for C */
    if ((enc_data=PyUnicode_AsEncodedString(data,&quot;utf-8&quot;,&quot;strict&quot;))==NULL) {
      Py_DECREF(data);
      goto final;
    }

    /* Extract underlying buffer data */
    PyBytes_AsStringAndSize(enc_data, &amp;buf, &amp;len);

    /* Write to stdout (replace with something more useful) */
    write(1, buf, len);

    /* Cleanup */
    Py_DECREF(enc_data);
    Py_DECREF(data);
  }
  result = Py_BuildValue(&quot;&quot;);

 final:
  /* Cleanup */
  Py_DECREF(read_meth);
  Py_DECREF(read_args);
  return result;
}
</pre></div>
</div>
<p>要测试这个代码，先构造一个类文件对象比如一个StringIO实例，然后传递进来：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">World</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">consume_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">Hello</span>
<span class="go">World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>和普通系统文件不同的是，一个类文件对象并不需要使用低级文件描述符来构建。
因此，你不能使用普通的C库函数来访问它。
你需要使用Python的C API来像普通文件类似的那样操作类文件对象。</p>
<p>在我们的解决方案中，<code class="docutils literal"><span class="pre">read()</span></code> 方法从被传递的对象中提取出来。
一个参数列表被构建然后不断的被传给 <code class="docutils literal"><span class="pre">PyObject_Call()</span></code> 来调用这个方法。
要检查文件末尾（EOF），使用了 <code class="docutils literal"><span class="pre">PySequence_Length()</span></code> 来查看是否返回对象长度为0.</p>
<p>对于所有的I/O操作，你需要关注底层的编码格式，还有字节和Unicode之前的区别。
本节演示了如何以文本模式读取一个文件并将结果文本解码为一个字节编码，这样在C中就可以使用它了。
如果你想以二进制模式读取文件，只需要修改一点点即可，例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>...
/* Call read() */
if ((data = PyObject_Call(read_meth, read_args, NULL)) == NULL) {
  goto final;
}

/* Check for EOF */
if (PySequence_Length(data) == 0) {
  Py_DECREF(data);
  break;
}
if (!PyBytes_Check(data)) {
  Py_DECREF(data);
  PyErr_SetString(PyExc_IOError, &quot;File must be in binary mode&quot;);
  goto final;
}

/* Extract underlying buffer data */
PyBytes_AsStringAndSize(data, &amp;buf, &amp;len);
...
</pre></div>
</div>
<p>本节最难的地方在于如何进行正确的内存管理。
当处理 <code class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span> <span class="pre">``</span> <span class="pre">变量的时候，需要注意管理引用计数以及在不需要的变量的时候清理它们的值。</span>
<span class="pre">对</span> <span class="pre">``Py_DECREF()</span></code> 的调用就是来做这个的。</p>
<p>本节代码以一种通用方式编写，因此他也能适用于其他的文件操作，比如写文件。
例如，要写数据，只需要获取类文件对象的 <code class="docutils literal"><span class="pre">write()</span></code> 方法，将数据转换为合适的Python对象
（字节或Unicode），然后调用该方法将输入写入到文件。</p>
<p>最后，尽管类文件对象通常还提供其他方法（比如readline(), read_info()），
我们最好只使用基本的 <code class="docutils literal"><span class="pre">read()</span></code> 和 <code class="docutils literal"><span class="pre">write()</span></code> 方法。
在写C扩展的时候，能简单就尽量简单。</p>
</div>
</div>
<span id="document-c15/p20_consuming_an_iterable_from_c"></span><div class="section" id="c">
<h3>15.20 处理C语言中的可迭代对象<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h3>
<div class="section" id="id1">
<h4>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h4>
<p>你想写C扩展代码处理来自任何可迭代对象如列表、元组、文件或生成器中的元素。</p>
</div>
<div class="section" id="id2">
<h4>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>下面是一个C扩展函数例子，演示了怎样处理可迭代对象中的元素：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>static PyObject *py_consume_iterable(PyObject *self, PyObject *args) {
  PyObject *obj;
  PyObject *iter;
  PyObject *item;

  if (!PyArg_ParseTuple(args, &quot;O&quot;, &amp;obj)) {
    return NULL;
  }
  if ((iter = PyObject_GetIter(obj)) == NULL) {
    return NULL;
  }
  while ((item = PyIter_Next(iter)) != NULL) {
    /* Use item */
    ...
    Py_DECREF(item);
  }

  Py_DECREF(iter);
  return Py_BuildValue(&quot;&quot;);
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>本节中的代码和Python中对应代码类似。
<code class="docutils literal"><span class="pre">PyObject_GetIter()</span></code> 的调用和调用 <code class="docutils literal"><span class="pre">iter()</span></code> 一样可获得一个迭代器。
<code class="docutils literal"><span class="pre">PyIter_Next()</span></code> 函数调用 <code class="docutils literal"><span class="pre">next</span></code> 方法返回下一个元素或NULL(如果没有元素了)。
要注意正确的内存管理—— <code class="docutils literal"><span class="pre">Py_DECREF()</span></code> 需要同时在产生的元素和迭代器对象本身上同时被调用，
以避免出现内存泄露。</p>
</div>
</div>
<span id="document-c15/p21_diagnosing_segmentation_faults"></span><div class="section" id="id1">
<h3>15.21 诊断分段错误<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>解释器因为某个分段错误、总线错误、访问越界或其他致命错误而突然间奔溃。
你想获得Python堆栈信息，从而找出在发生错误的时候你的程序运行点。</p>
</div>
<div class="section" id="id3">
<h4>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">faulthandler</span></code> 模块能被用来帮你解决这个问题。
在你的程序中引入下列代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">faulthandler</span>
<span class="n">faulthandler</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
</pre></div>
</div>
<p>另外还可以像下面这样使用 <code class="docutils literal"><span class="pre">-Xfaulthandler</span></code> 来运行Python：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="o">%</span> <span class="n">python3</span> <span class="o">-</span><span class="n">Xfaulthandler</span> <span class="n">program</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>最后，你可以设置 <code class="docutils literal"><span class="pre">PYTHONFAULTHANDLER</span></code> 环境变量。
开启faulthandler后，在C扩展中的致命错误会导致一个Python错误堆栈被打印出来。例如：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Fatal</span> <span class="n">Python</span> <span class="n">error</span><span class="p">:</span> <span class="n">Segmentation</span> <span class="n">fault</span>

<span class="n">Current</span> <span class="n">thread</span> <span class="mh">0x00007fff71106cc0</span><span class="p">:</span>
  <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span> <span class="ow">in</span> <span class="n">foo</span>
  <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">10</span> <span class="ow">in</span> <span class="n">bar</span>
  <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">14</span> <span class="ow">in</span> <span class="n">spam</span>
  <span class="n">File</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">19</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="n">Segmentation</span> <span class="n">fault</span>
</pre></div>
</div>
<p>尽管这个并不能告诉你C代码中哪里出错了，但是至少能告诉你Python里面哪里有错。</p>
</div>
<div class="section" id="id4">
<h4>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>faulthandler会在Python代码执行出错的时候向你展示跟踪信息。
至少，它会告诉你出错时被调用的最顶级扩展函数是哪个。
在pdb和其他Python调试器的帮助下，你就能追根溯源找到错误所在的位置了。</p>
<p>faulthandler不会告诉你任何C语言中的错误信息。
因此，你需要使用传统的C调试器，比如gdb。
不过，在faulthandler追踪信息可以让你去判断从哪里着手。
还要注意的是在C中某些类型的错误可能不太容易恢复。
例如，如果一个C扩展丢弃了程序堆栈信息，它会让faulthandler不可用，
那么你也得不到任何输出（除了程序奔溃外）。</p>
</div>
</div>
</div>
</div>
<span id="document-chapters/p16_appendix"></span><div class="section" id="a">
<h2>附录A<a class="headerlink" href="#a" title="永久链接至标题">¶</a></h2>
<div class="section" id="id1">
<h3>在线资源<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="http://docs.python.org">http://docs.python.org</a></p>
<p>如果你需要深入了解探究语言和模块的细节，那么不必说，Python自家的在线文档是一个卓越的资源。只要保证你查看的是python 3 的文档而不是以前的老版本</p>
<p><a class="reference external" href="http://www.python.org/dev/peps">http://www.python.org/dev/peps</a></p>
<p>如果你向理解为python语言添加新特性的动机以及实现的细节，那么PEPs（Python Enhancement Proposals&#8212;-Python开发编码规范）绝对是非常宝贵的资源。尤其是一些高级语言功能更是如此。在写这本书的时候，PEPS通常比官方文档管用。</p>
<p><a class="reference external" href="http://pyvideo.org">http://pyvideo.org</a></p>
<p>这里有来自最近的PyCon大会、用户组见面会等的大量视频演讲和教程素材。对于学习潮流的python开发是非常宝贵的资源。许多视频中都会有Python的核心开发者现身说法，讲解Python 3中添加的的新特性。</p>
<p><a class="reference external" href="http://code.activestate.com/recipes/langs/python">http://code.activestate.com/recipes/langs/python</a></p>
<p>长期以来，ActiveState的Python版块已经成为一个找到数以千计的针对特定编程问题的解决方案。到写作此书位置，已经包含了大约300个特定于Python3的秘籍。你会发现，其中多数的秘籍要么对本书覆盖的话题进行了扩展，要么专精于具体的任务。所以说，它是一个好伴侣。</p>
<p><a class="reference external" href="http://stackoverflow.com/questions/tagged/python">http://stackoverflow.com/questions/tagged/python</a></p>
<p>Stack Overflow 目前有超过175,000个问题被标记为Python相关（而其中大约5000个问题是针对Python 3的）。尽管问题和回答的质量不同，但是仍然能发现很多好优秀的素材。</p>
</div>
<div class="section" id="python">
<h3>Python学习书籍<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h3>
<p>下面这些书籍提供了对Python编程的入门介绍，且重点放在了Python 3上。</p>
<p>Beginning Python: From Novice to Professional, 2nd Edition, by Magnus Lie Het‐ land, Apress (2008).
Programming in Python 3, 2nd Edition, by Mark Summerfield, Addison-Wesley (2010).</p>
<ul class="simple">
<li><em>Learning Python</em>，第四版 ，作者 Mark Lutz， O’Reilly &amp; Associates 出版 (2009)。</li>
<li><em>The Quick Python Book</em>，作者 Vernon Ceder， Manning 出版(2010)。</li>
<li><em>Python Programming for the Absolute Beginner</em>，第三版，作者 Michael Dawson，Course Technology PTR 出版(2010).</li>
<li><em>Beginning Python: From Novice to Professional</em>，第二版， 作者 Magnus Lie Het‐ land， Apress 出版(2008).</li>
<li><em>Programming in Python 3</em>，第二版，作者 Mark Summerfield，Addison-Wesley 出版 (2010).</li>
</ul>
</div>
<div class="section" id="id2">
<h3>高级书籍<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>下面的这些书籍提供了更多高级的范围，也包含Python 3方面的内容。</p>
<ul class="simple">
<li><em>Programming Python</em>，第四版, by Mark Lutz, O’Reilly &amp; Associates 出版(2010).</li>
<li><em>Python Essential Reference</em>，第四版，作者 David Beazley, Addison-Wesley 出版(2009).</li>
<li><em>Core Python Applications Programming</em>，第三版，作者 Wesley Chun, Prentice Hall 出版(2012).</li>
<li><em>The Python Standard Library by Example</em> ， 作者 Doug Hellmann，Addison-Wesley 出版(2011).</li>
<li><em>Python 3 Object Oriented Programming</em>，作者 Dusty Phillips, Packt Publishing 出版(2010).</li>
<li><em>Porting to Python 3</em>， 作者 Lennart Regebro，CreateSpace 出版(2011), <a class="reference external" href="http://python3porting.com">http://python3porting.com</a>.</li>
</ul>
</div>
</div>
<span id="document-aboutme"></span><div class="section" id="id1">
<h2>关于译者<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p><em>关于译者</em></p>
<ul class="simple">
<li>姓名：     熊能</li>
<li>微信：     yidao620</li>
<li>Email：   <a class="reference external" href="mailto:yidao620&#37;&#52;&#48;gmail&#46;com">yidao620<span>&#64;</span>gmail<span>&#46;</span>com</a></li>
<li>博客：     <a class="reference external" href="http://yidao620c.github.io/">http://yidao620c.github.io/</a></li>
<li>GitHub：  <a class="reference external" href="https://github.com/yidao620c">https://github.com/yidao620c</a></li>
</ul>
<hr class="docutils" />
</div>
<span id="document-roadmap"></span><div class="section" id="roadmap">
<h2>Roadmap<a class="headerlink" href="#roadmap" title="永久链接至标题">¶</a></h2>
<p>2014/08/10 - 2014/08/31:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>|    github项目搭建，readthedocs文档生成。
|    整个项目的框架完成
</pre></div>
</div>
<p>2014/09/01 - 2014/10/31:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="n">前4章翻译完成</span>
</pre></div>
</div>
<p>2014/11/01 - 2015/01/31:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="n">前8章翻译完成</span>
</pre></div>
</div>
<p>2015/02/01 - 2015/03/31:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="n">前9章翻译完成</span>
</pre></div>
</div>
<p>2015/04/01 - 2015/05/31:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="mi">10</span><span class="n">章翻译完成</span>
</pre></div>
</div>
<p>2015/06/01 - 2015/06/30:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="mi">11</span><span class="n">章翻译完成</span>
</pre></div>
</div>
<p>2015/07/01 - 2015/07/31:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="mi">12</span><span class="n">章翻译完成</span>
</pre></div>
</div>
<p>2015/08/01 - 2015/08/31:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="mi">13</span><span class="n">章翻译完成</span>
</pre></div>
</div>
<p>2015/09/01 - 2015/11/30:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="mi">14</span><span class="n">章翻译完成</span>
</pre></div>
</div>
<p>2015/12/01 - 2015/12/20:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="mi">15</span><span class="n">章翻译完成</span>
</pre></div>
</div>
<p>2015/12/21 - 2015/12/31:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="n">对全部翻译进行校对一次</span>
</pre></div>
</div>
<p>2016/01/01 - 2016/01/10:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>|    对外公开发布完整版1.0，包括转换后的PDF文件
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="index.html#document-copyright">Copyright</a> 2017, 熊能.
      
        <span class="commit">
          Revision <code>727e4b1a</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: stable
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/zh_CN/latest/">latest</a></dd>
        
          <dd><a href="/zh_CN/stable/">stable</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="//readthedocs.org/projects/python3-cookbook/downloads/htmlzip/stable/">htmlzip</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/python3-cookbook/?fromdocs=python3-cookbook">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/python3-cookbook/?fromdocs=python3-cookbook">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'3.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>