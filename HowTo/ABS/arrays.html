<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Arrays</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Advanced Topics"
HREF="part4.html"><LINK
REL="PREVIOUS"
TITLE="List Constructs"
HREF="list-cons.html"><LINK
REL="NEXT"
TITLE="/dev and /proc"
HREF="devproc.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=gb2312"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-size:18px;
font-family:"黑体", Arial;
font-weight:bolder;
line-height:200%;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="list-cons.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="devproc.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
>
  <H1
><A
NAME="ARRAYS"
>第26章. 数组</A
></H1
>
  <P
><A
NAME="ARRAYREF"
></A
></P
>
  <P
>较新的Bash版本支持一维数组. 数组元素可以用符号<TT
CLASS="USERINPUT"
><B
>variable[xx]</B
></TT
>来初始化. 另外，脚本可以用<TT
CLASS="USERINPUT"
><B
>declare -a variable</B
></TT
>语句来清楚地指定一个数组. 要访问一个数组元素，可以使用花括号来访问，即<TT
CLASS="USERINPUT"
><B
>${variable[xx]}</B
></TT
>.</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX66"
></A
>
    <P
><B
>例子 26-1. 简单的数组用法</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;
   4&nbsp;area[11]=23
   5&nbsp;area[13]=37
   6&nbsp;area[51]=UFOs
   7&nbsp;
   8&nbsp;#  数组成员不必一定要连贯或连续的.
   9&nbsp;
  10&nbsp;#  数组的一部分成员允许不被初始化.
  11&nbsp;#  数组中空缺元素是允许的.
  12&nbsp;#  实际上，保存着稀疏数据的数组(“稀疏数组”)在电子表格处理软件中非常有用.
  13&nbsp;#
  14&nbsp;
  15&nbsp;
  16&nbsp;echo -n "area[11] = "
  17&nbsp;echo ${area[11]}    #  {大括号}是需要的.
  18&nbsp;
  19&nbsp;echo -n "area[13] = "
  20&nbsp;echo ${area[13]}
  21&nbsp;
  22&nbsp;echo "Contents of area[51] are ${area[51]}."
  23&nbsp;
  24&nbsp;# 没有初始化内容的数组元素打印空值(NULL值).
  25&nbsp;echo -n "area[43] = "
  26&nbsp;echo ${area[43]}
  27&nbsp;echo "(area[43] unassigned)"
  28&nbsp;
  29&nbsp;echo
  30&nbsp;
  31&nbsp;# 两个数组元素的和被赋值给另一个数组元素
  32&nbsp;area[5]=`expr ${area[11]} + ${area[13]}`
  33&nbsp;echo "area[5] = area[11] + area[13]"
  34&nbsp;echo -n "area[5] = "
  35&nbsp;echo ${area[5]}
  36&nbsp;
  37&nbsp;area[6]=`expr ${area[11]} + ${area[51]}`
  38&nbsp;echo "area[6] = area[11] + area[51]"
  39&nbsp;echo -n "area[6] = "
  40&nbsp;echo ${area[6]}
  41&nbsp;# 这里会失败是因为整数和字符串相加是不允许的.
  42&nbsp;
  43&nbsp;echo; echo; echo
  44&nbsp;
  45&nbsp;# -----------------------------------------------------------------
  46&nbsp;# 另一个数组, "area2".
  47&nbsp;# 另一种指定数组元素的值的办法...
  48&nbsp;# array_name=( XXX YYY ZZZ ... )
  49&nbsp;
  50&nbsp;area2=( zero one two three four )
  51&nbsp;
  52&nbsp;echo -n "area2[0] = "
  53&nbsp;echo ${area2[0]}
  54&nbsp;# 啊哈, 从0开始计数(即数组的第一个元素是[0], 而不是 [1]).
  55&nbsp;
  56&nbsp;echo -n "area2[1] = "
  57&nbsp;echo ${area2[1]}    # [1] 是数组的第二个元素.
  58&nbsp;# -----------------------------------------------------------------
  59&nbsp;
  60&nbsp;echo; echo; echo
  61&nbsp;
  62&nbsp;# -----------------------------------------------
  63&nbsp;# 第三种数组, "area3".
  64&nbsp;# 第三种指定数组元素值的办法...
  65&nbsp;# array_name=([xx]=XXX [yy]=YYY ...)
  66&nbsp;
  67&nbsp;area3=([17]=seventeen [24]=twenty-four)
  68&nbsp;
  69&nbsp;echo -n "area3[17] = "
  70&nbsp;echo ${area3[17]}
  71&nbsp;
  72&nbsp;echo -n "area3[24] = "
  73&nbsp;echo ${area3[24]}
  74&nbsp;# -----------------------------------------------
  75&nbsp;
  76&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Bash 允许把变量当成数组来操作，即使这个变量没有明确地被声明为数组. 
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;string=abcABC123ABCabc
   2&nbsp;echo ${string[@]}               # abcABC123ABCabc
   3&nbsp;echo ${string[*]}               # abcABC123ABCabc 
   4&nbsp;echo ${string[0]}               # abcABC123ABCabc
   5&nbsp;echo ${string[1]}               # 没有输出!
   6&nbsp;                                # 为什么?
   7&nbsp;echo ${#string[@]}              # 1
   8&nbsp;                                # 数组中只有一个元素.
   9&nbsp;                                # 且是这个字符串本身.
  10&nbsp;
  11&nbsp;# Thank you, Michael Zick, for pointing this out.</PRE
></TD
></TR
></TABLE
>
      类似的示范请参考<A
HREF="untyped.html#BVUNTYPED"
>Bash variables are untyped</A
>. </P
></TD
>
      </TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="POEM"
></A
>
    <P
><B
>例子 26-2. 格式化一首诗</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# poem.sh: 排印出作者喜欢的一首诗.
   3&nbsp;
   4&nbsp;# 诗的行数 (一小节诗).
   5&nbsp;Line[1]="I do not know which to prefer,"
   6&nbsp;Line[2]="The beauty of inflections"
   7&nbsp;Line[3]="Or the beauty of innuendoes,"
   8&nbsp;Line[4]="The blackbird whistling"
   9&nbsp;Line[5]="Or just after."
  10&nbsp;
  11&nbsp;# 出处.
  12&nbsp;Attrib[1]=" Wallace Stevens"
  13&nbsp;Attrib[2]="\"Thirteen Ways of Looking at a Blackbird\""
  14&nbsp;# 此诗是公众的 (版权期已经到期了).
  15&nbsp;
  16&nbsp;echo
  17&nbsp;
  18&nbsp;for index in 1 2 3 4 5    # 5行.
  19&nbsp;do
  20&nbsp;  printf "     %s\n" "${Line[index]}"
  21&nbsp;done
  22&nbsp;
  23&nbsp;for index in 1 2          # 打印两行出处行.
  24&nbsp;do
  25&nbsp;  printf "          %s\n" "${Attrib[index]}"
  26&nbsp;done
  27&nbsp;
  28&nbsp;echo
  29&nbsp;
  30&nbsp;exit 0
  31&nbsp;
  32&nbsp;# 练习:
  33&nbsp;# --------
  34&nbsp;# 修改这个脚本使其从一个文本文件中提取内容打印一首行.</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>数组元素有它们独有的语法, 并且甚至Bash命令和操作符有特殊的选项可以支持数组使用.</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARRAYOPS"
></A
>
    <P
><B
>例子 26-3. 多种数组操作</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# array-ops.sh: 数组更多有趣的用法.
   3&nbsp;
   4&nbsp;
   5&nbsp;array=( zero one two three four five )
   6&nbsp;# 元素    0   1   2    3     4    5
   7&nbsp;
   8&nbsp;echo ${array[0]}       #  zero
   9&nbsp;echo ${array:0}        #  zero
  10&nbsp;                       #  第一个元素的参数扩展,
  11&nbsp;                       #+ 从位置0开始 (即第一个字符).
  12&nbsp;echo ${array:1}        #  ero
  13&nbsp;                       #  第一个元素的参数扩展,
  14&nbsp;                       #+ 从位置1开始 (即第二个字符).
  15&nbsp;
  16&nbsp;echo "--------------"
  17&nbsp;
  18&nbsp;echo ${#array[0]}      #  4
  19&nbsp;                       #  数组第一个元素的长度.
  20&nbsp;echo ${#array}         #  4
  21&nbsp;                       #  数组第一个元素的长度.
  22&nbsp;                       #  (另一种写法)
  23&nbsp;
  24&nbsp;echo ${#array[1]}      #  3
  25&nbsp;                       #  数组第二个元素的长度.
  26&nbsp;                       #  Bash的数组是0开始索引的.
  27&nbsp;
  28&nbsp;echo ${#array[*]}      #  6
  29&nbsp;                       #  数组中元素的个数.
  30&nbsp;echo ${#array[@]}      #  6
  31&nbsp;                       #  数组中元素的个数.
  32&nbsp;
  33&nbsp;echo "--------------"
  34&nbsp;
  35&nbsp;array2=( [0]="first element" [1]="second element" [3]="fourth element" )
  36&nbsp;
  37&nbsp;echo ${array2[0]}      # 第一个元素
  38&nbsp;echo ${array2[1]}      # 第二个元素
  39&nbsp;echo ${array2[2]}      #
  40&nbsp;                       # 因为初始化时没有指定，因此值为空(null).
  41&nbsp;echo ${array2[3]}      # 第四个元素
  42&nbsp;
  43&nbsp;
  44&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>大部分标准的<A
HREF="string-manipulation.html#STRINGMANIP"
>字符串操作符</A
> 可以用于数组操作.</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARRAYSTROPS"
></A
>
    <P
><B
>例子 26-4. 用于数组的字符串操作符</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# array-strops.sh: 用于数组的字符串操作符.
   3&nbsp;# 由Michael Zick编码.
   4&nbsp;# 已征得作者的同意.
   5&nbsp;
   6&nbsp;#  一般来说，任何类似 ${name ... } 写法的字符串操作符
   7&nbsp;#+ 都能在一个数组的所有字符串元素中使用
   8&nbsp;#+ 像${name[@] ... } 或 ${name[*] ...} 的写法.
   9&nbsp;
  10&nbsp;
  11&nbsp;arrayZ=( one two three four five five )
  12&nbsp;
  13&nbsp;echo
  14&nbsp;
  15&nbsp;# 提取尾部的子串
  16&nbsp;echo ${arrayZ[@]:0}     # one two three four five five
  17&nbsp;                        # 所有的元素.
  18&nbsp;
  19&nbsp;echo ${arrayZ[@]:1}     # two three four five five
  20&nbsp;                        # 在第一个元素 element[0]后面的所有元素.
  21&nbsp;
  22&nbsp;echo ${arrayZ[@]:1:2}   # two three
  23&nbsp;                        # 只提取在元素 element[0]后面的两个元素.
  24&nbsp;
  25&nbsp;echo "-----------------------"
  26&nbsp;
  27&nbsp;#  子串删除
  28&nbsp;#  从字符串的前部删除最短的匹配,
  29&nbsp;#+ 匹配字串是一个正则表达式.
  30&nbsp;
  31&nbsp;echo ${arrayZ[@]#f*r}   # one two three five five
  32&nbsp;                        # 匹配表达式作用于数组所有元素.
  33&nbsp;                        # 匹配了"four"并把它删除.
  34&nbsp;
  35&nbsp;# 字符串前部最长的匹配
  36&nbsp;echo ${arrayZ[@]##t*e}  # one two four five five
  37&nbsp;                        # 匹配表达式作用于数组所有元素.
  38&nbsp;                        # 匹配"three"并把它删除.
  39&nbsp;
  40&nbsp;# 字符串尾部的最短匹配
  41&nbsp;echo ${arrayZ[@]%h*e}   # one two t four five five
  42&nbsp;                        # 匹配表达式作用于数组所有元素.
  43&nbsp;                        # 匹配"hree"并把它删除.
  44&nbsp;
  45&nbsp;# 字符串尾部的最长匹配
  46&nbsp;echo ${arrayZ[@]%%t*e}  # one two four five five
  47&nbsp;                        # 匹配表达式作用于数组所有元素.
  48&nbsp;                        # 匹配"three"并把它删除.
  49&nbsp;
  50&nbsp;echo "-----------------------"
  51&nbsp;
  52&nbsp;# 子串替换
  53&nbsp;
  54&nbsp;# 第一个匹配的子串会被替换
  55&nbsp;echo ${arrayZ[@]/fiv/XYZ}   # one two three four XYZe XYZe
  56&nbsp;                            # 匹配表达式作用于数组所有元素.
  57&nbsp;
  58&nbsp;# 所有匹配的子串会被替换
  59&nbsp;echo ${arrayZ[@]//iv/YY}    # one two three four fYYe fYYe
  60&nbsp;                            # 匹配表达式作用于数组所有元素.
  61&nbsp;
  62&nbsp;# 删除所有的匹配子串
  63&nbsp;# 没有指定代替字串意味着删除
  64&nbsp;echo ${arrayZ[@]//fi/}      # one two three four ve ve
  65&nbsp;                            # 匹配表达式作用于数组所有元素.
  66&nbsp;
  67&nbsp;# 替换最前部出现的字串
  68&nbsp;echo ${arrayZ[@]/#fi/XY}    # one two three four XYve XYve
  69&nbsp;                            # 匹配表达式作用于数组所有元素.
  70&nbsp;
  71&nbsp;# 替换最后部出现的字串
  72&nbsp;echo ${arrayZ[@]/%ve/ZZ}    # one two three four fiZZ fiZZ
  73&nbsp;                            # 匹配表达式作用于数组所有元素.
  74&nbsp;
  75&nbsp;echo ${arrayZ[@]/%o/XX}     # one twXX three four five five
  76&nbsp;                            # 为什么?
  77&nbsp;
  78&nbsp;echo "-----------------------"
  79&nbsp;
  80&nbsp;
  81&nbsp;# 在从awk(或其他的工具)取得数据之前 --
  82&nbsp;# 记得:
  83&nbsp;#   $( ... ) 是命令替换.
  84&nbsp;#   函数以子进程运行.
  85&nbsp;#   函数将输出打印到标准输出.
  86&nbsp;#   用read来读取函数的标准输出.
  87&nbsp;#   name[@]的写法指定了一个"for-each"的操作.
  88&nbsp;
  89&nbsp;newstr() {
  90&nbsp;    echo -n "!!!"
  91&nbsp;}
  92&nbsp;
  93&nbsp;echo ${arrayZ[@]/%e/$(newstr)}
  94&nbsp;# on!!! two thre!!! four fiv!!! fiv!!!
  95&nbsp;# Q.E.D: 替换部分的动作实际上是一个'赋值'.
  96&nbsp;
  97&nbsp;#  使用"For-Each"型的
  98&nbsp;echo ${arrayZ[@]//*/$(newstr optional_arguments)}
  99&nbsp;#  现在Now, 如果if Bash只传递匹配$0的字符串给要调用的函数. . . 
 100&nbsp;#
 101&nbsp;
 102&nbsp;echo
 103&nbsp;
 104&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
><A
HREF="commandsub.html#COMMANDSUBREF"
>命令替换</A
> 能创建数组的新的单个元素.</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="SCRIPTARRAY"
></A
>
    <P
><B
>例子 26-5. 将脚本的内容传给数组</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# script-array.sh: 把此脚本的内容传进数组.
   3&nbsp;# 从Chris Martin的e-mail中得到灵感 (多谢!).
   4&nbsp;
   5&nbsp;script_contents=( $(cat "$0") )  #  把这个脚本($0)的内容存进数组.
   6&nbsp;                                 #
   7&nbsp;
   8&nbsp;for element in $(seq 0 $((${#script_contents[@]} - 1)))
   9&nbsp;  do                #  ${#script_contents[@]}
  10&nbsp;                    #+ 表示数组中元素的个数.
  11&nbsp;                    #
  12&nbsp;                    #  问题:
  13&nbsp;                    #  为什么需要  seq 0  ?
  14&nbsp;                    #  试试更改成 seq 1.
  15&nbsp;  echo -n "${script_contents[$element]}"
  16&nbsp;                    # 将脚本的每行列成一个域.
  17&nbsp;  echo -n " -- "    # 使用" -- "作为域分隔符.
  18&nbsp;done
  19&nbsp;
  20&nbsp;echo
  21&nbsp;
  22&nbsp;exit 0
  23&nbsp;
  24&nbsp;# 练习:
  25&nbsp;# --------
  26&nbsp;#  修改这个脚本使它能按照它原本的格式输出,
  27&nbsp;#+ 连同空白符，换行，等等.
  28&nbsp;#</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>在数组的环境里, 一些 Bash <A
HREF="internal.html#BUILTINREF"
>内建的命令</A
> 含义有一些轻微的改变. 例如, <A
HREF="internal.html#UNSETREF"
>unset</A
> 会删除数组元素, 或甚至删除整个数组.</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX67"
></A
>
    <P
><B
>例子 26-6. 一些数组专用的工具</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;declare -a colors
   4&nbsp;#  所有脚本后面的命令都会把
   5&nbsp;#+ 变量"colors"作为数组对待.
   6&nbsp;
   7&nbsp;echo "Enter your favorite colors (separated from each other by a space)."
   8&nbsp;
   9&nbsp;read -a colors    # 键入至少3种颜色以用于下面的示例.
  10&nbsp;#  指定'read'命令的选项,
  11&nbsp;#+ 允许指定数组元素.
  12&nbsp;
  13&nbsp;echo
  14&nbsp;
  15&nbsp;element_count=${#colors[@]}
  16&nbsp;# 专用语法来提取数组元素的个数.
  17&nbsp;#     element_count=${#colors[*]} 也可以.
  18&nbsp;#
  19&nbsp;#  "@"变量允许分割引号内的单词
  20&nbsp;#+ (依靠空白字符来分隔变量).
  21&nbsp;#
  22&nbsp;#  这就像"$@" 和"$*"在位置参数中表现出来的一样.
  23&nbsp;# 
  24&nbsp;
  25&nbsp;index=0
  26&nbsp;
  27&nbsp;while [ "$index" -lt "$element_count" ]
  28&nbsp;do    # List all the elements in the array.
  29&nbsp;  echo ${colors[$index]}
  30&nbsp;  let "index = $index + 1"
  31&nbsp;done
  32&nbsp;# 每个数组元素被列为单独的一行.
  33&nbsp;# 如果这个没有要求, 可以用  echo -n "${colors[$index]} "
  34&nbsp;#
  35&nbsp;# 可以用一个"for"循环来做:
  36&nbsp;#   for i in "${colors[@]}"
  37&nbsp;#   do
  38&nbsp;#     echo "$i"
  39&nbsp;#   done
  40&nbsp;# (Thanks, S.C.)
  41&nbsp;
  42&nbsp;echo
  43&nbsp;
  44&nbsp;# 再次列出数组中所有的元素, 但使用更优雅的做法.
  45&nbsp;  echo ${colors[@]}          # echo ${colors[*]} 也可以.
  46&nbsp;
  47&nbsp;echo
  48&nbsp;
  49&nbsp;# "unset"命令删除一个数组元素或是整个数组.
  50&nbsp;unset colors[1]              # 删除数组的第二个元素.
  51&nbsp;                             # 作用等同于   colors[1]=
  52&nbsp;echo  ${colors[@]}           # 再列出数组,第二个元素没有了.
  53&nbsp;
  54&nbsp;unset colors                 # 删除整个数组.
  55&nbsp;                             #  unset colors[*] 或
  56&nbsp;                             #+ unset colors[@] 都可以.
  57&nbsp;echo; echo -n "Colors gone."			   
  58&nbsp;echo ${colors[@]}            # 再列出数组, 则为空了.
  59&nbsp;
  60&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>正如在前面的例子中看到的, <B
CLASS="COMMAND"
>${array_name[@]}</B
>和<B
CLASS="COMMAND"
>${array_name[*]}</B
> 都与数组的所有元素相关. 同样地, 为了计算数组的元素个数, 可以用<B
CLASS="COMMAND"
>${#array_name[@]}</B
> 或<B
CLASS="COMMAND"
>${#array_name[*]}</B
>. <B
CLASS="COMMAND"
>${#array_name}</B
> 是数组第一个元素<b
class="COMMAND"
>${array_name[0]}</b
>的长度(字符数) .</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="EMPTYARRAY"
></A
>
    <P
><B
>例子 26-7. 关于空数组和空数组元素</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# empty-array.sh
   3&nbsp;
   4&nbsp;#  多谢 Stephane Chazelas 制作这个例子最初的版本,
   5&nbsp;#+ 并由 Michael Zick 扩展了.
   6&nbsp;
   7&nbsp;
   8&nbsp;# 空数组不同与含有空值元素的数组.
   9&nbsp;
  10&nbsp;array0=( first second third )
  11&nbsp;array1=( '' )   # "array1" 由一个空元素组成.
  12&nbsp;array2=( )      # 没有元素 . . . "array2" 是空的.
  13&nbsp;
  14&nbsp;echo
  15&nbsp;ListArray()
  16&nbsp;{
  17&nbsp;echo
  18&nbsp;echo "Elements in array0:  ${array0[@]}"
  19&nbsp;echo "Elements in array1:  ${array1[@]}"
  20&nbsp;echo "Elements in array2:  ${array2[@]}"
  21&nbsp;echo
  22&nbsp;echo "Length of first element in array0 = ${#array0}"
  23&nbsp;echo "Length of first element in array1 = ${#array1}"
  24&nbsp;echo "Length of first element in array2 = ${#array2}"
  25&nbsp;echo
  26&nbsp;echo "Number of elements in array0 = ${#array0[*]}"  # 3
  27&nbsp;echo "Number of elements in array1 = ${#array1[*]}"  # 1  (惊奇!)
  28&nbsp;echo "Number of elements in array2 = ${#array2[*]}"  # 0
  29&nbsp;}
  30&nbsp;
  31&nbsp;# ===================================================================
  32&nbsp;
  33&nbsp;ListArray
  34&nbsp;
  35&nbsp;# 尝试扩展这些数组.
  36&nbsp;
  37&nbsp;# 增加一个元素到数组.
  38&nbsp;array0=( "${array0[@]}" "new1" )
  39&nbsp;array1=( "${array1[@]}" "new1" )
  40&nbsp;array2=( "${array2[@]}" "new1" )
  41&nbsp;
  42&nbsp;ListArray
  43&nbsp;
  44&nbsp;# 或
  45&nbsp;array0[${#array0[*]}]="new2"
  46&nbsp;array1[${#array1[*]}]="new2"
  47&nbsp;array2[${#array2[*]}]="new2"
  48&nbsp;
  49&nbsp;ListArray
  50&nbsp;
  51&nbsp;# 当像上面的做法增加数组时，数组像 '栈'
  52&nbsp;# 上面的做法是 'push(压栈)'
  53&nbsp;# 栈高是:
  54&nbsp;height=${#array2[@]}
  55&nbsp;echo
  56&nbsp;echo "Stack height for array2 = $height"
  57&nbsp;
  58&nbsp;# 'pop(出栈)' 是:
  59&nbsp;unset array2[${#array2[@]}-1]   # 数组是以0开始索引的,
  60&nbsp;height=${#array2[@]}            #+ 这就意味着第一个元素下标是 0.
  61&nbsp;echo
  62&nbsp;echo "POP"
  63&nbsp;echo "New stack height for array2 = $height"
  64&nbsp;
  65&nbsp;ListArray
  66&nbsp;
  67&nbsp;# 只列出数组array0的第二和第三个元素.
  68&nbsp;from=1		 #是以0开始的数字
  69&nbsp;to=2		#
  70&nbsp;array3=( ${array0[@]:1:2} )
  71&nbsp;echo
  72&nbsp;echo "Elements in array3:  ${array3[@]}"
  73&nbsp;
  74&nbsp;# 像一个字符串一样处理(字符的数组).
  75&nbsp;# 试试其他的字符串格式.
  76&nbsp;
  77&nbsp;# 替换:
  78&nbsp;array4=( ${array0[@]/second/2nd} )
  79&nbsp;echo
  80&nbsp;echo "Elements in array4:  ${array4[@]}"
  81&nbsp;
  82&nbsp;# 替换所有匹配通配符的字符串.
  83&nbsp;array5=( ${array0[@]//new?/old} )
  84&nbsp;echo
  85&nbsp;echo "Elements in array5:  ${array5[@]}"
  86&nbsp;
  87&nbsp;# 当你开始觉得对此有把握的时候 . . .
  88&nbsp;array6=( ${array0[@]#*new} )
  89&nbsp;echo # 这个可能会使你感到惊奇.
  90&nbsp;echo "Elements in array6:  ${array6[@]}"
  91&nbsp;
  92&nbsp;array7=( ${array0[@]#new1} )
  93&nbsp;echo # 数组array6之后就没有惊奇了.
  94&nbsp;echo "Elements in array7:  ${array7[@]}"
  95&nbsp;
  96&nbsp;# 这看起来非常像 . . .
  97&nbsp;array8=( ${array0[@]/new1/} )
  98&nbsp;echo
  99&nbsp;echo "Elements in array8:  ${array8[@]}"
 100&nbsp;
 101&nbsp;#  那么我们怎么总结它呢So what can one say about this?
 102&nbsp;
 103&nbsp;#  字符串操作在数组var[@]的每一个元素中执行.
 104&nbsp;#
 105&nbsp;#  因此Therefore : 如果结果是一个零长度的字符串，
 106&nbsp;#+ Bash支持字符串向量操作,
 107&nbsp;#+ 元素会在结果赋值中消失不见.
 108&nbsp;
 109&nbsp;#  提问, 这些字符串是强还是弱引用?
 110&nbsp;
 111&nbsp;zap='new*'
 112&nbsp;array9=( ${array0[@]/$zap/} )
 113&nbsp;echo
 114&nbsp;echo "Elements in array9:  ${array9[@]}"
 115&nbsp;
 116&nbsp;# 当你还在想你在Kansas州的何处时 . . .
 117&nbsp;array10=( ${array0[@]#$zap} )
 118&nbsp;echo
 119&nbsp;echo "Elements in array10:  ${array10[@]}"
 120&nbsp;
 121&nbsp;# 把 array7 和 array10比较.
 122&nbsp;# 把 array8 和 array9比较.
 123&nbsp;
 124&nbsp;# 答案: 必须用弱引用.
 125&nbsp;
 126&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
><B
CLASS="COMMAND"
>${array_name[@]}</B
>和<B
CLASS="COMMAND"
>${array_name[*]}</B
> 的关系类似于<A
HREF="variables2.html#APPREF"
>$@ and $*</A
>. 这种数组用法非常有用.</P
>
  <P
>      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# 复制一个数组.
   2&nbsp;array2=( "${array1[@]}" )
   3&nbsp;# 或
   4&nbsp;array2="${array1[@]}"
   5&nbsp;
   6&nbsp;# 给数组增加一个元素.
   7&nbsp;array=( "${array[@]}" "new element" )
   8&nbsp;# 或
   9&nbsp;array[${#array[*]}]="new element"
  10&nbsp;
  11&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>
      </P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><B
CLASS="COMMAND"
>array=( element1 element2 ... elementN )</B
> 初始化操作, 依赖于<A
HREF="commandsub.html#COMMANDSUBREF"
>命令替换(command substitution)</A
>使将一个文本内容加载进数组成为可能.</P
>
              <P
>  	
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;filename=sample_file
   4&nbsp;
   5&nbsp;#            cat sample_file
   6&nbsp;#
   7&nbsp;#            1 a b c
   8&nbsp;#            2 d e fg
   9&nbsp;
  10&nbsp;
  11&nbsp;declare -a array1
  12&nbsp;
  13&nbsp;array1=( `cat "$filename"`)                #  加载$filename文件的内容进数组array1.
  14&nbsp;#         打印文件到标准输出               #
  15&nbsp;#
  16&nbsp;#  array1=( `cat "$filename" | tr '\n' ' '`)
  17&nbsp;#                            把文件里的换行变为空格. 
  18&nbsp;#  这是没必要的，因为Bash做单词分割时会把换行变为空格.
  19&nbsp;#
  20&nbsp;
  21&nbsp;echo ${array1[@]}            # 打印数组.
  22&nbsp;#                              1 a b c 2 d e fg
  23&nbsp;#
  24&nbsp;#  文件中每个由空白符分隔开的“词”都被存在数组的一个元素里
  25&nbsp;#
  26&nbsp;
  27&nbsp;element_count=${#array1[*]}
  28&nbsp;echo $element_count          # 8</PRE
></TD
></TR
></TABLE
>
      </P
></TD
></TR
></TABLE
></DIV
>
      <P
>出色的技巧使数组的操作技术又多了一种.</P
>
      <DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARRAYASSIGN"
></A
>
    <P
><B
>例子 26-8. 初始化数组</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;# array-assign.bash
   3&nbsp;
   4&nbsp;#  数组操作是Bash特有的,
   5&nbsp;#+ 因此脚本名用".bash"结尾.
   6&nbsp;
   7&nbsp;# Copyright (c) Michael S. Zick, 2003, All rights reserved.
   8&nbsp;# 许可证: 没有任何限制，可以用于任何目的的反复使用.
   9&nbsp;# Version: $ID$
  10&nbsp;#
  11&nbsp;# 由William Park添加注释.
  12&nbsp;
  13&nbsp;#  基于Stephane Chazelas提供在本书中的一个例子
  14&nbsp;#
  15&nbsp;
  16&nbsp;# 'times' 命令的输出格式:
  17&nbsp;# User CPU &#60;空格&#62; System CPU
  18&nbsp;# User CPU of dead children &#60;空格&#62; System CPU of dead children
  19&nbsp;
  20&nbsp;#  Bash赋一个数组的所有元素给新的数组变量有两种办法. 
  21&nbsp;#
  22&nbsp;#  在Bash版本2.04, 2.05a 和 2.05b,
  23&nbsp;#+ 这两种办法都对NULL的值的元素全部丢弃.
  24&nbsp;#  另一种数组赋值办法是维护[下标]=值之间的关系将会在新版本的Bash支持.
  25&nbsp;#
  26&nbsp;
  27&nbsp;#  可以用外部命令来构造一个大数组,
  28&nbsp;#+ 但几千个元素的数组如下就可以构造了.
  29&nbsp;#
  30&nbsp;
  31&nbsp;declare -a bigOne=( /dev/* )
  32&nbsp;echo
  33&nbsp;echo 'Conditions: Unquoted, default IFS, All-Elements-Of'
  34&nbsp;echo "Number of elements in array is ${#bigOne[@]}"
  35&nbsp;
  36&nbsp;# set -vx
  37&nbsp;
  38&nbsp;
  39&nbsp;
  40&nbsp;echo
  41&nbsp;echo '- - testing: =( ${array[@]} ) - -'
  42&nbsp;times
  43&nbsp;declare -a bigTwo=( ${bigOne[@]} )
  44&nbsp;#                 ^              ^
  45&nbsp;times
  46&nbsp;
  47&nbsp;echo
  48&nbsp;echo '- - testing: =${array[@]} - -'
  49&nbsp;times
  50&nbsp;declare -a bigThree=${bigOne[@]}
  51&nbsp;# 这次没有用括号.
  52&nbsp;times
  53&nbsp;
  54&nbsp;#  正如Stephane Chazelas指出的那样比较输出的数组可以了解第二种格式的赋值比第三和第四的times的更快
  55&nbsp;#
  56&nbsp;#
  57&nbsp;#  William Park 解释explains:
  58&nbsp;#+ bigTwo 数组是被赋值了一个单字符串,
  59&nbsp;#+ bigThree 则赋值时一个一个元素的赋值.
  60&nbsp;#  所以, 实际上的情况是:
  61&nbsp;#                   bigTwo=( [0]="... ... ..." )
  62&nbsp;#                   bigThree=( [0]="..." [1]="..." [2]="..." ... )
  63&nbsp;
  64&nbsp;
  65&nbsp;#  我在本书的例子中仍然会继续用第一种格式,
  66&nbsp;#+ 因为我认为这会对说明清楚更有帮助.
  67&nbsp;
  68&nbsp;#  我的例子中的可复用的部分实际上还是会使用第二种格式，
  69&nbsp;#+ 因为这种格式更快一些.
  70&nbsp;
  71&nbsp;# MSZ: 很抱歉早先的失误(应是指本书的先前版本).
  72&nbsp;
  73&nbsp;
  74&nbsp;#  注:
  75&nbsp;#  ----
  76&nbsp;#  在31和43行的"declare -a"语句不是必须的,
  77&nbsp;#+ 因为会在使用Array=( ... )赋值格式时暗示它是数组.
  78&nbsp;#
  79&nbsp;#  但是, 省略这些声明会导致后面脚本的相关操作更慢一些.
  80&nbsp;#
  81&nbsp;#  试一下, 看有什么变化.
  82&nbsp;
  83&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>对变量增加 <B
CLASS="COMMAND"
>declare -a</B
>
	语句声明可以加速后面的数组操作速度.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COPYARRAY"
></A
>
    <P
><B
>例子 26-9. 复制和连接数组</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;# CopyArray.sh
   3&nbsp;#
   4&nbsp;# 由 Michael Zick编写.
   5&nbsp;# 在本书中使用已得到许可.
   6&nbsp;
   7&nbsp;#  怎么传递变量名和值处理，返回就用使用该变量,
   8&nbsp;#+ 或说"创建你自己的赋值语句".
   9&nbsp;
  10&nbsp;
  11&nbsp;CpArray_Mac() {
  12&nbsp;
  13&nbsp;# 创建赋值命令语句
  14&nbsp;
  15&nbsp;    echo -n 'eval '
  16&nbsp;    echo -n "$2"                    # 目的变量名
  17&nbsp;    echo -n '=( ${'
  18&nbsp;    echo -n "$1"                    # 源名字
  19&nbsp;    echo -n '[@]} )'
  20&nbsp;
  21&nbsp;# 上面的全部会合成单个命令.
  22&nbsp;# 这就是函数所有的功能.
  23&nbsp;}
  24&nbsp;
  25&nbsp;declare -f CopyArray                # 函数"指针"
  26&nbsp;CopyArray=CpArray_Mac               # 建立命令
  27&nbsp;
  28&nbsp;Hype()
  29&nbsp;{
  30&nbsp;
  31&nbsp;# 要复制的数组名为 $1.
  32&nbsp;# (接合数组，并包含尾部的字符串"Really Rocks".)
  33&nbsp;# 返回结果的数组名为 $2.
  34&nbsp;
  35&nbsp;    local -a TMP
  36&nbsp;    local -a hype=( Really Rocks )
  37&nbsp;
  38&nbsp;    $($CopyArray $1 TMP)
  39&nbsp;    TMP=( ${TMP[@]} ${hype[@]} )
  40&nbsp;    $($CopyArray TMP $2)
  41&nbsp;}
  42&nbsp;
  43&nbsp;declare -a before=( Advanced Bash Scripting )
  44&nbsp;declare -a after
  45&nbsp;
  46&nbsp;echo "Array Before = ${before[@]}"
  47&nbsp;
  48&nbsp;Hype before after
  49&nbsp;
  50&nbsp;echo "Array After = ${after[@]}"
  51&nbsp;
  52&nbsp;# 有多余的字符串?
  53&nbsp;
  54&nbsp;echo "What ${after[@]:3:2}?"
  55&nbsp;
  56&nbsp;declare -a modest=( ${after[@]:2:1} ${after[@]:3:2} )
  57&nbsp;#                    ----     子串提取       ----
  58&nbsp;
  59&nbsp;echo "Array Modest = ${modest[@]}"
  60&nbsp;
  61&nbsp;# 'before'变量变成什么了 ?
  62&nbsp;
  63&nbsp;echo "Array Before = ${before[@]}"
  64&nbsp;
  65&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARRAYAPPEND"
></A
>
    <P
><B
>例子 26-10. 关于连接数组的更多信息</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;# array-append.bash
   3&nbsp;
   4&nbsp;# Copyright (c) Michael S. Zick, 2003, All rights reserved.
   5&nbsp;# 许可: 可以无限制的以任何目的任何格式重复使用.
   6&nbsp;# 版本: $ID$
   7&nbsp;#
   8&nbsp;# 格式上由M.C做了轻微的修改.
   9&nbsp;
  10&nbsp;
  11&nbsp;# 数组操作是Bash特有的属性.
  12&nbsp;# 原来的 UNIX /bin/sh 没有类似的功能.
  13&nbsp;
  14&nbsp;
  15&nbsp;#  把此脚本的输出管道输送给 'more'
  16&nbsp;#+ 以便输出不会滚过终端屏幕.
  17&nbsp;
  18&nbsp;
  19&nbsp;# 下标依次使用.
  20&nbsp;declare -a array1=( zero1 one1 two1 )
  21&nbsp;# 下标有未使用的 ([1] 没有被定义).
  22&nbsp;declare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )
  23&nbsp;
  24&nbsp;echo
  25&nbsp;echo '- Confirm that the array is really subscript sparse. -'
  26&nbsp;echo "Number of elements: 4"        # 这儿是举例子就用硬编码.
  27&nbsp;for (( i = 0 ; i &#60; 4 ; i++ ))
  28&nbsp;do
  29&nbsp;    echo "Element [$i]: ${array2[$i]}"
  30&nbsp;done
  31&nbsp;# 也可以参考basics-reviewed.bash更多的常见代码.
  32&nbsp;
  33&nbsp;
  34&nbsp;declare -a dest
  35&nbsp;
  36&nbsp;# 组合 (添加) 两个数组到第三个数组.
  37&nbsp;echo
  38&nbsp;echo 'Conditions: Unquoted, default IFS, All-Elements-Of operator'
  39&nbsp;echo '- Undefined elements not present, subscripts not maintained. -'
  40&nbsp;# # 那些未定义的元素不存在; 组合时会丢弃这些元素.
  41&nbsp;
  42&nbsp;dest=( ${array1[@]} ${array2[@]} )
  43&nbsp;# dest=${array1[@]}${array2[@]}     # 奇怪的结果, 或者叫臭虫.
  44&nbsp;
  45&nbsp;# 现在, 打印出结果.
  46&nbsp;echo
  47&nbsp;echo '- - Testing Array Append - -'
  48&nbsp;cnt=${#dest[@]}
  49&nbsp;
  50&nbsp;echo "Number of elements: $cnt"
  51&nbsp;for (( i = 0 ; i &#60; cnt ; i++ ))
  52&nbsp;do
  53&nbsp;    echo "Element [$i]: ${dest[$i]}"
  54&nbsp;done
  55&nbsp;
  56&nbsp;# 把一个数组赋值给另一个数组的单个元素 (两次).
  57&nbsp;dest[0]=${array1[@]}
  58&nbsp;dest[1]=${array2[@]}
  59&nbsp;
  60&nbsp;# 列出结果.
  61&nbsp;echo
  62&nbsp;echo '- - Testing modified array - -'
  63&nbsp;cnt=${#dest[@]}
  64&nbsp;
  65&nbsp;echo "Number of elements: $cnt"
  66&nbsp;for (( i = 0 ; i &#60; cnt ; i++ ))
  67&nbsp;do
  68&nbsp;    echo "Element [$i]: ${dest[$i]}"
  69&nbsp;done
  70&nbsp;
  71&nbsp;# 检测第二个元素的改变.
  72&nbsp;echo
  73&nbsp;echo '- - Reassign and list second element - -'
  74&nbsp;
  75&nbsp;declare -a subArray=${dest[1]}
  76&nbsp;cnt=${#subArray[@]}
  77&nbsp;
  78&nbsp;echo "Number of elements: $cnt"
  79&nbsp;for (( i = 0 ; i &#60; cnt ; i++ ))
  80&nbsp;do
  81&nbsp;    echo "Element [$i]: ${subArray[$i]}"
  82&nbsp;done
  83&nbsp;
  84&nbsp;#  用 '=${ ... }' 把整个数组的值赋给另一个数组的单个元素
  85&nbsp;#+ 使数组所有元素值被转换成了一个字符串，各元素的值由一个空格分开(其实是IFS的第一个字符).
  86&nbsp;#
  87&nbsp;#
  88&nbsp;
  89&nbsp;# 如果原先的元素没有包含空白符 . . .
  90&nbsp;# 如果原先的数组下标都是连续的 . . .
  91&nbsp;# 我们就能取回最初的数组结构.
  92&nbsp;
  93&nbsp;# 恢复第二个元素的修改回元素.
  94&nbsp;echo
  95&nbsp;echo '- - Listing restored element - -'
  96&nbsp;
  97&nbsp;declare -a subArray=( ${dest[1]} )
  98&nbsp;cnt=${#subArray[@]}
  99&nbsp;
 100&nbsp;echo "Number of elements: $cnt"
 101&nbsp;for (( i = 0 ; i &#60; cnt ; i++ ))
 102&nbsp;do
 103&nbsp;    echo "Element [$i]: ${subArray[$i]}"
 104&nbsp;done
 105&nbsp;echo '- - Do not depend on this behavior. - -'
 106&nbsp;echo '- - This behavior is subject to change - -'
 107&nbsp;echo '- - in versions of Bash newer than version 2.05b - -'
 108&nbsp;
 109&nbsp;# MSZ: 很抱歉早先时混淆的几个要点（译者注：应该是指本书早先的版本）.
 110&nbsp;
 111&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>--</P
>
 <P
>数组允许在脚本中实现一些常见的熟悉算法.这是否是必要的好想法在此不讨论，留给读者自行判断.</P
>
 <DIV
CLASS="EXAMPLE"
><HR><A
NAME="BUBBLE"
></A
>
    <P
><B
>例子 26-11. 一位老朋友: <I
CLASS="EMPHASIS"
>冒泡排序</I
></B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# bubble.sh: 排序法之冒泡排序.
   3&nbsp;
   4&nbsp;# 回忆冒泡排序法. 在这个版本中要实现它...
   5&nbsp;
   6&nbsp;#  靠连续地多次比较数组元素来排序,
   7&nbsp;#+ 比较两个相邻的元素，如果排序顺序不对，则交换两者的顺序.
   8&nbsp;#  当第一轮比较结束后，最&quot;重&quot;的元素就被排到了最底部.
   9&nbsp;#  当第二轮比较结束后，第二&quot;重&quot;的元素就被排到了次底部的位置.
  10&nbsp;#  以此类推.
  11&nbsp;#  这意味着每轮的比较不需要比较先前已&quot;沉淀&quot;好的数据.
  12&nbsp;#  因此你会注意到后面数据的打印会比较快一些.
  13&nbsp;
  14&nbsp;
  15&nbsp;exchange()
  16&nbsp;{
  17&nbsp;  # 交换数组的两个元素.
  18&nbsp;  local temp=${Countries[$1]} #  临时保存要交换的一个元素.
  19&nbsp;                              #
  20&nbsp;  Countries[$1]=${Countries[$2]}
  21&nbsp;  Countries[$2]=$temp
  22&nbsp;  
  23&nbsp;  return
  24&nbsp;}  
  25&nbsp;
  26&nbsp;declare -a Countries  #  声明数组,
  27&nbsp;                      #+ 在此是可选的，因为下面它会被按数组来初始化.
  28&nbsp;
  29&nbsp;#  是否允许用转义符(\)将数组的各变量值放到几行上?
  30&nbsp;#
  31&nbsp;#  是的.
  32&nbsp;
  33&nbsp;Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \
  34&nbsp;Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \
  35&nbsp;Israel Peru Canada Oman Denmark Wales France Kenya \
  36&nbsp;Xanadu Qatar Liechtenstein Hungary)
  37&nbsp;
  38&nbsp;# "Xanadu" 是个虚拟的充满美好的神话之地.
  39&nbsp;#
  40&nbsp;
  41&nbsp;
  42&nbsp;clear                      # 开始之前清除屏幕. 
  43&nbsp;
  44&nbsp;echo "0: ${Countries[*]}"  # 从0索引的元素开始列出整个数组.
  45&nbsp;
  46&nbsp;number_of_elements=${#Countries[@]}
  47&nbsp;let "comparisons = $number_of_elements - 1"
  48&nbsp;
  49&nbsp;count=1 # 传递数字.
  50&nbsp;
  51&nbsp;while [ "$comparisons" -gt 0 ]          # 开始外部的循环
  52&nbsp;do
  53&nbsp;
  54&nbsp;  index=0  # 每轮开始前重设索引值为0.
  55&nbsp;
  56&nbsp;  while [ "$index" -lt "$comparisons" ] # 开始内部循环
  57&nbsp;  do
  58&nbsp;    if [ ${Countries[$index]} \&#62; ${Countries[`expr $index + 1`]} ]
  59&nbsp;    #  如果原来的排序次序不对...
  60&nbsp;    #  回想一下 \&#62; 在单方括号里是is ASCII 码的比较操作符.
  61&nbsp;    #
  62&nbsp;
  63&nbsp;    #  if [[ ${Countries[$index]} &#62; ${Countries[`expr $index + 1`]} ]]
  64&nbsp;    #+ 也可以.
  65&nbsp;    then
  66&nbsp;      exchange $index `expr $index + 1`  # 交换.
  67&nbsp;    fi  
  68&nbsp;    let "index += 1"
  69&nbsp;  done # 内部循环结束
  70&nbsp;
  71&nbsp;# ----------------------------------------------------------------------
  72&nbsp;# Paulo Marcel Coelho Aragao 建议使用更简单的for-loops.
  73&nbsp;#
  74&nbsp;# for (( last = $number_of_elements - 1 ; last &#62; 1 ; last-- ))
  75&nbsp;# do
  76&nbsp;#     for (( i = 0 ; i &#60; last ; i++ ))
  77&nbsp;#     do
  78&nbsp;#         [[ "${Countries[$i]}" &#62; "${Countries[$((i+1))]}" ]] \
  79&nbsp;#             &#38;&#38; exchange $i $((i+1))
  80&nbsp;#     done
  81&nbsp;# done
  82&nbsp;# ----------------------------------------------------------------------
  83&nbsp;  
  84&nbsp;
  85&nbsp;let "comparisons -= 1" #  因为最"重"的元素冒到了最底部,
  86&nbsp;                       #+ 我们可以每轮少做一些比较.
  87&nbsp;
  88&nbsp;echo
  89&nbsp;echo "$count: ${Countries[@]}"  # 每轮结束后，打印一次数组.
  90&nbsp;echo
  91&nbsp;let "count += 1"                # 增加传递计数.
  92&nbsp;
  93&nbsp;done                            # 外部循环结束
  94&nbsp;                                # 完成.
  95&nbsp;
  96&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>--</P
>
  <P
>在数组内嵌一个数组有可能做到吗?</P
>
  <P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# "内嵌" 数组.
   3&nbsp;
   4&nbsp;#  Michael Zick 提供这个例子,
   5&nbsp;#+ 由William Park作了些纠正和解释.
   6&nbsp;
   7&nbsp;AnArray=( $(ls --inode --ignore-backups --almost-all \
   8&nbsp;	--directory --full-time --color=none --time=status \
   9&nbsp;	--sort=time -l ${PWD} ) )  # 命令及选项.
  10&nbsp;
  11&nbsp;# 空格是有意义的 . . . 不要在上面引号引用任何东西.
  12&nbsp;
  13&nbsp;SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
  14&nbsp;#  这个数组有6个元素:
  15&nbsp;#+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}
  16&nbsp;#      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )
  17&nbsp;#
  18&nbsp;#  Bash中的数组像是字符串(char *)型的(循环)链表.
  19&nbsp;#
  20&nbsp;#  因此, 这实际上不是内嵌的数组,
  21&nbsp;#+ 但它的功能是相似的.
  22&nbsp;
  23&nbsp;echo "Current directory and date of last status change:"
  24&nbsp;echo "${SubArray[@]}"
  25&nbsp;
  26&nbsp;exit 0</PRE
></TD
></TR
></TABLE
></P
><P
>--</P
>
  <P
>内嵌数组和<A
HREF="bash2.html#VARREFNEW"
>间接引用（indirect references）</A
> 的组合使用产生了一些有趣的用法.</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="EMBARR"
></A
>
    <P
><B
>例子 26-12. 内嵌数组和间接引用</B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# embedded-arrays.sh
   3&nbsp;# 内嵌数组和间接引用.
   4&nbsp;
   5&nbsp;# 由Dennis Leeuw编写.
   6&nbsp;# 已获使用许可.
   7&nbsp;# 由本文作者修改.
   8&nbsp;
   9&nbsp;
  10&nbsp;ARRAY1=(
  11&nbsp;        VAR1_1=value11
  12&nbsp;        VAR1_2=value12
  13&nbsp;        VAR1_3=value13
  14&nbsp;)
  15&nbsp;
  16&nbsp;ARRAY2=(
  17&nbsp;        VARIABLE="test"
  18&nbsp;        STRING="VAR1=value1 VAR2=value2 VAR3=value3"
  19&nbsp;        ARRAY21=${ARRAY1[*]}
  20&nbsp;)       # 把ARRAY1数组嵌到这个数组里.
  21&nbsp;
  22&nbsp;function print () {
  23&nbsp;        OLD_IFS="$IFS"
  24&nbsp;        IFS=$'\n'       #  这是为了在每个行打印一个数组元素.
  25&nbsp;                        #
  26&nbsp;        TEST1="ARRAY2[*]"
  27&nbsp;        local ${!TEST1} # 试下删除这行会发生什么.
  28&nbsp;        #  间接引用.
  29&nbsp;	#  这使 $TEST1只在函数内存取。
  30&nbsp;	#
  31&nbsp;
  32&nbsp;
  33&nbsp;        #  我们看看还能干点什么.
  34&nbsp;        echo
  35&nbsp;        echo "\$TEST1 = $TEST1"       #  变量的名称.
  36&nbsp;        echo; echo
  37&nbsp;        echo "{\$TEST1} = ${!TEST1}"  #  变量的内容.
  38&nbsp;                                      #  这就是间接引用的作用.
  39&nbsp;                                      #
  40&nbsp;        echo
  41&nbsp;        echo "-------------------------------------------"; echo
  42&nbsp;        echo
  43&nbsp;
  44&nbsp;
  45&nbsp;        # 打印变量
  46&nbsp;        echo "Variable VARIABLE: $VARIABLE"
  47&nbsp;	
  48&nbsp;        # 打印一个字符串元素
  49&nbsp;        IFS="$OLD_IFS"
  50&nbsp;        TEST2="STRING[*]"
  51&nbsp;        local ${!TEST2}      # 间接引用 (像上面一样).
  52&nbsp;        echo "String element VAR2: $VAR2 from STRING"
  53&nbsp;
  54&nbsp;        # 打印一个字符串元素
  55&nbsp;        TEST2="ARRAY21[*]"
  56&nbsp;        local ${!TEST2}      # 间接引用 (像上面一样).
  57&nbsp;        echo "Array element VAR1_1: $VAR1_1 from ARRAY21"
  58&nbsp;}
  59&nbsp;
  60&nbsp;print
  61&nbsp;echo
  62&nbsp;
  63&nbsp;exit 0
  64&nbsp;
  65&nbsp;#   脚本作者注,
  66&nbsp;#+ "你可以很容易地将其扩展成Bash的一个能创建hash的脚本."
  67&nbsp;#   (难) 留给读者的练习: 实现它.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>--</P
>
  <P
>数组使埃拉托色尼素数筛子有了shell脚本的实现. 当然, 如果是追求效率的应用自然应该用一种编译型的语言，例如用C. 这种脚本运行实在是太慢.</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX68"
></A
>
    <P
><B
>例子 26-13. 复杂数组应用: <I
CLASS="EMPHASIS"
>埃拉托色尼素数筛子</I
></B
></P
>
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# sieve.sh (ex68.sh)
   3&nbsp;
   4&nbsp;# 埃拉托色尼素数筛子
   5&nbsp;# 找素数的经典算法.
   6&nbsp;
   7&nbsp;#  在同等数量的数值内这个脚本比用C写的版本慢很多.
   8&nbsp;#
   9&nbsp;
  10&nbsp;LOWER_LIMIT=1       # 从1开始.
  11&nbsp;UPPER_LIMIT=1000    # 到 1000.
  12&nbsp;# (如果你很有时间的话，你可以把它设得更高 . . . )
  13&nbsp;
  14&nbsp;PRIME=1
  15&nbsp;NON_PRIME=0
  16&nbsp;
  17&nbsp;let SPLIT=UPPER_LIMIT/2
  18&nbsp;# 优化:
  19&nbsp;# 只需要测试中间到最大之间的值 (为什么?).
  20&nbsp;
  21&nbsp;
  22&nbsp;declare -a Primes
  23&nbsp;# Primes[] 是一个数组.
  24&nbsp;
  25&nbsp;
  26&nbsp;initialize ()
  27&nbsp;{
  28&nbsp;# 初始化数组.
  29&nbsp;
  30&nbsp;i=$LOWER_LIMIT
  31&nbsp;until [ "$i" -gt "$UPPER_LIMIT" ]
  32&nbsp;do
  33&nbsp;  Primes[i]=$PRIME
  34&nbsp;  let "i += 1"
  35&nbsp;done
  36&nbsp;#  假定所有的数组成员都是需要检查的 (素数)
  37&nbsp;#+ 一直到检查完成前.
  38&nbsp;}
  39&nbsp;
  40&nbsp;print_primes ()
  41&nbsp;{
  42&nbsp;# 打印出所有Primes[]数组中被标记为素数的元素.
  43&nbsp;
  44&nbsp;i=$LOWER_LIMIT
  45&nbsp;
  46&nbsp;until [ "$i" -gt "$UPPER_LIMIT" ]
  47&nbsp;do
  48&nbsp;
  49&nbsp;  if [ "${Primes[i]}" -eq "$PRIME" ]
  50&nbsp;  then
  51&nbsp;    printf "%8d" $i
  52&nbsp;    # 每个数字打印前先打印8个空格, 数字是在偶数列打印的.
  53&nbsp;  fi
  54&nbsp;  
  55&nbsp;  let "i += 1"
  56&nbsp;  
  57&nbsp;done
  58&nbsp;
  59&nbsp;}
  60&nbsp;
  61&nbsp;sift () # 查出非素数.
  62&nbsp;{
  63&nbsp;
  64&nbsp;let i=$LOWER_LIMIT+1
  65&nbsp;# 我们都知道1是素数, 所以我们从2开始.
  66&nbsp;
  67&nbsp;until [ "$i" -gt "$UPPER_LIMIT" ]
  68&nbsp;do
  69&nbsp;
  70&nbsp;if [ "${Primes[i]}" -eq "$PRIME" ]
  71&nbsp;# 不要处理已经过滤过的数字 (被标识为非素数).
  72&nbsp;then
  73&nbsp;
  74&nbsp;  t=$i
  75&nbsp;
  76&nbsp;  while [ "$t" -le "$UPPER_LIMIT" ]
  77&nbsp;  do
  78&nbsp;    let "t += $i "
  79&nbsp;    Primes[t]=$NON_PRIME
  80&nbsp;    # 标识为非素数.
  81&nbsp;  done
  82&nbsp;
  83&nbsp;fi  
  84&nbsp;
  85&nbsp;  let "i += 1"
  86&nbsp;done  
  87&nbsp;
  88&nbsp;
  89&nbsp;}
  90&nbsp;
  91&nbsp;
  92&nbsp;# ==============================================
  93&nbsp;# main ()
  94&nbsp;# 继续调用函数.
  95&nbsp;initialize
  96&nbsp;sift
  97&nbsp;print_primes
  98&nbsp;# 这就是被称为结构化编程的东西了.
  99&nbsp;# ==============================================
 100&nbsp;
 101&nbsp;echo
 102&nbsp;
 103&nbsp;exit 0
 104&nbsp;
 105&nbsp;
 106&nbsp;
 107&nbsp;# -------------------------------------------------------- #
 108&nbsp;# 因为前面的一个'exit',所以下面的代码不会被执行. 
 109&nbsp;
 110&nbsp;#  下面是Stephane Chazelas写的一个埃拉托色尼素数筛子的改进版本,
 111&nbsp;#+ 运行会稍微快一点.
 112&nbsp;
 113&nbsp;# 必须在命令行上指定参数(寻找素数的限制范围).
 114&nbsp;
 115&nbsp;UPPER_LIMIT=$1                  # 值来自命令行.
 116&nbsp;let SPLIT=UPPER_LIMIT/2         # 从中间值到最大值.
 117&nbsp;
 118&nbsp;Primes=( '' $(seq $UPPER_LIMIT) )
 119&nbsp;
 120&nbsp;i=1
 121&nbsp;until (( ( i += 1 ) &#62; SPLIT ))  # 仅需要从中间值检查.
 122&nbsp;do
 123&nbsp;  if [[ -n $Primes[i] ]]
 124&nbsp;  then
 125&nbsp;    t=$i
 126&nbsp;    until (( ( t += i ) &#62; UPPER_LIMIT ))
 127&nbsp;    do
 128&nbsp;      Primes[t]=
 129&nbsp;    done
 130&nbsp;  fi  
 131&nbsp;done  
 132&nbsp;echo ${Primes[*]}
 133&nbsp;
 134&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>比较这个用数组的素数产生器和另一种不用数组的<A
HREF="contributed-scripts.html#PRIMES"
>例子 A-16</A
>.</P
>
  <P
>--</P
>
        <P
>数组可以做一定程度的扩展,以模拟支持Bash原本不支持的数据结构.</P
>
        <DIV
CLASS="EXAMPLE"
><HR><A
NAME="STACKEX"
></A
>
        <P
><B
>例子 26-14. 模拟下推的堆栈</B
></P
>
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# stack.sh: 下推的堆栈模拟
   3&nbsp;
   4&nbsp;#  类似于CPU栈, 下推的堆栈依次保存数据项, 
   5&nbsp;#+ 但取出时则反序进行, 后进先出.
   6&nbsp;
   7&nbsp;BP=100            #  栈数组的基点指针.
   8&nbsp;                  #  从元素100开始.
   9&nbsp;
  10&nbsp;SP=$BP            #  栈指针.
  11&nbsp;                  #  初始化栈底.
  12&nbsp;
  13&nbsp;Data=             #  当前栈的内容.  
  14&nbsp;                  #  必须定义成全局变量,
  15&nbsp;                  #+ 因为函数的返回整数有范围限制.
  16&nbsp;
  17&nbsp;declare -a stack
  18&nbsp;
  19&nbsp;
  20&nbsp;push()            # 把一个数据项压入栈.
  21&nbsp;{
  22&nbsp;if [ -z "$1" ]    # 没有可压入的?
  23&nbsp;then
  24&nbsp;  return
  25&nbsp;fi
  26&nbsp;
  27&nbsp;let "SP -= 1"     # 更新堆栈指针.
  28&nbsp;stack[$SP]=$1
  29&nbsp;
  30&nbsp;return
  31&nbsp;}
  32&nbsp;
  33&nbsp;pop()                    # 从栈中弹出一个数据项.
  34&nbsp;{
  35&nbsp;Data=                    # 清空保存数据项中间变量.
  36&nbsp;
  37&nbsp;if [ "$SP" -eq "$BP" ]   # 已经没有数据可弹出?
  38&nbsp;then
  39&nbsp;  return
  40&nbsp;fi                       #  这使SP不会超过100,
  41&nbsp;                         #+ 例如, 这可保护一个失控的堆栈.
  42&nbsp;
  43&nbsp;Data=${stack[$SP]}
  44&nbsp;let "SP += 1"            # 更新堆栈指针.
  45&nbsp;return
  46&nbsp;}
  47&nbsp;
  48&nbsp;status_report()          # 打印堆栈的当前状态.
  49&nbsp;{
  50&nbsp;echo "-------------------------------------"
  51&nbsp;echo "REPORT"
  52&nbsp;echo "Stack Pointer = $SP"
  53&nbsp;echo "Just popped \""$Data"\" off the stack."
  54&nbsp;echo "-------------------------------------"
  55&nbsp;echo
  56&nbsp;}
  57&nbsp;
  58&nbsp;
  59&nbsp;# =======================================================
  60&nbsp;# 现在，来点乐子.
  61&nbsp;
  62&nbsp;echo
  63&nbsp;
  64&nbsp;# 看你是否能从空栈里弹出数据项来.
  65&nbsp;pop
  66&nbsp;status_report
  67&nbsp;
  68&nbsp;echo
  69&nbsp;
  70&nbsp;push garbage
  71&nbsp;pop
  72&nbsp;status_report     # 压入garbage, 弹出garbage.      
  73&nbsp;
  74&nbsp;value1=23; push $value1
  75&nbsp;value2=skidoo; push $value2
  76&nbsp;value3=FINAL; push $value3
  77&nbsp;
  78&nbsp;pop              # FINAL
  79&nbsp;status_report
  80&nbsp;pop              # skidoo
  81&nbsp;status_report
  82&nbsp;pop              # 23
  83&nbsp;status_report    # 后进, 先出!
  84&nbsp;
  85&nbsp;#  注意堆栈指针每次压栈时减,
  86&nbsp;#+ 每次弹出时加一.
  87&nbsp;
  88&nbsp;echo
  89&nbsp;
  90&nbsp;exit 0
  91&nbsp;
  92&nbsp;# =======================================================
  93&nbsp;
  94&nbsp;
  95&nbsp;# 练习:
  96&nbsp;# ---------
  97&nbsp;
  98&nbsp;# 1)  修改"push()"函数，使其调用一次就能够压入多个数据项.
  99&nbsp;#
 100&nbsp;
 101&nbsp;# 2)  修改"pop()"函数，使其调用一次就能弹出多个数据项.
 102&nbsp;#
 103&nbsp;
 104&nbsp;# 3)  给那些有临界操作的函数增加出错检查.
 105&nbsp;#     即是指是否一次完成操作或没有完成操作返回相应的代码，
 106&nbsp;#   + 没有完成要启动合适的处理动作.
 107&nbsp;#
 108&nbsp;
 109&nbsp;# 4)  这个脚本为基础,
 110&nbsp;#   + 写一个栈实现的四则运算计算器.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>--</P
>
 <P
>要想操作数组的下标需要中间变量. 如果确实要这么做, 可以考虑使用一种更强功能的编程语言, 例如 Perl 或 C.</P
>
 <DIV
CLASS="EXAMPLE"
><HR><A
NAME="QFUNCTION"
></A
>
	<P
><B
>例子 26-15. 复杂的数组应用:
             <I
CLASS="EMPHASIS"
>列出一种怪异的数学序列</I
></B
></P
>
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# Douglas Hofstadter的有名的"Q-series":
   4&nbsp;
   5&nbsp;# Q(1) = Q(2) = 1
   6&nbsp;# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), 当 n&#62;2 时
   7&nbsp;
   8&nbsp;# 这是令人感到陌生的也是没有规律的"乱序"整数序列.
   9&nbsp;# 序列的头20个如下所示:
  10&nbsp;# 1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12 
  11&nbsp;
  12&nbsp;#  参考Hofstadter的书, "Goedel, Escher, Bach: An Eternal Golden Braid",
  13&nbsp;#+ 页码 137.
  14&nbsp;
  15&nbsp;
  16&nbsp;LIMIT=100     # 计算数的个数.
  17&nbsp;LINEWIDTH=20  # 很行要打印的数的个数.
  18&nbsp;
  19&nbsp;Q[1]=1        # 序列的头2个是 1.
  20&nbsp;Q[2]=1
  21&nbsp;
  22&nbsp;echo
  23&nbsp;echo "Q-series [$LIMIT terms]:"
  24&nbsp;echo -n "${Q[1]} "             # 打印头2个数.
  25&nbsp;echo -n "${Q[2]} "
  26&nbsp;
  27&nbsp;for ((n=3; n &#60;= $LIMIT; n++))  # C风格的循环条件.
  28&nbsp;do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  当 n&#62;2 时
  29&nbsp;#  需要将表达式分步计算,
  30&nbsp;#+ 因为Bash不擅长处理此类复杂计算.
  31&nbsp;
  32&nbsp;  let "n1 = $n - 1"        # n-1
  33&nbsp;  let "n2 = $n - 2"        # n-2
  34&nbsp;  
  35&nbsp;  t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
  36&nbsp;  t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]
  37&nbsp;  
  38&nbsp;  T0=${Q[t0]}              # Q[n - Q[n-1]]
  39&nbsp;  T1=${Q[t1]}              # Q[n - Q[n-2]]
  40&nbsp;
  41&nbsp;Q[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - Q[n-2]]
  42&nbsp;echo -n "${Q[n]} "
  43&nbsp;
  44&nbsp;if [ `expr $n % $LINEWIDTH` -eq 0 ]    # 格式化输出.
  45&nbsp;then   #      ^ 取模操作
  46&nbsp;  echo # 把行分成内部的块.
  47&nbsp;fi
  48&nbsp;
  49&nbsp;done
  50&nbsp;
  51&nbsp;echo
  52&nbsp;
  53&nbsp;exit 0
  54&nbsp;
  55&nbsp;# 这是Q-series问题的迭代实现.
  56&nbsp;# 更直接明了的递归实现留给读者完成.
  57&nbsp;# 警告: 递归地计算这个序列会花很长的时间.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>--</P
>
  <P
>Bash 只支持一维数组，但有一些技巧可用来模拟多维数组.</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="TWODIM"
></A
>
  <P
><B
>例子 26-16. 模拟二维数组，并使它倾斜</B
></P
>
  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# twodim.sh: 模拟二维数组.
   3&nbsp;
   4&nbsp;# 一维数组由单行组成.
   5&nbsp;# 二维数组由连续的行组成.
   6&nbsp;
   7&nbsp;Rows=5
   8&nbsp;Columns=5
   9&nbsp;# 5 X 5 的数组Array.
  10&nbsp;
  11&nbsp;declare -a alpha     # char alpha [Rows] [Columns];
  12&nbsp;                     # 不必要的声明. 为什么?
  13&nbsp;
  14&nbsp;load_alpha ()
  15&nbsp;{
  16&nbsp;local rc=0
  17&nbsp;local index
  18&nbsp;
  19&nbsp;for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
  20&nbsp;do     # 如果你高兴，可以使用不同的符号.
  21&nbsp;  local row=`expr $rc / $Columns`
  22&nbsp;  local column=`expr $rc % $Rows`
  23&nbsp;  let "index = $row * $Rows + $column"
  24&nbsp;  alpha[$index]=$i
  25&nbsp;# alpha[$row][$column]
  26&nbsp;  let "rc += 1"
  27&nbsp;done  
  28&nbsp;
  29&nbsp;#  更简单的办法
  30&nbsp;#+   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
  31&nbsp;#+ 但这就缺少了二维数组的感觉了.
  32&nbsp;}
  33&nbsp;
  34&nbsp;print_alpha ()
  35&nbsp;{
  36&nbsp;local row=0
  37&nbsp;local index
  38&nbsp;
  39&nbsp;echo
  40&nbsp;
  41&nbsp;while [ "$row" -lt "$Rows" ]   #  以行顺序为索引打印行的各元素:
  42&nbsp;do                             #+ 即数组列值变化快,
  43&nbsp;                               #+ 行值变化慢.
  44&nbsp;  local column=0
  45&nbsp;
  46&nbsp;  echo -n "       "            #  依行倾斜打印正方形的数组.
  47&nbsp;  
  48&nbsp;  while [ "$column" -lt "$Columns" ]
  49&nbsp;  do
  50&nbsp;    let "index = $row * $Rows + $column"
  51&nbsp;    echo -n "${alpha[index]} "  # alpha[$row][$column]
  52&nbsp;    let "column += 1"
  53&nbsp;  done
  54&nbsp;
  55&nbsp;  let "row += 1"
  56&nbsp;  echo
  57&nbsp;
  58&nbsp;done  
  59&nbsp;
  60&nbsp;# 等同于
  61&nbsp;#     echo ${alpha[*]} | xargs -n $Columns
  62&nbsp;
  63&nbsp;echo
  64&nbsp;}
  65&nbsp;
  66&nbsp;filter ()     # 过滤出负数的数组索引.
  67&nbsp;{
  68&nbsp;
  69&nbsp;echo -n "  "  # 产生倾斜角度.
  70&nbsp;              # 解释怎么办到的.
  71&nbsp;
  72&nbsp;if [[ "$1" -ge 0 &#38;&#38;  "$1" -lt "$Rows" &#38;&#38; "$2" -ge 0 &#38;&#38; "$2" -lt "$Columns" ]]
  73&nbsp;then
  74&nbsp;    let "index = $1 * $Rows + $2"
  75&nbsp;    # Now, print it rotated现在，打印旋转角度.
  76&nbsp;    echo -n " ${alpha[index]}"
  77&nbsp;    #           alpha[$row][$column]
  78&nbsp;fi    
  79&nbsp;
  80&nbsp;}
  81&nbsp;  
  82&nbsp;
  83&nbsp;
  84&nbsp;
  85&nbsp;rotate ()  #  旋转数组 45 度 --
  86&nbsp;{          #+ 在左下角"平衡"图形.
  87&nbsp;local row
  88&nbsp;local column
  89&nbsp;
  90&nbsp;for (( row = Rows; row &#62; -Rows; row-- ))
  91&nbsp;  do       # 从后面步进数组. 为什么?
  92&nbsp;
  93&nbsp;  for (( column = 0; column &#60; Columns; column++ ))
  94&nbsp;  do
  95&nbsp;
  96&nbsp;    if [ "$row" -ge 0 ]
  97&nbsp;    then
  98&nbsp;      let "t1 = $column - $row"
  99&nbsp;      let "t2 = $column"
 100&nbsp;    else
 101&nbsp;      let "t1 = $column"
 102&nbsp;      let "t2 = $column + $row"
 103&nbsp;    fi  
 104&nbsp;
 105&nbsp;    filter $t1 $t2   # 过滤出负数数组索引.
 106&nbsp;                     # 如果你不这样做会怎么样?
 107&nbsp;  done
 108&nbsp;
 109&nbsp;  echo; echo
 110&nbsp;
 111&nbsp;done 
 112&nbsp;
 113&nbsp;#  数组旋转灵感源于Herbert Mayer写的
 114&nbsp;#+ "Advanced C Programming on the IBM PC," 的例子 (页码. 143-146)
 115&nbsp;#+ (看参考书目附录).
 116&nbsp;#  这也能看出C能做的事情有多少能用shell脚本做到.
 117&nbsp;#
 118&nbsp;
 119&nbsp;}
 120&nbsp;
 121&nbsp;
 122&nbsp;#---------------   现在, 可以开始了.     ------------#
 123&nbsp;load_alpha     # 加载数组.
 124&nbsp;print_alpha    # 打印数组.  
 125&nbsp;rotate         # 反时钟旋转数组45度.
 126&nbsp;#-----------------------------------------------------#
 127&nbsp;
 128&nbsp;exit 0
 129&nbsp;
 130&nbsp;# 这是有点做作，不太优雅.
 131&nbsp;
 132&nbsp;# 练习:
 133&nbsp;# ---------
 134&nbsp;# 1)  重写数组加载和打印函数，
 135&nbsp;#     使其更直观和容易了解.
 136&nbsp;#
 137&nbsp;# 2)  指出数组旋转函数是什么原理.
 138&nbsp;#     Hint索引: 思考数组从尾向前索引的实现.
 139&nbsp;#
 140&nbsp;# 3)  重写脚本使其可以处理非方形数组Rewrite this script to handle a non-square array,
 141&nbsp;#     例如 6 X 4 的数组.
 142&nbsp;#     尝试旋转数组时做到最小"失真".</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>二维数组本质上等同于一维数组, 而只增加了使用行和列的位置来引用和操作元素的寻址模式.</P
>
  <P
>关于二维数组更好的例子, 请参考<A
HREF="contributed-scripts.html#LIFESLOW"
>例子 A-10</A
>.</P
>
  <P
>--</P
>
        <P
>另一个有趣的使用数组的脚本:
        <UL
><LI
>
          <P
><A
HREF="commandsub.html#AGRAM2"
>例子 14-3</A
></P
>
        </LI
></UL
>
     </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="list-cons.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="devproc.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>List Constructs</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part4.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>/dev and /proc</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>