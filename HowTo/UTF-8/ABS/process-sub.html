<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Process Substitution</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Advanced Topics"
HREF="part4.html"><LINK
REL="PREVIOUS"
TITLE="Restricted Shells"
HREF="restricted-sh.html"><LINK
REL="NEXT"
TITLE="Functions"
HREF="functions.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=gb2312"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-size:18px;
font-family:"黑体", Arial;
font-weight:bolder;
line-height:200%;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="restricted-sh.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="functions.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
>
  <H1
><A
NAME="PROCESS-SUB"
>第22章. 进程替换</A
></H1
>
  <P
><A
NAME="PROCESSSUBREF"
></A
><TT
CLASS="REPLACEABLE"
><I
>进程替换</I
></TT
>与<a
href="commandsub.html#COMMANDSUBREF"
>命令替换（command substitution）</a
>很相似. 命令替换把一个命令的结果赋给一个变量，例如<B
CLASS="COMMAND"
> dir_contents=`ls -al`</B
>或<B
CLASS="COMMAND"
>xref=$( grep word datafile)</B
>. 进程替换则是把一个进程的输出回馈给另一个进程 (换句话说，它把一个命令的结果发送给另一个命令).</P
>
  <DIV
CLASS="VARIABLELIST"
>
    <P
><B
><A
NAME="COMMANDSPARENS1"
></A
>命令替换的一般形式</B
></P
>
    <DL
>
      <DT
>由圆括号括起的命令</DT
>
      <DD
><P
><B
CLASS="COMMAND"
>&#62;(command)</B
></P
><P
><B
CLASS="COMMAND"
>&#60;(command)</B
></P
>
        <P
>启动进程替换. 它是用<TT
CLASS="FILENAME"
>/dev/fd/&#60;n&#62;</TT
>文件把在圆括号内的进程的处理结果发送给另外一个进程. <A
NAME="AEN14032"
HREF="#FTN.AEN14032"
>[1]</A
> (译者注：实际上现代的UNIX类操作系统提供的/dev/fd/n文件是与文件描述相关的，整数n指的就是在进程运行时对应数字的文件描述符)</P
>
        <DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>在<SPAN
CLASS="QUOTE"
>"&#60;"</SPAN
> 或or <SPAN
CLASS="QUOTE"
>"&#62;"</SPAN
> 与圆括号之间是没有空格的. 如果加了空格将会引起错误信息.</P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo &#62;(true)</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/dev/fd/63</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo &#60;(true)</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/dev/fd/63</TT
>
 	      </PRE
></TD
></TR
></TABLE
>

	  Bash在两个<a
href="io-redirection.html#FDREF"
>文件描述符（file descriptors）</a
>之间创建了一个管道, <TT
CLASS="FILENAME"
>--fIn</TT
> 和 <TT
CLASS="FILENAME"
>fOut--</TT
>. <a
href="internal.html#TRUEREF"
>true</a
>命令的标准输入被连接到fOut(dup2(fOut, 0)), 然后Bash把<tt
class="FILENAME"
>/dev/fd/fIn</tt
>作为参数传给<B
CLASS="COMMAND"
>echo</B
>.如果系统的<tt
class="FILENAME"
>/dev/fd/&#60;n&#62;</tt
>文件不够时，Bash会使用临时文件. (Thanks, S.C.)
	  </P
> 
      <P
>进程替换能比较两个不同命令之间的输出，或者甚至相同命令不同选项的输出.</P
>
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>comm &#60;(ls -l) &#60;(ls -al)</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>total 12
-rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
-rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
-rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
        total 20
        drwxrwxrwx    2 bozo bozo     4096 Mar 10 18:10 .
        drwx------   72 bozo bozo     4096 Mar 10 17:58 ..
        -rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
        -rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
        -rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh</TT
></PRE
></TD
></TR
></TABLE
>
  <P
> 用进程替换来比较两个不同目录的内容 
    (考察哪些文件名是相同的，哪些是不同的): 
  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;diff &#60;(ls $first_directory) &#60;(ls $second_directory)</PRE
></TD
></TR
></TABLE
>
              </P
>
  <P
>其他一些进程替换的用法和技巧:</P
>
  <P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat &#60;(ls -l)
   2&nbsp;# 等同于     ls -l | cat
   3&nbsp;
   4&nbsp;sort -k 9 &#60;(ls -l /bin) &#60;(ls -l /usr/bin) &#60;(ls -l /usr/X11R6/bin)
   5&nbsp;# 列出系统中3个主要的'bin'目录的所有文件，并且按文件名排序.
   6&nbsp;# 注意是三个明显不同的命令输出回馈给'sort'.
   7&nbsp;
   8&nbsp; 
   9&nbsp;diff &#60;(command1) &#60;(command2)    # 给出两个命令输出的不同之处.
  10&nbsp;
  11&nbsp;tar cf &#62;(bzip2 -c &#62; file.tar.bz2) $directory_name
  12&nbsp;# 调用"tar cf /dev/fd/?? $directory_name",和"bzip2 -c &#62; file.tar.bz2".
  13&nbsp;#
  14&nbsp;# 因为/dev/fd/&#60;n&#62;的系统属性,
  15&nbsp;# 所以两个命令之间的管道不必是命名的.
  16&nbsp;#
  17&nbsp;# 这种效果可以模仿出来.
  18&nbsp;#
  19&nbsp;bzip2 -c &#60; pipe &#62; file.tar.bz2&#38;
  20&nbsp;tar cf pipe $directory_name
  21&nbsp;rm pipe
  22&nbsp;#        或者
  23&nbsp;exec 3&#62;&#38;1
  24&nbsp;tar cf /dev/fd/4 $directory_name 4&#62;&#38;1 &#62;&#38;3 3&#62;&#38;- | bzip2 -c &#62; file.tar.bz2 3&#62;&#38;-
  25&nbsp;exec 3&#62;&#38;-
  26&nbsp;
  27&nbsp;
  28&nbsp;# Thanks, St