<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Communications Commands</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="External Filters, Programs and Commands"
HREF="external.html"><LINK
REL="PREVIOUS"
TITLE="File and Archiving Commands"
HREF="filearchiv.html"><LINK
REL="NEXT"
TITLE="Terminal Control Commands"
HREF="terminalccmds.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=gb2312"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default">
</HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-size:18px;
font-family:"黑体", Arial;
font-weight:bolder;
line-height:200%;
"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="filearchiv.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 12. External Filters, Programs and Commands</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="terminalccmds.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
>
  <H1
CLASS="SECT1"
><A
NAME="COMMUNICATIONS"
>12.6. 通讯命令</A
></H1
>
  <P
>下边命令中的某几个命令你会在 &quot;<A
HREF="writingscripts.html#CSPAMMERS"
>追踪垃圾邮件</A
>&quot; 练习中找到其用法, 用来进行网络数据的转换和分析.</P
>
  <DIV
CLASS="VARIABLELIST"
>
    <P
><B
><A
NAME="COMMUNINFO1"
></A
>信息与统计</B
></P
>
    <DL
><DT
><B
CLASS="COMMAND"
>host</B
></DT
><DD
>
      <P
>通过名字或 IP 地址来搜索一个互联网主机的信息, 使用 DNS.</P
>
      <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>host surfacemail.com</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>surfacemail.com. has address 202.92.42.236</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>ipcalc</B
></DT
><DD
>
	      <P
>显示一个主机 IP 信息.
	      使用 <TT
CLASS="OPTION"
>-h</TT
> 选项,
	      <B
CLASS="COMMAND"
>ipcalc</B
> 将会做一个 DNS 的反向查询, 通过 IP 地址找到主机(服务器)名.</P
>
	      <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ipcalc -h 202.92.42.236</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>HOSTNAME=surfacemail.com</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>nslookup</B
></DT
><DD
>
	      <P
>通过 IP 地址在一个主机上做一个互联网的 &quot;名字服务查询&quot;. 事实上这与<B
CLASS="COMMAND"
> ipcalc -h</B
> 或 <B
CLASS="COMMAND"
>dig -x
	      </B
>等价. 这个命令既可以交互运行也可以非交互运行, 换句话说, 就是在脚本中运行.</P
>
	      <P
><B
CLASS="COMMAND"
>nslookup</B
> 命令据说已经慢慢被&quot;忽视&quot;了, 但是它还是有它的用处.</P
>
	      <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>nslookup -sil 66.97.104.180</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>nslookup kuhleersparnis.ch
 Server:         135.116.137.2
 Address:        135.116.137.2#53

 Non-authoritative answer:
 Name:   kuhleersparnis.ch</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	  </P
></DD
><DT
><B
CLASS="COMMAND"
>dig</B
></DT
><DD
>
	    <P
>域信息查询. 与
	      <B
CLASS="COMMAND"
>nslookup</B
> 很相似, <B
CLASS="COMMAND"
>dig</B
> 在一个主机上做一个互联网的 &quot;名字服务查询&quot;.
	      这个命令既可以交互运行也可以非交互运行, 换句话说, 就是在脚本中运行.</P
>
	    <P
>下边是一些 <strong>dig</strong> 命令有趣的选项, <TT
CLASS="OPTION"
>+time=N</TT
> 选项用来设置查询超时为 <em>N</em> 秒, <TT
CLASS="OPTION"
>+nofail</TT
> 选项用来持续查询服务器直到收到一个响应, <TT
CLASS="OPTION"
>-x</TT
> 选项会做反向地址查询.</P
>
	    <P
>比较下边这3个命令的输出, <B
CLASS="COMMAND"
>dig -x</B
> ,
	      <B
CLASS="COMMAND"
>ipcalc -h</B
> 和
	      <B
CLASS="COMMAND"
>nslookup</B
>.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>dig -x 81.9.6.2</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>;; Got answer:
 ;; -&#62;&#62;HEADER&#60;&#60;- opcode: QUERY, status: NXDOMAIN, id: 11649
 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0

 ;; QUESTION SECTION:
 ;2.6.9.81.in-addr.arpa.         IN      PTR

 ;; AUTHORITY SECTION:
 6.9.81.in-addr.arpa.    3600    IN      SOA     ns.eltel.net. noc.eltel.net.
 2002031705 900 600 86400 3600

 ;; Query time: 537 msec
 ;; SERVER: 135.116.137.2#53(135.116.137.2)
 ;; WHEN: Wed Jun 26 08:35:24 2002
 ;; MSG SIZE  rcvd: 91</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	  </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SPAMLOOKUP"
></A
><P
><B
>Example 12-36. <span class="PROGRAMLISTING">查找滥用的连接来报告垃圾邮件发送者</span></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# spam-lookup.sh: 查找滥用的连接来报告垃圾邮件发送者.
   3&nbsp;# 感谢 Michael Zick.
   4&nbsp;
   5&nbsp;# 检查命令行参数.
   6&nbsp;ARGCOUNT=1
   7&nbsp;E_WRONGARGS=65
   8&nbsp;if [ $# -ne "$ARGCOUNT" ]
   9&nbsp;then
  10&nbsp;  echo "Usage: `basename $0` domain-name"
  11&nbsp;  exit $E_WRONGARGS
  12&nbsp;fi
  13&nbsp;
  14&nbsp;
  15&nbsp;dig +short $1.contacts.abuse.net -c in -t txt
  16&nbsp;# 也试试:
  17&nbsp;#     dig +nssearch $1
  18&nbsp;#     尽量找到 &quot;可信赖的名字服务器&quot; 并且显示 SOA 记录.
  19&nbsp;
  20&nbsp;# 下边这句也可以:
  21&nbsp;#     whois -h whois.abuse.net $1
  22&nbsp;#           ^^ ^^^^^^^^^^^^^^^  指定主机.
  23&nbsp;#     使用这个命令也可以查找多个垃圾邮件发送者, 比如:"
  24&nbsp;#     whois -h whois.abuse.net $spamdomain1 $spamdomain2 . . .
  25&nbsp;
  26&nbsp;
  27&nbsp;#  练习:
  28&nbsp;#  -----
  29&nbsp;#  扩展这个脚本的功能,
  30&nbsp;#+ 让它可以自动发送 e-mail 来通知
  31&nbsp;#+ 需要对此负责的 ISP 的联系地址.
  32&nbsp;#  暗示: 使用 "mail" 命令.
  33&nbsp;
  34&nbsp;exit $?
  35&nbsp;
  36&nbsp;# spam-lookup.sh chinatietong.com
  37&nbsp;#                一个已知的垃圾邮件域.(译者: 中国铁通. . .)
  38&nbsp;
  39&nbsp;# "crnet_mgr@chinatietong.com"
  40&nbsp;# "crnet_tec@chinatietong.com"
  41&nbsp;# "postmaster@chinatietong.com"
  42&nbsp;
  43&nbsp;
  44&nbsp;#  如果想找到这个脚本的一个更详尽的版本,
  45&nbsp;#+ 请访问 SpamViz 的主页, http://www.spamviz.net/index.html.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ISSPAMMER"
></A
>
    <P
><B
>Example 12-37. 分析一个垃圾邮件域</B
>&lt;rojy bug&gt;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;# is-spammer.sh: 鉴别一个垃圾邮件域
   3&nbsp;
   4&nbsp;# $Id: is-spammer, v 1.4 2004/09/01 19:37:52 mszick Exp $
   5&nbsp;# 上边这行是 RCS ID 信息.
   6&nbsp;#
   7&nbsp;#  这是附件中捐献脚本 is_spammer.bash
   8&nbsp;#+ 的一个简单版本.
   9&nbsp;
  10&nbsp;# is-spammer &#60;domain.name&#62;
  11&nbsp;
  12&nbsp;# 使用外部程序: 'dig'
  13&nbsp;# 测试版本: 9.2.4rc5
  14&nbsp;
  15&nbsp;# 使用函数.
  16&nbsp;# 使用 IFS 来分析分配在数组中的字符串.
  17&nbsp;# 检查 e-mail 黑名单.
  18&nbsp;
  19&nbsp;# 使用来自文本体中的 domain.name:
  20&nbsp;# http://www.good_stuff.spammer.biz/just_ignore_everything_else
  21&nbsp;#                       ^^^^^^^^^^^
  22&nbsp;# 或者使用来自任意 e-mail 地址的 domain.name:
  23&nbsp;# Really_Good_Offer@spammer.biz
  24&nbsp;#
  25&nbsp;# 并将其作为这个脚本的唯一参数.
  26&nbsp;#(另: 你的 Inet 连接应该保证连接)
  27&nbsp;#
  28&nbsp;# 这样, 在上边两个实例中调用这个脚本:
  29&nbsp;#       is-spammer.sh spammer.biz
  30&nbsp;
  31&nbsp;
  32&nbsp;# Whitespace == :Space:Tab:Line Feed:Carriage Return:
  33&nbsp;WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'
  34&nbsp;
  35&nbsp;# No Whitespace == Line Feed:Carriage Return
  36&nbsp;No_WSP=$'\x0A'$'\x0D'
  37&nbsp;
  38&nbsp;# 域分隔符为点分10进制 ip 地址
  39&nbsp;ADR_IFS=${No_WSP}'.'
  40&nbsp;
  41&nbsp;# 取得 dns 文本资源记录.
  42&nbsp;# get_txt &#60;error_code&#62; &#60;list_query&#62;
  43&nbsp;get_txt() {
  44&nbsp;
  45&nbsp;    # 分析在&quot;.&quot;中分配的 $1.
  46&nbsp;    local -a dns
  47&nbsp;    IFS=$ADR_IFS
  48&nbsp;    dns=( $1 )
  49&nbsp;    IFS=$WSP_IFS
  50&nbsp;    if [ "${dns[0]}" == '127' ]
  51&nbsp;    then
  52&nbsp;        # 查看此处是否有原因.
  53&nbsp;        echo $(dig +short $2 -t txt)
  54&nbsp;    fi
  55&nbsp;}
  56&nbsp;
  57&nbsp;# 取得 dns 地址资源记录.
  58&nbsp;# chk_adr &#60;rev_dns&#62; &#60;list_server&#62;
  59&nbsp;chk_adr() {
  60&nbsp;    local reply
  61&nbsp;    local server
  62&nbsp;    local reason
  63&nbsp;
  64&nbsp;    server=${1}${2}
  65&nbsp;    reply=$( dig +short ${server} )
  66&nbsp;
  67&nbsp;    # 假设应答可能是一个错误码 . . .
  68&nbsp;    if [ ${#reply} -gt 6 ]
  69&nbsp;    then
  70&nbsp;        reason=$(get_txt ${reply} ${server} )
  71&nbsp;        reason=${reason:-${reply}}
  72&nbsp;    fi
  73&nbsp;    echo ${reason:-' not blacklisted.'}
  74&nbsp;}
  75&nbsp;
  76&nbsp;# 需要从名字中取得 IP 地址.
  77&nbsp;echo 'Get address of: '$1
  78&nbsp;ip_adr=$(dig +short $1)
  79&nbsp;dns_reply=${ip_adr:-' no answer '}
  80&nbsp;echo ' Found address: '${dns_reply}
  81&nbsp;
  82&nbsp;# 一个可用的应答至少是4个数字加上3个点.
  83&nbsp;if [ ${#ip_adr} -gt 6 ]
  84&nbsp;then
  85&nbsp;    echo
  86&nbsp;    declare query
  87&nbsp;
  88&nbsp;    # 分析点中的分配.
  89&nbsp;    declare -a dns
  90&nbsp;    IFS=$ADR_IFS
  91&nbsp;    dns=( ${ip_adr} )
  92&nbsp;    IFS=$WSP_IFS
  93&nbsp;
  94&nbsp;    # Reorder octets into dns query order.
  95&nbsp;    rev_dns="${dns[3]}"'.'"${dns[2]}"'.'"${dns[1]}"'.'"${dns[0]}"'.'
  96&nbsp;
  97&nbsp;# 参见: http://www.spamhaus.org (Conservative, well maintained)
  98&nbsp;    echo -n 'spamhaus.org says: '
  99&nbsp;    echo $(chk_adr ${rev_dns} 'sbl-xbl.spamhaus.org')
 100&nbsp;
 101&nbsp;# 参见: http://ordb.org (Open mail relays)
 102&nbsp;    echo -n '   ordb.org  says: '
 103&nbsp;    echo $(chk_adr ${rev_dns} 'relays.ordb.org')
 104&nbsp;
 105&nbsp;# 参见: http://www.spamcop.net/ (你可以在这里报告 spammer)
 106&nbsp;    echo -n ' spamcop.net says: '
 107&nbsp;    echo $(chk_adr ${rev_dns} 'bl.spamcop.net')
 108&nbsp;
 109&nbsp;# # # 其他的黑名单操作 # # #
 110&nbsp;
 111&nbsp;# 参见: http://cbl.abuseat.org.
 112&nbsp;    echo -n ' abuseat.org says: '
 113&nbsp;    echo $(chk_adr ${rev_dns} 'cbl.abuseat.org')
 114&nbsp;
 115&nbsp;# 参见: http://dsbl.org/usage (Various mail relays)
 116&nbsp;    echo
 117&nbsp;    echo 'Distributed Server Listings'
 118&nbsp;    echo -n '       list.dsbl.org says: '
 119&nbsp;    echo $(chk_adr ${rev_dns} 'list.dsbl.org')
 120&nbsp;
 121&nbsp;    echo -n '   multihop.dsbl.org says: '
 122&nbsp;    echo $(chk_adr ${rev_dns} 'multihop.dsbl.org')
 123&nbsp;
 124&nbsp;    echo -n 'unconfirmed.dsbl.org says: '
 125&nbsp;    echo $(chk_adr ${rev_dns} 'unconfirmed.dsbl.org')
 126&nbsp;
 127&nbsp;else
 128&nbsp;    echo
 129&nbsp;    echo 'Could not use that address.'
 130&nbsp;fi
 131&nbsp;
 132&nbsp;exit 0
 133&nbsp;
 134&nbsp;# 练习:
 135&nbsp;# -----
 136&nbsp;
 137&nbsp;# 1) 检查脚本的参数,
 138&nbsp;#    并且如果必要的话使用合适的错误消息退出.
 139&nbsp;
 140&nbsp;# 2) 检查调用这个脚本的时候是否在线,
 141&nbsp;#    并且如果必要的话使用合适的错误消息退出.
 142&nbsp;
 143&nbsp;# 3) Substitute generic variables for "hard-coded" BHL domains.
 144&nbsp;
 145&nbsp;# 4) 通过对 'dig' 命令使用 &quot;+time=&quot; 选项
 146&nbsp;     来给这个脚本设置一个暂停.</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>想获得比上边这个脚本更详细的版本, 参见 <A
HREF="contributed-scripts.html#ISSPAMMER2"
>Example A-27</A
>.</P
>
	  </DD
><DT
><B
CLASS="COMMAND"
>traceroute</B
></DT
><DD
>
	      <P
>跟踪包发送到远端主机过程中的路由信息. 这个命令在 LAN, WAN, 或者在
	      Internet 上都可以正常工作. 远端主机可以通过 IP 地址来指定. 这个命令的输出也可以通过管道中的 <A
HREF="textproc.html#GREPREF"
>grep</A
> 或 <A
HREF="sedawk.html#SEDREF"
>sed</A
> 命令来过滤.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>traceroute 81.9.6.2</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets
 1  tc43.xjbnnbrb.com (136.30.178.8)  191.303 ms  179.400 ms  179.767 ms
 2  or0.xjbnnbrb.com (136.30.178.1)  179.536 ms  179.534 ms  169.685 ms
 3  192.168.11.101 (192.168.11.101)  189.471 ms  189.556 ms *
 ...</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	  </P
></DD
><DT
><A
NAME="PINGREF"
></A
><B
CLASS="COMMAND"
>ping</B
></DT
><DD
>
	      <P
>广播一个 <SPAN
CLASS="QUOTE"
>"ICMP ECHO_REQUEST"</SPAN
> 包到其他主机上, 既可以是本地网络也可以使远端网络. 这是一个测试网络连接的诊断工具, 应该小心使用.</P
>
	      <P
>一个成功的 <B
CLASS="COMMAND"
>ping</B
> 返回的 <A
HREF="exit-status.html#EXITSTATUSREF"
>退出码</A
> 为
	      <SPAN
CLASS="ERRORCODE"
>0</SPAN
>. 可以用在脚本的测试语句中.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ping localhost</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec

 --- localhost.localdomain ping statistics ---
 2 packets transmitted, 2 packets received, 0% packet loss
 round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><A
NAME="WHOISREF"
></A
><B
CLASS="COMMAND"
>whois</B
></DT
><DD
>
	      <P
>执行DNS (域名系统) 查询lookup. <TT
CLASS="OPTION"
>-h</TT
> 选项允许指定需要查询的特定的 <I
CLASS="EMPHASIS"
>whois</I
> 服务器. 参见
	      <A
HREF="othertypesv.html#EX18"
>Example 4-6</A
> 和 <A
HREF="communications.html#SPAMLOOKUP"
>Example 12-36</A
>.</P
>
	    </DD
><DT
><B
CLASS="COMMAND"
>finger</B
></DT
><DD
>
	      <P
>取得网络上的用户信息. 另外这个命令可以显示一个用户的<TT
CLASS="FILENAME"
>~/.plan</TT
>, <TT
CLASS="FILENAME"
>~/.project</TT
>, 和 <TT
CLASS="FILENAME"
>~/.forward</TT
> 文件, 如果存在的话.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>finger</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Login  Name           Tty      Idle  Login Time   Office     Office Phone
 bozo   Bozo Bozeman   tty1        8  Jun 25 16:59
 bozo   Bozo Bozeman   ttyp0          Jun 25 16:59
 bozo   Bozo Bozeman   ttyp1          Jun 25 17:07</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>finger bozo</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Login: bozo                             Name: Bozo Bozeman
 Directory: /home/bozo                   Shell: /bin/bash
 Office: 2355 Clown St., 543-1234
 On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
 On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
 On since Fri Aug 31 20:13 (MST) on pts/1
 On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
 No mail.
 No Plan.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
>处于安全上的考虑, 许多网络都禁用了 <B
CLASS="COMMAND"
>finger</B
> 以及和它相关的幽灵进程.
	          <A
NAME="AEN9738"
HREF="#FTN.AEN9738"
>[1]</A
>	      </P
>
	    </DD
><DT
><B
CLASS="COMMAND"
>chfn</B
></DT
><DD
>
	      <P
>修改 <strong>finger</strong> 命令所显示出来的用户信息.</P
>
	    </DD
><DT
><B
CLASS="COMMAND"
>vrfy</B
></DT
><DD
>
	        <P
>验证一个互联网的 e-mail 地址.</P
>
	      </DD
></DL
>
  </DIV
><DIV
CLASS="VARIABLELIST"
>
    <P
><B
><A
NAME="COMMREMOTE1"
></A
>远端主机接入</B
></P
>
    <DL
><DT
><B
CLASS="COMMAND"
>sx</B
>, <B
CLASS="COMMAND"
>rx</B
></DT
><DD
>
      <P
><B
CLASS="COMMAND"
>sx</B
> 和 <B
CLASS="COMMAND"
>rx</B
>
	      命令使用 <I
CLASS="EMPHASIS"
>xmodem</I
> 协议, 设置服务来向远端主机传输文件和接收文件. 这些都是通讯安装包的一般部分, 比如
	      <B
CLASS="COMMAND"
>minicom</B
>.</P
>
    </DD
><DT
><B
CLASS="COMMAND"
>sz</B
>, <B
CLASS="COMMAND"
>rz</B
></DT
><DD
>
      <P
><B
CLASS="COMMAND"
>sz</B
> 和 <B
CLASS="COMMAND"
>rz</B
> 命令使用<I
CLASS="EMPHASIS"
> zmodem</I
> 协议, 设置服务来向远端主机传输文件和接收文件. <I
CLASS="EMPHASIS"
>zmodem</I
> 协议在某些方面比 <I
CLASS="EMPHASIS"
>xmodem</I
>强, 比如使用更快的的传输波特率, 并且可以对中断的文件进行续传.与 <B
CLASS="COMMAND"
>sx</B
> 一样 <B
CLASS="COMMAND"
>rx</B
>,
	      这些都是通讯安装包的一般部分.</P
>
    </DD
><DT
><A
NAME="FTPREF"
></A
><B
CLASS="COMMAND"
>ftp</B
></DT
><DD
>
	        <P
>向远端服务器上传或下载的工具和协议. 一个ftp会话可以写到脚本中自动运行. (见 <A
HREF="here-docs.html#EX72"
>Example 17-6</A
>, <A
HREF="contributed-scripts.html#ENCRYPTEDPW"
>Example A-4</A
>, 和 <A
HREF="contributed-scripts.html#FTPGET"
>Example A-13</A
>).</P
>
	      </DD
><DT
><B
CLASS="COMMAND"
>uucp</B
>, <B
CLASS="COMMAND"
>uux</B
>, <B
CLASS="COMMAND"
>cu</B
></DT
><DD
>
	      <P
><B
CLASS="COMMAND"
>uucp</B
>: <I
CLASS="EMPHASIS"
>UNIX 到 UNIX
	      拷贝</I
>. 这是一个通讯安装包, 目的是为了在 UNIX 服务器之间传输文件. 使用 shell 脚本来处理 <strong>uucp</strong> 命令序列是一种有效的方法.</P
>
	      <P
>因为互联网和电子邮件的出现, 
	      <B
CLASS="COMMAND"
>uucp</B
> 现在看起来已经很落伍了, 但是这个命令在互联网连接不可用或者不适合使用的地方, 这个命令还是可以完美的运行. <B
CLASS="COMMAND"
>uucp</B
>
	      的优点就是它的容错性, 即使有一个服务将拷贝操作中断了, 那么当连接恢复的时候, 这个命令还是可以在中断的地方续传.</P
><P
>---</P
>
	      <P
><B
CLASS="COMMAND"
>uux</B
>: <I
CLASS="EMPHASIS"
>UNIX 到 UNIX 执行</I
>.
              在远端系统上执行一个命令.这个命令是 <B
CLASS="COMMAND"
>uucp</B
> 包的一部分.</P
><P
>---</P
>
              <P
><B
CLASS="COMMAND"
>cu</B
>: <I
CLASS="EMPHASIS"
>C</I
>all <I
CLASS="EMPHASIS"
>U</I
>p
	      一个远端系统并且作为一个简单终端进行连接.
              这是一个 <A
HREF="communications.html#TELNETREF"
>telnet</A
> 的缩减版本.  这个命令是 <B
CLASS="COMMAND"
>uucp</B
> 包的一部分.</P
>
	      </DD
><DT
><A
NAME="TELNETREF"
></A
><B
CLASS="COMMAND"
>telnet</B
></DT
><DD
>
                <P
>连接远端主机的工具和协议.</P
>
                <DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>telnet 协议本身包含安全漏洞, 因此我们应该适当的避免使用.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="WGETREF"
></A
><B
CLASS="COMMAND"
>wget</B
></DT
><DD
>
	      <P
><B
CLASS="COMMAND"
>wget</B
> 工具使用非交互的形式从 web 或 ftp 站点上取得或下载文件. 在脚本中使用正好.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;wget -p http://www.xyz23.com/file01.html
   2&nbsp;#  The -p or --page-requisite 选项将会使得 wget 取得显示指定页时
   3&nbsp;#+ 所需要的所有文件.(译者: 比如内嵌图片和样式表等).
   4&nbsp;
   5&nbsp;wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -O $SAVEFILE
   6&nbsp;#  -r 选项将会递归的从指定站点
   7&nbsp;#+ 上下载所有连接.</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="QUOTEFETCH"
></A
>
   <P
><B
>Example 12-38. 获得一份股票报价</B
></P
>
   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# quote-fetch.sh: 下载一份股票报价.
   3&nbsp;
   4&nbsp;
   5&nbsp;E_NOPARAMS=66
   6&nbsp;
   7&nbsp;if [ -z "$1" ]  # 必须指定需要获取的股票(代号).
   8&nbsp;  then echo "Usage: `basename $0` stock-symbol"
   9&nbsp;  exit $E_NOPARAMS
  10&nbsp;fi
  11&nbsp;
  12&nbsp;stock_symbol=$1
  13&nbsp;
  14&nbsp;file_suffix=.html
  15&nbsp;# 获得一个 HTML 文件, 所以要正确命名它.
  16&nbsp;URL='http://finance.yahoo.com/q?s='
  17&nbsp;# Yahoo 金融板块, 后缀是股票查询.
  18&nbsp;
  19&nbsp;# -----------------------------------------------------------
  20&nbsp;wget -O ${stock_symbol}${file_suffix} "${URL}${stock_symbol}"
  21&nbsp;# -----------------------------------------------------------
  22&nbsp;
  23&nbsp;
  24&nbsp;# 在 http://search.yahoo.com 上查询相关材料:
  25&nbsp;# -----------------------------------------------------------
  26&nbsp;# URL="http://search.yahoo.com/search?fr=ush-news&#38;p=${query}"
  27&nbsp;# wget -O "$savefilename" "${URL}"
  28&nbsp;# -----------------------------------------------------------
  29&nbsp;# 保存相关 URL 的列表.
  30&nbsp;
  31&nbsp;exit $?
  32&nbsp;
  33&nbsp;# 练习:
  34&nbsp;# -----
  35&nbsp;#
  36&nbsp;# 1) 添加一个测试来验证用户正在线.
  37&nbsp;#    (暗示: 对 &quot;ppp&quot; 或 &quot;connect&quot; 来分析 'ps -ax' 的输出.
  38&nbsp;#
  39&nbsp;# 2) 修改这个脚本, 让这个脚本具有获得本地天气预报的能力,
  40&nbsp;#+   将用户的 zip code 作为参数.</PRE
></TD
></TR
></TABLE
><HR></DIV
>
   <P
>参见 <A
HREF="contributed-scripts.html#WGETTER2"
>Example A-29</A
> 和 <A
HREF="contributed-scripts.html#BASHPODDER"
>Example A-30</A
>.</P
>
                </DD
><DT
><A
NAME="LYNXREF"
></A
><B
CLASS="COMMAND"
>lynx</B
></DT
><DD
>
                  <P
><B
CLASS="COMMAND"
>lynx</B
> 是一个网页浏览器, 也是一个文件浏览器. 它可以(通过使用 -dump 选项)在脚本中使用. 它的作用是可以从 Web 或 ftp 站点上非交互的获得文件.
                  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;lynx -dump http://www.xyz23.com/file01.html &#62;$SAVEFILE</PRE
></TD
></TR
></TABLE
>
            </P
>
            <P
>使用 <TT
CLASS="OPTION"
>-traversal</TT
> 选项,
	      <B
CLASS="COMMAND"
>lynx</B
> 将从参数中指定的 HTTP URL 开始, 遍历指定服务器上的所有链接. 如果与 <TT
CLASS="OPTION"
>-crawl</TT
> 选项一起用的话, 将会把每个输出的页面文本都放到一个 log 文件中.</P
>
                </DD
><DT
><B
CLASS="COMMAND"
>rlogin</B
></DT
><DD
>
                  <P
><TT
CLASS="REPLACEABLE"
><I
>远端登陆</I
></TT
>, 在远端的主机上开启一个会话. 这个命令存在安全隐患, 所以要使用 <A
HREF="communications.html#SSHREF"
>ssh</A
> 来代替.</P
>
                </DD
><DT
><B
CLASS="COMMAND"
>rsh</B
></DT
><DD
>
                  <P
><TT
CLASS="REPLACEABLE"
><I
>远端 shell</I
></TT
>, 在远端的主机上执行命令. 这个命令存在安全隐患,
	      所以要使用 <B
CLASS="COMMAND"
>ssh</B
> 来代替.</P
>
                </DD
><DT
><B
CLASS="COMMAND"
>rcp</B
></DT
><DD
>
                  <P
><TT
CLASS="REPLACEABLE"
><I
>远端拷贝</I
></TT
>, 在网络上的不同主机间拷贝文件.</P
>
                </DD
><DT
><B
CLASS="COMMAND"
>rsync</B
></DT
><DD
>
                  <P
><TT
CLASS="REPLACEABLE"
><I
>远端同步</I
></TT
>, 在网络上的不同主机间(同步)更新文件.</P
>
                  <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>rsync -a ~/sourcedir/*txt /node1/subdirectory/</B
></TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FC4UPD"
></A
>
	    <P
><B
>Example 12-39. 更新 Fedora 4</B
> &lt;rojy bug&gt; </P
>
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# fc4upd.sh
   3&nbsp;
   4&nbsp;# 脚本作者: Frank Wang.
   5&nbsp;# 本书作者作了少量修改.
   6&nbsp;# 授权在本书中使用.
   7&nbsp;
   8&nbsp;
   9&nbsp;#  使用 rsync 命令从镜像站点上下载 Fedora 4 的更新.
  10&nbsp;#  为了节省空间, 如果有多个版本存在的话,
  11&nbsp;#+ 只下载最新的包.
  12&nbsp;
  13&nbsp;URL=rsync://distro.ibiblio.org/fedora-linux-core/updates/
  14&nbsp;# URL=rsync://ftp.kddilabs.jp/fedora/core/updates/
  15&nbsp;# URL=rsync://rsync.planetmirror.com/fedora-linux-core/updates/
  16&nbsp;
  17&nbsp;DEST=${1:-/var/www/html/fedora/updates/}
  18&nbsp;LOG=/tmp/repo-update-$(/bin/date +%Y-%m-%d).txt
  19&nbsp;PID_FILE=/var/run/${0##*/}.pid
  20&nbsp;
  21&nbsp;E_RETURN=65        # 某些意想不到的错误.
  22&nbsp;
  23&nbsp;
  24&nbsp;# 一搬 rsync 选项
  25&nbsp;# -r: 递归下载
  26&nbsp;# -t: 保存时间
  27&nbsp;# -v: verbose
  28&nbsp;
  29&nbsp;OPTS="-rtv --delete-excluded --delete-after --partial"
  30&nbsp;
  31&nbsp;# rsync include 模式
  32&nbsp;# Leading slash causes absolute path name match.
  33&nbsp;INCLUDE=(
  34&nbsp;    "/4/i386/kde-i18n-Chinese*" 
  35&nbsp;#   ^                         ^
  36&nbsp;# 双引号是必须的, 用来防止file globbing.
  37&nbsp;) 
  38&nbsp;
  39&nbsp;
  40&nbsp;# rsync exclude 模式
  41&nbsp;# 使用 &quot;#&quot; 临时注释掉一些不需要的包.
  42&nbsp;EXCLUDE=(
  43&nbsp;    /1
  44&nbsp;    /2
  45&nbsp;    /3
  46&nbsp;    /testing
  47&nbsp;    /4/SRPMS
  48&nbsp;    /4/ppc
  49&nbsp;    /4/x86_64
  50&nbsp;    /4/i386/debug
  51&nbsp;   "/4/i386/kde-i18n-*"
  52&nbsp;   "/4/i386/openoffice.org-langpack-*"
  53&nbsp;   "/4/i386/*i586.rpm"
  54&nbsp;   "/4/i386/GFS-*"
  55&nbsp;   "/4/i386/cman-*"
  56&nbsp;   "/4/i386/dlm-*"
  57&nbsp;   "/4/i386/gnbd-*"
  58&nbsp;   "/4/i386/kernel-smp*"
  59&nbsp;#  "/4/i386/kernel-xen*" 
  60&nbsp;#  "/4/i386/xen-*" 
  61&nbsp;)
  62&nbsp;
  63&nbsp;
  64&nbsp;init () {
  65&nbsp;    # 让管道命令返回可能的 rsync 错误, 比如, 网络延时(stalled network).
  66&nbsp;    set -o pipefail
  67&nbsp;
  68&nbsp;    TMP=${TMPDIR:-/tmp}/${0##*/}.$$     # 保存精炼的下载列表.
  69&nbsp;    trap "{
  70&nbsp;        rm -f $TMP 2&#62;/dev/null
  71&nbsp;    }" EXIT                             # 删除存在的临时文件.
  72&nbsp;}
  73&nbsp;
  74&nbsp;
  75&nbsp;check_pid () {
  76&nbsp;# 检查进程是否存在.
  77&nbsp;    if [ -s "$PID_FILE" ]; then
  78&nbsp;        echo "PID file exists. Checking ..."
  79&nbsp;        PID=$(/bin/egrep -o "^[[:digit:]]+" $PID_FILE)
  80&nbsp;        if /bin/ps --pid $PID &#38;&#62;/dev/null; then
  81&nbsp;            echo "Process $PID found. ${0##*/} seems to be running!"
  82&nbsp;           /usr/bin/logger -t ${0##*/} \
  83&nbsp;                 "Process $PID found. ${0##*/} seems to be running!"
  84&nbsp;            exit $E_RETURN
  85&nbsp;        fi
  86&nbsp;        echo "Process $PID not found. Start new process . . ."
  87&nbsp;    fi
  88&nbsp;}
  89&nbsp;
  90&nbsp;
  91&nbsp;#  根据上边的模式,
  92&nbsp;#+ 设置整个文件的更新范围, 从 root 或 $URL 开始.
  93&nbsp;set_range () {
  94&nbsp;    include=
  95&nbsp;    exclude=
  96&nbsp;    for p in "${INCLUDE[@]}"; do
  97&nbsp;        include="$include --include \"$p\""
  98&nbsp;    done
  99&nbsp;
 100&nbsp;    for p in "${EXCLUDE[@]}"; do
 101&nbsp;        exclude="$exclude --exclude \"$p\""
 102&nbsp;    done
 103&nbsp;}
 104&nbsp;
 105&nbsp;
 106&nbsp;# 获得并提炼 rsync 更新列表.
 107&nbsp;get_list () {
 108&nbsp;    echo $$ &#62; $PID_FILE || {
 109&nbsp;        echo "Can't write to pid file $PID_FILE"
 110&nbsp;        exit $E_RETURN
 111&nbsp;    }
 112&nbsp;
 113&nbsp;    echo -n "Retrieving and refining update list . . ."
 114&nbsp;
 115&nbsp;    # 获得列表 -- 为了作为单个命令来运行 rsync 需要 'eval'.
 116&nbsp;    # $3 和 $4 是文件创建的日期和时间.
 117&nbsp;    # $5 是完整的包名字.
 118&nbsp;    previous=
 119&nbsp;    pre_file=
 120&nbsp;    pre_date=0
 121&nbsp;    eval /bin/nice /usr/bin/rsync \
 122&nbsp;        -r $include $exclude $URL | \
 123&nbsp;        egrep '^dr.x|^-r' | \
 124&nbsp;        awk '{print $3, $4, $5}' | \
 125&nbsp;        sort -k3 | \
 126&nbsp;        { while read line; do
 127&nbsp;            # 获得这段运行的秒数, 过滤掉不用的包.
 128&nbsp;            cur_date=$(date -d "$(echo $line | awk '{print $1, $2}')" +%s)
 129&nbsp;            #  echo $cur_date
 130&nbsp;
 131&nbsp;            # 取得文件名.
 132&nbsp;            cur_file=$(echo $line | awk '{print $3}')
 133&nbsp;            #  echo $cur_file
 134&nbsp;
 135&nbsp;            # 如果可能的话, 从文件名中取得 rpm 的包名字.
 136&nbsp;            if [[ $cur_file == *rpm ]]; then
 137&nbsp;                pkg_name=$(echo $cur_file | sed -r -e \
 138&nbsp;                    's/(^([^_-]+[_-])+)[[:digit:]]+\..*[_-].*$/\1/')
 139&nbsp;            else
 140&nbsp;                pkg_name=
 141&nbsp;            fi
 142&nbsp;            # echo $pkg_name
 143&nbsp;
 144&nbsp;            if [ -z "$pkg_name" ]; then   #  如果不是一个 rpm 文件,
 145&nbsp;                echo $cur_file &#62;&#62; $TMP    #+ 然后添加到下载列表里.
 146&nbsp;            elif [ "$pkg_name" != "$previous" ]; then   # 发现一个新包.
 147&nbsp;                echo $pre_file &#62;&#62; $TMP                  # 输出最新的文件.
 148&nbsp;                previous=$pkg_name                      # 保存当前状态.
 149&nbsp;                pre_date=$cur_date
 150&nbsp;                pre_file=$cur_file
 151&nbsp;            elif [ "$cur_date" -gt "$pre_date" ]; then  #  如果是相同的包, 但是更新一些,
 152&nbsp;                pre_date=$cur_date                      #+ 那么就更新最新的.
 153&nbsp;                pre_file=$cur_file
 154&nbsp;            fi
 155&nbsp;            done
 156&nbsp;            echo $pre_file &#62;&#62; $TMP                      #  TMP 现在包含所有
 157&nbsp;                                                        #+ 提炼过的列表.
 158&nbsp;            # echo "subshell=$BASH_SUBSHELL"
 159&nbsp;
 160&nbsp;    }       # 这里的打括号是为了让最后这句&quot;echo $pre_file &gt;&gt; $TMP&quot;
 161&nbsp;            # 也能与整个循环一起放到同一个子 shell ( 1 )中.
 162&nbsp;
 163&nbsp;    RET=$?  # 取得管道命令的返回码.
 164&nbsp;
 165&nbsp;    [ "$RET" -ne 0 ] &#38;&#38; {
 166&nbsp;        echo "List retrieving failed with code $RET"
 167&nbsp;        exit $E_RETURN
 168&nbsp;    }
 169&nbsp;
 170&nbsp;    echo "done"; echo
 171&nbsp;}
 172&nbsp;
 173&nbsp;# 真正的 rsync 的下载部分.
 174&nbsp;get_file () {
 175&nbsp;
 176&nbsp;    echo "Downloading..."
 177&nbsp;    /bin/nice /usr/bin/rsync \
 178&nbsp;        $OPTS \
 179&nbsp;        --filter "merge,+/ $TMP" \
 180&nbsp;        --exclude '*'  \
 181&nbsp;        $URL $DEST     \
 182&nbsp;        | /usr/bin/tee $LOG
 183&nbsp;
 184&nbsp;    RET=$?
 185&nbsp;
 186&nbsp;        #  --filter merge,+/ is crucial for the intention. 
 187&nbsp;        #  + modifier means include and / means absolute path.
 188&nbsp;        #  Then sorted list in $TMP will contain ascending dir name and 
 189&nbsp;        #+ prevent the following --exclude '*' from "shortcutting the circuit." 
 190&nbsp;
 191&nbsp;    echo "Done"
 192&nbsp;
 193&nbsp;    rm -f $PID_FILE 2&#62;/dev/null
 194&nbsp;
 195&nbsp;    return $RET
 196&nbsp;}
 197&nbsp;
 198&nbsp;# -------
 199&nbsp;# Main
 200&nbsp;init
 201&nbsp;check_pid
 202&nbsp;set_range
 203&nbsp;get_list
 204&nbsp;get_file
 205&nbsp;RET=$?
 206&nbsp;# -------
 207&nbsp;
 208&nbsp;if [ "$RET" -eq 0 ]; then
 209&nbsp;    /usr/bin/logger -t ${0##*/} "Fedora update mirrored successfully."
 210&nbsp;else
 211&nbsp;    /usr/bin/logger -t ${0##*/} "Fedora update mirrored with failure code: $RET"
 212&nbsp;fi
 213&nbsp;
 214&nbsp;exit $RET</PRE
></TD
></TR
></TABLE
><HR></DIV
>
	    <P
>使用 <B
CLASS="COMMAND"
>rcp</B
>, <B
CLASS="COMMAND"
>rsync</B
>,
	      和其他一些有安全问题的类似工具, 并将这些工具用在 shell 脚本中是不明智的. 应该考虑使用 <strong>ssh</strong>, <strong>scp</strong>, 或者一个 <strong>expect</strong> 脚本来代替这些不安全的工具.</P
>
                </DD
><DT
><A
NAME="SSHREF"
></A
><B
CLASS="COMMAND"
>ssh</B
></DT
><DD
>
	        <P
><TT
CLASS="REPLACEABLE"
><I
>安全 shell</I
></TT
>, 登陆远端主机并在其上运行命令. 这个工具具有身份认证和加密的功能, 可以安全的替换  <B
CLASS="COMMAND"
>telnet</B
>,
	      <B
CLASS="COMMAND"
>rlogin</B
>, <B
CLASS="COMMAND"
>rcp</B
>, 和
	      <B
CLASS="COMMAND"
>rsh</B
> 等工具. 参见 <I
CLASS="EMPHASIS"
>man页</I
>
	      来获取详细信息.</P
>
	        <DIV
CLASS="EXAMPLE"
><HR><A
NAME="REMOTE"
></A
>
	        <P
><B
>Example 12-40. 使用 ssh</B
></P
>
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# remote.bash: 使用 ssh.
   3&nbsp;
   4&nbsp;# 这个例子是 Michael Zick 编写的.
   5&nbsp;# 授权使用.
   6&nbsp;
   7&nbsp;
   8&nbsp;#   假设:
   9&nbsp;#   -----
  10&nbsp;#   fd-2(文件描述符2) 并没有被抛弃 ( '2&#62;/dev/null' ).
  11&nbsp;#   ssh/sshd 假设 stderr ('2') 将会被显示给用户.
  12&nbsp;#
  13&nbsp;#   sshd 正运行在你的机器上.
  14&nbsp;#   对于大多数 '标准' 的发行版, 是应该有的,
  15&nbsp;#+  并且没有一些稀奇古怪的 ssh-keygen.
  16&nbsp;
  17&nbsp;# 在你的机器上从命令行中试一下 ssh:
  18&nbsp;#
  19&nbsp;# $ ssh $HOSTNAME
  20&nbsp;# 不同特殊的准备, 你将被要求输入你的密码.
  21&nbsp;#   输入密码
  22&nbsp;#   完成后,  $ exit
  23&nbsp;#
  24&nbsp;# 好使了么? 如果好使了, 你可以做好准备来获取更多的乐趣了.
  25&nbsp;
  26&nbsp;# 在你的机器上用 'root'身份来试试 ssh:
  27&nbsp;#
  28&nbsp;#   $  ssh -l root $HOSTNAME
  29&nbsp;#   当询问密码时, 输入 root 的密码, 别输入你的密码.
  30&nbsp;#          Last login: Tue Aug 10 20:25:49 2004 from localhost.localdomain
  31&nbsp;#   完成后键入 'exit'.
  32&nbsp;
  33&nbsp;#  上边的动作将会给你一个交互的shell.
  34&nbsp;#  在 'single command' 模式下建立 sshd 是可能的, &lt;rojy bug&gt;
  35&nbsp;#+ 不过这已经超出本例的范围了.
  36&nbsp;#  唯一需要注意的事情是下面都可以工作在
  37&nbsp;#+ 'single command' 模式.
  38&nbsp;
  39&nbsp;
  40&nbsp;# 一个基本的写输出(本地)命令.
  41&nbsp;
  42&nbsp;ls -l
  43&nbsp;
  44&nbsp;# 现在在远端机器上使用同样的基本命令.
  45&nbsp;# 使用一套不同的 'USERNAME' 和 'HOSTNAME' :
  46&nbsp;USER=${USERNAME:-$(whoami)}
  47&nbsp;HOST=${HOSTNAME:-$(hostname)}
  48&nbsp;
  49&nbsp;#  现在在远端主机上运行上边的命令行命令,
  50&nbsp;#+ 当然, 所有的传输都被加密了.
  51&nbsp;
  52&nbsp;ssh -l ${USER} ${HOST} " ls -l "
  53&nbsp;
  54&nbsp;#  期望的结果就是在远端主机上列出你的
  55&nbsp;#+ username 主目录的所有文件.
  56&nbsp;#  如果想看点不一样的, 那就
  57&nbsp;#+ 在别的地方运行这个脚本, 别再你的主目录上运行这个脚本.
  58&nbsp;
  59&nbsp;#  换句话说, Bash 命令已经作为一个引用行
  60&nbsp;#+ 被传递到远端的shell 中了,这样就可以在远端的机器上运行它了.
  61&nbsp;#  在这种情况下, sshd 代表你运行了 ' bash -c &quot;ls -l&quot; '.
  62&nbsp;
  63&nbsp;#  对于每个命令行如果想不输入密码的话,
  64&nbsp;#+ 对于这种类似的议题, 可以参阅
  65&nbsp;#+    man ssh
  66&nbsp;#+    man ssh-keygen
  67&nbsp;#+    man sshd_config.
  68&nbsp;
  69&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>在循环中, <B
CLASS="COMMAND"
>ssh</B
> 可能会引起意想不到的异常行为. 根据comp.unix 上的shell文档<A
HREF="http://groups-beta.google.com/group/comp.unix.shell/msg/dcb446b5fff7d230"
TARGET="_top"
>		Usenet post</A
> ,
		<B
CLASS="COMMAND"
>ssh</B
> 继承了循环的标准输入.为了解决这个问题, 使用 ssh 的 -n 或者 -f 选项.</P
>
          <P
>感谢 Jason Bechtel, 指出这点.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>scp</B
></DT
><DD
>
		  <P
><TT
CLASS="REPLACEABLE"
><I
>安全拷贝</I
></TT
>, 在功能上与 <B
CLASS="COMMAND"
>rcp</B
> 很相似, 就是在2个不同的网络主机之间拷贝文件, 但是要通过鉴权的方式, 并且使用与 <strong>ssh</strong> 类似的安全层.</P
>
		</DD
></DL
>
  </DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="COMMLOCAL1"
></A
>Local Network</B
></P
><DL
><DT
><A
NAME="WRITEREF"
></A
><B
CLASS="COMMAND"
>write</B
></DT
><DD
>
    <P
>这是一个端到端通讯的工具. 这个工具可以从你的终端上(console 或者 <em>xterm</em>)发送整行到另一个用户的终端上. 
	      <A
HREF="system.html#MESGREF"
>mesg</A
> 命令当然也可以用来对于一个终端的写权限</P
>
    <P
>因为 <B
CLASS="COMMAND"
>write</B
> 是需要交互的, 所以这个命令通常不使用在脚本中.</P
>
  </DD
><DT
><B
CLASS="COMMAND"
>netconfig</B
></DT
><DD
>
    <P
>用来配置网络适配器(使用 DHCP)的命令行工具. 这个命令对于红帽发行版来说是内置的.</P
>
  </DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="COMMMAIL1"
></A
>Mail</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>mail</B
></DT
><DD
>
	        <P
>发送或读取 e-mail 消息.</P
>
          <P
>如果把这个命令行的 mail 客户端当成一个脚本中的命令来使用的话, 效果非常好.</P
>
	        <DIV
CLASS="EXAMPLE"
><HR><A
NAME="SELFMAILER"
></A
>
	      <P
><B
>Example 12-41. 一个可以mail自己的脚本</B
></P
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/sh
   2&nbsp;# self-mailer.sh: mail自己的脚本
   3&nbsp;
   4&nbsp;adr=${1:-`whoami`}     # 如果不指定的话, 默认是当前用户.
   5&nbsp;#  键入 'self-mailer.sh wiseguy@superdupergenius.com'
   6&nbsp;#+ 发送这个脚本到这个地址.
   7&nbsp;#  如果只键入 'self-mailer.sh' (不给参数) 的话, 那么这脚本就会被发送给
   8&nbsp;#+ 调用者, 比如 bozo@localhost.localdomain.
   9&nbsp;#
  10&nbsp;#  如果想了解 ${parameter:-default} 结构的更多细节,
  11&nbsp;#+ 请参见第9章 变量重游中的
  12&nbsp;#+ 第3节 参数替换.
  13&nbsp;
  14&nbsp;# ============================================================================
  15&nbsp;  cat $0 | mail -s "Script \"`basename $0`\" has mailed itself to you." "$adr"
  16&nbsp;# ============================================================================
  17&nbsp;
  18&nbsp;# --------------------------------------------
  19&nbsp;#  来自 self-mailing 脚本的一份祝福.
  20&nbsp;#  一个喜欢恶搞的家伙运行了这个脚本,
  21&nbsp;#+ 这导致了他自己收到了这份mail.
  22&nbsp;#  显然的, 有些人确实没什么事好做,
  23&nbsp;#+ 就只能浪费他们自己的时间玩了.
  24&nbsp;# --------------------------------------------
  25&nbsp;
  26&nbsp;echo "At `date`, script \"`basename $0`\" mailed to "$adr"."
  27&nbsp;
  28&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>mailto</B
></DT
><DD
>
    <P
>与 <B
CLASS="COMMAND"
>mail</B
> 命令很相似,
	      <B
CLASS="COMMAND"
>mailto</B
> 命令可以使用命令行或在脚本中发送 e-mail 消息. 然而,
	      <B
CLASS="COMMAND"
>mailto</B
> 命令也允许发送 MIME
	      (多媒体) 消息.</P
>
  </DD
><DT
><B
CLASS="COMMAND"
>vacation</B
></DT
><DD
>
    <P
>这个工具可以自动回复 e-mail 给发送者, 表示邮件的接受者正在度假暂时无法收到邮件. 这个工具与 <strong>sendmail</strong> 一起运行于网络上, 并且这个工具不支持拨号的 POPmail 帐号.</P
>
  </DD
></DL
></DIV
></DIV
>
<H3
CLASS="FOOTNOTES"
>注意事项</H3
>
	      <TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9738"
HREF="communications.html#AEN9738"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
NAME="DAEMONREF"
></A
></P
>
	      <P
>一个<em> 幽灵进程</em> 指的是并未附加在终端会话中的后台进程. <em>幽灵进程</em> 在指定的时间执行指定的服务, 或者由特定的事件出发来执行指定的服务.</P
>
	      <P
>希腊文中的 <SPAN
CLASS="QUOTE"
>"daemon"</SPAN
> 意思是幽灵, 这个词充满了神秘感和神奇的力量, 在 UNIX 中幽灵进程总是在后台默默地执行着分配给它们的任务.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="filearchiv.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="terminalccmds.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>File and Archiving Commands</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="external.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Terminal Control Commands</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>