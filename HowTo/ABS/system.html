<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>System and Administrative Commands</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Beyond the Basics"
HREF="part3.html"><LINK
REL="PREVIOUS"
TITLE="Miscellaneous Commands"
HREF="extmisc.html"><LINK
REL="NEXT"
TITLE="Command Substitution"
HREF="commandsub.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=gb2312"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default">
</HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-size:18px;
font-family:"黑体", Arial;
font-weight:bolder;
line-height:200%;
"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="extmisc.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="commandsub.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
>
  <H1
><A
NAME="SYSTEM"
>Chapter 13. 系统与管理命令</A
></H1
>
  <P
>在/etc/rc.d目录中的启动和关机脚本中包含了好多有用的(和没用的)这些系统管理命令. 这些命令通常总是被root用户使用, 用与系统维护或者是紧急文件系统修复.一定要小心使用这些工具, 因为如果滥用的话, 它们会损坏你的系统.</P
>
  <DIV
CLASS="VARIABLELIST"
>
    <P
><B
><A
NAME="USERSGROUPS1"
></A
>Users 和 Groups</B
> <strong>类命令</strong></P
>
    <DL
><DT
><B
CLASS="COMMAND"
>users</B
></DT
><DD
>
      <P
>显示所有的登录的用户. 这个命令与 <B
CLASS="COMMAND"
>who -q</B
> 基本一致.</P
>
    </DD
><DT
><B
CLASS="COMMAND"
>groups</B
></DT
><DD
>
      <P
>列出当前用户和他所属于的组.
	       这相当于 <A
HREF="variables2.html#GROUPSREF"
>$GROUPS</A
> 内部变量,
	       但是这个命令将会给出组名字, 而不是数字.</P
>
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>groups</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozita cdrom cdwriter audio xgrp</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $GROUPS</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>501</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>chown</B
>, <B
CLASS="COMMAND"
>chgrp</B
></DT
><DD
>
   <P
><B
CLASS="COMMAND"
>chown</B
> 命令将会修改一个或多个文件的所有权. 对于<em>root</em>来说这是一种非常好的将文件的所有权从一个用户换到另一个用户的方法. 一个普通用户不能修改文件的所有权, 即使他是文件的宿主也不行.
	         <A
NAME="AEN10817"
HREF="#FTN.AEN10817"
>[1]</A
>	      </P
>
   <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>chown bozo *.txt</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
></TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
><B
CLASS="COMMAND"
>chgrp</B
> 将会修改一个或个文件党<em>组</em>所有权. 你必须是这些文件的宿主, 并且是目的组的成员(或者<em>root</em>), 这样才能使用这个操作.
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;chgrp --recursive dunderheads *.data
   2&nbsp;#  "dunderheads"(译者: 晕,蠢才...) 组现在拥有了所有的&quot;*.data&quot;文件.
   3&nbsp;#+ 包括所有$PWD目录下的子目录中的文件(--recursive的作用就是包含子目录).</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>useradd</B
>, <B
CLASS="COMMAND"
>userdel</B
></DT
><DD
>
     <P
><B
CLASS="COMMAND"
>useradd</B
> 管理命令将会在系统上添加一个用户帐号, 并且如果指定的话, 还会为特定的用户创建home目录. 相应的<B
CLASS="COMMAND"
>userdel</B
> 命令将会从系统上删除一个用户帐号,
		 <A
NAME="AEN10848"
HREF="#FTN.AEN10848"
>[2]</A
>
	      并且删除相应的文件.</P
>
     <DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><B
CLASS="COMMAND"
>adduser</B
>命令与<B
CLASS="COMMAND"
>useradd</B
>是相同的, <strong>adduser</strong>通常都是一个符号链接.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>usermod</B
></DT
><DD
>
	        <P
>修改用户帐号. 可以修改密码, 组身份, 截止日期, 或者给定用户帐号的其他的属性. 使用这个命令, 用户的密码可能会被锁定, 因为密码会影响到帐号的有效性.</P
>
	      </DD
><DT
><B
CLASS="COMMAND"
>groupmod</B
></DT
><DD
>
	        <P
>修改指定组. 组名字或者ID号都可以使用这个命令来修改.</P
>
	      </DD
><DT
><A
NAME="IDREF"
></A
><B
CLASS="COMMAND"
>id</B
></DT
><DD
>
	        <P
><B
CLASS="COMMAND"
>id</B
> 将会列出当前进程的真实和有效用户ID, 还有用户的组ID。 这与Bash的内部变量 <A
HREF="variables2.html#UIDREF"
>$UID</A
>,
	      <A
HREF="variables2.html#EUIDREF"
>$EUID</A
>, 和 <A
HREF="variables2.html#GROUPSREF"
>$GROUPS</A
> 很相像.</P
>
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>id</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $UID</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>501</TT
></PRE
></TD
></TR
></TABLE
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><B
CLASS="COMMAND"
>id</B
> 命令只有在<em>有效</em>ID与<em>真实</em>ID不符时才会显示<em>有效</em>id.</P
></TD
></TR
></TABLE
></DIV
>
 <P
>参见 <A
HREF="variables2.html#AMIROOT"
>Example 9-5</A
>.</P
>
	      </DD
><DT
><A
NAME="WHOREF"
></A
><B
CLASS="COMMAND"
>who</B
></DT
><DD
>
	        <P
>显示系统上所有已经登录的用户.</P
>
	        <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>who</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozo  tty1     Apr 27 17:45
 bozo  pts/0    Apr 27 17:46
 bozo  pts/1    Apr 27 17:47
 bozo  pts/2    Apr 27 17:49</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
><TT
CLASS="OPTION"
>-m</TT
> 选项将会只给出当前用户的详细信息. 将任意两个参数传递到<B
CLASS="COMMAND"
>who</B
>中 都等价于<B
CLASS="COMMAND"
>who
	      -m</B
>, 就像 <B
CLASS="COMMAND"
>who am i</B
> 或者 <B
CLASS="COMMAND"
>who
	      The Man</B
>.</P
>
	    <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>who -m</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>localhost.localdomain!bozo  pts/2    Apr 27 17:49</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
><A
NAME="WHOAMIREF"
></A
><B
CLASS="COMMAND"
>whoami</B
> 与<B
CLASS="COMMAND"
>who
	      -m</B
> 很相似, 但是只列出用户名.</P
>
	    <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>whoami</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozo</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>w</B
></DT
><DD
>
	      <P
>显示所有的登录的用户和属于它们的进程. 这是一个<strong>who</strong>的扩展版本. <strong>w</strong>的输出可以通过管道传递到<B
CLASS="COMMAND"
>grep</B
>中, 这样就可以查找指定的用户或进程.</P
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>w | grep startx</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozo  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>logname</B
></DT
><DD
>
   <P
>显示当前用户的登录名(可以在<TT
CLASS="FILENAME"
>/var/run/utmp</TT
>中找到). 这与上边的<A
HREF="system.html#WHOAMIREF"
>whoami</A
>很相近.</P
>
   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>logname</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozo</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>whoami</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozo</TT
></PRE
></TD
></TR
></TABLE
>
   <P
>然而...</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>su</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Password: ......</TT
>
 
 <TT
CLASS="PROMPT"
>bash# </TT
><TT
CLASS="USERINPUT"
><B
>whoami</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>root</TT
>
 <TT
CLASS="PROMPT"
>bash# </TT
><TT
CLASS="USERINPUT"
><B
>logname</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozo</TT
></PRE
></TD
></TR
></TABLE
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><B
CLASS="COMMAND"
>logname</B
>只会打印出登录的用户名, 而<B
CLASS="COMMAND"
>whoami</B
> 将会给出附着到当前进程的用户名. 就像我们上边看到的那样, 这两个名字有时会不同.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="SUREF"
></A
><B
CLASS="COMMAND"
>su</B
></DT
><DD
>
   <P
>使用一个代替的<em>用户</em>来运行一个程序或脚本.<B
CLASS="COMMAND"
> su rjones</B
> 将会以<I
CLASS="EMPHASIS"
> rjones</I
> 来启动一个shell. 一个不加参数的<B
CLASS="COMMAND"
>su</B
>默认就是<I
CLASS="EMPHASIS"
>root</I
>.  参见 <A
HREF="contributed-scripts.html#FIFO"
>Example A-15</A
>.</P
>
 </DD
><DT
><B
CLASS="COMMAND"
>sudo</B
></DT
><DD
>
	      <P
>以root(或其他用户)的身份来运行一个命令. 这个命令可以运行在脚本中, 这样就允许以正规的用户身份来运行脚本.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# 一些命令.
   4&nbsp;sudo cp /root/secretfile /home/bozo/secret
   5&nbsp;# 一些命令.</PRE
></TD
></TR
></TABLE
></P
>
   <P
>文件 <TT
CLASS="FILENAME"
>/etc/sudoers</TT
> 持有允许调用<B
CLASS="COMMAND"
>sudo</B
>的用户名.</P
>
 </DD
><DT
><B
CLASS="COMMAND"
>passwd</B
></DT
><DD
>
        <P
>设置, 修改, 或者管理用户的密码.</P
>
        <P
><B
CLASS="COMMAND"
>passwd</B
> 命令可以用在脚本中, 但可能你<em>不想</em>这么用.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SETNEWPW"
></A
>
        <P
><B
>Example 13-1. 设置一个新密码</B
></P
>
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;#  setnew-password.sh: 只用于说明目的.
   3&nbsp;#                      如果真正运行这个脚本并不是一个好主意.
   4&nbsp;#  这个脚本必须以root身份运行.
   5&nbsp;
   6&nbsp;ROOT_UID=0         # Root 的 $UID 0.
   7&nbsp;E_WRONG_USER=65    # 不是 root?
   8&nbsp;
   9&nbsp;E_NOSUCHUSER=70
  10&nbsp;SUCCESS=0
  11&nbsp;
  12&nbsp;
  13&nbsp;if [ "$UID" -ne "$ROOT_UID" ]
  14&nbsp;then
  15&nbsp;  echo; echo "Only root can run this script."; echo
  16&nbsp;  exit $E_WRONG_USER
  17&nbsp;else
  18&nbsp;  echo
  19&nbsp;  echo "You should know better than to run this script, root."
  20&nbsp;  echo "Even root users get the blues... "
  21&nbsp;  echo
  22&nbsp;fi  
  23&nbsp;
  24&nbsp;
  25&nbsp;username=bozo
  26&nbsp;NEWPASSWORD=security_violation
  27&nbsp;
  28&nbsp;# 检查bozo是否在这里.
  29&nbsp;grep -q "$username" /etc/passwd
  30&nbsp;if [ $? -ne $SUCCESS ]
  31&nbsp;then
  32&nbsp;  echo "User $username does not exist."
  33&nbsp;  echo "No password changed."
  34&nbsp;  exit $E_NOSUCHUSER
  35&nbsp;fi  
  36&nbsp;
  37&nbsp;echo "$NEWPASSWORD" | passwd --stdin "$username"
  38&nbsp;#  'passwd'命令 '--stdin' 选项允许
  39&nbsp;#+ 从stdin(或者管道)中获得一个新的密码.
  40&nbsp;
  41&nbsp;echo; echo "User $username's password changed!"
  42&nbsp;
  43&nbsp;# 在脚本中使用'passwd'命令是很危险的.
  44&nbsp;
  45&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>
	      <P
><B
CLASS="COMMAND"
>passwd</B
> 命令的 <TT
CLASS="OPTION"
>-l</TT
>,
	      <TT
CLASS="OPTION"
>-u</TT
>, 和 <TT
CLASS="OPTION"
>-d</TT
> 选项允许锁定, 解锁,和删除一个用户的密码. 只有root用户可以使用这些选项.</P
>
 </DD
><DT
><B
CLASS="COMMAND"
>ac</B
></DT
><DD
>
	      <P
>显示用户登录的连接时间, 就像从 /var/log/wtmp 中读取一样. 这是GNU的一个统计工具.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ac</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>        total       68.08</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>last</B
></DT
><DD
>
	      <P
>用户<em>最后</em>登录的信息, 就像从<TT
CLASS="FILENAME"
>/var/log/wtmp中读出来一样</TT
>. 这个命令也可以用来显示远端登录.</P
>
	      <P
>比如, 显示最后几次系统的重启信息:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>last reboot</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>reboot   system boot  2.6.9-1.667      Fri Feb  4 18:18          (00:02)    
 reboot   system boot  2.6.9-1.667      Fri Feb  4 15:20          (01:27)    
 reboot   system boot  2.6.9-1.667      Fri Feb  4 12:56          (00:49)    
 reboot   system boot  2.6.9-1.667      Thu Feb  3 21:08          (02:17)    
 . . .

 wtmp begins Tue Feb  1 12:50:09 2005</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>newgrp</B
></DT
><DD
>
   <P
>不用登出就可以修改用户的组ID. 并且允许存取新组的文件. 因为用户可能同时属于多个组, 这个命令很少被使用.</P
>
 </DD
></DL
>
  </DIV
><DIV
CLASS="VARIABLELIST"
>
    <P
><B
><A
NAME="TERMINALSSYS1"
></A
>终端类命令</B
></P
>
    <DL
><DT
><B
CLASS="COMMAND"
>tty</B
></DT
><DD
>
      <P
>显示当前用户终端的名字.
	      注意每一个单独的<I
CLASS="FIRSTTERM"
>xterm</I
>窗口都被算作一个不同的终端.</P
>
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>tty</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/dev/pts/1</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="STTYREF"
></A
><B
CLASS="COMMAND"
>stty</B
></DT
><DD
>
   <P
>显示并(或)修改终端设置. 这个复杂命令可以用在脚本中, 并可以用来控制终端的行为和其显示输出的方法. 参见这个命令的info页, 并仔细学习它.</P
>
   <DIV
CLASS="EXAMPLE"
><HR><A
NAME="ERASE"
></A
>
   <P
><B
>Example 13-2. 设置一个擦除字符</B
></P
>
   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# erase.sh: 在读取输入时使用"stty"来设置一个擦除字符.
   3&nbsp;
   4&nbsp;echo -n "What is your name? "
   5&nbsp;read name                      #  试试退格键
   6&nbsp;                               #+ 来删除输入的字符.
   7&nbsp;                               #  有什么问题?
   8&nbsp;echo "Your name is $name."
   9&nbsp;
  10&nbsp;stty erase '#'                 #  将 "hashmark" (#) 设置为退格字符.
  11&nbsp;echo -n "What is your name? "
  12&nbsp;read name                      #  使用#来删除最后键入的字符.
  13&nbsp;echo "Your name is $name."
  14&nbsp;
  15&nbsp;# 警告: 即使在脚本退出后, 新的键值还是保持设置.(译者: 使用stty erase '^?' 恢复)
  16&nbsp;
  17&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SECRETPW"
></A
>
  <P
><B
>Example 13-3. <B
CLASS="COMMAND"
>关掉终端对于密码的echo</B
></B
></P
>
  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# secret-pw.sh: 保护密码不被显示
   3&nbsp;
   4&nbsp;echo
   5&nbsp;echo -n "Enter password "
   6&nbsp;read passwd
   7&nbsp;echo "password is $passwd"
   8&nbsp;echo -n "If someone had been looking over your shoulder, "
   9&nbsp;echo "your password would have been compromised."
  10&nbsp;
  11&nbsp;echo &#38;&#38; echo  # 在一个&quot;与列表&quot;中产生2个换行.
  12&nbsp;
  13&nbsp;
  14&nbsp;stty -echo    # 关闭屏幕的echo.
  15&nbsp;
  16&nbsp;echo -n "Enter password again "
  17&nbsp;read passwd
  18&nbsp;echo
  19&nbsp;echo "password is $passwd"
  20&nbsp;echo
  21&nbsp;
  22&nbsp;stty echo     # 恢复屏幕的echo.
  23&nbsp;
  24&nbsp;exit 0
  25&nbsp;
  26&nbsp;# 详细的阅读stty命令的info页, 以便于更好的掌握这个有用并且狡猾的工具.</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>一个具有创造性的<B
CLASS="COMMAND"
>stty</B
>命令的用法,  检测用户所按的键(不用敲<strong>回车</strong>).</P
>
  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="KEYPRESS"
></A
>
  <P
><B
>Example 13-4. 按键检测</B
></P
>
  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# keypress.sh: 检测用户按键 ("hot keys").
   3&nbsp;
   4&nbsp;echo
   5&nbsp;
   6&nbsp;old_tty_settings=$(stty -g)   # 保存老的设置(为什么?).
   7&nbsp;stty -icanon
   8&nbsp;Keypress=$(head -c1)          # 或者 $(dd bs=1 count=1 2&#62; /dev/null)
   9&nbsp;                              # 在非GNU的系统上
  10&nbsp;
  11&nbsp;echo
  12&nbsp;echo "Key pressed was \""$Keypress"\"."
  13&nbsp;echo
  14&nbsp;
  15&nbsp;stty "$old_tty_settings"      # 恢复老的设置.
  16&nbsp;
  17&nbsp;# 感谢, Stephane Chazelas.
  18&nbsp;
  19&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>
  <P
>参见 <A
HREF="variables2.html#TIMEOUT"
>Example 9-3</A
>.</P
>
  <TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN11131"
></A
>
  <P
><B
>终端与模式terminals and modes</B
></P
>
  <P
>一般情况下, 一个终端都是工作在<I
CLASS="EMPHASIS"
>canonical</I
>(标准)模式下.  当用户按键后, 事实上所产生的字符并没有马上传递到运行在当前终端上的程序.  终端上的一个本地的缓存保存了这些按键. 当用按下<B
CLASS="KEYCAP"
>ENTER</B
>键的时候, 才会将所有保存的按键信息传递到运行的程序中.  这就意味着在终端内部存在一个基本的行编辑器.	        </P
>
  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>stty -a</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>speed 9600 baud; rows 36; columns 96; line = 0;
 intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = &#60;undef&#62;; eol2 = &#60;undef&#62;;
 start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;
 ...
 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</TT
>
                 </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
>在使用canonical模式的时候, 可以对本地终端行编辑器所定义的特殊按键进行重新定义.
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cat &#62; filexxx</B
></TT
>
 <TT
CLASS="USERINPUT"
><B
>wha&#60;ctl-W&#62;I&#60;ctl-H&#62;foo bar&#60;ctl-U&#62;hello world&#60;ENTER&#62;</B
></TT
>
 <TT
CLASS="USERINPUT"
><B
>&#60;ctl-D&#62;</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cat filexxx</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>hello world</TT
>		
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>wc -c &#60; filexxx</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>12</TT
>		
                 </PRE
></TD
></TR
></TABLE
>

              控制终端的进程只保存了12个字符(11个字母加上一个换行), 虽然用户敲了26个按键.
              <P
>在 non-canonical (<SPAN
CLASS="QUOTE"
>"raw"</SPAN
>) 模式, 每次按键(包括特殊定义的按键, 比如 
              <B
CLASS="KEYCAP"
>ctl-H</B
>)将会立即发送一个字符到控制进程.</P
>
              <P
>Bash提示符禁用了<TT
CLASS="OPTION"
>icanon</TT
>和<TT
CLASS="OPTION"
>echo</TT
>, 因为它用自己的更好的行编辑器代替了终端的基本行编辑器. 比如, 当你在Bash提示符下敲<B
CLASS="KEYCAP"
>ctl-A</B
>的时候, 终端将不会显示 <B
CLASS="KEYCAP"
>^A</B
>, 但是Bash将会获得<B
CLASS="KEYCAP"
>\1</B
>字符,
              然后解释这个字符, 这样光标就移动到行首了.</P
>
              <P
><I
CLASS="EMPHASIS"
>Stéphane Chazelas</I
></P
></DIV
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>setterm</B
></DT
><DD
>
                <P
>设置特定的终端属性. 这个命令将向它的终端的stdout写一个字符串, 这个字符串将修改终端的行为.</P
>
                <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>setterm -cursor off</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bash$</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
><B
CLASS="COMMAND"
>setterm</B
> 命令可以被用在脚本中来修改写到stdout的文本的外观, 虽然如果你仅仅只想完成这个目的, 还有特定的<A
HREF="colorizing.html#COLORIZINGREF"
>更好的工具</A
>可以用.</P
>
	    <P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;setterm -bold on
   2&nbsp;echo bold hello
   3&nbsp;
   4&nbsp;setterm -bold off
   5&nbsp;echo normal hello</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>tset</B
></DT
><DD
>
	      <P
>显示或初始化终端设置. 可以说这是<strong>stty</strong>的功能比较弱的版本.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>tset -r</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Terminal type is xterm-xfree86.
 Kill is control-U (^U).
 Interrupt is control-C (^C).</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>setserial</B
></DT
><DD
>
	      <P
>设置或者显示串口参数. 这个脚本只能被root用户来运行, 并且通常都在系统安装脚本中使用.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# 来自于 /etc/pcmcia/serial 脚本:
   2&nbsp;
   3&nbsp;IRQ=`setserial /dev/$DEVICE | sed -e 's/.*IRQ: //'`
   4&nbsp;setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>getty</B
>, <B
CLASS="COMMAND"
>agetty</B
></DT
><DD
>
     <P
>一个终端的初始化过程通常都是使用<B
CLASS="COMMAND"
>getty</B
>或<B
CLASS="COMMAND"
>agetty</B
>来建立, 这样才能让用户登录. 这些命令并不用在用户的shell脚本中. 它们的行为与<strong>stty</strong>很相似.</P
>
   </DD
><DT
><A
NAME="MESGREF"
></A
><B
CLASS="COMMAND"
>mesg</B
></DT
><DD
>
	      <P
>使能或禁用当前用户终端的存取权限. 禁用存取权限将会阻止网络上的另一用户向这个终端<A
HREF="communications.html#WRITEREF"
>写</A
>消息.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>当你正在编写文本文件的时候, 在文本中间突然来了一个莫名其妙的消息, 这对你来说是非常烦人的. 在多用户的网络环境下, 当你不想被打断的时候, 你可能因此希望禁用对你终端的写权限.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="WALLREF"
></A
><B
CLASS="COMMAND"
>wall</B
></DT
><DD
>
	      <P
>这是一个缩写单词 <SPAN
CLASS="QUOTE"
>"<A
HREF="communications.html#WRITEREF"
>write</A
> all"</SPAN
>, 也就是, 向登录到网络上的任何终端的所有用户都发送一个消息. 最早这是一个管理员的工具, 很有用, 比如, 当系统有问题的时候, 管理可以警告系统上的所有人暂时离开 (参见 <A
HREF="here-docs.html#EX70"
>Example 17-1</A
>).</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>wall System going down for maintenance in 5 minutes!</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Broadcast message from bozo (pts/1) Sun Jul  8 13:53:27 2001...

 System going down for maintenance in 5 minutes!</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>如果某个特定终端使用<strong>mesg</strong>来禁止了写权限, 那么wall将不会给它发消息.</P
></TD
></TR
></TABLE
></DIV
></DD
></DL
>
  </DIV
><DIV
CLASS="VARIABLELIST"
>
    <P
><B
><A
NAME="STATISTICSSYS1"
></A
>信息与统计</B
><strong>类</strong></P
>
    <DL
><DT
><B
CLASS="COMMAND"
>uname</B
></DT
><DD
>
      <P
>输出系统的说明(OS, 内核版本,
	      等等.)到stdout.  使用
	      <TT
CLASS="OPTION"
>-a</TT
> 选项, 将会给出详细的信息(参见 <A
HREF="moreadv.html#EX41"
>Example 12-5</A
>). 使用<TT
CLASS="OPTION"
>-s</TT
>选项只会输出OS类型.</P
>
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>uname -a</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Linux localhost.localdomain 2.2.15-2.5.0 #1 Sat Feb 5 00:13:43 EST 2000 i686 unknown</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>uname -s</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Linux</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>arch</B
></DT
><DD
>
	      <P
>显示系统的硬件体系结构.
	      等价于 <B
CLASS="COMMAND"
>uname -m</B
>. 参见 <A
HREF="testbranch.html#CASECMD"
>Example 10-26</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>arch</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>i686</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>uname -m</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>i686</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>lastcomm</B
></DT
><DD
>
   <P
>给出前一个命令的信息, 存储在<TT
CLASS="FILENAME"
>/var/account/pacct文件中.</TT
> 命令名字与用户名字都可以使用选项来指定. 这是GNU的一个统计工具.</P
>
 </DD
><DT
><A
NAME="LASTLOGREF"
></A
><B
CLASS="COMMAND"
>lastlog</B
></DT
><DD
>
	      <P
>列出系统上所有用户最后登录的时间. 存在/var/log/lastlog文件中.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>lastlog</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>root          tty1                      Fri Dec  7 18:43:21 -0700 2001
 bin                                     **Never logged in**
 daemon                                  **Never logged in**
 ...
 bozo          tty1                      Sat Dec  8 21:14:29 -0700 2001</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>lastlog | grep root</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>root          tty1                      Fri Dec  7 18:43:21 -0700 2001</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>如果用户对于/var/log/lastlog文件没有读权限的话, 那么调用这个命令就会失败.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>lsof</B
></DT
><DD
>
	      <P
>列出打开的文件. 这个命令将会把所有当前打开的文件列出一份详细的表格, 包括文件的所有者信息, 尺寸, 与它们相关的信息等等. 当然, <B
CLASS="COMMAND"
>lsof</B
>也可以管道输出到 <A
HREF="textproc.html#GREPREF"
>grep</A
> 和(或)<A
HREF="awk.html#AWKREF"
>awk</A
>来分析它的结果.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>lsof</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>COMMAND    PID    USER   FD   TYPE     DEVICE    SIZE     NODE NAME
 init         1    root  mem    REG        3,5   30748    30303 /sbin/init
 init         1    root  mem    REG        3,5   73120     8069 /lib/ld-2.1.3.so
 init         1    root  mem    REG        3,5  931668     8075 /lib/libc-2.1.3.so
 cardmgr    213    root  mem    REG        3,5   36956    30357 /sbin/cardmgr
 ...</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>strace</B
></DT
><DD
>
	      <P
>为了跟踪系统和信号的诊断和调试工具. 调用它最简单的方法就是<B
CLASS="COMMAND"
>strace COMMAND</B
>.</P
><P
>	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>strace df</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>execve("/bin/df", ["df"], [/* 45 vars */]) = 0
 uname({sys="Linux", node="bozo.localdomain", ...}) = 0
 brk(0)                                  = 0x804f5e4
 ...</TT
>
 	    </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
>这是 Solaris <strong>truss</strong>命令的Linux的等价工具.</P
>
	    </DD
><DT
><A
NAME="NMAPREF"
></A
><B
CLASS="COMMAND"
>nmap</B
></DT
><DD
>
	      <P
>网络端口扫描器. 这个命令将会扫描一个服务器来定位打开的端口, 并且定位这些端口相关的服务. 这是一个防止网络被黑客入侵的一个重要的安全工具.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;SERVER=$HOST                           # localhost.localdomain (127.0.0.1).
   4&nbsp;PORT_NUMBER=25                         # SMTP 端口.
   5&nbsp;
   6&nbsp;nmap $SERVER | grep -w "$PORT_NUMBER"  # 这个指定端口打开了么?
   7&nbsp;#              grep -w 匹配整个单词,
   8&nbsp;#+             这样就不会匹配类似于1025这种含有25的端口了.
   9&nbsp;
  10&nbsp;exit 0
  11&nbsp;
  12&nbsp;# 25/tcp     open        smtp</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>nc</B
></DT
><DD
>
	      <P
><B
CLASS="COMMAND"
>nc</B
>(<I
CLASS="EMPHASIS"
>netcat</I
>)工具是一个完整的工具包, 可以使用它来连接和监听TCP和UDP端口. 它可以用来作为诊断和测试工具, 也可以用来作为基于脚本的HTTP客户端和服务器的组件.</P
><P
>	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>nc localhost.localdomain 25</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>220 localhost.localdomain ESMTP Sendmail 8.13.1/8.13.1; Thu, 31 Mar 2005 15:41:35 -0700</TT
></PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ISCAN"
></A
>
	    <P
><B
>Example 13-5. Checking a remote server for <I
CLASS="EMPHASIS"
>identd</I
></B
>&lt;rojy bug&gt;</P
>
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/sh
   2&nbsp;## Duplicate DaveG's ident-scan thingie using netcat. Oooh, he'll be p*ssed.
   3&nbsp;## Args: target port [port port port ...]
   4&nbsp;## Hose stdout _and_ stderr together.
   5&nbsp;##
   6&nbsp;##  优点: runs slower than ident-scan, giving remote inetd less cause
   7&nbsp;##+ for alarm, and only hits the few known daemon ports you specify.
   8&nbsp;##  缺点: requires numeric-only port args, the output sleazitude,
   9&nbsp;##+ and won't work for r-services when coming from high source ports.
  10&nbsp;# 脚本作者: Hobbit &#60;hobbit@avian.org&#62;
  11&nbsp;# 授权使用在本书中.
  12&nbsp;
  13&nbsp;# ---------------------------------------------------
  14&nbsp;E_BADARGS=65       # 至少需要两个参数.
  15&nbsp;TWO_WINKS=2        # 需要睡多长时间.
  16&nbsp;THREE_WINKS=3
  17&nbsp;IDPORT=113         # Authentication "tap ident" port.
  18&nbsp;RAND1=999
  19&nbsp;RAND2=31337
  20&nbsp;TIMEOUT0=9
  21&nbsp;TIMEOUT1=8
  22&nbsp;TIMEOUT2=4
  23&nbsp;# ---------------------------------------------------
  24&nbsp;
  25&nbsp;case "${2}" in
  26&nbsp;  "" ) echo "Need HOST and at least one PORT." ; exit $E_BADARGS ;;
  27&nbsp;esac
  28&nbsp;
  29&nbsp;# Ping 'em once and see if they *are* running identd.
  30&nbsp;nc -z -w $TIMEOUT0 "$1" $IDPORT || { echo "Oops, $1 isn't running identd." ; exit 0 ; }
  31&nbsp;#  -z scans for listening daemons.
  32&nbsp;#     -w $TIMEOUT = How long to try to connect.
  33&nbsp;
  34&nbsp;# Generate a randomish base port.
  35&nbsp;RP=`expr $$ % $RAND1 + $RAND2`
  36&nbsp;
  37&nbsp;TRG="$1"
  38&nbsp;shift
  39&nbsp;
  40&nbsp;while test "$1" ; do
  41&nbsp;  nc -v -w $TIMEOUT1 -p ${RP} "$TRG" ${1} &#60; /dev/null &#62; /dev/null &#38;
  42&nbsp;  PROC=$!
  43&nbsp;  sleep $THREE_WINKS
  44&nbsp;  echo "${1},${RP}" | nc -w $TIMEOUT2 -r "$TRG" $IDPORT 2&#62;&#38;1
  45&nbsp;  sleep $TWO_WINKS
  46&nbsp;
  47&nbsp;# 这个脚本看起来是不是一个瘸腿脚本, 或者其它更差的什么东西?
  48&nbsp;# ABS Guide 作者注释: "并不是真的那么差,
  49&nbsp;#+                            事实上相当清楚.&quot;
  50&nbsp;
  51&nbsp;  kill -HUP $PROC
  52&nbsp;  RP=`expr ${RP} + 1`
  53&nbsp;  shift
  54&nbsp;done
  55&nbsp;
  56&nbsp;exit $?
  57&nbsp;
  58&nbsp;#  注意事项:
  59&nbsp;#  ---------
  60&nbsp;
  61&nbsp;#  尝试注释一下第30行的程序, 并且使用"localhost.localdomain 25"
  62&nbsp;#+ 作为参数来运行这个脚本.
  63&nbsp;
  64&nbsp;#  For more of Hobbit's 'nc' example scripts,
  65&nbsp;#+ look in the documentation:
  66&nbsp;#+ the /usr/share/doc/nc-X.XX/scripts directory.</PRE
></TD
></TR
></TABLE
><HR></DIV
>
	    <P
>	      并且, 当然, 这里还有Dr. Andrew Tridgell在BistKeeper事件中臭名卓著的一行脚本:
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo clone | nc thunk.org 5000 &#62; e2fsprogs.dat</PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><A
NAME="FREEREF"
></A
><B
CLASS="COMMAND"
>free</B
></DT
><DD
>
	      <P
>使用表格形式来显示内存和缓存的使用情况. 这个命令的输出非常适合于使用
	      <A
HREF="textproc.html#GREPREF"
>grep</A
>, <A
HREF="awk.html#AWKREF"
>awk</A
> 或者<B
CLASS="COMMAND"
>Perl</B
>来分析. 
	      <B
CLASS="COMMAND"
>procinfo</B
>命令将会显示<B
CLASS="COMMAND"
>free</B
>命令所能显示的所有信息, 而且更多.</P
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><B
CLASS="COMMAND"
>free</B
>
 <TT
CLASS="COMPUTEROUTPUT"
>                total       used       free     shared    buffers     cached
   Mem:         30504      28624       1880      15820       1608       16376
   -/+ buffers/cache:      10640      19864
   Swap:        68540       3128      65412</TT
></PRE
></TD
></TR
></TABLE
>
	      <P
>显示未使用的RAM内存:</P
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><B
CLASS="COMMAND"
>free | grep Mem | awk '{ print $4 }'</B
>
 <TT
CLASS="COMPUTEROUTPUT"
>1880</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="PROCINFOREF"
></A
><B
CLASS="COMMAND"
>procinfo</B
></DT
><DD
>
   <P
>从<A
HREF="devproc.html#DEVPROCREF"
><TT
CLASS="FILENAME"
>/proc</TT
> pseudo-filesystem</A
>中提取和显示所有信息和统计资料. 这个命令将给出更详细的信息.</P
>
   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>procinfo | grep Bootup</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Bootup: Wed Mar 21 15:15:50 2001    Load average: 0.04 0.21 0.34 3/47 6829</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="LSDEVREF"
></A
><B
CLASS="COMMAND"
>lsdev</B
></DT
><DD
>
   <P
>显示设备, 也就是显示安装的硬件.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>lsdev</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Device            DMA   IRQ  I/O Ports
 ------------------------------------------------
 cascade             4     2 
 dma                          0080-008f
 dma1                         0000-001f
 dma2                         00c0-00df
 fpu                          00f0-00ff
 ide0                     14  01f0-01f7 03f6-03f6
 ...</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><A
NAME="DUREF"
></A
><B
CLASS="COMMAND"
>du</B
></DT
><DD
>
	      <P
>递归的显示(磁盘)文件的使用状况. 除非指定, 默认是当前工作目录.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><B
CLASS="COMMAND"
>du -ach</B
>
 <TT
CLASS="COMPUTEROUTPUT"
>1.0k    ./wi.sh
 1.0k    ./tst.sh
 1.0k    ./random.file
 6.0k    .
 6.0k    total</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="DFREF"
></A
><B
CLASS="COMMAND"
>df</B
></DT
><DD
>
   <P
>使用列表的形式显示文件系统的使用状况.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><B
CLASS="COMMAND"
>df</B
>
 <TT
CLASS="COMPUTEROUTPUT"
>Filesystem           1k-blocks      Used Available Use% Mounted on
 /dev/hda5               273262     92607    166547  36% /
 /dev/hda8               222525    123951     87085  59% /home
 /dev/hda7              1408796   1075744    261488  80% /usr</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>dmesg</B
></DT
><DD
>
	      <P
>将所有的系统启动消息输出到stdout上. 方便出错,并且可以查出安装了哪些设备驱动和察看使用了哪些系统中断.  <B
CLASS="COMMAND"
>dmesg</B
>命令的输出当然也可以在脚本中使用 <A
HREF="textproc.html#GREPREF"
>grep</A
>,
	      <A
HREF="sedawk.html#SEDREF"
>sed</A
>, 或 <A
HREF="awk.html#AWKREF"
>awk</A
> 来进行分析.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>dmesg | grep hda</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Kernel command line: ro root=/dev/hda2
 hda: IBM-DLGA-23080, ATA DISK drive
 hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63
 hda: hda1 hda2 hda3 &#60; hda5 hda6 hda7 &#62; hda4</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>stat</B
></DT
><DD
>
	      <P
>显示一个或多个给定文件(也可以是目录文件或设备文件)的详细的统计信息.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>stat test.cru</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>  File: "test.cru"
   Size: 49970        Allocated Blocks: 100          Filetype: Regular File
   Mode: (0664/-rw-rw-r--)         Uid: (  501/ bozo)  Gid: (  501/ bozo)
 Device:  3,8   Inode: 18185     Links: 1    
 Access: Sat Jun  2 16:40:24 2001
 Modify: Sat Jun  2 16:40:24 2001
 Change: Sat Jun  2 16:40:24 2001</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
>如果目标文件不存在,  <B
CLASS="COMMAND"
>stat</B
>
	      将会返回一个错误信息.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>stat nonexistent-file</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>nonexistent-file: No such file or directory</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><A
NAME="VMSTATREF"
></A
><B
CLASS="COMMAND"
>vmstat</B
></DT
><DD
>
	      <P
>显示虚拟内存的统计信息.</P
><P
>	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>vmstat</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>   procs                      memory    swap          io system         cpu
 r  b  w   swpd   free   buff  cache  si  so    bi    bo   in    cs  us  sy id
 0  0  0      0  11040   2636  38952   0   0    33     7  271    88   8   3 89</TT
>
 	    </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>netstat</B
></DT
><DD
>
	      <P
>显示当前网络的统计和信息, 比如路由表和激活的连接. 这个工具存取/proc/net(<A
HREF="devproc.html"
>第27章</A
>)中的信息. 参见 <A
HREF="procref1.html#CONSTAT"
>Example 27-3</A
>.</P
>
	      <P
><B
CLASS="COMMAND"
>netstat -r</B
> 等价于 <A
HREF="system.html#ROUTEREF"
>route</A
> 命令.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>netstat</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Active Internet connections (w/o servers)
 Proto Recv-Q Send-Q Local Address           Foreign Address         State      
 Active UNIX domain sockets (w/o servers)
 Proto RefCnt Flags       Type       State         I-Node Path
 unix  11     [ ]         DGRAM                    906    /dev/log
 unix  3      [ ]         STREAM     CONNECTED     4514   /tmp/.X11-unix/X0
 unix  3      [ ]         STREAM     CONNECTED     4513
 . . .</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="UPTIMEREF"
></A
><B
CLASS="COMMAND"
>uptime</B
></DT
><DD
>
	      <P
>显示系统运行的时间, 还有其他一些统计信息.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>uptime</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>10:28pm  up  1:57,  3 users,  load average: 0.17, 0.34, 0.27</TT
></PRE
></TD
></TR
></TABLE
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><I
CLASS="FIRSTTERM"
>load average</I
> 如果小于或等于1, 那么就意味着系统会马上处理. 如果<I
CLASS="FIRSTTERM"
>load average</I
>大于1, 那么就意味着进程需要排队. 如果<I
CLASS="FIRSTTERM"
>load average</I
>大于3, 那么就意味着, 系统性能已经显著下降了.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="HNAMEREF"
></A
><B
CLASS="COMMAND"
>hostname</B
></DT
><DD
>
        <P
>显示系统的主机名字. 这个命令在 <TT
CLASS="FILENAME"
>/etc/rc.d</TT
>
	      安装脚本(<TT
CLASS="FILENAME"
>/etc/rc.d/rc.sysinit</TT
> 或类似的)中设置主机名.  等价于<B
CLASS="COMMAND"
>uname
	      -n</B
>,  并且与<A
HREF="variables2.html#HOSTNAMEREF"
>$HOSTNAME</A
>内部变量很相像.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>hostname</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>localhost.localdomain</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $HOSTNAME</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>localhost.localdomain</TT
></PRE
></TD
></TR
></TABLE
>
	      <P
>与 <B
CLASS="COMMAND"
>hostname</B
> 命令很相像的命令还有
	      <B
CLASS="COMMAND"
>domainname</B
>,
	      <B
CLASS="COMMAND"
>dnsdomainname</B
>,
	      <B
CLASS="COMMAND"
>nisdomainname</B
>, 和
	      <B
CLASS="COMMAND"
>ypdomainname</B
> 命令. 使用这些来显示或设置系统DNS 或者 NIS/YP 域名. 对于<B
CLASS="COMMAND"
>hostname</B
>命令来说使用不同的选项一样可以达到上边这些命令的目的.</P
>
 </DD
><DT
><A
NAME="HOSTIDREF"
></A
><B
CLASS="COMMAND"
>hostid</B
></DT
><DD
>
	      <P
>显示主机的32位的16进制ID.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>hostid</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>7f0100</TT
></PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>这个命令据说对于特定系统可以获得一个&quot;唯一&quot;的序号. 某些产品的注册过程可能会需要这个序号来作为用户的许可证. 不幸的是,
	      <B
CLASS="COMMAND"
>hostid</B
> 只会使用字节转换的方法来用16进制显示机器的网络地址.</P
>
	      <P
>一个没有网络的Linux机器的典型的网络地址设置在/ect/hosts中.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cat /etc/hosts</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>127.0.0.1               localhost.localdomain localhost</TT
></PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
>碰巧, 通过对<TT
CLASS="USERINPUT"
><B
>127.0.0.1</B
>进行字节转换</TT
>, 我们获得了
	      <TT
CLASS="USERINPUT"
><B
>0.127.1.0</B
></TT
>, 用16进制表示就是<TT
CLASS="USERINPUT"
><B
>007f0100</B
></TT
>, 这就是上边<strong>hostid</strong>返回的结果. 这样几乎所有的无网络的Linux机器都会得到这个<I
CLASS="EMPHASIS"
>hostid</I
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>sar</B
></DT
><DD
>
	      <P
><B
CLASS="COMMAND"
>sar</B
> (System Activity Reporter系统活动报告)
	      命令将会给出系统统计的一个非常详细的概要. Santa Cruz Operation(<SPAN
CLASS="QUOTE"
>"老"</SPAN
> SCO)公司在1999年4月份以开源软件的形式发布了<B
CLASS="COMMAND"
>sar</B
>.</P
>
	      <P
>这个命令并不是基本Linux发行版的一部分, 但是你可以从<A
HREF="mailto:sebastien.godard@wanadoo.fr"
TARGET="_top"
>Sebastien
	      Godard</A
> 写的 <A
HREF="http://perso.wanadoo.fr/sebastien.godard/"
TARGET="_top"
>sysstat utilities</A
> 包中获得这个工具.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>sar</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Linux 2.4.9 (brooks.seringas.fr) 	09/26/03

10:30:00          CPU     %user     %nice   %system   %iowait     %idle
10:40:00          all      2.21     10.90     65.48      0.00     21.41
10:50:00          all      3.36      0.00     72.36      0.00     24.28
11:00:00          all      1.12      0.00     80.77      0.00     18.11
Average:          all      2.23      3.63     72.87      0.00     21.27

14:32:30          LINUX RESTART

15:00:00          CPU     %user     %nice   %system   %iowait     %idle
15:10:00          all      8.59      2.40     17.47      0.00     71.54
15:20:00          all      4.07      1.00     11.95      0.00     82.98
15:30:00          all      0.79      2.94      7.56      0.00     88.71
Average:          all      6.33      1.70     14.71      0.00     77.26</TT
>
            </PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>readelf</B
></DT
><DD
>
	      <P
>显示指定的 <em>elf</em> 格式的2进制文件的统计信息. 这个工具是<I
CLASS="EMPHASIS"
>binutils</I
>工具包的一部分.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>readelf -h /bin/bash</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>ELF Header:
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
   Class:                             ELF32
   Data:                              2's complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   . . .</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>size</B
></DT
><DD
>
	      <P
><B
CLASS="COMMAND"
>size [/path/to/binary]</B
> 命令可以显示2进制可执行文件或归档文件每部分的尺寸.
	      这个工具主要是程序员使用.	      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>size /bin/bash</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>   text    data     bss     dec     hex filename
  495971   22496   17392  535859   82d33 /bin/bash</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
></DL
>
  </DIV
><DIV
CLASS="VARIABLELIST"
>
    <P
><B
><A
NAME="SYSLOG1"
></A
>系统日志类</B
></P
>
    <DL
><DT
><B
CLASS="COMMAND"
>logger</B
></DT
><DD
>
    <P
>附加一个用户产生的消息到系统日之中
	      (<TT
CLASS="FILENAME"
>/var/log/messages</TT
>). 不是root用户也可以调用<B
CLASS="COMMAND"
>logger</B
>.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;logger Experiencing instability in network connection at 23:10, 05/21.
   2&nbsp;# 现在, 运行 'tail /var/log/messages'.</PRE
></TD
></TR
></TABLE
></P
>
   <P
>通过在脚本中调用一个<B
CLASS="COMMAND"
>logger</B
>命令,
	      就可以将调试信息写到<TT
CLASS="FILENAME"
>/var/log/messages中</TT
>.
                 <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;logger -t $0 -i Logging at line "$LINENO".
   2&nbsp;# "-t" 选项可以为长的入口指定标签.
   3&nbsp;# "-i" 选项记录进程ID.
   4&nbsp;
   5&nbsp;# tail /var/log/message
   6&nbsp;# ...
   7&nbsp;# Jul  7 20:48:58 localhost ./test.sh[1712]: Logging at line 3.</PRE
></TD
></TR
></TABLE
>
            </P
></DD
><DT
><B
CLASS="COMMAND"
>logrotate</B
></DT
><DD
>
              <P
>这个工具用来管理系统的log文件, 可以在合适的时候轮换,
	      压缩, 删除, 和(或)e-mail它们.
	      这个工具将从老的log文件中取得一些杂乱的记录保存在<TT
CLASS="FILENAME"
>/var/log中.</TT
>	      通常使用 <A
HREF="system.html#CRONREF"
>cron</A
> 来每天运行<B
CLASS="COMMAND"
>logrotate</B
>.</P
>
              <P
>在/etc/logrotate.conf中添加合适的入口就可以管理自己的log文件了, 就像管理系统log文件一样.</P
>
              <DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Stefano Falsetto 创造了<A
HREF="http://www.gnu.org/software/rottlog/"
TARGET="_top"
>rottlog</A
>,
	     他认为这是<B
CLASS="COMMAND"
>logrotate</B
>的改进版本.</P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
>
	       <P
><B
><A
NAME="JOBCONTROLSYS1"
></A
>作业控制</B
></P
>
	       <DL
><DT
><B
CLASS="COMMAND"
>ps</B
></DT
><DD
>
	         <P
><em>进程统计</em>: 通过进程所有者和PID(进程ID)来列出当前执行的进程. 通常都是使用ax选项来调用这个命令, 并且结果可以通过管道传递到 <A
HREF="textproc.html#GREPREF"
>grep</A
>
	      或 <A
HREF="sedawk.html#SEDREF"
>sed</A
> 中来搜索特定的进程(参见 <A
HREF="internal.html#EX44"
>Example 11-12</A
> 和 <A
HREF="procref1.html#PIDID"
>Example 27-2</A
>).</P
>
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
> ps ax | grep sendmail</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>295 ?	   S	  0:00 sendmail: accepting connections on port 25</TT
></PRE
></TD
></TR
></TABLE
>
	         <P
>如果想使用&quot;树&quot;的形式来显示系统进程:  <B
CLASS="COMMAND"
>ps afjx</B
> 或者
	      <B
CLASS="COMMAND"
>ps ax --forest</B
>.</P
>
	       </DD
><DT
><B
CLASS="COMMAND"
>pgrep</B
>, <B
CLASS="COMMAND"
>pkill</B
></DT
><DD
>
	         <P
><B
CLASS="COMMAND"
>ps</B
> 命令与<A
HREF="textproc.html#GREPREF"
>grep</A
>或<A
HREF="internal.html#KILLREF"
>kill</A
>结合使用.</P
>
	         <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ps a | grep mingetty</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>2212 tty2     Ss+    0:00 /sbin/mingetty tty2
 2213 tty3     Ss+    0:00 /sbin/mingetty tty3
 2214 tty4     Ss+    0:00 /sbin/mingetty tty4
 2215 tty5     Ss+    0:00 /sbin/mingetty tty5
 2216 tty6     Ss+    0:00 /sbin/mingetty tty6
 4849 pts/2    S+     0:00 grep mingetty</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pgrep mingetty</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>2212 mingetty
 2213 mingetty
 2214 mingetty
 2215 mingetty
 2216 mingetty</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>pstree</B
></DT
><DD
>
	      <P
>使用&quot;树&quot;形式列出当前执行的进程. -p选项显示PID，和进程名字.</P
>
	    </DD
>
	    <DT
><B
CLASS="COMMAND"
>top</B
></DT
><DD
>
	      <P
>连续不断的显示cpu使用率最高的进程. -b 选项将会以文本方式显示, 以便于可以在脚本中分析或存取.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>top -b</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>  8:30pm  up 3 min,  3 users,  load average: 0.49, 0.32, 0.13
 45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped
 CPU states: 13.6% user,  7.3% system,  0.0% nice, 78.9% idle
 Mem:    78396K av,   65468K used,   12928K free,       0K shrd,    2352K buff
 Swap:  157208K av,       0K used,  157208K free                   37244K cached

   PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
   848 bozo      17   0   996  996   800 R     5.6  1.2   0:00 top
     1 root       8   0   512  512   444 S     0.0  0.6   0:04 init
     2 root       9   0     0    0     0 SW    0.0  0.0   0:00 keventd
   ...</TT
>  
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>nice</B
></DT
><DD
>
	      <P
>使用修改后的优先级来运行一个后台作业. 优先级从19(最低)到-20(最高). 只有<I
CLASS="EMPHASIS"
>root</I
>用户可以设置负的(比较高的)优先级. 相关的命令是<B
CLASS="COMMAND"
>renice</B
>, <B
CLASS="COMMAND"
>snice</B
>,
	      和<B
CLASS="COMMAND"
>skill</B
>.</P
>
	    </DD
><DT
><B
CLASS="COMMAND"
>nohup</B
></DT
><DD
>
	      <P
>保持一个命令的运行, 即使用户登出系统.
	      这个命令做为前台进程来运行, 除非前边加 &amp;.  如果你在脚本中使用<B
CLASS="COMMAND"
>nohup</B
>命令, 最好和<A
HREF="internal.html#WAITREF"
>wait</A
> 命令一起使用, 这样可以避免创建一个孤儿进程或僵尸进程.</P
>
	    </DD
><DT
><A
NAME="PIDOFREF"
></A
><B
CLASS="COMMAND"
>pidof</B
></DT
><DD
>
	    <P
>取得一个正在运行的作业的<I
CLASS="EMPHASIS"
>进程ID(PID)</I
>. 因为一些作业控制命令, 比如<A
HREF="internal.html#KILLREF"
>kill</A
>和<B
CLASS="COMMAND"
>renice</B
>只能使用进程的<I
CLASS="EMPHASIS"
>PID</I
>(而不是它的名字), 所以有时候必须的取得<em>PID</em>.  <B
CLASS="COMMAND"
>pidof</B
>命令与<A
HREF="variables2.html#PPIDREF"
>$PPID</A
>内部变量非常相似.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pidof xclock</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>880</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="KILLPROCESS"
></A
>
	      <P
><B
>Example 13-6. <B
CLASS="COMMAND"
>pidof</B
> 帮助杀掉一个进程</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# kill-process.sh
   3&nbsp;
   4&nbsp;NOPROCESS=2
   5&nbsp;
   6&nbsp;process=xxxyyyzzz  # 使用不存在的进程.
   7&nbsp;# 只不过是为了演示...
   8&nbsp;# ... 并不想在这个脚本中杀掉任何真正的进程.
   9&nbsp;#
  10&nbsp;# 如果, 举个例子, 你想使用这个脚本来断线Internet,
  11&nbsp;#     process=pppd
  12&nbsp;
  13&nbsp;t=`pidof $process`       # 取得$process的pid(进程id).
  14&nbsp;# 'kill'必须使用pid(不能用程序名).
  15&nbsp;
  16&nbsp;if [ -z "$t" ]           # 如果没这个进程, 'pidof' 返回空.
  17&nbsp;then
  18&nbsp;  echo "Process $process was not running."
  19&nbsp;  echo "Nothing killed."
  20&nbsp;  exit $NOPROCESS
  21&nbsp;fi  
  22&nbsp;
  23&nbsp;kill $t                  # 对于顽固的进程可能需要'kill -9'.
  24&nbsp;
  25&nbsp;# 这里需要做一个检查, 看看进程是否允许自身被kill.
  26&nbsp;# 或许另一个 " t=`pidof $process` " 或者 ...
  27&nbsp;
  28&nbsp;
  29&nbsp;# 整个脚本都可以使用下边这句来替换:
  30&nbsp;#    kill $(pidof -x process_name)
  31&nbsp;# 但是这就没有教育意义了.
  32&nbsp;
  33&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>fuser</B
></DT
><DD
>
	      <P
>取得一个正在存取某个或某些文件(或目录)的进程ID. 使用-k选项将会杀掉这些进程. 对于系统安全来说, 尤其是在脚本中想阻止未被授权的用户存取系统服务的时候, 这个命令就显得很有用了.</P
>
	      <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>fuser -u /usr/bin/vim</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/usr/bin/vim:         3207e(bozo)</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>fuser -u /dev/null</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/dev/null:            3009(bozo)  3010(bozo)  3197(bozo)  3199(bozo)</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
>当正常的插入或删除保存的媒体, 比如CD ROM或者USB闪存设备的时候, <B
CLASS="COMMAND"
>fuser</B
>的应用也显得特别重要. 有时候当你想<A
HREF="system.html#UMOUNTREF"
>umount</A
>一个设备失败的时候(出现设备忙的错误消息), 这意味着某些用户或进程正在存取这个设备. 使用<B
CLASS="COMMAND"
>fuser -um /dev/device_name</B
>可以搞定这些, 这样你就可以杀掉所有相关的进程.</P
>
	    <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>umount /mnt/usbdrive</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>umount: /mnt/usbdrive: device is busy</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>fuser -um /dev/usbdrive</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/mnt/usbdrive:        1772c(bozo)</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>kill -9 1772</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>umount /mnt/usbdrive</B
></TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
><B
CLASS="COMMAND"
>fuser</B
> 的-n选项可以获得正在存取某一<em>端口</em>的进程. 当和<A
HREF="system.html#NMAPREF"
>nmap</A
>命令组合使用的时候尤其有用.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>nmap localhost.localdomain</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>PORT     STATE SERVICE
 25/tcp   open  smtp</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>fuser -un tcp 25</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>25/tcp:               2095(root)</TT
>
 
 <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>ps ax | grep 2095 | grep -v grep</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>2095 ?        Ss     0:00 sendmail: accepting connections</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
            </P
></DD
><DT
><A
NAME="CRONREF"
></A
><B
CLASS="COMMAND"
>cron</B
></DT
><DD
>
	      <P
>管理程序调度器, 执行一些日常任务, 比如清除和删除系统log文件, 或者更新<span class="DATABASE"><strong>slocate</strong></span>命令的数据库. 这是<A
HREF="timedate.html#ATREF"
>at</A
>命令的超级用户版本(虽然每个用户都可以有自己的crontab文件, 并且这个文件可以使用<B
CLASS="COMMAND"
>crontab</B
>命令来修改). 它以<A
HREF="communications.html#DAEMONREF"
>幽灵进程</A
>T的身份来运行, 并且从/ect/crontab中获得执行的调度入口.</P
>
	      <DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>一些Linux的风格都使用<B
CLASS="COMMAND"
>crond</B
>, Matthew Dillon的<B
CLASS="COMMAND"
>cron</B
>.</P
></TD
></TR
></TABLE
></DIV
></DD
></DL
>
	     </DIV
><DIV
CLASS="VARIABLELIST"
>
	       <P
><B
><A
NAME="RUNCONTROLSYS1"
></A
>进程控制和启动类</B
></P
>
	       <DL
><DT
><B
CLASS="COMMAND"
>init</B
></DT
><DD
><P
><A
NAME="INITTABREF"
></A
></P
>
	       <P
><B
CLASS="COMMAND"
>init</B
> 命令是所有进程的<A
HREF="internal.html#FORKREF"
>父进程</A
>. 在系统启动的最后一步调用,  <B
CLASS="COMMAND"
>init</B
>
	      将会依据<TT
CLASS="FILENAME"
>/etc/inittab</TT
>来决定系统的运行级别. 只能使用root身份来运行它的别名<B
CLASS="COMMAND"
>telinit</B
>.</P
>
	       </DD
><DT
><B
CLASS="COMMAND"
>telinit</B
></DT
><DD
>
	         <P
><B
CLASS="COMMAND"
>init</B
>命令的符号链接, 这是一种修改系统运行级别的一个手段,
	      通常在系统维护或者紧急的文件系统修复的时候才用. 只能使用root身份调用. 调用这个命令是非常危险的 - 在你使用之前确定你已经很好地了解它.</P
>
	       </DD
><DT
><B
CLASS="COMMAND"
>runlevel</B
></DT
><DD
>
	         <P
>显示当前和最后的运行级别, 也就是, 确定你的系统是否终止(runlevel 为0), 还是运行在单用户模式(1), 多用户模式(2), 或者是运行在X Windows(5), 还是正在重启(6). 这个命令将会存取<TT
CLASS="FILENAME"
>/var/run/utmp</TT
>文件.</P
>
	       </DD
><DT
><B
CLASS="COMMAND"
>halt</B
>, <B
CLASS="COMMAND"
>shutdown</B
>, <B
CLASS="COMMAND"
>reboot</B
></DT
><DD
>
	         <P
>设置系统关机的命令, 通常比电源关机的优先级高.</P
>
	       </DD
><DT
><B
CLASS="COMMAND"
>service</B
></DT
><DD
>
	    <P
>开启或停止一个系统<em>服务</em>.
	    启动脚本在<TT
CLASS="FILENAME"
>/etc/init.d</TT
>中, 并且<TT
CLASS="FILENAME"
>/etc/rc.d</TT
>在系统启动的时候使用这个命令来启动服务.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>/sbin/service iptables stop</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Flushing firewall rules:                                   [  OK  ]
 Setting chains to policy ACCEPT: filter                    [  OK  ]
 Unloading iptables modules:                                [  OK  ]</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
></DL
>
	     </DIV
><DIV
CLASS="VARIABLELIST"
>
	       <P
><B
><A
NAME="NETWORKSYS1"
></A
>网络类</B
></P
>
	       <DL
><DT
><B
CLASS="COMMAND"
>ifconfig</B
></DT
><DD
>
	         <P
>网络的<em>接口配置</em>和调试工具.</P
>
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ifconfig -a</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>lo        Link encap:Local Loopback
           inet addr:127.0.0.1  Mask:255.0.0.0
           UP LOOPBACK RUNNING  MTU:16436  Metric:1
           RX packets:10 errors:0 dropped:0 overruns:0 frame:0
           TX packets:10 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:0 
           RX bytes:700 (700.0 b)  TX bytes:700 (700.0 b)</TT
></PRE
></TD
></TR
></TABLE
>
	         <P
><B
CLASS="COMMAND"
>ifconfig</B
> 命令绝大多数情况都是在启动时候设置接口, 或者在重启的时候关闭它们.</P
>
             <P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# 来自于 /etc/rc.d/init.d/network 的代码片段
   2&nbsp;
   3&nbsp;# ...
   4&nbsp;
   5&nbsp;# 检查网络是否启动.
   6&nbsp;[ ${NETWORKING} = "no" ] &#38;&#38; exit 0
   7&nbsp;
   8&nbsp;[ -x /sbin/ifconfig ] || exit 0
   9&nbsp;
  10&nbsp;# ...
  11&nbsp;
  12&nbsp;for i in $interfaces ; do
  13&nbsp;  if ifconfig $i 2&#62;/dev/null | grep -q "UP" &#62;/dev/null 2&#62;&#38;1 ; then
  14&nbsp;    action "Shutting down interface $i: " ./ifdown $i boot
  15&nbsp;  fi
  16&nbsp;# grep命令的GNU指定的 "-q" 的意思是&quot;安静&quot;, 也就是不产生输出.
  17&nbsp;# 这样, 后边重定向到/dev/null的操作就有点重复了.
  18&nbsp;       
  19&nbsp;# ...
  20&nbsp;
  21&nbsp;echo "Currently active devices:"
  22&nbsp;echo `/sbin/ifconfig | grep ^[a-z] | awk '{print $1}'`
  23&nbsp;#                            ^^^^^  应该被引用防止globbing.
  24&nbsp;#  下边这段也能工作.
  25&nbsp;#    echo $(/sbin/ifconfig | awk '/^[a-z]/ { print $1 })'
  26&nbsp;#    echo $(/sbin/ifconfig | sed -e 's/ .*//')
  27&nbsp;#  Thanks, S.C.做了额外的注释.</PRE
></TD
></TR
></TABLE
></P
>
  <P
>参见 <A
HREF="debugging.html#ONLINE"
>Example 29-6</A
>.</P
>
	       </DD
><DT
><B
CLASS="COMMAND"
>iwconfig</B
></DT
><DD
>
	         <P
>这是为了配置无线网络的命令集合.
	      可以说是上边的<B
CLASS="COMMAND"
>ifconfig</B
>的无线版本.</P
>
	       </DD
><DT
><A
NAME="ROUTEREF"
></A
><B
CLASS="COMMAND"
>route</B
></DT
><DD
>
	         <P
>显示内核路由表信息, 或者查看内核路由表的修改.</P
>
	         <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>route</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
 pm3-67.bozosisp *               255.255.255.255 UH       40 0          0 ppp0
 127.0.0.0       *               255.0.0.0       U        40 0          0 lo
 default         pm3-67.bozosisp 0.0.0.0         UG       40 0          0 ppp0</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>chkconfig</B
></DT
><DD
>
	      <P
>检查网络配置. 这个命令负责显示和管理在启动过程中所开启的网络服务(这些服务都是从/etc/rc?.d目录中开启的).</P
>
	      <P
>最开始是从IRIX到Red Hat Linux的一个接口,
	      <B
CLASS="COMMAND"
>chkconfig</B
>在某些Linux发行版中并不是核心安装的一部分.</P
>
	      <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>chkconfig --list</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>atd             0:off   1:off   2:off   3:on    4:on    5:on    6:off
 rwhod           0:off   1:off   2:off   3:off   4:off   5:off   6:off
 ...</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>tcpdump</B
></DT
><DD
>
	      <P
>网络包的&quot;嗅探器&quot;. 这是一个用来分析和调试网络上传输情况的工具, 它所使用的手段是把匹配指定规则的包头都显示出来.</P
>
	      <P
>显示主机<I
CLASS="EMPHASIS"
>bozoville</I
>和主机<I
CLASS="EMPHASIS"
>caduceus</I
>之间所有传输的ip包.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>tcpdump ip host bozoville and caduceus</B
></TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
>
	      <P
>当然,<B
CLASS="COMMAND"
>tcpdump</B
>的输出可以被分析, 可以用我们之前讨论的<A
HREF="textproc.html#TPCOMMANDLISTING1"
>文本处理工具</A
>来分析结果.</P
>
	    </DD
></DL
>
	     </DIV
><DIV
CLASS="VARIABLELIST"
>
		  <P
><B
><A
NAME="FILESYSTEMSYS1"
></A
>文件系统类</B
></P
>
		  <DL
><DT
><A
NAME="MOUNTREF"
></A
><B
CLASS="COMMAND"
>mount</B
></DT
><DD
>
		    <P
>加载一个文件系统, 通常都用来安装外部设备, 比如软盘或CDROM. 文件<TT
CLASS="FILENAME"
>/etc/fstab</TT
> 将会提供一个方便的列表, 这个列表列出了所有可用的文件系统, 分区和设备, 另外还包括某些选项, 比如是否可以自动或者手动的mount. 文件<TT
CLASS="FILENAME"
>/etc/mtab</TT
> 显示了当前已经mount的文件系统和分区(包括虚拟的, 比如/proc).</P
>
		    <P
><B
CLASS="COMMAND"
>mount -a</B
> 将会mount所有列在/ect/fstab中的文件系统和分区, 除了那些标记有非自动选项的. 在启动的时候, 在/etc/rc.d中的一个启动脚本(rc.sysinit或者一些相似的脚本)将会这么调用, mount所有可用的文件系统和分区.</P
>
		    <P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;mount -t iso9660 /dev/cdrom /mnt/cdrom
   2&nbsp;# 加载 CDROM
   3&nbsp;mount /mnt/cdrom
   4&nbsp;# 方便的方法, 如果 /mnt/cdrom 包含在 /etc/fstab 中</PRE
></TD
></TR
></TABLE
>
     </P
>
     <P
>这个多功能的命令甚至可以将一个普通文件mount到块设备中, 并且这个文件就好像一个文件系统一样.  <B
CLASS="COMMAND"
>mount</B
>可以将文件与一个<A
HREF="devproc.html#LOOPBACKREF"
>loopback设备</A
>相关联来达到这个目的.ccomplishes that by
       associating the file with a <A
HREF="devproc.html#LOOPBACKREF"
>loopback
       device</A
>. 这种应用通常都是用来mount和检查一个ISO9660镜像,在这个镜像被烧录到CDR之前.
       
	  <A
NAME="AEN12176"
HREF="#FTN.AEN12176"
>[3]</A
>       </P
>
     <DIV
CLASS="EXAMPLE"
><HR><A
NAME="ISOMOUNTREF"
></A
>
       <P
><B
>Example 13-7. 检查一个CD镜像</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# 以root身份...
   2&nbsp;
   3&nbsp;mkdir /mnt/cdtest  # 如果没有的话,准备一个mount点.
   4&nbsp;
   5&nbsp;mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest   # mount这个镜像.
   6&nbsp;#                  "-o loop" option equivalent to "losetup /dev/loop0"
   7&nbsp;cd /mnt/cdtest     # 现在检查这个镜像.
   8&nbsp;ls -alR            # 列出目录树中的文件.
   9&nbsp;                   # 等等.</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="UMOUNTREF"
></A
><B
CLASS="COMMAND"
>umount</B
></DT
><DD
>
	      <P
>卸除一个当前已经mount的文件系统. 在正常删除之前已经mount的软盘和CDROM之前, 这个设备必须被unmount， 否则文件系统将会损坏.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;umount /mnt/cdrom
   2&nbsp;# 现在你可以按下退出按钮(指的是cdrom或软盘驱动器上的退出钮), 并安全的退出光盘.</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><B
CLASS="COMMAND"
>automount</B
>工具, 如果适当的安装, 当需要存取或退出磁盘或软盘的时候, 就可自动的mount和unmount它们. 但是在带有软盘和光驱的笔记本电脑上, 这可能会引起问题.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>sync</B
></DT
><DD
>
	      <P
>强制写入所有需要更新的buffer上的数据到硬盘上(同步带有buffer的驱动器). 如果不是严格必要的话,一个<B
CLASS="COMMAND"
>sync</B
>就可以保证系统管理员或者用户刚刚修改的数据会安全的在突然的断点中幸存下来. 在比较早以前, 在系统重启前都是使用 <TT
CLASS="USERINPUT"
><B
>sync;
	      sync</B
></TT
> (两次, 这样保证绝对可靠), 这是一种很有用的小心的方法.</P
>
        <P
>有时候, 比如当你想安全删除一个文件的时候(参见 <A
HREF="extmisc.html#BLOTOUT"
>Example 12-55</A
>), 或者当磁盘灯开始闪烁的时候, 你可能需要强制马上进行buffer刷新.</P
>
   </DD
><DT
><A
NAME="LOSETUPREF"
></A
><B
CLASS="COMMAND"
>losetup</B
></DT
><DD
>
	        <P
>建立和配置<A
HREF="devproc.html#LOOPBACKREF"
>loopback设备</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="CREATEFS"
></A
>
	          <P
><B
>Example 13-8. 在一个文件中创建文件系统</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;SIZE=1000000  # 1M
   2&nbsp;
   3&nbsp;head -c $SIZE &#60; /dev/zero &#62; file  # 建立指定尺寸的文件.
   4&nbsp;losetup /dev/loop0 file           # 作为loopback设备来建立.
   5&nbsp;mke2fs /dev/loop0                 # 创建文件系统.
   6&nbsp;mount -o loop /dev/loop0 /mnt     # Mount它.
   7&nbsp;
   8&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>mkswap</B
></DT
><DD
>
     <P
>创建一个交换分区或文件. 交换区域随后必须马上使用<B
CLASS="COMMAND"
>swapon</B
>来使能.</P
>
   </DD
><DT
><B
CLASS="COMMAND"
>swapon</B
>, <B
CLASS="COMMAND"
>swapoff</B
></DT
><DD
>
     <P
>使能/禁用 交换分区或文件.
	      这两个命令通常在启动和关机的时候才有效.</P
>
   </DD
><DT
><A
NAME="MKE2FSREF"
></A
><B
CLASS="COMMAND"
>mke2fs</B
></DT
><DD
>
	      <P
>创建Linux ext2 文件系统. 这个命令必须以root身份调用.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ADDDRV"
></A
>
	        <P
><B
>Example 13-9. 添加一个新的硬盘驱动器</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# 在系统上添加第二块硬盘驱动器.
   4&nbsp;# 软件配置. 假设硬件已经安装了.
   5&nbsp;# 来自于本书作者的一篇文章.
   6&nbsp;# 在"Linux Gazette"的问题#38上, http://www.linuxgazette.com.
   7&nbsp;
   8&nbsp;ROOT_UID=0     # 这个脚本必须以root身份运行.
   9&nbsp;E_NOTROOT=67   # 非root用户将会产生这个错误.
  10&nbsp;
  11&nbsp;if [ "$UID" -ne "$ROOT_UID" ]
  12&nbsp;then
  13&nbsp;  echo "Must be root to run this script."
  14&nbsp;  exit $E_NOTROOT
  15&nbsp;fi  
  16&nbsp;
  17&nbsp;# 要非常谨慎的小心使用!
  18&nbsp;# 如果某步错了, 可能会彻底摧毁你当前的文件系统.
  19&nbsp;
  20&nbsp;
  21&nbsp;NEWDISK=/dev/hdb         # 假设/dev/hdb空白. 检查一下!
  22&nbsp;MOUNTPOINT=/mnt/newdisk  # 或者选择另外的mount点.
  23&nbsp;
  24&nbsp;
  25&nbsp;fdisk $NEWDISK
  26&nbsp;mke2fs -cv $NEWDISK1   # 检查坏块, 详细输出.
  27&nbsp;#  注意:    /dev/hdb1, *不是* /dev/hdb!
  28&nbsp;mkdir $MOUNTPOINT
  29&nbsp;chmod 777 $MOUNTPOINT  # 让所有用户都具有全部权限.
  30&nbsp;
  31&nbsp;
  32&nbsp;# 现在, 测试一下...
  33&nbsp;# mount -t ext2 /dev/hdb1 /mnt/newdisk
  34&nbsp;# 尝试创建一个目录.
  35&nbsp;# 如果工作起来了, umount它, 然后继续.
  36&nbsp;
  37&nbsp;# 最后一步:
  38&nbsp;# 将下边这行添加到/etc/fstab.
  39&nbsp;# /dev/hdb1  /mnt/newdisk  ext2  defaults  1 1
  40&nbsp;
  41&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>
	      <P
>参见 <A
HREF="system.html#CREATEFS"
>Example 13-8</A
> 和 <A
HREF="zeros.html#RAMDISK"
>Example 28-3</A
>.</P
>
   </DD
><DT
><B
CLASS="COMMAND"
>tune2fs</B
></DT
><DD
>
	      <P
>调整ext2文件系统. 可以用来修改文件系统参数, 比如mount的最大数量. 必须以root身份调用.</P
><DIV
CLASS="WARNING"
><TABLE
CLASS="WARNING"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/warning.png"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>这是一个非常危险的命令. 如果坏了, 你需要自己负责, 因为它可能会破坏你的文件系统.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>dumpe2fs</B
></DT
><DD
>
	      <P
>打印(输出到stdout上)非常详细的文件系统信息. 必须以root身份调用.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>root# </TT
><B
CLASS="COMMAND"
>dumpe2fs /dev/hda7 | grep 'ount count'</B
>
 <TT
CLASS="COMPUTEROUTPUT"
>dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
 Mount count:              6
 Maximum mount count:      20</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><B
CLASS="COMMAND"
>hdparm</B
></DT
><DD
>
   <P
>列出或修改硬盘参数. 这个命令必须以root身份调用, 如果滥用的话会有危险.</P
>
 </DD
><DT
><A
NAME="FDISKREF"
></A
><B
CLASS="COMMAND"
>fdisk</B
></DT
><DD
>
	      <P
>在存储设备上(通常都是硬盘)创建和修改一个分区表. 必须以root身份使用.</P
><DIV
CLASS="WARNING"
><TABLE
CLASS="WARNING"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/warning.png"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>谨慎使用这个命令. 如果出错, 会破坏你现存的文件系统.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="FSCKREF"
></A
><B
CLASS="COMMAND"
>fsck</B
>, <B
CLASS="COMMAND"
>e2fsck</B
>, <B
CLASS="COMMAND"
>debugfs</B
></DT
><DD
>
	        <P
>文件系统的检查, 修复, 和除错命令集合.</P
>
	        <P
><B
CLASS="COMMAND"
>fsck</B
>: 检查UNIX文件系统的前端工具(也可以调用其它的工具). 文件系统的类型一般都是默认的ext2.</P
>
	        <P
><B
CLASS="COMMAND"
>e2fsck</B
>: ext2文件系统检查器.</P
>
	        <P
><B
CLASS="COMMAND"
>debugfs</B
>: ext2文件系统除错器.
	      这个多功能但是危险的工具的用处之一就是(尝试)恢复删除的文件. 只有高级用户才能用.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>上边的这几个命令都必须以root身份调用, 这些命令都很危险, 如果滥用的话会破坏文件系统.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>badblocks</B
></DT
><DD
>
	      <P
>检查存储设备的坏块(物理损坏).  这个命令在格式化新安装的硬盘时或者测试备份的完整性的时候会被用到.
	        <A
NAME="AEN12367"
HREF="#FTN.AEN12367"
>[4]</A
>
	      举个例子, <B
CLASS="COMMAND"
>badblocks /dev/fd0</B
>
	      测试一个软盘.</P
>
	      <P
><B
CLASS="COMMAND"
>badblocks</B
>可能会引起比较糟糕的结果(覆盖所有数据), 在只读模式下就不会发生这种情况. 如果root用户拥有需要测试的设备(通常都是这种情况), 那么root用户必须调用这个命令.</P
>
	      </DD
><DT
><B
CLASS="COMMAND"
>lsusb</B
>, <B
CLASS="COMMAND"
>usbmodules</B
></DT
><DD
>
	      <P
><B
CLASS="COMMAND"
>lsusb</B
> 命令会列出所有USB(Universal Serial Bus通用串行总线)总线和使用USB的设备.</P
>
	      <P
><B
CLASS="COMMAND"
>usbmodules</B
> 命令会输出连接USB设备的驱动模块的信息.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>lsusb</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Bus 001 Device 001: ID 0000:0000  
 Device Descriptor:
   bLength                18
   bDescriptorType         1
   bcdUSB               1.00
   bDeviceClass            9 Hub
   bDeviceSubClass         0 
   bDeviceProtocol         0 
   bMaxPacketSize0         8
   idVendor           0x0000 
   idProduct          0x0000
   . . .</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
            </P
></DD
><DT
><B
CLASS="COMMAND"
>mkbootdisk</B
></DT
><DD
>
              <P
>创建启动软盘, 启动盘可以唤醒系统, 比如当MBR(master boot record主启动记录)坏掉的时候. <B
CLASS="COMMAND"
>mkbootdisk</B
> 命令其实是一个Bash脚本, 由Erik Troan所编写, 放在<TT
CLASS="FILENAME"
>/sbin</TT
>目录中.</P
>
            </DD
><DT
><B
CLASS="COMMAND"
>chroot</B
></DT
><DD
>
	      <P
>修改ROOT目录. 一般的命令都是从<A
HREF="variables2.html#PATHREF"
>$PATH</A
>中获得的, 相对的默认的根目录是 /. 这个命令将会把根目录修改为另一个目录(并且也将把工作目录修改到那).
	      出于安全目的, 这个命令时非常有用的, 举个例子, 当系统管理员希望限制一些特定的用户, 比如<A
HREF="communications.html#TELNETREF"
>telnet</A
>上来的用户, 将他们限定到文件系统上一个安全的地方(这有时候被称为将一个guest用户限制在&quot;chroot 监牢&quot;中). 注意, 在使用<B
CLASS="COMMAND"
>chroot</B
>之后, 系统的二进制可执行文件的目录将不再可用了.</P
>
	      <P
><TT
CLASS="USERINPUT"
><B
>chroot /opt</B
></TT
> 将会使得原来的/usr/bin目录变为/opt/usr/bin. 同样,
		<TT
CLASS="USERINPUT"
><B
>chroot /aaa/bbb /bin/ls</B
></TT
> 将会使得ls命令以/aaa/bbb作为根目录, 而不是以前的/. 如果使用<B
CLASS="COMMAND"
>alias XX 'chroot /aaa/bbb
		ls'</B
>, 并把这句放到用户的~/.bashrc文件中的话, 这将可以有效地限制运行命令&quot;XX&quot;时, 命令&quot;XX&quot;可以使用文件系统的范围.</P
>
	      <P
>当从启动盘恢复的时候(<B
CLASS="COMMAND"
>chroot</B
> 到 <TT
CLASS="FILENAME"
>/dev/fd0</TT
>), 或者当系统从死机状态恢复过来并作为进入<B
CLASS="COMMAND"
>lilo</B
>的选择手段的时候, <B
CLASS="COMMAND"
>chroot</B
>命令都是非常方便的. 其它的应用还包括从不同的文件系统进行安装(一个<A
HREF="filearchiv.html#RPMREF"
>rpm</A
>选项)或者从CDROM上运行一个只读文件系统.
	      只能以root身份调用, 小心使用.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>由于正常的$PATH将不再被关联了, 所以可能需要将一些特定的系统文件拷贝到<I
CLASS="EMPHASIS"
>chrooted</I
>目录中.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>lockfile</B
></DT
><DD
>
	      <P
>这个工具是<B
CLASS="COMMAND"
>procmail</B
>包的一部分(<A
HREF="http://www.procmail.org"
TARGET="_top"
>www.procmail.org</A
>).
	      它可以创建一个<em>锁定文件</em>, 锁定文件是一种用来控制存取文件, 设备或资源的标记文件. 锁定文件就像一个标记一样被使用, 如果特定的文件, 设备, 或资源正在被一个特定的进程所使用(&quot;busy&quot;), 那么对于其它进程来说, 就只能受限进行存取(或者不能存取). </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;lockfile /home/bozo/lockfiles/$0.lock
   2&nbsp;# 创建一个以脚本名字为前缀的写保护锁定文件.</PRE
></TD
></TR
></TABLE
></P
>
   <P
>锁定文件用在一些特定的场合, 比如说保护系统的mail目录以防止多个用户同时修改, 或者提示一个modem端口正在被存取, 或者显示Netscape的一个实例正在使用它的缓存. 脚本可以做一些检查工作, 比如说一个特定的进程可以创建一个锁定文件, 那么只要检查这个特定的进程是否在运行, 就可以判断出锁定文件是否存在了. 注意如果脚本尝试创建一个已经存在的锁定文件的话, 那么脚本很可能被挂起.</P
>
   <P
>一般情况下, 应用创建或检查锁定文件都放在/var/lock目录中.
	         <A
NAME="AEN12471"
HREF="#FTN.AEN12471"
>[5]</A
>
	      脚本可以使用下面的方法来检测锁定文件是否存在.
   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;appname=xyzip
   2&nbsp;# 应用 "xyzip" 创建锁定文件 "/var/lock/xyzip.lock".
   3&nbsp;
   4&nbsp;if [ -e "/var/lock/$appname.lock" ]
   5&nbsp;then
   6&nbsp;  ...</PRE
></TD
></TR
></TABLE
></P
></DD
>
	      <DT
><B
CLASS="COMMAND"
>flock</B
>&lt;rojy bug&gt;</DT
>
	      <DD
>
	      <P
><B
CLASS="COMMAND"
>flock</B
>命令比<B
CLASS="COMMAND"
>lockfile</B
>命令用得少得多.Much less useful than the <B
CLASS="COMMAND"
>lockfile</B
>
	      command is <B
CLASS="COMMAND"
>flock</B
>. It sets an
	      <SPAN
CLASS="QUOTE"
>"advisory"</SPAN
> lock on a file and then executes
	      a command while the lock is on. This is to prevent
	      any other process from setting a lock on that file until
	      completion of the specified command.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;flock $0 cat $0 &#62; lockfile__$0
   2&nbsp;#  Set a lock on the script the above line appears in,
   3&nbsp;#+ while listing the script to stdout.</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>与<B
CLASS="COMMAND"
>lockfile</B
>不同,
	      <B
CLASS="COMMAND"
>flock</B
>不会自动创建一个锁定文件.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>mknod</B
></DT
><DD
>
	        <P
>创建块或者字符设备文件(当在系统上安装新硬盘时可能是必要的). <B
CLASS="COMMAND"
>MAKEDEV</B
>工具事实上具有<strong>nknod</strong>的全部功能, 而且更容易使用.</P
>
	      </DD
><DT
><B
CLASS="COMMAND"
>MAKEDEV</B
></DT
><DD
>
	    <P
>创建设备文件的工具. 必须在/dev目录下, 并且以root身份使用.
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>root# </TT
><B
CLASS="COMMAND"
>./MAKEDEV</B
></PRE
></TD
></TR
></TABLE
>

	      这是<strong>mknod</strong>的高级版本.</DD
><DT
><B
CLASS="COMMAND"
>tmpwatch</B
></DT
><DD
>
	        <P
>自动删除在指定时间内未被存取过的文件. 通常都是被<A
HREF="system.html#CRONREF"
>cron</A
>调用, 用来删掉老的log文件.</P
>
	      </DD
></DL
>
	     </DIV
><DIV
CLASS="VARIABLELIST"
>
	       <P
><B
><A
NAME="PERIPHSYS1"
></A
>备份类</B
></P
>
	       <DL
><DT
><B
CLASS="COMMAND"
>dump</B
>, <B
CLASS="COMMAND"
>restore</B
></DT
><DD
>
	         <P
><B
CLASS="COMMAND"
>dump</B
> 命令是一个精巧的文件系统备份工具, 通常都用在比较大的安装和网络上.
		<A
NAME="AEN12555"
HREF="#FTN.AEN12555"
>[6]</A
>
	      它读取原始的磁盘分区并且以二进制形式来写备份文件.  需要备份的文件可以保存到各种各样的存储设备上, 包括磁盘和磁带. <B
CLASS="COMMAND"
>restore</B
>命令用来恢复<strong>dump</strong>所产生的备份.</P
>
	       </DD
><DT
><B
CLASS="COMMAND"
>fdformat</B
></DT
><DD
>
	         <P
>对软盘进行低级格式化.</P
>
	       </DD
></DL
>
	     </DIV
><DIV
CLASS="VARIABLELIST"
>
	       <P
><B
><A
NAME="SYSRESOURCES1"
></A
>系统资源类</B
></P
>
	       <DL
><DT
><B
CLASS="COMMAND"
>ulimit</B
></DT
><DD
>
	         <P
>设置使用系统资源的<em>上限</em>. 通常情况下都是使用-f选项来调用, -f用来设置文件尺寸的限制(<B
CLASS="COMMAND"
>ulimit -f 1000</B
>就是将文件大小限制为1M).  <TT
CLASS="OPTION"
>-c(译者注: 这里应该是作者笔误, 作者写的是-t)</TT
>选项来限制coredump(译者注:   核心转储, 程序崩溃时的内存状态写入文件)尺寸(<B
CLASS="COMMAND"
>ulimit -c 0</B
> 就是不要coredumps).
	      一般情况下, <B
CLASS="COMMAND"
>ulimit</B
>的值应该设置在<TT
CLASS="FILENAME"
>/etc/profile</TT
> 和(或)<TT
CLASS="FILENAME"
>~/.bash_profile</TT
>中(参见 <A
HREF="files.html"
>Appendix G</A
>).</P
>
	         <DIV
CLASS="IMPORTANT"
><TABLE
CLASS="IMPORTANT"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/important.png"
HSPACE="5"
ALT="Important"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Judicious 使用<B
CLASS="COMMAND"
>ulimit</B
> 可以保护系统免受可怕的<I
CLASS="EMPHASIS"
>fork</I
><em>炸弹</em>的迫害.</P
><P
>	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# 这个脚本只是为了展示用.
   3&nbsp;# 你要自己为运行这个脚本的后果负责 -- 它*将*凝固你的系统.
   4&nbsp;
   5&nbsp;while true  #  死循环.
   6&nbsp;do
   7&nbsp;  $0 &#38;      #  这个脚本调用自身 . . .
   8&nbsp;            #+ fork无限次 . . .
   9&nbsp;            #+ 直道系统完全不动, 因为所有的资源都耗尽了.
  10&nbsp;done        #  这就是臭名卓著的 <SPAN
CLASS="QUOTE"
>"sorcerer's appentice"</SPAN
> 剧情.&lt;rojy bug&gt;(译者注:巫师的厢房?没看懂)
  11&nbsp;
  12&nbsp;exit 0      #  这里不会真正的推出, 因为这个脚本不会终止.</PRE
></TD
></TR
></TABLE
>
	    </P
>
	    <P
>当这个脚本超过预先设置的限制时, 在<TT
CLASS="FILENAME"
>/etc/profile中的</TT
> <B
CLASS="COMMAND"
>ulimit -Hu XX</B
> (<I
CLASS="EMPHASIS"
>XX</I
> 就是需要限制的用户进程) 可以终止这个脚本的运行.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="QUOTAREF"
></A
><B
CLASS="COMMAND"
>quota</B
></DT
><DD
>
	      <P
>显示用户或组的磁盘配额.</P
>
	    </DD
><DT
><A
NAME="SETQUOTAREF"
></A
><B
CLASS="COMMAND"
>setquota</B
></DT
><DD
>
	      <P
>从命令行中设置用户或组的磁盘配额.</P
>
	    </DD
><DT
><A
NAME="UMASKREF"
></A
><B
CLASS="COMMAND"
>umask</B
></DT
><DD
>
	      <P
>设定用户创建文件时权限的缺省<I
CLASS="FIRSTTERM"
>mask</I
>(掩码). 也可以用来限制特定用户的默认文件属性.  所有用户创建的文件属性都是由<B
CLASS="COMMAND"
>umask</B
>所指定的. The (octal) 传递给<B
CLASS="COMMAND"
>umask</B
>的8进制的值定义了文件的权限. 比如, <B
CLASS="COMMAND"
>umask
	      022</B
>将会使得新文件的权限最多为755(777 与非 022)

                <A
NAME="AEN12641"
HREF="#FTN.AEN12641"
>[7]</A
>

	      当然, 用户可以随后使用<A
HREF="external.html#CHMODREF"
>chmod</A
>来修改指定文件的属性. 用户一般都是将<B
CLASS="COMMAND"
>umask</B
>设置值的地方放在<TT
CLASS="FILENAME"
>/etc/profile</TT
> 和(或)
	      <TT
CLASS="FILENAME"
>~/.bash_profile中</TT
> (参见 <A
HREF="files.html"
>Appendix G</A
>).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ROT13A"
></A
>
	        <P
><B
>Example 13-10. 使用<B
CLASS="COMMAND"
>umask来将输出文件隐藏起来</B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# rot13a.sh: 与"rot13.sh"脚本相同, 但是会将输出写道&quot;安全&quot;文件中.
   3&nbsp;
   4&nbsp;# 用法: ./rot13a.sh filename
   5&nbsp;# 或     ./rot13a.sh &#60;filename
   6&nbsp;# 或     ./rot13a.sh 同时提供键盘输入(stdin)
   7&nbsp;
   8&nbsp;umask 177               #  文件创建掩码.
   9&nbsp;                        #  被这个脚本所创建的文件
  10&nbsp;                        #+ 将具有600权限.
  11&nbsp;
  12&nbsp;OUTFILE=decrypted.txt   #  结果保存在"decrypted.txt"中
  13&nbsp;                        #+ 这个文件只能够被
  14&nbsp;                        #  这个脚本的调用者(or root)所读写.
  15&nbsp;
  16&nbsp;cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M' &#62; $OUTFILE 
  17&nbsp;#    ^^ 从stdin 或文件中输入.         ^^^^^^^^^^ 输出重定向到文件中.
  18&nbsp;
  19&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>rdev</B
></DT
><DD
>
    <P
>取得root device, swap space, 或 video
         mode的相关信息, 或者对它们进行修改.  通常说来<B
CLASS="COMMAND"
>rdev</B
>都是被<B
CLASS="COMMAND"
>lilo</B
>所使用, 但是在建立一个ram disk的时候, 这个命令也很有用. 小心使用, 这是一个危险的命令.</P
>
  </DD
></DL
>
	     </DIV
><DIV
CLASS="VARIABLELIST"
>
	       <P
><B
><A
NAME="MODULESSYS1"
></A
>模块类</B
></P
>
	       <DL
><DT
><B
CLASS="COMMAND"
>lsmod</B
></DT
><DD
>
	       <P
>列出所有安装的内核模块.</P
>
	       <P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>lsmod</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Module                  Size  Used by
 autofs                  9456   2 (autoclean)
 opl3                   11376   0
 serial_cs               5456   0 (unused)
 sb                     34752   0
 uart401                 6384   0 [sb]
 sound                  58368   0 [opl3 sb uart401]
 soundlow                 464   0 [sound]
 soundcore               2800   6 [sb sound]
 ds                      6448   2 [serial_cs]
 i82365                 22928   2
 pcmcia_core            45984   0 [serial_cs ds i82365]</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>使用<B
CLASS="COMMAND"
>cat /proc/modules</B
>可以得到同样的结果.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>insmod</B
></DT
><DD
>
	      <P
>强制一个内核模块的安装(如果可能的话, 使用<B
CLASS="COMMAND"
>modprobe</B
>来代替) 必须以root身份调用.</P
>
	    </DD
><DT
><B
CLASS="COMMAND"
>rmmod</B
></DT
><DD
>
	      <P
>强制卸载一个内核模块. 必须以root身份调用.</P
>
	    </DD
><DT
><B
CLASS="COMMAND"
>modprobe</B
></DT
><DD
>
	      <P
>模块装载器, 一般情况下都是在启动脚本中自动调用. 必须以root身份调用.</P
>
	    </DD
><DT
><B
CLASS="COMMAND"
>depmod</B
></DT
><DD
>
	      <P
>创建模块依赖文件, 一般都是在启动脚本中调用.</P
>
	    </DD
><DT
><B
CLASS="COMMAND"
>modinfo</B
></DT
><DD
>
	      <P
>输出一个可装载模块的信息.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>modinfo hid</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>filename:    /lib/modules/2.4.20-6/kernel/drivers/usb/hid.o
 description: "USB HID support drivers"
 author:      "Andreas Gal, Vojtech Pavlik &#60;vojtech@suse.cz&#62;"
 license:     "GPL"</TT
>
 	      </PRE
></TD
></TR
></TABLE
></DD
></DL
>
	     </DIV
><DIV
CLASS="VARIABLELIST"
>
	       <P
><B
><A
NAME="MISCSYS1"
></A
>杂项类</B
></P
>
	       <DL
><DT
><B
CLASS="COMMAND"
>env</B
></DT
><DD
>
	         <P
>使用设置过的或修改过(并不是修改整个系统环境)的<A
HREF="othertypesv.html#ENVREF"
>环境变量</A
>来运行一个程序或脚本. 使用 <TT
CLASS="OPTION"
>[varname=xxx]</TT
>
	      形式可以在脚本中修改环境变量. 如果没有指定参数, 那么这个命令将会列出所有设置的环境变量.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>在Bash和其它的Bourne shell 衍生物中, 是可以在单一命令行上设置多个变量的.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;var1=value1 var2=value2 commandXXX
   2&nbsp;# $var1 和 $var2 只设置在'commandXXX'的环境中.</PRE
></TD
></TR
></TABLE
>	      
            </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>当不知道shell或解释器的路径的时候, 脚本的第一行(#!行)可以使用<B
CLASS="COMMAND"
>env</B
>.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /usr/bin/env perl
   2&nbsp;
   3&nbsp;print "This Perl script will run,\n";
   4&nbsp;print "even when I don't know where to find Perl.\n";
   5&nbsp;
   6&nbsp;# 便于跨平台移植,
   7&nbsp;# Perl程序可能没在期望的地方.
   8&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>
            </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>ldd</B
></DT
><DD
>
              <P
>显示一个可执行文件的共享库的依赖关系.</P
>
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ldd /bin/ls</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>libc.so.6 =&#62; /lib/libc.so.6 (0x4000c000)
/lib/ld-linux.so.2 =&#62; /lib/ld-linux.so.2 (0x80000000)</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="WATCHREF"
></A
><B
CLASS="COMMAND"
>watch</B
></DT
><DD
>
  <P
>以指定的时间间隔来重复运行一个命令.</P
>
  <P
>默认的时间间隔是2秒, 但时刻以使用-n选项来修改.</P
>
  <P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;watch -n 5 tail /var/log/messages
   2&nbsp;# 每隔5秒钟显示系统log文件的结尾, /var/log/messages.</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>strip</B
></DT
><DD
>
     <P
>从可执行文件中去掉调试符号引用. 这样做可以减小尺寸, 但是就不能调试了.</P
>
     <P
>这个命令一般都用在<A
HREF="filearchiv.html#MAKEFILEREF"
>Makefile</A
>中,
	      但是很少用在shell脚本中.</P
>
   </DD
><DT
><B
CLASS="COMMAND"
>nm</B
></DT
><DD
>
     <P
>列出未strip过的编译后的2进制文件的符号.</P
>
   </DD
><DT
><B
CLASS="COMMAND"
>rdist</B
></DT
><DD
>
     <P
> 远程文件分布客户机程序: 在远端服务器上同步, 克隆, 或者备份一个文件系统.</P
>
   </DD
></DL
>
	     </DIV
><DIV
CLASS="SECT1"
>
	        <H1
CLASS="SECT1"
><A
NAME="SYSSCRIPTS"
>13.1. 分析一个系统脚本</A
></H1
>
	        <P
>利用我们所学到的关于管理命令的知识, 让我们一起来练习分析一个系统脚本. 最简单并且最短的系统脚本之一是<B
CLASS="COMMAND"
>killall</B
>， 这个脚本被用来在系统关机时挂起运行的脚本.</P
>
	        <DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX55"
></A
>
	        <P
><B
>Example 13-11. <B
CLASS="COMMAND"
>killall</B
>, 来自于 <TT
CLASS="FILENAME"
>/etc/rc.d/init.d</TT
></B
></P
>
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/sh
   2&nbsp;
   3&nbsp;# --&#62; 本书作者所作的注释全部以"# --&#62;"开头.
   4&nbsp;
   5&nbsp;# --&#62; 这是由Miquel van Smoorenburg所编写的
   6&nbsp;# --&#62; 'rc'脚本包的一部分, &#60;miquels@drinkel.nl.mugnet.org&#62;.
   7&nbsp;
   8&nbsp;# --&#62; 这个特殊的脚本看起来是是为Red Hat / FC所特定的,
   9&nbsp;# --&#62; (在其它的发行版中可能不会出现).
  10&nbsp;
  11&nbsp;#  停止所有正在运行的不必要的服务
  12&nbsp;#+ (there shouldn't be any, so this is just a sanity check)
  13&nbsp;
  14&nbsp;for i in /var/lock/subsys/*; do
  15&nbsp;        # --&#62; 标准的for/in循环, 但是由于"do"在同一行上,
  16&nbsp;        # --&#62; 所以必须添加";".
  17&nbsp;        # 检查脚本是否在那.
  18&nbsp;        [ ! -f $i ] &#38;&#38; continue
  19&nbsp;        # --&#62; 这是一种使用&quot;与列表&quot;的聪明的方法, 等价于:
  20&nbsp;        # --&#62; if [ ! -f "$i" ]; then continue
  21&nbsp;
  22&nbsp;        # 取得子系统的名字.
  23&nbsp;        subsys=${i#/var/lock/subsys/}
  24&nbsp;        # --&#62; 匹配变量名, 在这里就是文件名.
  25&nbsp;        # --&#62; 与subsys=`basename $i`完全等价.
  26&nbsp;	
  27&nbsp;        # --&#62;  从锁定文件名中获得
  28&nbsp;        # --&#62;+ (如果那里有锁定文件的话,
  29&nbsp;        # --&#62;+ 那就证明进程正在运行).
  30&nbsp;        # --&#62;  参考一下上边所讲的&quot;锁定文件&quot;的内容.
  31&nbsp;
  32&nbsp;
  33&nbsp;        # 终止子系统.
  34&nbsp;        if [ -f /etc/rc.d/init.d/$subsys.init ]; then
  35&nbsp;           /etc/rc.d/init.d/$subsys.init stop
  36&nbsp;        else
  37&nbsp;           /etc/rc.d/init.d/$subsys stop
  38&nbsp;        # --&#62;  挂起运行的作业和幽灵进程.
  39&nbsp;        # --&#62;  注意"stop"只是一个位置参数,
  40&nbsp;        # --&#62;+ 并不是shell内建命令.
  41&nbsp;        fi
  42&nbsp;done</PRE
></TD
></TR
></TABLE
><HR></DIV
>
	        <P
>这个没有那么糟. 除了在变量匹配的地方玩了一点花样, 其它也没有别的材料了.</P
><DIV
CLASS="FORMALPARA"
>
	  <P
><B
>练习 1. </B
>在<TT
CLASS="FILENAME"
>/etc/rc.d/init.d中</TT
>,
	  分析<B
CLASS="COMMAND"
>halt</B
>脚本. 比脚本<B
CLASS="COMMAND"
>killall</B
>长一些, 但是概念上很相近. 对这个脚本做一个拷贝, 放到你的home目录下并且用它练习一下(<em>不</em>要以root身份运行它). 使用-vn标志来模拟运行一下(<TT
CLASS="USERINPUT"
><B
>sh -vn scriptname</B
></TT
>). 添加详细的注释. 将<SPAN
CLASS="QUOTE"
>"action"命令修改为</SPAN
><SPAN
CLASS="QUOTE"
>"echos"</SPAN
>.</P
>
	</DIV
><DIV
CLASS="FORMALPARA"
>
	  <P
><B
>练习 2. </B
>察看/etc/rc.d/init.d下的更多更复杂的脚本. 看看你是不是能够理解其中的一些脚本. 使用上边的过程来分析这些脚本. 为了更详细的理解, 你可能也需要分析在<TT
CLASS="FILENAME"
>usr/share/doc/initscripts-?.??</TT
>目录下的文件<TT
CLASS="FILENAME"
>sysvinitfile</TT
>,
	这些都是&quot;<span class="QUOTE">initscript</span>&quot;文件的一部分.</P
>
	</DIV
></DIV
></DIV
>
<H3
CLASS="FOOTNOTES"
>注意事项:</H3
>
<TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN10817"
HREF="system.html#AEN10817"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>这是在Linux机器上或者在带有磁盘配额的UNIX系统上的真实情况.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN10848"
HREF="system.html#AEN10848"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>如果正在被删除的特定的用户已经登录了主机, 那么 <B
CLASS="COMMAND"
>userdel</B
> 命令将会失败.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12176"
HREF="system.html#AEN12176"
>[3]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>对于烧录CDR的更多的细节, 可以参见Alex
	    Withers的文章, <A
HREF="http://www2.linuxjournal.com/lj-issues/issue66/3335.html"
TARGET="_top"
>创建CD</A
>, 在<A
HREF="http://www.linuxjournal.com"
TARGET="_top"
><I
CLASS="CITETITLE"
>Linux
	     Journal</I
></A
> 的1999年的10月文章列表中.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12367"
HREF="system.html#AEN12367"
>[4]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
HREF="system.html#MKE2FSREF"
>mke2fs</A
>的-c选项也会进行坏块检查.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12471"
HREF="system.html#AEN12471"
>[5]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>因为只有<em>root</em>用户才具有对<TT
CLASS="FILENAME"
>/var/lock目录的写权限,</TT
>		 一般的用户脚本是不能在那里设置一个锁定文件的.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12555"
HREF="system.html#AEN12555"
>[6]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>单用户的Linux系统的操作更倾向于使用简单的备份工具, 比如<strong>tar</strong>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12641"
HREF="system.html#AEN12641"
>[7]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>NAND(与非)是一种逻辑操作. 这种操作的效果和减法很相像.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="extmisc.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="commandsub.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Miscellaneous Commands</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part3.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Command Substitution</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>